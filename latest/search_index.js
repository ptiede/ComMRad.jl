var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [Comrade]","category":"page"},{"location":"api/#Comrade.Comrade","page":"API","title":"Comrade.Comrade","text":"Comrade\n\nRadio Observation Sampling Exploration\n\n\n\n\n\n","category":"module"},{"location":"api/#Comrade.AbstractCache","page":"API","title":"Comrade.AbstractCache","text":"abstract type AbstractCache\n\nThis defines an abstract cache that can be used to hold or precompute some computations.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.AbstractModifier","page":"API","title":"Comrade.AbstractModifier","text":"abstract type AbstractModifier{M<:ComradeBase.AbstractModel} <: ComradeBase.AbstractModel\n\nAbstract type for image modifiers. These are some model wrappers that can transform any model using simple Fourier transform properties. To see the implemented modifier\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.AddModel","page":"API","title":"Comrade.AddModel","text":"struct AddModel{T1, T2} <: Comrade.CompositeModel{T1, T2}\n\nAdds two models together to create composite models. Note that I may change this in the future so make it easier on the compiler, i.e. make the composite model a fancy model vector and heap allocate stuff. This should help when combining multiple models together.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ArrayConfiguration","page":"API","title":"Comrade.ArrayConfiguration","text":"abstract type ArrayConfiguration\n\nThis defined the abstract type for an array configuration. Namely, baseline times, SEFD's, bandwidth, observation frequencies, etc.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.CompositeModel","page":"API","title":"Comrade.CompositeModel","text":"abstract type CompositeModel{M1, M2} <: ComradeBase.AbstractModel\n\nAbstract type that denotes a composite model. Where we have combined two models together.\n\nImplementation\n\nAny implementation of a composite type must define the following methods:\n\nvisibility_point\nuv_combinator\nimanalytic\nvisanalytic\nComradeBase.intensity_point if model intensity is IsAnalytic\nintensitymap! if model intensity is NotAnalytic\nintensitymap if model intensity is NotAnalytic\nflux\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ConcordanceCrescent","page":"API","title":"Comrade.ConcordanceCrescent","text":"struct ConcordanceCrescent{T} <: Comrade.GeometricModel\n\nCreates the ConcordanceCrescent model, i.e. a flat-top crescent with a displacment and a slash. Note this creates a crescent with unit flux. If you want a different flux please use the renomed modifier.\n\nFields\n\nNotes\n\nUnlike the Gaussian and Disk models this does not create the unit version. In fact, this model could have been created using the Disk and primitives by using Comrade.jl's model composition functionality.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ConvolvedModel","page":"API","title":"Comrade.ConvolvedModel","text":"struct ConvolvedModel{M1, M2} <: Comrade.CompositeModel{M1, M2}\n\nConvolves two models m1 and m2.\n\nNotes\n\nThis is the non-exported constructor. The user should call the convolved function during use\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.DImage","page":"API","title":"Comrade.DImage","text":"$(TYPEDEF)\n\nAn image model given by a set of coefficients and a kernel response or basis function. This corresponds to a continous image defined by a finite set of points. The defined intensity is given by\n\n    I(xy) = sum_ij c_ijκ(x-x_i)κ(y-y_i)\n\nAn important thing to note is that the c_ij do not represent pixel intensities, i.e. the κ doesn't have to be an interpolating kernel.\n\nExample\n\nsamples = rand(10,10)\nmodel = DImage(samples, BSplineKernel{3})\n\nNotes\n\nThis is defined in terms of pixel response, so the image size is 1μas. To resize the image use the scale function like with other models.\n\nFields\n\nFIELDS\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.EHTClosurePhaseDatum","page":"API","title":"Comrade.EHTClosurePhaseDatum","text":"struct EHTClosurePhaseDatum{T<:Number} <: Comrade.ClosureProducts{T<:Number}\n\nA Datum for a single closure phase. Note in the future this may get replaced with the fully covariant formalism from Blackburn et al. (2020).\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ExtendedRing","page":"API","title":"Comrade.ExtendedRing","text":"struct ExtendedRing{F} <: Comrade.GeometricModel\n\nA symmetric extended ring whose radial profile follows an inverse gamma distributions.\n\nNote\n\n@e mainly use this as an example of a non-analytic Fourier transform (although it has a complicated expression)\n\nFields\n\nradius\nradius of peak emission\nshape\nshape of the radial distribution\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.FFT","page":"API","title":"Comrade.FFT","text":"struct FFT <: Comrade.FourierTransform\n\nFourier transform type that specifies we will use the FFTW package to compute the Fourier transform.\n\nFields\n\npadfac\nThe amount to pad the image by. Note we actually round up to the nearest factor of 2, but this will be improved in the future to use small primes\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.FFTCache","page":"API","title":"Comrade.FFTCache","text":"struct FFTCache{P, I} <: Comrade.AbstractCache\n\nThe cache used when the FFT algorithm is used to compute visibilties. This is an internal type and is not part of the public API\n\nFields\n\nplan\nFFTW Plan\nsitp\nFFT interpolator function\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.FourierTransform","page":"API","title":"Comrade.FourierTransform","text":"abstract type FourierTransform\n\nAbstract type that specified which fourier transform to use\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.Gaussian","page":"API","title":"Comrade.Gaussian","text":"struct Gaussian{T} <: Comrade.GeometricModel\n\nGaussian geometrical model. This is a Gaussian with unit flux and standard deviation.\n\nNotes\n\nTo change the Gaussian flux, and shape please use the modifier functions\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.GeometricModel","page":"API","title":"Comrade.GeometricModel","text":"abstract type GeometricModel <: ComradeBase.AbstractModel\n\nA type that defines it is a geometric model. These are usually primitive models, and are usually analytic in Fourier and the image domain.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.MRing","page":"API","title":"Comrade.MRing","text":"struct MRing{T, N} <: Comrade.GeometricModel\n\nm-ring geometric model. This corresponds to a delta ring with a fourier expansion in θ. The m in m-ring refers to the order of the Fourier expansion. The radius is unity.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ModelImage","page":"API","title":"Comrade.ModelImage","text":"struct ModelImage{M, I, C} <: Comrade.AbstractModelImage{M}\n\nContainer for non-analytic model that contains a image cache which will hold the image, a Fourier transform cache C, which usually an instance of a <: FourierCache which usually holds a interpolator that allows you to compute visibilities.\n\nNotes\n\nThis is an internal implementation detail that shouldn't usually be called directly. Instead the user should use the exported function modelimage, for example\n\nusing Comrade\nm = ExtendedRing(20.0, 5.0)\n\n# This creates an version where the image is dynamically specified according to the\n# radial extent of the image\nmimg = modelimage(m) # you can also optionally pass the number of pixels nx and ny\n\n# Or you can create an IntensityMap\nimg = intensitymap(m, 100.0, 100.0, 512, 512)\nmimg = modelimage(m, img)\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.NoCache","page":"API","title":"Comrade.NoCache","text":"struct NoCache <: Comrade.AbstractCache\n\nNo cache is used. This is typically used when the model is analytic in the Fourier domain.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ParabolicSegment","page":"API","title":"Comrade.ParabolicSegment","text":"struct ParabolicSegment{F} <: Comrade.GeometricModel\n\nA delta parabolic segment in the image domain. The segment is centered at zero, with roots ±1 and a yintercept of 1.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ParabolicSegment-Tuple{Any, Any}","page":"API","title":"Comrade.ParabolicSegment","text":"ParabolicSegment(a, h)\n\nA parabolic segment with x-intercepts ±aand a yintercept ofh``.\n\nNote\n\nThis is just a convenience function for stretched(ParabolicSegment(), a, h)\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.PolarizedModel","page":"API","title":"Comrade.PolarizedModel","text":"struct PolarizedModel{TI, TQ, TU, TV} <: ComradeBase.AbstractPolarizedModel\n\nWrapped model for a polarized model. This uses the stokes representation of the image.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.Posterior","page":"API","title":"Comrade.Posterior","text":"Posterior(lklhd, prior, model)\n\nPosterior density that follows obeys the DensityInferface\n\nThe expected arguments are:\n\nlklhd: Which should be an intance of RadioLikelihood with whatever data products you want to fit\nprior: This should be a NamedTuple with the priors for each model ParameterHandling\nmodel: Function that takes a NamedTuple of parameters and constructs the Comrade model.\n\nTo evaluate the logdensity of the posterior use can either use DensityInterface.logdensityof or logdensity.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.RenormalizedModel","page":"API","title":"Comrade.RenormalizedModel","text":"struct RenormalizedModel{M<:ComradeBase.AbstractModel, T} <: Comrade.AbstractModifier{M<:ComradeBase.AbstractModel}\n\nRenormalizes the flux of the model to the new value flux. We have also overloaded the Base.:* operator as syntactic sugar although I may get rid of this.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.Ring","page":"API","title":"Comrade.Ring","text":"struct Ring{T} <: Comrade.GeometricModel\n\nm-ring geometric model. This corresponds to a delta ring with a fourier expansion in θ. The m in m-ring refers to the order of the Fourier expansion. The radius is unity.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.RotatedModel","page":"API","title":"Comrade.RotatedModel","text":"struct RotatedModel{M<:ComradeBase.AbstractModel, T} <: Comrade.AbstractModifier{M<:ComradeBase.AbstractModel}\n\nType for the rotated model. This is more fine grained constrol of rotated model. In most use cases the end-user should be using the rotate method e.g.\n\nrotate(model, ξ)\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ShiftedModel","page":"API","title":"Comrade.ShiftedModel","text":"struct ShiftedModel{T, M<:ComradeBase.AbstractModel} <: Comrade.AbstractModifier{M<:ComradeBase.AbstractModel}\n\nShifts the model by Δx units in the x-direction and Δy units in the y-direction.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.StretchedModel","page":"API","title":"Comrade.StretchedModel","text":"struct StretchedModel{M<:ComradeBase.AbstractModel, T} <: Comrade.AbstractModifier{M<:ComradeBase.AbstractModel}\n\nStretched the model in the x and y directions, i.e. the new intensity is\n\n    I_s(xy) = 1(αβ) I(xα yβ)\n\nwhere were renormalize the intensity to preserve the models flux.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.TransformedPosterior","page":"API","title":"Comrade.TransformedPosterior","text":"`\n\nstruct TransformedPosterior{P<:Posterior, T}\n\nA transformed version of the posteriorlpost`. This is an internal type that an end user shouldn't have to directly construct.\n\nTo construct a transformed posterior see the asflat, ascube, and flatten functions.\n\nWhen evaluating the logdensity of the TransformedPosterior, logdenisty will include any jacobian terms automatically, and expects the argument to be the vector of transformed quantities. This is usually easier to incorporate with samplers, and optimizers, which expect homogenous vectors as arguments.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.size-Tuple{DImage}","page":"API","title":"Base.size","text":"size(model)\n\n\nreturn the size of the coefficient matrix for model.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.Crescent-NTuple{4, Any}","page":"API","title":"Comrade.Crescent","text":"Creates a Kamruddin and Dexter crescent model. This works by composing two disk models together.\n\nArguments\n\nrouter: The radius of the outer disk\nrinner: The radius of the inner disk\nshift: How much the inner disk radius is shifted (positive is to the right)\nfloor: The floor of the inner disk 0 means the inner intensity is zero and 1 means it is a large disk.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade._visibilities-Tuple{Any, AbstractArray, AbstractArray}","page":"API","title":"Comrade._visibilities","text":"_visibilities(m, u, v)\n\n\nComputes the visibilities of the model m at the u,v positions u, v.\n\nNote this is done lazily so the visibility is only computed when accessed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.amplitude-Tuple{Any, Any, Any}","page":"API","title":"Comrade.amplitude","text":"amplitude(model, u, v)\n\n\nComputes the visibility amplitude of model m at u,v positions u,v\n\nIf you want to compute the amplitudes at a large number of positions consider using the amplitudes function which uses MappedArrays to compute a lazy, no allocation vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.amplitudes-Tuple{Any, AbstractArray, AbstractArray}","page":"API","title":"Comrade.amplitudes","text":"amplitudes(m, u, v)\n\n\nComputes the amplitudes of the model m at the u,v positions u, v.\n\nNote this is done lazily so the visibility is only computed when accessed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.basemodel-Tuple{Comrade.AbstractModifier}","page":"API","title":"Comrade.basemodel","text":"basemodel(model)\n\n\nReturns the base model from a modified model.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.bispectra-Tuple{Any, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray}","page":"API","title":"Comrade.bispectra","text":"bispectra(m, u1, v1, u2, v2, u3, v3)\n\n\nComputes the bispectra of the model m at the triangles (u1,v1), (u2,v2), (u3,v3).\n\nNote this is done lazily so the bispectra is only computed when accessed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.bispectrum-NTuple{7, Any}","page":"API","title":"Comrade.bispectrum","text":"bispectrum(model, u1, v1, u2, v2, u3, v3)\n\n\nComputes the complex bispectrum of model m at the uv-triangle u1,v1 -> u2,v2 -> u3,v3\n\nIf you want to compute the bispectrum over a number of triangles consider using the bispectra function which uses MappedArrays to compute a lazy, no allocation vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.closure_phase-NTuple{7, Any}","page":"API","title":"Comrade.closure_phase","text":"closure_phase(model, u1, v1, u2, v2, u3, v3)\n\n\nComputes the closure phase of model m at the uv-triangle u1,v1 -> u2,v2 -> u3,v3\n\nIf you want to compute closure phases over a number of triangles consider using the closure_phases function which uses MappedArrays to compute a lazy, no allocation vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.closure_phase-Tuple{Comrade.EHTVisibilityDatum, Comrade.EHTVisibilityDatum, Comrade.EHTVisibilityDatum}","page":"API","title":"Comrade.closure_phase","text":"closure_phase(D1, D2, D3)\n\n\nComputes the closure phase of the three visibility datums.\n\nNotes\n\nWe currently use the high SNR Gaussian error approximation for the closure phase. In the future we may use the moment matching from Monte Carlo sampling.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.closure_phases-Tuple{Any, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray}","page":"API","title":"Comrade.closure_phases","text":"closure_phases(m, u1, v1, u2, v2, u3, v3)\n\n\nComputes the closure phases of the model m at the triangles (u1,v1), (u2,v2), (u3,v3).\n\nNote this is done lazily so the closure_phases is only computed when accessed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.coherencymatrix-Tuple{PolarizedModel, Any, Any}","page":"API","title":"Comrade.coherencymatrix","text":"coherencymatrix(pimg, u, v)\n\n\nComputes the coherency matrix of the polarized model.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.components-Tuple{ComradeBase.AbstractModel}","page":"API","title":"Comrade.components","text":"components(m)\n\n\nReturns the components for a composite model. This will return a Tuple with all the models you have constructed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.convolved-Tuple{Any, Any}","page":"API","title":"Comrade.convolved","text":"convolved(m1, m2)\n\n\nConvolves two models m1 and m2. This is done lazily.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.create_cache-Tuple{Comrade.FFT, Any}","page":"API","title":"Comrade.create_cache","text":"create_cache(alg, img)\n\n\nCreates the model cache given for the algorithm alg using the model and a image cache image\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.extract_cphase-Tuple{Any}","page":"API","title":"Comrade.extract_cphase","text":"extract_cphase(obs)\n\nExtracts the closure phases from an ehtim observation object\n\nReturns an EHTObservation with closure phases datums\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.extract_lcamp-Tuple{Any}","page":"API","title":"Comrade.extract_lcamp","text":"extract_lcamp(obs)\n\nExtracts the log-closure amp. from an ehtim observation object\n\nReturns an EHTObservation with closure amp. datums\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.extract_vis-Tuple{Any}","page":"API","title":"Comrade.extract_vis","text":"extract_vis(obs)\n\nExtracts the complex visibilities from an ehtim observation object\n\nReturns an EHTObservation with complex visibility data\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.load_ehtim-Tuple{}","page":"API","title":"Comrade.load_ehtim","text":"load_ehtim()\n\n\nLoads the eht-imaging library and stores it in the ehtim variable.\n\nNotes\n\nThis will fail if ehtim isn't installed in the python installation that PyCall references.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.load_tpy-Tuple{Any}","page":"API","title":"Comrade.load_tpy","text":"load_tpy(file)\n\n\nLoad a ThemisPy style ascii EHT observation file.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.logclosure_amplitude-NTuple{9, Any}","page":"API","title":"Comrade.logclosure_amplitude","text":"logclosure_amplitude(model, u1, v1, u2, v2, u3, v3, u4, v4)\n\n\nComputes the log-closure amplitude of model m at the uv-quadrangle u1,v1 -> u2,v2 -> u3,v3 -> u4,v3 using the formula\n\nC = logleftfracV(u1v1)V(u2v2)V(u3v3)V(u4v4)right\n\nIf you want to compute log closure amplitudes over a number of triangles consider using the logclosure_amplitudes function which uses MappedArrays to compute a lazy, no allocation vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.logclosure_amplitudes-Tuple{Any, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray}","page":"API","title":"Comrade.logclosure_amplitudes","text":"logclosure_amplitudes(m, u1, v1, u2, v2, u3, v3, u4, v4)\n\n\nComputes the log closure amplitudes of the model m at the quadrangles (u1,v1), (u2,v2), (u3,v3), (u4, v4).\n\nNote this is done lazily so the log closure amplitude is only computed when accessed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.modelimage-Tuple{M} where M","page":"API","title":"Comrade.modelimage","text":"Construct a ModelImage where just the model m is specified\n\nNotes\n\nIf m IsAnalytic() is the visibility domain this is a no-op and just returns the model itself. Otherwise modelimage will guess a reasonable field of view based on the radialextent function. One can optionally pass the number of pixels nx and ny in each direction.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.modelimage-Union{Tuple{M}, Tuple{M, ComradeBase.AbstractIntensityMap}} where M","page":"API","title":"Comrade.modelimage","text":"modelimage(model, image; alg)\nmodelimage(m; fovx, fovy, nx, ny, pulse, alg)\n\n\nConstruct a ModelImage from a model, image and the optionally specified visibility algorithm alg\n\nNotes\n\nFor analytic models this is a no-op and just return the model. For non-analytic models this wraps the model in a object with an image and precomputes the fourier transform using alg.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.rad2μas-Tuple{Any}","page":"API","title":"Comrade.rad2μas","text":"rad2μas(x)\n\nConverts a number from radians to μas\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.renormed-Union{Tuple{M}, Tuple{M, Any}} where M<:ComradeBase.AbstractModel","page":"API","title":"Comrade.renormed","text":"renormed(model, f)\n\n\nRenormalizes the model m to have total flux flux.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.rotated-Tuple{Any, Any}","page":"API","title":"Comrade.rotated","text":"rotated(model, ξ)\n\n\nRotates the model by an amount ξ in radians.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.shifted-Tuple{Any, Any, Any}","page":"API","title":"Comrade.shifted","text":"shifted(model, Δx, Δy)\n\n\nShifts the model m in the image domain by an amount Δx,Δy.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.smoothed-Tuple{Any, Number}","page":"API","title":"Comrade.smoothed","text":"smoothed(m, σ)\n\n\nSmooths a model m with a Gaussian kernel with standard deviation σ.\n\nNotes\n\nThis will created a convolved model under the hood.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.stretched-Tuple{Any, Any, Any}","page":"API","title":"Comrade.stretched","text":"stretched(model, α, β)\n\n\nStretches the model m according to the formula\n\n    I_s(xy) = 1(αβ) I(xα yβ)\n\nwhere were renormalize the intensity to preserve the models flux.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.uviterator-NTuple{4, Any}","page":"API","title":"Comrade.uviterator","text":"uviterator(dx, dy, nnx, nny)\n\n\nConstruct the u,v iterators for the Fourier transform of the image with pixel sizes dx, dy and number of pixels nx, ny\n\nIf you are extending Fourier transform stuff please use these functions to ensure that the centroid is being properly computed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.visibility-Tuple{PolarizedModel, Any, Any}","page":"API","title":"Comrade.visibility","text":"visibility(pimg, u, v)\n\n\nComputes the visibility in the stokes basis of the polarized model\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.visibility-Union{Tuple{M}, Tuple{M, Any, Any}} where M","page":"API","title":"Comrade.visibility","text":"visibility(mimg, u, v)\n\n\nComputes the complex visibility of model m at u,v positions u,v\n\nIf you want to compute the visibilities at a large number of positions consider using the visibilities function which uses MappedArrays to compute a lazy, no allocation vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.μas2rad-Tuple{Any}","page":"API","title":"Comrade.μas2rad","text":"μas2rad(x)\n\nConverts a number from μas to rad\n\n\n\n\n\n","category":"method"},{"location":"api/#ComradeBase.evpa-Tuple{Any, Any, Any}","page":"API","title":"ComradeBase.evpa","text":"evpa(pimg, u, v)\n\n\nelectric vector position angle or EVPA of the polarized model\n\n\n\n\n\n","category":"method"},{"location":"api/#ComradeBase.intensitymap!-Tuple{IntensityMap{<:StokesVector}, PolarizedModel}","page":"API","title":"ComradeBase.intensitymap!","text":"intensitymap!(pimg, pmodel)\n\n\nFinds the polarized intensity map of the polarized model pmodel.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComradeBase.m̆-Tuple{Any, Any, Any}","page":"API","title":"ComradeBase.m̆","text":"m̆(pimg, u, v)\n\n\nComputes the fractional linear polarization in the visibility domain\n\n    brevem = fracQ + iUI\n\n\n\n\n\n","category":"method"},{"location":"api/#HypercubeTransform.ascube-Tuple{Posterior}","page":"API","title":"HypercubeTransform.ascube","text":"ascube(post::Posterior)\n\nConstruct a flattened version of the posterior, where the parameters are transformed to live in the unit hypercube. In astronomy parlance, we are transforming the variables to the unit hypercube. This is done using the HypercubeTransform package.\n\nThe transformed posterior can then be evaluated by the logdensityof(transformed_posterior,x) method following the DensityInterface, where x vector that lives in the unit hypercube. Note this already includes the jacobian of the transformation so this does not need to be added.\n\nThis transform is useful for NestedSampling methods that often assume that the model is written to live in the unit hypercube.\n\n\n\n\n\n","category":"method"},{"location":"api/#HypercubeTransform.asflat-Tuple{Posterior}","page":"API","title":"HypercubeTransform.asflat","text":"asflat(post::Posterior)\n\nConstruct a flattened version of the posterior, where the parameters are transformed so that their support is from (-∞, ∞). This uses TransformVariables\n\nThe transformed posterior can then be evaluated by the logdensityof(transformed_posterior,x) method following the DensityInterface, where x is a flattened vector of the infinite support variables. Note this already includes the jacobian of the transformation so this does not need to be added.\n\nThis is useful for optimization and sampling algorithms such as HMC that will use gradients to explore the posterior surface.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParameterHandling.flatten-Tuple{Posterior}","page":"API","title":"ParameterHandling.flatten","text":"flatten(post::Posterior)\n\nFlatten the representation of the posterior. Internally this uses ParameterHandling to construct a flattened version of the posterior.\n\nNote this is distinct from asflat that transforms the variables to live in (-∞,∞). Instead this method just flattens the repsentation of the model from a NamedTuple to a vector. This allows the easier integration to optimization and sampling algorithms.\n\n\n\n\n\n","category":"method"},{"location":"api/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, ComradeBase.AbstractModel}","page":"API","title":"RecipesBase.apply_recipe","text":"plot(image::IntensityMap)\n\nwhere image is templated off of EHTImage struct.\n\nDetails\n\nThis was created to be close to the ehtim display object. It takes an EHTImage object and plots it according to EHT conventions.\n\nNote that is does not save the figure.\n\n\n\n\n\n","category":"method"},{"location":"api/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, IntensityMap}","page":"API","title":"RecipesBase.apply_recipe","text":"plot(image::IntensityMap)\n\nwhere image is templated off of EHTImage struct.\n\nDetails\n\nThis was created to be close to the ehtim display object. It takes an EHTImage object and plots it according to EHT conventions.\n\nNote that is does not save the figure.\n\n\n\n\n\n","category":"method"},{"location":"api/#TransformVariables.inverse-Tuple{Comrade.TransformedPosterior, Any}","page":"API","title":"TransformVariables.inverse","text":"inverse(posterior::TransformedPosterior, x)\n\nTransforms the value model parameters x into the flattened transformed space.\n\n\n\n\n\n","category":"method"},{"location":"api/#TransformVariables.transform-Tuple{Comrade.TransformedPosterior, Any}","page":"API","title":"TransformVariables.transform","text":"transform(posterior::TransformedPosterior, x)\n\nTransforms the value x into parameter space, i.e. usually a NamedTuple.\n\n\n\n\n\n","category":"method"},{"location":"interface/#Model-Interface","page":"Model Interface","title":"Model Interface","text":"","category":"section"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Comrade aims to be more modular and extensible than previous VLBI modeling packages. Namely, instead of making many different models, simple models are composed to construct complicated source morphologies. This is accomplished with a type, and trait based hierarchy.","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"To see how this works we will implement a  model","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"struct Gamma{T} <: Comrade.AbstractModel\n    α::T\nend","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"This will a compact source that has more extent than a usual Gaussian blob. This is a primtive model in that it can't easily be constructed from other models. Additionally, this model has analytic expressions in the image and Fourier domain. To tell Comrade that Gamma has these properties we need to specify a couple of traits","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"# Tell Comrade Gamma is a primitive model\nComrade.isprimitive(::Type{<:Gamma}) = IsPrimitive()\n\n# Fourier and image domain are analytic\nComrade.visanalytic(::Type{<:Gamma}) = IsAnalytic()\nComrade.imanalytic(::Type{<:Gamma}) = IsAnalytic()","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Now since both the image and visibilities are analytic we need to specify how to calculate them. First we will specify the image domain function:","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"function Comrade.intensity_point(m::Gamma, x, y)\n    r = hypot(x,y) + eps()\n    return inv(2π*gamma(α))*r^(α-1)*exp(-r)\nend","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Similarly we specify the visibility function as follows:","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"function Comrade.visibility_point(m, u, v)\n    return (1- )\nend","category":"page"},{"location":"vlbi_imaging_problem/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"vlbi_imaging_problem/#Introduction-to-the-VLBI-Imaging-Problem","page":"Getting Started","title":"Introduction to the VLBI Imaging Problem","text":"","category":"section"},{"location":"vlbi_imaging_problem/","page":"Getting Started","title":"Getting Started","text":"Very-long baseline interferometry (VLBI) is capable of taking the highest resolution images in the world, achieving angular resolutions of ~20 μas. In 2019 the first ever image of a black hole was produced by the Event Horizon Telescope (EHT). However, the EHT is a very sparse interferometer. This makes imaging uncertain. This is because VLBI doesn't measure an actual image, but rather the Fourier transform of the on-sky image. Futhermore, the EHT only have ~7 dishes at any one time. This makes the Fourier sampling very sparse/incomplete. As a result, there is no single image that can explain the data. Traditional imaging methods get around this with curated imaging algorithms, such as DIFMAP and regularized-maximum-likelihood. However, these methods still ignore the inherent uncertainty in the image reconstruction. Comrade instead views the imaging problem as a Bayesian inverse problem. ","category":"page"},{"location":"vlbi_imaging_problem/","page":"Getting Started","title":"Getting Started","text":"Namely, there isn't a single image capable of explaining the source structure but a family. Comrade is a Julia software package that views the imaging problem as a classical Bayesian inverse problem.","category":"page"},{"location":"vlbi_imaging_problem/","page":"Getting Started","title":"Getting Started","text":"Due to the high resolution VLBI data can be quite complicated. As such there is a variety of possible source structures. As such, Comrade provides a number of ","category":"page"},{"location":"vlbi_imaging_problem/","page":"Getting Started","title":"Getting Started","text":"To get started with Comrade","category":"page"},{"location":"vlbi_imaging_problem/","page":"Getting Started","title":"Getting Started","text":"using Comrade\n\n#load ehtim\nload_ehtim()\n\n# To load some data we can use\nobs = ehtim.obsdata.load_uvfits(\"FILENAME\")\n\n# Extract various data products from the EHTIM object\ndvis   = extract_vis(obs)\ndcp    = extract_cphase(obs)\ndlcamp = extract_lcamp(obs)\n\n# Just want the array configuration?\nac = arrayconfig(data)\n\n# Want to construct a elliptical Gaussian\nm1 = rotated(stretched(Gaussian(), 20.0, 10.0), π/4)\nm2 = ExtendedRing(20.0, 10.0)\nmtot = m1+m2\n\n# plot the model\nplot(mtot)\n\n# Lets make an image!\nimg = intensitymap(mtot, 80.0, 80.0, 128, 128)\n\n# plot the image\nplot(img)\n\n# Now construct a model image wrapper\n# Since Extended ring doesn't have a simple FT we need to specify an image to hold it.\n# In the future this will be automated.\nmimage = modelimage(mtot, img)\n\n\n#Now evaluate the visibilities\nvis = visibilities(mimage, ac)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Comrade","category":"page"},{"location":"#Comrade","page":"Home","title":"Comrade","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Comrade is a differentiable modular modeling framework for use with very long baseline interferometry. The goal is to allow the user to easily combine and modify a set of primitive models to construct complicated source structures. The benefit of this approach is that is straightforward to construct different source models out of these primitives. Namely, a end-user does not have to create a separate source \"model\" every time they change the model specification. Additionally, most models currently implemented are differentiable with at least ForwardDiff. This allows for gradient accelerated optimization, and sampling (e.g. HMC) to be used with little effort by the end user.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Comrade does not currently have a native optimization or sampling interface. The reasoning for this is that different problems are amenable to different optimizers. Rather than including all optimizers in Comrade, expanding the number of dependencies, Comrade tries to make moving from an image model to objective function easy. As an example of this we To use perform inferences on data you can then hook into the vast array of different modeling and optimization packages in Julia. There are some small examples packages defining these interface such as ComradeSoss.jl which combines Comrade with Soss a probabilistic programming language. Other interfaces to e.g. Turing, BAT are planned.","category":"page"},{"location":"#Requirements","page":"Home","title":"Requirements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The minimum Julia version we require is 1.6, which is the current LTS release. In the future we may increase this as Julia advances.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"index.md\",\n    \"vlbi_imaging_problem.md\",\n    \"example.md\",\n    \"interface.md\",\n    \"api.md\"\n]","category":"page"}]
}
