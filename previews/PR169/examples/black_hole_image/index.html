<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Making an Image of a Black Hole · Comrade.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Comrade.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../benchmarks/">Benchmarks</a></li><li><a class="tocitem" href="../../vlbi_imaging_problem/">Introduction to the VLBI Imaging Problem</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../data/">Loading Data into Comrade</a></li><li class="is-active"><a class="tocitem" href>Making an Image of a Black Hole</a><ul class="internal"><li><a class="tocitem" href="#Sampling-the-posterior"><span>Sampling the posterior</span></a></li></ul></li><li><a class="tocitem" href="../nonanalytic/">Modeling with non-analytic Fourier transforms</a></li></ul></li><li><span class="tocitem">Libraries</span><ul><li><a class="tocitem" href="../../libs/optimization/">ComradeOptimization</a></li><li><a class="tocitem" href="../../libs/ahmc/">ComradeAHMC</a></li><li><a class="tocitem" href="../../libs/nested/">ComradeNested</a></li><li><a class="tocitem" href="../../libs/dynesty/">ComradDynesty</a></li><li><a class="tocitem" href="../../libs/adaptmcmc/">ComradeAdaptMCMC</a></li></ul></li><li><a class="tocitem" href="../../interface/">Model Interface</a></li><li><a class="tocitem" href="../../base_api/">ComradeBase API</a></li><li><a class="tocitem" href="../../api/">Comrade API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Making an Image of a Black Hole</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Making an Image of a Black Hole</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ptiede/Comrade.jl/blob/main/docs/src/examples/black_hole_image.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Making-an-Image-of-a-Black-Hole"><a class="docs-heading-anchor" href="#Making-an-Image-of-a-Black-Hole">Making an Image of a Black Hole</a><a id="Making-an-Image-of-a-Black-Hole-1"></a><a class="docs-heading-anchor-permalink" href="#Making-an-Image-of-a-Black-Hole" title="Permalink"></a></h1><p><code>Comrade</code> has been designed to work with the EHT and ngEHT. In this tutorial we will show how to reproduce some of the results from <a href="https://iopscience.iop.org/article/10.3847/2041-8213/ab1141">EHTC VI 2019</a>.</p><p>In EHTC VI, they considered fitting simple geometric models to the data to estimate the image size, shape, brightness profile etc of the black hole. In this page we will construct a similar model and fit it to the data in under 50 lines of code (sans comments). To start we load some packages we will need</p><pre><code class="language-julia hljs">using Comrade</code></pre><p>The next step is to load the data. For this we will use the publically available M 87 data which can be downloaded from <a href="https://datacommons.cyverse.org/browse/iplant/home/shared/commons_repo/curated/EHTC_FirstM87Results_Apr2019">cyverse</a>. For an introduction to data loading see <a href="../data/#Loading-Data-into-Comrade">Loading Data into Comrade</a>.</p><pre><code class="language-julia hljs">load_ehtim()
obs = ehtim.obsdata.load_uvfits(joinpath(@__DIR__, &quot;../assets/SR1_M87_2017_096_lo_hops_netcal_StokesI.uvfits&quot;))
obs.add_scans()</code></pre><p>kill 0-baselines since we don&#39;t care about large scale flux and make scan-average data</p><pre><code class="language-julia hljs">obs = obs.flag_uvdist(uv_min=0.1e9).avg_coherent(0.0, scan_avg=true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PyObject &lt;ehtim.obsdata.Obsdata object at 0x7f2c22307d30&gt;</code></pre><p>grab data products we want to fit: log closure amplitudes and closure phases</p><pre><code class="language-julia hljs">dlcamp = extract_lcamp(obs)
dcphase = extract_cphase(obs)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EHTObservation{Float64,Comrade.EHTClosurePhaseDatum{Float64}, ...}
  source: M87
  mjd: 57849
  frequency: 2.27070703125e11
  bandwidth: 1.856e9
  stations: [:AP, :LM, :PV, :AA, :AZ, :JC, :SM]
  nsamples: 141
</code></pre><p>For this demo only consider closure products since these are invariant to station specific gain systematics. Given these data products we can then form our radio likelihood:</p><pre><code class="language-julia hljs">lklhd = RadioLikelihood(dlcamp, dcphase)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">RadioLikelihood
	Number of data products: 1
</code></pre><p>The <code>lklhd</code> constructs a measure using <code>MeasureTheory.jl</code>. To evaluate the likelihood we need to pass it a type that implements the <code>Comrade</code> model interface which is described in <a href="../../interface/#Model-Interface">Model Interface</a>.</p><p>To finish the construction of our posterior we need to specify an image model and a prior. For the image model we will be using a modified <code>MRing</code>, which is a infinitely thin delta ring with an azimuthal structure given by a Fourier expansion. To give the ring some width we will convolve the ring with a gaussian, and add an additional gaussian to the image to model any non-ring flux. For the model a user must give a function that accepts a named tuple and return the constructed model:</p><pre><code class="language-julia hljs">function model(θ)
  (;radius, width, α, β, f, σG, τG, ξG, xG, yG) = θ
  ring = f*smoothed(stretched(MRing((α,), (β,)), radius, radius), width)
  g = (1-f)*shifted(rotated(stretched(Gaussian(), σG, σG*(1+τG)), ξG), xG, yG)
  return ring + g
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">model (generic function with 1 method)</code></pre><p>We now need to specify the priors for our model. The easiest way to do this is to specify a NamedTuple of distributions:</p><pre><code class="language-julia hljs">using Distributions
prior = (
          radius = Uniform(μas2rad(10.0), μas2rad(30.0)),
          width = Uniform(μas2rad(1.0), μas2rad(10.0)),
          α = Uniform(-0.5, 0.5),
          β = Uniform(-0.5, 0.5),
          f = Uniform(0.0, 1.0),
          σG = Uniform(μas2rad(1.0), μas2rad(40.0)),
          τG = Uniform(0.0, 0.75),
          ξG = Uniform(0.0, 1π),
          xG = Uniform(-μas2rad(80.0), μas2rad(80.0)),
          yG = Uniform(-μas2rad(80.0), μas2rad(80.0))
        )</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(radius = Distributions.Uniform{Float64}(a=4.848136811095359e-11, b=1.454441043328608e-10), width = Distributions.Uniform{Float64}(a=4.84813681109536e-12, b=4.848136811095359e-11), α = Distributions.Uniform{Float64}(a=-0.5, b=0.5), β = Distributions.Uniform{Float64}(a=-0.5, b=0.5), f = Distributions.Uniform{Float64}(a=0.0, b=1.0), σG = Distributions.Uniform{Float64}(a=4.84813681109536e-12, b=1.9392547244381437e-10), τG = Distributions.Uniform{Float64}(a=0.0, b=0.75), ξG = Distributions.Uniform{Float64}(a=0.0, b=3.141592653589793), xG = Distributions.Uniform{Float64}(a=-3.8785094488762873e-10, b=3.8785094488762873e-10), yG = Distributions.Uniform{Float64}(a=-3.8785094488762873e-10, b=3.8785094488762873e-10))</code></pre><p>To form the posterior we now call</p><pre><code class="language- hljs">post = Posterior(lklhd, prior, model)</code></pre><p>This constructs a posterior density that can be evaluated by calling <code>logdensityof</code>. For example</p><pre><code class="language- hljs">logdensityof(post, (radius = μas2rad(20.0),
                  width = μas2rad(10.0),
                  α = 0.3,
                  β = 0.3,
                  f = 0.6,
                  σG = μas2rad(20.0),
                  τG = 0.1,
                  ξG = 0.5,
                  xG = 0.0,
                  yG = 0.0))</code></pre><p>We can now try to sample from our posterior <code>post</code> so that we can make probabilstic inferences about our data.</p><p>Now this model is in <strong>parameter</strong> space. Often optimization and sampling algorithms want it in some modified space. For example, nested sampling algorithms want the parameters in the unit hypercube. To transform the posterior to the unit hypercube we can use the <code>ascube</code> function</p><pre><code class="language- hljs">cpost = ascube(post)</code></pre><p>If we want to flatten the parameter space and move to (-∞, ∞) support we can use the <code>asflat</code> function</p><pre><code class="language- hljs">fpost = asflat(post)</code></pre><p>These transformed posterior expect a vector of parameters. That is we can evaluate the transformed log density by calling</p><pre><code class="language- hljs">logdensityof(cpost, rand(dimension(cpost)))
logdensityof(fpost, randn(dimension(fpost)))</code></pre><p>Note that this automatically takes care of the jacobian in the parameter transformation.</p><h2 id="Sampling-the-posterior"><a class="docs-heading-anchor" href="#Sampling-the-posterior">Sampling the posterior</a><a id="Sampling-the-posterior-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling-the-posterior" title="Permalink"></a></h2><p>Our strategy here will be to use Hamiltonian Monte Carlo. However, to lower burn-in time we will first use an optimizer to find a reasonable starting location. Since this is a lower dimensional problem we will use BlackboxOptim or the OptimizationBBO package</p><pre><code class="language- hljs">using ComradeOptimization
using OptimizationBBO

ndim = dimension(fpost)
f = OptimizationFunction(fpost)
prob = OptimizationProblem(f, randn(ndim), nothing, lb=fill(-5.0, ndim), ub=fill(5.0, ndim))
sol = solve(prob, BBO_adaptive_de_rand_1_bin_radiuslimited(); maxiters=50_000)</code></pre><p>The sol vector is in the transformed space, so first we need to transform back to parameter space</p><pre><code class="language- hljs">xopt = transform(fpost, sol)</code></pre><p>And we can also plot the map</p><pre><code class="language- hljs">using Plots
plot(model(xopt), title=&quot;MAP image&quot;, xlims=(-60.0,50.0), ylims=(-60.0,50.0))</code></pre><p>The main goal of <code>Comrade</code> is to explore the posterior of the model parameters. Currently the go to tool is <a href="https://github.com/TuringLang/AdvancedHMC.jl">AdvancedHMC.jl</a>. To sample from the posterior you can use the following:</p><pre><code class="language- hljs">using ComradeAHMC
chain, stats = sample(post, AHMC(metric=DiagEuclideanMetric(ndim)), 2000; nadapts=1000, init_params=xopt)</code></pre><p>That&#39;s it! To finish it up we can then plot some simple visual fit diagnostics.</p><p>First to plot the image we call</p><pre><code class="language- hljs">plot(model(chain[end]), title=&quot;Random image&quot;, xlims=(-60.0,50.0), ylims=(-60.0,50.0))</code></pre><p>What about the mean image? Well let&#39;s grab 100 images from the chain</p><pre><code class="language- hljs">meanimg = mean(intensitymap.(model.(sample(chain[1000:end], 100)), μas2rad(120.0), μas2rad(120.0), 128, 128))
plot(sqrt.(max.(meanimg, 0.0)), title=&quot;Mean Image&quot;) #plot on a sqrt color scale to see the Gaussian</code></pre><p>That looks similar to the EHTC VI, and it took us no time at all!. To see how well the model is fitting the data we can plot the model and data products</p><pre><code class="language- hljs">plot(model(xopt), dlcamp, label=&quot;MAP&quot;)</code></pre><p>We can also plot what many draws from the posterior look like</p><pre><code class="language- hljs">p = plot(dlcamp)
uva = [sqrt.(uvarea(dlcamp[i])) for i in 1:length(dlcamp)]
for i in 1:10
    m = logclosure_amplitudes(model(chain[rand(1000:2000)]), arrayconfig(dlcamp))
    scatter!(uva, m, color=:grey, label=:none, alpha=0.1)
end
p</code></pre><p>Finally, we can also put everything onto a common scale and plot the normalized residuals. The normalied residuals are the difference between the data and the model, divided by the data&#39;s error:</p><pre><code class="language- hljs">residual(model(xopt), dlcamp)</code></pre><p>All of the diagnostic plots suggest that the model is missing some emission. In fact, this model is slightly too simple to explain the data. Check out <a href="https://iopscience.iop.org/article/10.3847/2041-8213/ab1141">EHTC VI 2019</a> for some ideas what features need to be added to the model to get a better fit!</p><p>For a real run we should also check that the MCMC chain has converged. For this we can use MCMCDiagnostics</p><pre><code class="language-julia hljs">using MCMCDiagnostics, Tables</code></pre><p>First lets look at the effective sample size or ESS. This is important since the Monte Carlo standard error for MCMC estimates is proportional to 1/√ESS (for some problems).</p><pre><code class="language- hljs">ess = map(effective_sample_size, Tables.columns(chain))</code></pre><p>We can also calculate the split-rhat or potential scale reduction. For this we should actually use at least 4 chains. However for demonstation purposes we will use one chain that we split in two</p><pre><code class="language- hljs">rhats = map(Tables.columns(chain)) do c
    c1 = @view c[1001:1500]
    c2 = @view c[1501:2000]
    return potential_scale_reduction(c1, c2)
end</code></pre><p>Ok we have a split-rhat &lt; 1.01 on all parameters so we have success (in reality run more chains!).</p><p>Computing information</p><pre><code class="nohighlight hljs">Julia Version 1.7.3
Commit 742b9abb4d (2022-05-06 12:58 UTC)
Platform Info:
  OS: Linux (x86_64-pc-linux-gnu)
  CPU: 11th Gen Intel(R) Core(TM) i7-1185G7 @ 3.00GHz
  WORD_SIZE: 64
  LIBM: libopenlibm
  LLVM: libLLVM-12.0.1 (ORCJIT, tigerlake)</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../data/">« Loading Data into Comrade</a><a class="docs-footer-nextpage" href="../nonanalytic/">Modeling with non-analytic Fourier transforms »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Sunday 11 September 2022 06:46">Sunday 11 September 2022</span>. Using Julia version 1.8.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
