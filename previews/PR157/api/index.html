<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Comrade API · Comrade.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Comrade.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../benchmarks/">Benchmarks</a></li><li><a class="tocitem" href="../vlbi_imaging_problem/">Introduction to the VLBI Imaging Problem</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../examples/data/">Loading Data into Comrade</a></li><li><a class="tocitem" href="../examples/black_hole_image/">Making an Image of a Black Hole</a></li><li><a class="tocitem" href="../examples/nonanalytic/">Modeling with non-analytic Fourier transforms</a></li></ul></li><li><span class="tocitem">Libraries</span><ul><li><a class="tocitem" href="../libs/optimization/">ComradeOptimization</a></li><li><a class="tocitem" href="../libs/ahmc/">ComradeAHMC</a></li><li><a class="tocitem" href="../libs/nested/">ComradeNested</a></li><li><a class="tocitem" href="../libs/dynesty/">ComradDynesty</a></li><li><a class="tocitem" href="../libs/adaptmcmc/">ComradeAdaptMCMC</a></li></ul></li><li><a class="tocitem" href="../interface/">Model Interface</a></li><li><a class="tocitem" href="../base_api/">ComradeBase API</a></li><li class="is-active"><a class="tocitem" href>Comrade API</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Model-Definitions"><span>Model Definitions</span></a></li><li><a class="tocitem" href="#Data-Types"><span>Data Types</span></a></li><li><a class="tocitem" href="#eht-imaging-interface"><span>eht-imaging interface</span></a></li><li><a class="tocitem" href="#Bayesian-Tools"><span>Bayesian Tools</span></a></li><li><a class="tocitem" href="#Misc"><span>Misc</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Comrade API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Comrade API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ptiede/Comrade.jl/blob/source/docs/src/api.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Comrade-API"><a class="docs-heading-anchor" href="#Comrade-API">Comrade API</a><a id="Comrade-API-1"></a><a class="docs-heading-anchor-permalink" href="#Comrade-API" title="Permalink"></a></h1><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#Comrade-API">Comrade API</a></li><li class="no-marker"><ul><li><a href="#Contents">Contents</a></li><li><a href="#Index">Index</a></li><li><a href="#Model-Definitions">Model Definitions</a></li><li><a href="#Data-Types">Data Types</a></li><li><a href="#eht-imaging-interface">eht-imaging interface</a></li><li><a href="#Bayesian-Tools">Bayesian Tools</a></li><li><a href="#Misc">Misc</a></li></ul></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Comrade.AbstractModifier"><code>Comrade.AbstractModifier</code></a></li><li><a href="#Comrade.AddModel"><code>Comrade.AddModel</code></a></li><li><a href="#Comrade.AmpNormal"><code>Comrade.AmpNormal</code></a></li><li><a href="#Comrade.ArrayBaselineDatum"><code>Comrade.ArrayBaselineDatum</code></a></li><li><a href="#Comrade.CPVonMises"><code>Comrade.CPVonMises</code></a></li><li><a href="#Comrade.ClosureConfig"><code>Comrade.ClosureConfig</code></a></li><li><a href="#Comrade.ComplexNormal"><code>Comrade.ComplexNormal</code></a></li><li><a href="#Comrade.CompositeModel"><code>Comrade.CompositeModel</code></a></li><li><a href="#Comrade.ConcordanceCrescent"><code>Comrade.ConcordanceCrescent</code></a></li><li><a href="#Comrade.ConvolvedModel"><code>Comrade.ConvolvedModel</code></a></li><li><a href="#Comrade.DFTAlg-Tuple{Comrade.EHTObservation}"><code>Comrade.DFTAlg</code></a></li><li><a href="#Comrade.DFTAlg"><code>Comrade.DFTAlg</code></a></li><li><a href="#Comrade.DesignMatrix"><code>Comrade.DesignMatrix</code></a></li><li><a href="#Comrade.Disk"><code>Comrade.Disk</code></a></li><li><a href="#Comrade.EHTArrayConfiguration"><code>Comrade.EHTArrayConfiguration</code></a></li><li><a href="#Comrade.EHTClosurePhaseDatum"><code>Comrade.EHTClosurePhaseDatum</code></a></li><li><a href="#Comrade.EHTLogClosureAmplitudeDatum"><code>Comrade.EHTLogClosureAmplitudeDatum</code></a></li><li><a href="#Comrade.EHTObservation"><code>Comrade.EHTObservation</code></a></li><li><a href="#Comrade.EHTVisibilityAmplitudeDatum"><code>Comrade.EHTVisibilityAmplitudeDatum</code></a></li><li><a href="#Comrade.EHTVisibilityDatum"><code>Comrade.EHTVisibilityDatum</code></a></li><li><a href="#Comrade.ExtendedRing"><code>Comrade.ExtendedRing</code></a></li><li><a href="#Comrade.GainCache-Tuple{Comrade.ScanTable}"><code>Comrade.GainCache</code></a></li><li><a href="#Comrade.GainCache"><code>Comrade.GainCache</code></a></li><li><a href="#Comrade.GainModel"><code>Comrade.GainModel</code></a></li><li><a href="#Comrade.GainPrior"><code>Comrade.GainPrior</code></a></li><li><a href="#Comrade.GainPrior-Tuple{Any, Comrade.ScanTable}"><code>Comrade.GainPrior</code></a></li><li><a href="#Comrade.Gaussian"><code>Comrade.Gaussian</code></a></li><li><a href="#Comrade.GeometricModel"><code>Comrade.GeometricModel</code></a></li><li><a href="#Comrade.MRing"><code>Comrade.MRing</code></a></li><li><a href="#Comrade.ModelImage"><code>Comrade.ModelImage</code></a></li><li><a href="#Comrade.MultiRadioLikelihood"><code>Comrade.MultiRadioLikelihood</code></a></li><li><a href="#Comrade.ParabolicSegment"><code>Comrade.ParabolicSegment</code></a></li><li><a href="#Comrade.PolarizedModel"><code>Comrade.PolarizedModel</code></a></li><li><a href="#Comrade.Posterior"><code>Comrade.Posterior</code></a></li><li><a href="#Comrade.RIMEModel"><code>Comrade.RIMEModel</code></a></li><li><a href="#Comrade.RadioLikelihood"><code>Comrade.RadioLikelihood</code></a></li><li><a href="#Comrade.RenormalizedModel"><code>Comrade.RenormalizedModel</code></a></li><li><a href="#Comrade.Ring"><code>Comrade.Ring</code></a></li><li><a href="#Comrade.RotatedModel"><code>Comrade.RotatedModel</code></a></li><li><a href="#Comrade.Scan"><code>Comrade.Scan</code></a></li><li><a href="#Comrade.ScanTable"><code>Comrade.ScanTable</code></a></li><li><a href="#Comrade.ShiftedModel"><code>Comrade.ShiftedModel</code></a></li><li><a href="#Comrade.StretchedModel"><code>Comrade.StretchedModel</code></a></li><li><a href="#Comrade.TransformedPosterior"><code>Comrade.TransformedPosterior</code></a></li><li><a href="#Base.:+-Tuple{ComradeBase.AbstractModel, ComradeBase.AbstractModel}"><code>Base.:+</code></a></li><li><a href="#Comrade.Crescent"><code>Comrade.Crescent</code></a></li><li><a href="#Comrade.added"><code>Comrade.added</code></a></li><li><a href="#Comrade.amplitude-Tuple{Comrade.EHTVisibilityDatum}"><code>Comrade.amplitude</code></a></li><li><a href="#Comrade.amplitude"><code>Comrade.amplitude</code></a></li><li><a href="#Comrade.amplitude-Tuple{Comrade.EHTVisibilityAmplitudeDatum}"><code>Comrade.amplitude</code></a></li><li><a href="#Comrade.amplitudes"><code>Comrade.amplitudes</code></a></li><li><a href="#Comrade.arrayconfig"><code>Comrade.arrayconfig</code></a></li><li><a href="#Comrade.baselines"><code>Comrade.baselines</code></a></li><li><a href="#Comrade.basemodel"><code>Comrade.basemodel</code></a></li><li><a href="#Comrade.bispectra"><code>Comrade.bispectra</code></a></li><li><a href="#Comrade.bispectrum"><code>Comrade.bispectrum</code></a></li><li><a href="#Comrade.closure_phase-Tuple{Comrade.EHTVisibilityDatum, Comrade.EHTVisibilityDatum, Comrade.EHTVisibilityDatum}"><code>Comrade.closure_phase</code></a></li><li><a href="#Comrade.closure_phase"><code>Comrade.closure_phase</code></a></li><li><a href="#Comrade.closure_phases"><code>Comrade.closure_phases</code></a></li><li><a href="#Comrade.coherencymatrix-Tuple{PolarizedModel, Any, Any}"><code>Comrade.coherencymatrix</code></a></li><li><a href="#Comrade.components"><code>Comrade.components</code></a></li><li><a href="#Comrade.convolved"><code>Comrade.convolved</code></a></li><li><a href="#Comrade.corrupt"><code>Comrade.corrupt</code></a></li><li><a href="#Comrade.create_cache"><code>Comrade.create_cache</code></a></li><li><a href="#Comrade.extract_amp"><code>Comrade.extract_amp</code></a></li><li><a href="#Comrade.extract_cphase"><code>Comrade.extract_cphase</code></a></li><li><a href="#Comrade.extract_lcamp"><code>Comrade.extract_lcamp</code></a></li><li><a href="#Comrade.extract_vis"><code>Comrade.extract_vis</code></a></li><li><a href="#Comrade.fileio_load"><code>Comrade.fileio_load</code></a></li><li><a href="#Comrade.fileio_save"><code>Comrade.fileio_save</code></a></li><li><a href="#Comrade.fouriermap"><code>Comrade.fouriermap</code></a></li><li><a href="#Comrade.getdata"><code>Comrade.getdata</code></a></li><li><a href="#Comrade.getuv"><code>Comrade.getuv</code></a></li><li><a href="#Comrade.getuvtimefreq"><code>Comrade.getuvtimefreq</code></a></li><li><a href="#Comrade.load_ehtim"><code>Comrade.load_ehtim</code></a></li><li><a href="#Comrade.logclosure_amplitude"><code>Comrade.logclosure_amplitude</code></a></li><li><a href="#Comrade.logclosure_amplitudes"><code>Comrade.logclosure_amplitudes</code></a></li><li><a href="#Comrade.make_pullback"><code>Comrade.make_pullback</code></a></li><li><a href="#Comrade.mbreve"><code>Comrade.mbreve</code></a></li><li><a href="#Comrade.modelimage"><code>Comrade.modelimage</code></a></li><li><a href="#Comrade.posangle"><code>Comrade.posangle</code></a></li><li><a href="#Comrade.prior_sample"><code>Comrade.prior_sample</code></a></li><li><a href="#Comrade.rad2μas"><code>Comrade.rad2μas</code></a></li><li><a href="#Comrade.renormed"><code>Comrade.renormed</code></a></li><li><a href="#Comrade.rescaleuv!"><code>Comrade.rescaleuv!</code></a></li><li><a href="#Comrade.rotated"><code>Comrade.rotated</code></a></li><li><a href="#Comrade.scale_image"><code>Comrade.scale_image</code></a></li><li><a href="#Comrade.scale_uv"><code>Comrade.scale_uv</code></a></li><li><a href="#Comrade.scantable"><code>Comrade.scantable</code></a></li><li><a href="#Comrade.shifted"><code>Comrade.shifted</code></a></li><li><a href="#Comrade.smoothed"><code>Comrade.smoothed</code></a></li><li><a href="#Comrade.stations"><code>Comrade.stations</code></a></li><li><a href="#Comrade.stretched"><code>Comrade.stretched</code></a></li><li><a href="#Comrade.transform_image"><code>Comrade.transform_image</code></a></li><li><a href="#Comrade.transform_uv"><code>Comrade.transform_uv</code></a></li><li><a href="#Comrade.update_cache"><code>Comrade.update_cache</code></a></li><li><a href="#Comrade.uviterator"><code>Comrade.uviterator</code></a></li><li><a href="#Comrade.uvpositions"><code>Comrade.uvpositions</code></a></li><li><a href="#Comrade.visibilities"><code>Comrade.visibilities</code></a></li><li><a href="#Comrade.visibility"><code>Comrade.visibility</code></a></li><li><a href="#Comrade.μas2rad"><code>Comrade.μas2rad</code></a></li><li><a href="#ComradeBase.evpa-Tuple{ComradeBase.AbstractPolarizedModel, Any, Any}"><code>ComradeBase.evpa</code></a></li><li><a href="#ComradeBase.intensitymap"><code>ComradeBase.intensitymap</code></a></li><li><a href="#ComradeBase.intensitymap!"><code>ComradeBase.intensitymap!</code></a></li><li><a href="#ComradeBase.m̆-Tuple{ComradeBase.AbstractPolarizedModel, Any, Any}"><code>ComradeBase.m̆</code></a></li><li><a href="#HypercubeTransform.ascube"><code>HypercubeTransform.ascube</code></a></li><li><a href="#HypercubeTransform.asflat"><code>HypercubeTransform.asflat</code></a></li><li><a href="#ParameterHandling.flatten"><code>ParameterHandling.flatten</code></a></li><li><a href="#StatsBase.sample-Tuple{Posterior}"><code>StatsBase.sample</code></a></li><li><a href="#TransformVariables.inverse"><code>TransformVariables.inverse</code></a></li><li><a href="#TransformVariables.transform"><code>TransformVariables.transform</code></a></li></ul><h2 id="Model-Definitions"><a class="docs-heading-anchor" href="#Model-Definitions">Model Definitions</a><a id="Model-Definitions-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Definitions" title="Permalink"></a></h2><h3 id="Calibration-Models"><a class="docs-heading-anchor" href="#Calibration-Models">Calibration Models</a><a id="Calibration-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Calibration-Models" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Comrade.corrupt" href="#Comrade.corrupt"><code>Comrade.corrupt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">corrupt(vis::AbstractArray, cache::GainCache, gains::AbstractArray)</code></pre><p>Corrupt the visibilities <code>vis</code> with the gains <code>gains</code> using a <code>cache</code>.</p><p>This returns an array of corrupted visibilties. This is called internally by the <code>GainModel</code> when producing the visibilties.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/calibration/gains.jl#LL248-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.DesignMatrix" href="#Comrade.DesignMatrix"><code>Comrade.DesignMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DesignMatrix{X, M&lt;:AbstractArray{X, 2}, T, S} &lt;: AbstractArray{X, 2}</code></pre><p>Internal type that holds the gain design matrices for visibility corruption. See <a href="#Comrade.GainCache"><code>GainCache</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/calibration/gains.jl#LL24-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.GainCache" href="#Comrade.GainCache"><code>Comrade.GainCache</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GainCache{D1&lt;:Comrade.DesignMatrix, D2&lt;:Comrade.DesignMatrix, T, S}</code></pre><p><strong>Fields</strong></p><ul><li><p><code>m1</code></p><p>Gain design matrix for the first station</p></li></ul><ul><li><p><code>m2</code></p><p>Gain design matrix for the second station</p></li></ul><ul><li><p><code>times</code></p><p>Set of times for each gain</p></li></ul><ul><li><p><code>stations</code></p><p>Set of stations for each gain</p></li></ul><p><strong>Notes</strong></p><p>Internal type. This should be created using the <a href="#Comrade.GainCache"><code>GainCache(st::ScanTable)</code></a> method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/calibration/gains.jl#LL114-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.GainCache-Tuple{Comrade.ScanTable}" href="#Comrade.GainCache-Tuple{Comrade.ScanTable}"><code>Comrade.GainCache</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GainCache(st::ScanTable)</code></pre><p>Creates a cache for the application of gain corruptions to the model visibilities. This cache consists of the gain design matrices for each station and the set of times and stations for each gain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/calibration/gains.jl#LL171-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.GainModel" href="#Comrade.GainModel"><code>Comrade.GainModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GainModel{C, G&lt;:AbstractArray, M} &lt;: Comrade.RIMEModel</code></pre><p>A model that applies gain corruptions to a <code>Comrade</code> <code>model</code>. This obeys the usual <code>Comrade</code> interface and can be evaluated using <code>visibilities</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>cache</code></p><p>Cache for the application of gain. This can be constructed with <a href="#Comrade.GainCache"><code>GainCache</code></a>.</p></li></ul><ul><li><p><code>gains</code></p><p>Array of the specific gains that are to be applied to the visibilities.</p></li></ul><ul><li><p><code>model</code></p><p>Base model that will be used to compute the uncorrupted visibilities.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/calibration/gains.jl#LL185-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.GainPrior" href="#Comrade.GainPrior"><code>Comrade.GainPrior</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GainPrior(dists, st::ScanTable)</code></pre><p>Creates a distribution for the gain priors for scan table <code>st</code>. The <code>dists</code> should be a NamedTuple of <code>Distributions</code>, where each name corresponds to a telescope or station in the scan table. See <a href="#Comrade.scantable"><code>scantable</code></a>. The resulting type if a subtype of the <code>Distributions.AbstractDistribution</code> so the usual <code>Distributions</code> interface should work.</p><p><strong>Example</strong></p><p>For the 2017 observations of M87 a common GainPrior call is:</p><pre><code class="language-julia-repl hljs">julia&gt; gdist = GainPrior((AA = LogNormal(0.0, 0.1),
                   AP = LogNormal(0.0, 0.1),
                   JC = LogNormal(0.0, 0.1),
                   SM = LogNormal(0.0, 0.1),
                   AZ = LogNormal(0.0, 0.1),
                   LM = LogNormal(0.0, 1.0),
                   PV = LogNormal(0.0, 0.1)
                ), st)

julia&gt; x = rand(gdist)
julia&gt; logdensityof(gdist, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/calibration/gains.jl#LL59-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.GainPrior-Tuple{Any, Comrade.ScanTable}" href="#Comrade.GainPrior-Tuple{Any, Comrade.ScanTable}"><code>Comrade.GainPrior</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GainPrior(dists, st::ScanTable)</code></pre><p>Creates a distribution for the gain priors for scan table <code>st</code>. The <code>dists</code> should be a NamedTuple of <code>Distributions</code>, where each name corresponds to a telescope or station in the scan table. See <a href="#Comrade.scantable"><code>scantable</code></a>. The resulting type if a subtype of the <code>Distributions.AbstractDistribution</code> so the usual <code>Distributions</code> interface should work.</p><p><strong>Example</strong></p><p>For the 2017 observations of M87 a common GainPrior call is:</p><pre><code class="language-julia-repl hljs">julia&gt; gdist = GainPrior((AA = LogNormal(0.0, 0.1),
                   AP = LogNormal(0.0, 0.1),
                   JC = LogNormal(0.0, 0.1),
                   SM = LogNormal(0.0, 0.1),
                   AZ = LogNormal(0.0, 0.1),
                   LM = LogNormal(0.0, 1.0),
                   PV = LogNormal(0.0, 0.1)
                ), st)

julia&gt; x = rand(gdist)
julia&gt; logdensityof(gdist, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/calibration/gains.jl#LL59-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.RIMEModel" href="#Comrade.RIMEModel"><code>Comrade.RIMEModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type RIMEModel &lt;: ComradeBase.AbstractModel</code></pre><p>Abstract type that encompasses all RIME style corruptions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/calibration/gains.jl#LL9-L13">source</a></section></article><h3 id="Combinators"><a class="docs-heading-anchor" href="#Combinators">Combinators</a><a id="Combinators-1"></a><a class="docs-heading-anchor-permalink" href="#Combinators" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Tuple{ComradeBase.AbstractModel, ComradeBase.AbstractModel}" href="#Base.:+-Tuple{ComradeBase.AbstractModel, ComradeBase.AbstractModel}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.:+(m1::AbstractModel, m2::AbstractModel)</code></pre><p>Combine two models to create a composite <a href="#Comrade.AddModel"><code>AddModel</code></a>. This adds two models pointwise, i.e.</p><pre><code class="language-julia-repl hljs">julia&gt; m1 = Gaussian()
julia&gt; m2 = Disk()
julia&gt; visibility(m1+m2, 1.0, 1.0) == visibility(m1, 1.0, 1.0) + visibility(m2, 1.0, 1.0)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/combinators.jl#LL77-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.added" href="#Comrade.added"><code>Comrade.added</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">added(m1::AbstractModel, m2::AbstractModel)</code></pre><p>Combine two models to create a composite <a href="#Comrade.AddModel"><code>AddModel</code></a>. This adds two models pointwise, i.e.</p><pre><code class="language-julia-repl hljs">julia&gt; m1 = Gaussian()
julia&gt; m2 = Disk()
julia&gt; visibility(added(m1,m2), 1.0, 1.0) == visibility(m1, 1.0, 1.0) + visibility(m2, 1.0, 1.0)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/combinators.jl#LL94-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.convolved" href="#Comrade.convolved"><code>Comrade.convolved</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">convolved(m1::AbstractModel, m2::AbstractModel)</code></pre><p>Convolve two models to create a composite <a href="#Comrade.ConvolvedModel"><code>ConvolvedModel</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; m1 = Ring()
julia&gt; m2 = Disk()
julia&gt; convolved(m1, m2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/combinators.jl#LL233-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.components" href="#Comrade.components"><code>Comrade.components</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">components(m::AbstractModel)</code></pre><p>Returns the model components for a composite model. This will return a Tuple with all the models you have constructed.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m = Gaussian() + Disk()
julia&gt; components(m)
(Gaussian{Float64}(), Disk{Float64}())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/combinators.jl#LL123-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.smoothed" href="#Comrade.smoothed"><code>Comrade.smoothed</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">smoothed(m::AbstractModel, σ::Number)</code></pre><p>Smooths a model <code>m</code> with a Gaussian kernel with standard deviation <code>σ</code>.</p><p><strong>Notes</strong></p><p>This uses <a href="#Comrade.convolved"><code>convolved</code></a> to created the model, i.e.</p><pre><code class="language-julia-repl hljs">julia&gt; m1 = Disk()
julia&gt; m2 = Gaussian()
julia&gt; convolved(m1, m2) == smoothed(m1, 1.0)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/combinators.jl#LL246-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.CompositeModel" href="#Comrade.CompositeModel"><code>Comrade.CompositeModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type CompositeModel{M1, M2} &lt;: ComradeBase.AbstractModel</code></pre><p>Abstract type that denotes a composite model. Where we have combined two models together.</p><p><strong>Implementation</strong></p><p>Any implementation of a composite type must define the following methods:</p><ul><li>visibility_point</li><li>uv_combinator</li><li>imanalytic</li><li>visanalytic</li><li>ComradeBase.intensity_point if model intensity is <code>IsAnalytic</code></li><li>intensitymap! if model intensity is <code>NotAnalytic</code></li><li>intensitymap if model intensity is <code>NotAnalytic</code></li><li>flux</li><li>radialextent</li><li>visibilities (optional)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/combinators.jl#LL3-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.AddModel" href="#Comrade.AddModel"><code>Comrade.AddModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct AddModel{T1, T2} &lt;: Comrade.CompositeModel{T1, T2}</code></pre><p>Pointwise addition of two models in the image and visibility domain. An end user should instead call <a href="#Comrade.added"><code>added</code></a> or <code>Base.+</code> when constructing a model</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m1 = Disk() + Gaussian()
julia&gt; m2 = added(Disk(), Gaussian()) + Ring()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/combinators.jl#LL58-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.ConvolvedModel" href="#Comrade.ConvolvedModel"><code>Comrade.ConvolvedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ConvolvedModel{M1, M2} &lt;: Comrade.CompositeModel{M1, M2}</code></pre><p>Pointwise addition of two models in the image and visibility domain. An end user should instead call <a href="#Comrade.convolved"><code>convolved</code></a>. Also see <a href="#Comrade.smoothed"><code>smoothed(m, σ)</code></a> for a simplified function that convolves a model <code>m</code> with a Gaussian with standard deviation <code>σ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/combinators.jl#LL220-L227">source</a></section></article><h3 id="GeometricModels"><a class="docs-heading-anchor" href="#GeometricModels">GeometricModels</a><a id="GeometricModels-1"></a><a class="docs-heading-anchor-permalink" href="#GeometricModels" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Comrade.scale_uv" href="#Comrade.scale_uv"><code>Comrade.scale_uv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">scale_image(model::AbstractModifier, u, u)</code></pre><p>Returns a number on how to scale the image visibility at <code>u</code> <code>v</code> for an modified <code>model</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/modifiers.jl#LL83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.scale_image" href="#Comrade.scale_image"><code>Comrade.scale_image</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">scale_image(model::AbstractModifier, x, y)</code></pre><p>Returns a number of how to to scale the image intensity at <code>x</code> <code>y</code> for an modified <code>model</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/modifiers.jl#LL68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.transform_uv" href="#Comrade.transform_uv"><code>Comrade.transform_uv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform_uv(model::AbstractModifier, u, u)</code></pre><p>Returns a transformed <code>u</code> and <code>v</code> according to the <code>model</code> modifier</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/modifiers.jl#LL90-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.transform_image" href="#Comrade.transform_image"><code>Comrade.transform_image</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform_image(model::AbstractModifier, x, y)</code></pre><p>Returns a transformed <code>x</code> and <code>y</code> according to the <code>model</code> modifier</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/modifiers.jl#LL76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.GeometricModel" href="#Comrade.GeometricModel"><code>Comrade.GeometricModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type GeometricModel &lt;: ComradeBase.AbstractModel</code></pre><p>A type that defines it is a geometric model. These are usually primitive models, and are usually analytic in Fourier and the image domain. As a result a user only needs to implement the following methods</p><ul><li><code>visibility_point</code></li><li><code>intensity_point</code></li><li><code>radialextent</code></li></ul><p>Note that if the geometric model isn&#39;t <strong>analytic</strong> then the usual methods listed in <a href="../base_api/#ComradeBase.AbstractModel"><code>Comrade.AbstractModel</code></a> for non-analytic models need to be implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/geometric_models.jl#LL11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.ConcordanceCrescent" href="#Comrade.ConcordanceCrescent"><code>Comrade.ConcordanceCrescent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ConcordanceCrescent{T} &lt;: Comrade.GeometricModel</code></pre><p>Creates the ConcordanceCrescent model, i.e. a flat-top crescent with a displacment and a slash. Note this creates a crescent with unit flux. If you want a different flux please use the <code>renomed</code> modifier.</p><p><strong>Fields</strong></p><ul><li><p><code>router</code></p><p>Outer radius of the crescent</p></li></ul><ul><li><p><code>rinner</code></p><p>Inner radius of the crescent (i.e. inside this radius there is a hole)</p></li></ul><ul><li><p><code>shift</code></p><p>Displacment of the inner disk radius</p></li></ul><ul><li><p><code>slash</code></p><p>Strength of the linear slash. Note that s∈[0.0,1.0] to ensure positivity in the image.</p></li></ul><p><strong>Notes</strong></p><p>Unlike the Gaussian and Disk models this does not create the unit version. In fact, this model could have been created using the <code>Disk</code> and primitives by using Comrade.jl&#39;s model composition functionality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/geometric_models.jl#LL278-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.Crescent" href="#Comrade.Crescent"><code>Comrade.Crescent</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Creates a <a href="https://academic.oup.com/mnras/article/434/1/765/1005984">Kamruddin and Dexter</a> crescent model. This works by composing two disk models together.</p><p><strong>Arguments</strong></p><ul><li><code>router</code>: The radius of the outer disk</li><li><code>rinner</code>: The radius of the inner disk</li><li><code>shift</code>: How much the inner disk radius is shifted (positive is to the right)</li><li><code>floor</code>: The floor of the inner disk 0 means the inner intensity is zero and 1 means it is a large disk.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/geometric_models.jl#LL261-L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.Disk" href="#Comrade.Disk"><code>Comrade.Disk</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Disk{T}() where {T}</code></pre><p>Tophat disk geometrical model, i.e. the intensity profile</p><p class="math-container">\[    I(x,y) = \begin{cases} \pi^{-1} &amp; x^2+y^2 &lt; 1 \\ 0 &amp; x^2+y^2 \geq 0 \end{cases}\]</p><p>i.e. a unit radius and unit flux disk.</p><p>By default if T isn&#39;t given, <code>Disk</code> defaults to <code>Float64</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/geometric_models.jl#LL57-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.ExtendedRing" href="#Comrade.ExtendedRing"><code>Comrade.ExtendedRing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ExtendedRing{F&lt;:Number} &lt;: Comrade.GeometricModel</code></pre><p>A symmetric extended ring whose radial profile follows an inverse gamma distributions.</p><p>The formula in the image domain is given by</p><pre><code class="nohighlight hljs">I(r,θ) = βᵅrᵅ⁻²exp(-β/r)/2πΓ(α)</code></pre><p>where <code>α = shape</code> and <code>β = shape+1</code></p><p><strong>Note</strong></p><p>We mainly use this as an example of a non-analytic Fourier transform (although it has a complicated expression)</p><p><strong>Fields</strong></p><ul><li><p><code>shape</code></p><p>shape of the radial distribution</p></li></ul><p>Note that if <code>T</code> isn&#39;t specified at construction then it defaults to <code>Float64</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/geometric_models.jl#LL356-L375">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.Gaussian" href="#Comrade.Gaussian"><code>Comrade.Gaussian</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Gaussian{T} &lt;: Comrade.GeometricModel</code></pre><p>Gaussian with unit standard deviation and flux.</p><p>By default if T isn&#39;t given, <code>Gaussian</code> defaults to <code>Float64</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/geometric_models.jl#LL34-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.MRing" href="#Comrade.MRing"><code>Comrade.MRing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct MRing{T, V&lt;:AbstractArray{T, 1}} &lt;: Comrade.GeometricModel</code></pre><p>m-ring geometric model. This is a infinitely thin unit flux delta ring whose angular structure is given by a Fourier expansion. That is,</p><pre><code class="nohighlight hljs">I(r,θ) = (2π)⁻¹δ(r-1)∑ₙ(αₙcos(nθ) - βₙsin(nθ))</code></pre><p>The <code>N</code> in the type defines the order of the Fourier expansion.</p><p><strong>Fields</strong></p><ul><li><p><code>α</code></p><p>Real Fourier mode coefficients</p></li></ul><ul><li><p><code>β</code></p><p>Imaginary Fourier mode coefficients</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/geometric_models.jl#LL118-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.Ring" href="#Comrade.Ring"><code>Comrade.Ring</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Ring{T} &lt;: Comrade.GeometricModel</code></pre><p>A infinitely thin ring model, whose expression in the image domain is     I(r,θ) = δ(r - 1)/2π i.e. a unit radius and flux delta ring.</p><p>By default if <code>T</code> isn&#39;t given, <code>Gaussian</code> defaults to <code>Float64</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/geometric_models.jl#LL83-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.ParabolicSegment" href="#Comrade.ParabolicSegment"><code>Comrade.ParabolicSegment</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ParabolicSegment{T} &lt;: Comrade.GeometricModel</code></pre><p>A infinitely thin parabolic segment in the image domain. The segment is centered at zero, with roots ±1 and a yintercept of 1.</p><p>Note that if <code>T</code> isn&#39;t specified at construction then it defaults to <code>Float64</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/geometric_models.jl#LL392-L399">source</a></section></article><h3 id="Model-Image-(non-analytic-FFT)"><a class="docs-heading-anchor" href="#Model-Image-(non-analytic-FFT)">Model Image (non analytic FFT)</a><a id="Model-Image-(non-analytic-FFT)-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Image-(non-analytic-FFT)" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Comrade.create_cache" href="#Comrade.create_cache"><code>Comrade.create_cache</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_cache(alg::AbstractFourierTransform, img::AbstractIntensityMap)</code></pre><p>Creates a Fourier transform cache for a img using algorithm <code>alg</code>. For non-analytic visibility models this can significantly speed up computations.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; u,v = rand(100), rand(100)
julia&gt; cache = create_cache(DFTAlg(u, v), IntensityMap(randn(50,50), 10.0, 10.0))
julia&gt; cache = create_cache(NFFTAlg(u, v), IntensityMap(randn(50,50), 10.0, 10.0))
julia&gt; cache = create_cache(FFTAlg(), IntensityMap(randn(50,50), 10.0, 10.0))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/modelimage/cache.jl#LL16-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.update_cache" href="#Comrade.update_cache"><code>Comrade.update_cache</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_cache(cache, img)</code></pre><p>Update the Fourier transform cache. This will reuse an FFT/NFFT plan saving some computational time.</p><p><strong>Note</strong></p><p>This is an intenal method than an end user shouldn&#39;t have to usually call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/modelimage/cache.jl#LL33-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.modelimage" href="#Comrade.modelimage"><code>Comrade.modelimage</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">modelimage(model::AbstractIntensityMap, image::AbstractIntensityMap, alg=FFTAlg(), executor=SequentialEx())</code></pre><p>Construct a <code>ModelImage</code> from a <code>model</code>, <code>image</code> and the optionally specified visibility algorithm <code>alg</code> and <code>executor</code> which uses Folds.jl parallelism formalism.</p><p><strong>Notes</strong></p><p>For analytic models this is a no-op and returns the model. For non-analytic models this creates a <code>ModelImage</code> object which uses <code>alg</code> to compute the non-analytic Fourier transform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/modelimage/modelimage.jl#LL69-L80">source</a></section><section><div><pre><code class="nohighlight hljs">modelimage(model, cache::AbstractCache, executor=SequentialEx())</code></pre><p>Construct a <code>ModelImage</code> from the <code>model</code> and using a precompute Fourier transform <code>cache</code>. You can optionally specify the executor which will compute the internal image buffer using the <code>executor</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m = ExtendedRing(10.0)
julia&gt; cache = create_cache(DFTAlg(), IntensityMap(zeros(128, 128), 50.0, 50.0)) # used threads to make the image
julia&gt; mimg = modelimage(m, cache, ThreadedEx())</code></pre><p><strong>Notes</strong></p><p>For analytic models this is a no-op and returns the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/modelimage/modelimage.jl#LL102-L120">source</a></section><section><div><pre><code class="nohighlight hljs">modelimage(img::IntensityMap, alg=NFFTAlg())</code></pre><p>Create a model image directly using an image, i.e. treating it as the model. You can optionally specify the Fourier transform algorithm using <code>alg</code></p><p><strong>Notes</strong></p><p>For analytic models this is a no-op and returns the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/modelimage/modelimage.jl#LL133-L142">source</a></section><section><div><pre><code class="nohighlight hljs">modelimage(img::IntensityMap, cache::AbstractCache)</code></pre><p>Create a model image directly using an image, i.e. treating it as the model. Additionally reuse a previously compute image <code>cache</code>. This can be used when directly modeling an image of a fixed size and number of pixels.</p><p><strong>Notes</strong></p><p>For analytic models this is a no-op and returns the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/modelimage/modelimage.jl#LL148-L158">source</a></section><section><div><pre><code class="nohighlight hljs">modelimage(m;
           fovx=2*radialextent(m),
           fovy=2*radialextent(m),
           nx=512,
           ny=512,
           pulse=ComradeBase.DeltaPulse(),
           alg=FFTAlg(),
           executor=SequentialEx()
            )</code></pre><p>Construct a <code>ModelImage</code> where just the model <code>m</code> is specified.</p><p>If <code>fovx</code> or <code>fovy</code> aren&#39;t given <code>modelimage</code> will <em>guess</em> a reasonable field of view based on the <code>radialextent</code> function. <code>nx</code> and <code>ny</code> are the number of pixels in the x and y direction. The <code>pulse</code> is the pulse used for the image and <code>alg</code></p><p><strong>Notes</strong></p><p>For analytic models this is a no-op and returns the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/modelimage/modelimage.jl#LL164-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.uviterator" href="#Comrade.uviterator"><code>Comrade.uviterator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">uviterator(dx, dy, nnx, nny)</code></pre><p>Construct the u,v iterators for the Fourier transform of the image with pixel sizes <code>dx, dy</code> and number of pixels <code>nx, ny</code></p><p>If you are extending Fourier transform stuff please use these functions to ensure that the centroid is being properly computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/modelimage/fft_alg.jl#LL161-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.fouriermap" href="#Comrade.fouriermap"><code>Comrade.fouriermap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fouriermap(m, fovx, fovy, nx, ny)</code></pre><p>Create a Fourier or visibility map of a model <code>m</code> assuming a image with a field of view <code>fovx/fovy</code> and <code>nx/ny</code> pixels in the x/y direction respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/modelimage/fft_alg.jl#LL190-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.ModelImage" href="#Comrade.ModelImage"><code>Comrade.ModelImage</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ModelImage{M, I, C} &lt;: Comrade.AbstractModelImage{M}</code></pre><p>Container for non-analytic model that contains a image cache which will hold the image, a Fourier transform cache, which usually an instance of a &lt;: FourierCache.</p><p><strong>Note</strong></p><p>This is an internal implementation detail that shouldn&#39;t usually be called directly. Instead the user should use the exported function <code>modelimage</code>, for example</p><pre><code class="language-julia hljs">using Comrade
m = ExtendedRing(20.0, 5.0)

# This creates an version where the image is dynamically specified according to the
# radial extent of the image
mimg = modelimage(m) # you can also optionally pass the number of pixels nx and ny

# Or you can create an IntensityMap
img = intensitymap(m, 100.0, 100.0, 512, 512)
mimg = modelimage(m, img)

# Or precompute a cache
cache = create_cache(FFTAlg(), img)
mimg = modelimage(m, cache)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/modelimage/modelimage.jl#LL3-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.DFTAlg" href="#Comrade.DFTAlg"><code>Comrade.DFTAlg</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DFTAlg</code></pre><p>Uses a discrete fourier transform. This is not very efficient for larger images. In those cases  NFFTAlg or FFTAlg are more reasonable. For small images this is a reasonable choice especially since it&#39;s easy to define derivatives.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/modelimage/nuft.jl#LL214-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.DFTAlg-Tuple{Comrade.EHTObservation}" href="#Comrade.DFTAlg-Tuple{Comrade.EHTObservation}"><code>Comrade.DFTAlg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DFTAlg(obs::EHTObservation)</code></pre><p>Create an algorithm object using the direct Fourier transform object from the observation <code>obs</code>. This will extract the uv positions from the observation to allow for a more efficient FT cache.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/modelimage/dft_alg.jl#LL6-L12">source</a></section></article><h3 id="Modifiers"><a class="docs-heading-anchor" href="#Modifiers">Modifiers</a><a id="Modifiers-1"></a><a class="docs-heading-anchor-permalink" href="#Modifiers" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Comrade.basemodel" href="#Comrade.basemodel"><code>Comrade.basemodel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basemodel(model::AbstractModel)</code></pre><p>Returns the base model from a modified <code>model</code>. If there is no basemodel this just return the <code>model</code> itself.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; basemodel(stretched(Disk(), 1.0, 2.0)) == Disk()
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/modifiers.jl#LL42-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.renormed" href="#Comrade.renormed"><code>Comrade.renormed</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">renormed(model, f)
</code></pre><p>Renormalizes the model <code>m</code> to have total flux <code>f*flux(m)</code>. This can also be done directly by calling <code>Base.:*</code> i.e.,</p><pre><code class="language-julia-repl hljs">julia&gt; renormed(m, f) == f*M
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/modifiers.jl#LL228-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.rotated" href="#Comrade.rotated"><code>Comrade.rotated</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotated(model, ξ)
</code></pre><p>Rotates the model by an amount <code>ξ</code> in radians in the clockwise direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/modifiers.jl#LL325-L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.posangle" href="#Comrade.posangle"><code>Comrade.posangle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">posangle(model)
</code></pre><p>Returns the rotation angle of the rotated <code>model</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/modifiers.jl#LL332-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.shifted" href="#Comrade.shifted"><code>Comrade.shifted</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">shifted(model, Δx, Δy)
</code></pre><p>Shifts the model <code>m</code> in the image domain by an amount <code>Δx,Δy</code> in the x and y directions respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/modifiers.jl#LL184-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.stretched" href="#Comrade.stretched"><code>Comrade.stretched</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stretched(model, α, β)
</code></pre><p>Stretches the model <code>m</code> according to the formula     Iₛ(x,y) = 1/(αβ) I(x/α, y/β), where were renormalize the intensity to preserve the models flux.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/modifiers.jl#LL285-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.AbstractModifier" href="#Comrade.AbstractModifier"><code>Comrade.AbstractModifier</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractModifier{M&lt;:ComradeBase.AbstractModel} &lt;: ComradeBase.AbstractModel</code></pre><p>Abstract type for image modifiers. These are some model wrappers that can transform any model using simple Fourier transform properties. By default these modified models will have the same analytic properties as the base unmodified model, i.e.</p><pre><code class="language-julia-repl hljs">julia&gt; visanalytic(stretched(Disk(), 2.0, 2.0)) == visanalytic(Disk())
true</code></pre><p>Additionally these are classic examples of non-primitive images i.e.,</p><pre><code class="language-julia-repl hljs">julia&gt; isprimitive(Comrade.AbstractModifier) == Comrade.NotAnalytic()</code></pre><p>As a result of this the implementation of a model is slightly different</p><ul><li><a href="#Comrade.transform_uv"><code>transform_uv</code></a></li><li><a href="#Comrade.transform_image"><code>transform_image</code></a></li><li><a href="#Comrade.scale_uv"><code>scale_uv</code></a></li><li><a href="#Comrade.scale_image"><code>scale_image</code></a></li><li><a href="../base_api/#ComradeBase.radialextent"><code>radialextent</code></a></li></ul><p>This methods assume the modifiers are of the form</p><p>I(x,y) -&gt; fᵢ(x,y)I(gᵢ(x,y)) V(u,v) -&gt; fᵥ(u,v)V(gᵥ(u,v))</p><p>where <code>g</code> are the transform<em>image/uv functions and <code>f</code> are the scale</em>image/uv function.</p><p>See those docstrings for guidance on implementation details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/modifiers.jl#LL4-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.RenormalizedModel" href="#Comrade.RenormalizedModel"><code>Comrade.RenormalizedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RenormalizedModel{M&lt;:ComradeBase.AbstractModel, T} &lt;: Comrade.AbstractModifier{M&lt;:ComradeBase.AbstractModel}</code></pre><p>Renormalizes the flux of the model to the new value <code>scale*flux(model)</code>. We have also overloaded the Base.:* operator as syntactic sugar although I may get rid of this.</p><p>An end user should not call this directly but instead the <a href="#Comrade.renormed"><code>renormed</code></a> function or Base.:* instead.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; renormed(Gaussian(), 2.0) == 2.0*Gaussian()
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/modifiers.jl#LL204-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.RotatedModel" href="#Comrade.RotatedModel"><code>Comrade.RotatedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RotatedModel{M&lt;:ComradeBase.AbstractModel, T} &lt;: Comrade.AbstractModifier{M&lt;:ComradeBase.AbstractModel}</code></pre><p>Type for the rotated model. This is more fine grained constrol of rotated model.</p><p>An end user should not call this directly but instead the <a href="#Comrade.rotated"><code>rotated</code></a> function instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/modifiers.jl#LL304-L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.ShiftedModel" href="#Comrade.ShiftedModel"><code>Comrade.ShiftedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ShiftedModel{M&lt;:ComradeBase.AbstractModel, T} &lt;: Comrade.AbstractModifier{M&lt;:ComradeBase.AbstractModel}</code></pre><p>Shifts the model by <code>Δx</code> units in the x-direction and <code>Δy</code> units in the y-direction.</p><p>An end user should not call this directly but instead the <a href="#Comrade.shifted"><code>shifted</code></a> function instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/modifiers.jl#LL164-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.StretchedModel" href="#Comrade.StretchedModel"><code>Comrade.StretchedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct StretchedModel{M&lt;:ComradeBase.AbstractModel, T} &lt;: Comrade.AbstractModifier{M&lt;:ComradeBase.AbstractModel}</code></pre><p>Stretched the model in the x and y directions, i.e. the new intensity is     Iₛ(x,y) = 1/(αβ) I(x/α, y/β), where were renormalize the intensity to preserve the models flux.</p><p>An end user should not call this directly but instead the <a href="#Comrade.stretched"><code>stretched</code></a> function instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/modifiers.jl#LL264-L273">source</a></section></article><h3 id="Polarized-Models"><a class="docs-heading-anchor" href="#Polarized-Models">Polarized Models</a><a id="Polarized-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Polarized-Models" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.m̆-Tuple{ComradeBase.AbstractPolarizedModel, Any, Any}" href="#ComradeBase.m̆-Tuple{ComradeBase.AbstractPolarizedModel, Any, Any}"><code>ComradeBase.m̆</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">m̆(pimg::AbstractPolarizedModel, u, v)</code></pre><p>Computes the fractional linear polarization in the visibility domain</p><pre><code class="nohighlight hljs">m̆ = (Q + iU)/I</code></pre><p>To create the symbol type <code>m\breve</code> in the REPL or use the <a href="../api/#Comrade.mbreve"><code>mbreve</code></a> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/polarized.jl#LL111-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.mbreve" href="#Comrade.mbreve"><code>Comrade.mbreve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mbreve(pimg, u, v)
</code></pre><p>Explicit m̆ function used for convenience.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/polarized.jl#LL128-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.evpa-Tuple{ComradeBase.AbstractPolarizedModel, Any, Any}" href="#ComradeBase.evpa-Tuple{ComradeBase.AbstractPolarizedModel, Any, Any}"><code>ComradeBase.evpa</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evpa(pimg::AbstractPolarizedModel, u, v)</code></pre><p>electric vector position angle or EVPA of the polarized model <code>pimg</code> at <code>u</code> and <code>v</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/polarized.jl#LL99-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.coherencymatrix-Tuple{PolarizedModel, Any, Any}" href="#Comrade.coherencymatrix-Tuple{PolarizedModel, Any, Any}"><code>Comrade.coherencymatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coherencymatrix(pimg, u, v)
</code></pre><p>Computes the coherency matrix of the polarized model <code>pimg</code> at <code>u</code> and <code>v</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/polarized.jl#LL89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.PolarizedModel" href="#Comrade.PolarizedModel"><code>Comrade.PolarizedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct PolarizedModel{TI, TQ, TU, TV} &lt;: ComradeBase.AbstractPolarizedModel</code></pre><p>Wrapped model for a polarized model. This uses the stokes representation of the image.</p><p><strong>Fields</strong></p><ul><li><p><code>I</code></p><p>Stokes I model</p></li></ul><ul><li><p><code>Q</code></p><p>Stokes Q Model</p></li></ul><ul><li><p><code>U</code></p><p>Stokes U Model</p></li></ul><ul><li><p><code>V</code></p><p>Stokes V Model</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/polarized.jl#LL5-L12">source</a></section></article><h3 id="Model-Evaluation"><a class="docs-heading-anchor" href="#Model-Evaluation">Model Evaluation</a><a id="Model-Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Evaluation" title="Permalink"></a></h3><p>For more docstrings on how to evaluate models see <a href="../base_api/#ComradeBase-API">ComradeBase API</a>.</p><article class="docstring"><header><a class="docstring-binding" id="Comrade.amplitude" href="#Comrade.amplitude"><code>Comrade.amplitude</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">amplitude(d::EHTVisibilityDatum)</code></pre><p>Get the amplitude of a visibility datum</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/observations/observations.jl#LL300-L304">source</a></section><section><div><pre><code class="language-julia hljs">amplitude(d::EHTVisibilityAmplitudeDatum)</code></pre><p>Get the amplitude of a amplitude datum</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/observations/observations.jl#LL365-L369">source</a></section><section><div><pre><code class="nohighlight hljs">amplitude(model, args...)</code></pre><p>Computes the visibility amplitude of model <code>m</code> at u,v positions <code>u,v</code></p><p>If you want to compute the amplitudes at a large number of positions consider using the <code>amplitudes</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/models.jl#LL44-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.amplitudes" href="#Comrade.amplitudes"><code>Comrade.amplitudes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">amplitudes(m::AbstractModel, u::AbstractArray, v::AbstractArray)</code></pre><p>Computes the amplitudes of the model <code>m</code> at the u,v positions <code>u</code>, <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/models.jl#LL168-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.bispectra" href="#Comrade.bispectra"><code>Comrade.bispectra</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bispectra(m,
          u1::AbstractArray, v1::AbstractArray,
          u2::AbstractArray, v2::AbstractArray,
          u3::AbstractArray, v3::AbstractArray,
        )</code></pre><p>Computes the bispectra of the model <code>m</code> at the triangles (u1,v1), (u2,v2), (u3,v3).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/models.jl#LL196-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.bispectrum" href="#Comrade.bispectrum"><code>Comrade.bispectrum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bispectrum(d1::T, d2::T, d3::T) where {T&lt;:EHTVisibilityDatum}</code></pre><p>Finds the bispectrum of three visibilities. We will assume these form closed triangles, i.e. the phase of the bispectrum is a closure phase.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/observations/observations.jl#LL375-L380">source</a></section><section><div><pre><code class="nohighlight hljs">bispectrum(model, u1, v1, u2, v2, u3, v3)</code></pre><p>Computes the complex bispectrum of model <code>m</code> at the uv-triangle u1,v1 -&gt; u2,v2 -&gt; u3,v3</p><p>If you want to compute the bispectrum over a number of triangles consider using the <code>bispectra</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/models.jl#LL56-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.closure_phase" href="#Comrade.closure_phase"><code>Comrade.closure_phase</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">closure_phase(D1::EHTVisibilityDatum,
              D2::EHTVisibilityDatum,
              D3::EHTVisibilityDatum
              )</code></pre><p>Computes the closure phase of the three visibility datums.</p><p><strong>Notes</strong></p><p>We currently use the high SNR Gaussian error approximation for the closure phase. In the future we may use the moment matching from Monte Carlo sampling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/observations/observations.jl#LL473-L484">source</a></section><section><div><pre><code class="nohighlight hljs">closure_phase(model. u1, v1, u2, v2, u3, v3)</code></pre><p>Computes the closure phase of model <code>m</code> at the uv-triangle u1,v1 -&gt; u2,v2 -&gt; u3,v3</p><p>If you want to compute closure phases over a number of triangles consider using the <code>closure_phases</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/models.jl#LL69-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.closure_phases" href="#Comrade.closure_phases"><code>Comrade.closure_phases</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">closure_phases(m,
               u1::AbstractArray, v1::AbstractArray,
               u2::AbstractArray, v2::AbstractArray,
               u3::AbstractArray, v3::AbstractArray,
               )</code></pre><p>Computes the closure phases of the model <code>m</code> at the triangles (u1,v1), (u2,v2), (u3,v3).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/models.jl#LL244-L253">source</a></section><section><div><pre><code class="nohighlight hljs">closure_phases(m::AbstractModel, ac::ClosureConfig)</code></pre><p>Computes the closure phases of the model <code>m</code> using the array configuration <code>ac</code>.</p><p><strong>Notes</strong></p><p>This is faster than the <code>closure_phases(m, u1, v1, ...)</code> method since it only computes as many visibilities as required thanks to the closure design matrix formalism from Blackburn et al.<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/models.jl#LL262-L273">source</a></section><section><div><pre><code class="nohighlight hljs">closure_phases(vis::AbstractArray, ac::ArrayConfiguration)</code></pre><p>Compute the closure phases for a set of visibilities and an array configuration</p><p><strong>Notes</strong></p><p>This uses a closure design matrix for the computation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/distributions/radiolikelihood.jl#LL78-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.logclosure_amplitude" href="#Comrade.logclosure_amplitude"><code>Comrade.logclosure_amplitude</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">logclosure_amplitude(model, u1, v1, u2, v2, u3, v3, u4, v4)</code></pre><p>Computes the log-closure amplitude of model <code>m</code> at the uv-quadrangle u1,v1 -&gt; u2,v2 -&gt; u3,v3 -&gt; u4,v4 using the formula</p><p class="math-container">\[C = \log\left|\frac{V(u1,v1)V(u2,v2)}{V(u3,v3)V(u4,v4)}\right|\]</p><p>If you want to compute log closure amplitudes over a number of triangles consider using the <code>logclosure_amplitudes</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/models.jl#LL82-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.logclosure_amplitudes" href="#Comrade.logclosure_amplitudes"><code>Comrade.logclosure_amplitudes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">logclosure_amplitudes(m::AbstractModel,
                      u1::AbstractArray, v1::AbstractArray,
                      u2::AbstractArray, v2::AbstractArray,
                      u3::AbstractArray, v3::AbstractArray,
                      u4::AbstractArray, v4::AbstractArray,
                     )</code></pre><p>Computes the log closure amplitudes of the model <code>m</code> at the quadrangles (u1,v1), (u2,v2), (u3,v3), (u4, v4).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/models.jl#LL306-L316">source</a></section><section><div><pre><code class="nohighlight hljs">logclosure_amplitudes(m::AbstractModel, ac::ClosureConfig)</code></pre><p>Computes the log closure amplitudes of the model <code>m</code> using the array configuration <code>ac</code>.</p><p><strong>Notes</strong></p><p>This is faster than the <code>logclosure_amplitudes(m, u1, v1, ...)</code> method since it only computes as many visibilities as required thanks to the closure design matrix formalism from Blackburn et al.<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/models.jl#LL326-L337">source</a></section><section><div><pre><code class="nohighlight hljs">logclosure_amplitudes(vis::AbstractArray, ac::ArrayConfiguration)</code></pre><p>Compute the log-closure amplitudes for a set of visibilities and an array configuration</p><p><strong>Notes</strong></p><p>This uses a closure design matrix for the computation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/distributions/radiolikelihood.jl#LL65-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.visibilities" href="#Comrade.visibilities"><code>Comrade.visibilities</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">visibilities(m, ac::ArrayConfiguration)</code></pre><p>Computes the visibilities of the model <code>m</code> using the array configuration <code>ac</code>. If you want to compute a single visibility you should call <a href="#Comrade.visibility"><code>visibility</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/models.jl#LL130-L135">source</a></section><section><div><pre><code class="nohighlight hljs">visibilities(m, u::AbstractArray, v::AbstractArray, args...)</code></pre><p>Computes the visibilities of the model <code>m</code> at <code>u</code> <code>v</code> and <code>args...</code>. If you want to compute a single visibility you should call <a href="#Comrade.visibility"><code>visibility</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/models.jl#LL141-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.visibility" href="#Comrade.visibility"><code>Comrade.visibility</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">visibility(d::EHTVisibilityDatum)</code></pre><p>Return the complex visibility of the visibility datum</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/observations/observations.jl#LL290-L294">source</a></section><section><div><pre><code class="nohighlight hljs">visibility(mimg, u, v, args...)</code></pre><p>Computes the complex visibility of model <code>m</code> at u,v positions <code>u,v</code> and other <code>args...</code> (e.g., frequency, time, etc.)</p><p><strong>Notes</strong></p><p>If you want to compute the visibilities at a large number of positions consider using the <a href="#Comrade.visibilities"><code>visibilities</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/models.jl#LL15-L24">source</a></section><section><div><pre><code class="nohighlight hljs">visibility(mimg, uv::ArrayBaselineDatum)</code></pre><p>Computes the complex visibility of a model <code>m</code> at the <code>uv</code> array baseline datum.</p><p><strong>Notes</strong></p><p>If you want to compute the visibilities at a large number of positions consider using the <a href="#Comrade.visibilities"><code>visibilities</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/models.jl#LL31-L39">source</a></section><section><div><pre><code class="nohighlight hljs">visibility(pimg::PolarizedModel, u, v)</code></pre><p>Computes the visibility in the stokes basis of the polarized model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/polarized.jl#LL51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.intensitymap" href="#ComradeBase.intensitymap"><code>ComradeBase.intensitymap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">intensitymap(model::AbstractModel, args...)</code></pre><p>Computes the intensity map of model. For the inplace version see <a href="#ComradeBase.intensitymap!"><code>intensitymap!</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.intensitymap!" href="#ComradeBase.intensitymap!"><code>ComradeBase.intensitymap!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">intensitymap!(buffer::AbstractMatrix, model::AbstractModel, args...)</code></pre><p>Computes the intensity map of <code>model</code> by modifying the <code>buffer</code></p></div></section></article><h2 id="Data-Types"><a class="docs-heading-anchor" href="#Data-Types">Data Types</a><a id="Data-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Comrade.amplitude-Tuple{Comrade.EHTVisibilityDatum}" href="#Comrade.amplitude-Tuple{Comrade.EHTVisibilityDatum}"><code>Comrade.amplitude</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">amplitude(d::EHTVisibilityDatum)</code></pre><p>Get the amplitude of a visibility datum</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/observations/observations.jl#LL300-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.amplitude-Tuple{Comrade.EHTVisibilityAmplitudeDatum}" href="#Comrade.amplitude-Tuple{Comrade.EHTVisibilityAmplitudeDatum}"><code>Comrade.amplitude</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">amplitude(d::EHTVisibilityAmplitudeDatum)</code></pre><p>Get the amplitude of a amplitude datum</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/observations/observations.jl#LL365-L369">source</a></section><section><div><pre><code class="nohighlight hljs">amplitude(model, args...)</code></pre><p>Computes the visibility amplitude of model <code>m</code> at u,v positions <code>u,v</code></p><p>If you want to compute the amplitudes at a large number of positions consider using the <code>amplitudes</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/models/models.jl#LL44-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.baselines" href="#Comrade.baselines"><code>Comrade.baselines</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">baselines(CP::EHTClosurePhaseDatum)</code></pre><p>Returns the baselines used for a single closure phase datum</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/observations/observations.jl#LL508-L512">source</a></section><section><div><pre><code class="nohighlight hljs">baselines(CP::EHTLogClosureAmplitudeDatum)</code></pre><p>Returns the baselines used for a single closure phase datum</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/observations/observations.jl#LL591-L595">source</a></section><section><div><pre><code class="nohighlight hljs">baselines(scan::Scan)</code></pre><p>Return the baselines for each datum in a scan</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/observations/observations.jl#LL745-L749">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.arrayconfig" href="#Comrade.arrayconfig"><code>Comrade.arrayconfig</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">arrayconfig(vis)
</code></pre><p>Extract the array configuration from a EHT observation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/observations/observations.jl#LL658-L662">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.closure_phase-Tuple{Comrade.EHTVisibilityDatum, Comrade.EHTVisibilityDatum, Comrade.EHTVisibilityDatum}" href="#Comrade.closure_phase-Tuple{Comrade.EHTVisibilityDatum, Comrade.EHTVisibilityDatum, Comrade.EHTVisibilityDatum}"><code>Comrade.closure_phase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">closure_phase(D1::EHTVisibilityDatum,
              D2::EHTVisibilityDatum,
              D3::EHTVisibilityDatum
              )</code></pre><p>Computes the closure phase of the three visibility datums.</p><p><strong>Notes</strong></p><p>We currently use the high SNR Gaussian error approximation for the closure phase. In the future we may use the moment matching from Monte Carlo sampling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/observations/observations.jl#LL473-L484">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.getdata" href="#Comrade.getdata"><code>Comrade.getdata</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getdata(obs::EHTObservation, s::Symbol)</code></pre><p>Pass-through function that gets the array of <code>s</code> from the EHTObservation. For example say you want the times of all measurement then</p><pre><code class="language-julia hljs">getdata(obs, :time)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/observations/observations.jl#LL195-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.getuv" href="#Comrade.getuv"><code>Comrade.getuv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getuv</code></pre><p>Get the u, v positions of the array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/observations/observations.jl#LL77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.getuvtimefreq" href="#Comrade.getuvtimefreq"><code>Comrade.getuvtimefreq</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getuvtimefreq(ac)
</code></pre><p>Get the u, v, time, freq of the array as a tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/observations/observations.jl#LL90-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.rescaleuv!" href="#Comrade.rescaleuv!"><code>Comrade.rescaleuv!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rescaleuv!(data::EHTObservation)</code></pre><p>rescale the u-v lengths according to scale. This can be useful when you want the spatial scales to be in 1/μas instead of 1/rad</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/observations/observations.jl#LL387-L392">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.scantable" href="#Comrade.scantable"><code>Comrade.scantable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">scantable(obs::EHTObservation)</code></pre><p>Reorganizes the observation into a table of scans, where scan are defined by unique timestamps. To access the data you can use scalar indexing</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">st = scantable(obs)
# Grab the first scan
scan1 = st[1]

# Acess the detections in the scan
scan1[1]

# grab e.g. the baselines
scan1[:baseline]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/observations/observations.jl#LL829-L848">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.stations" href="#Comrade.stations"><code>Comrade.stations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stations(d::EHTObservation)</code></pre><p>Get all the stations in a observation. The result is a vector of symbols.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/observations/observations.jl#LL223-L227">source</a></section><section><div><pre><code class="nohighlight hljs">stations(g::CalTable)</code></pre><p>Return the stations in the calibration table</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/calibration/caltable.jl#LL42-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.uvpositions" href="#Comrade.uvpositions"><code>Comrade.uvpositions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">uvpositions(datum::AbstractVisibilityDatum)</code></pre><p>Get the uvp positions of an inferometric datum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/observations/observations.jl#LL140-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.ClosureConfig" href="#Comrade.ClosureConfig"><code>Comrade.ClosureConfig</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ClosureConfig{A, D} &lt;: Comrade.ArrayConfiguration</code></pre><p>Array config file for closure quantities. This stores the design matrix <code>designmat</code> that transforms from visibilties to closure products.</p><p><strong>Fields</strong></p><ul><li><p><code>ac</code></p><p>Array configuration for visibilities</p></li><li><p><code>designmat</code></p><p>Closure design matrix</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/observations/observations.jl#LL55-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.ArrayBaselineDatum" href="#Comrade.ArrayBaselineDatum"><code>Comrade.ArrayBaselineDatum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ArrayBaselineDatum{T}</code></pre><p>A single datum of an <code>ArrayConfiguration</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/observations/observations.jl#LL102-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.EHTObservation" href="#Comrade.EHTObservation"><code>Comrade.EHTObservation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct EHTObservation{F, T&lt;:Comrade.AbstractInterferometryDatum{F}, S&lt;:(StructArrays.StructArray{T&lt;:Comrade.AbstractInterferometryDatum{F}}), A, N} &lt;: Comrade.Observation{F}</code></pre><p>The main data product type in <code>Comrade</code> this stores the <code>data</code> which can be a StructArray of any <code>AbstractInterferometryDatum</code> type.</p><p><strong>Fields</strong></p><ul><li><p><code>data</code></p><p>StructArray of data productts</p></li></ul><ul><li><p><code>config</code></p><p>Array config holds ancillary information about array</p></li></ul><ul><li><p><code>mjd</code></p><p>modified julia date of the observation</p></li></ul><ul><li><p><code>ra</code></p><p>RA of the observation in J2000 (deg)</p></li></ul><ul><li><p><code>dec</code></p><p>DEC of the observation in J2000 (deg)</p></li></ul><ul><li><p><code>bandwidth</code></p><p>bandwidth of the observation (Hz)</p></li></ul><ul><li><p><code>frequency</code></p><p>frequency of the observation (Hz)</p></li></ul><ul><li><p><code>source</code></p><p>Common source name</p></li></ul><ul><li><p><code>timetype</code></p><p>Time zone used.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/observations/observations.jl#LL147-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.EHTArrayConfiguration" href="#Comrade.EHTArrayConfiguration"><code>Comrade.EHTArrayConfiguration</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct EHTArrayConfiguration{F, T&lt;:AbstractArray} &lt;: Comrade.ArrayConfiguration</code></pre><p>Stores all the non-visibility data products for an EHT array. This is useful when evaluating model visibilities.</p><p><strong>Fields</strong></p><ul><li><p><code>frequency</code></p><p>Observing frequency (Hz)</p></li></ul><ul><li><p><code>bandwidth</code></p><p>Observing bandwith (Hz)</p></li></ul><ul><li><p><code>data</code></p><p>A struct array of <code>ArrayBaselineDatum</code> holding time, freq, u, v, baselines.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/observations/observations.jl#LL31-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.EHTClosurePhaseDatum" href="#Comrade.EHTClosurePhaseDatum"><code>Comrade.EHTClosurePhaseDatum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct EHTClosurePhaseDatum{T&lt;:Number} &lt;: Comrade.ClosureProducts{T&lt;:Number}</code></pre><p>A Datum for a single closure phase.</p><p><strong>Fields</strong></p><ul><li><p><code>phase</code></p><p>closure phase (rad)</p></li></ul><ul><li><p><code>error</code></p><p>error of the closure phase assuming the high-snr limit</p></li></ul><ul><li><p><code>u1</code></p><p>u (λ) of first station</p></li></ul><ul><li><p><code>v1</code></p><p>v (λ) of first station</p></li></ul><ul><li><p><code>u2</code></p><p>u (λ) of second station</p></li></ul><ul><li><p><code>v2</code></p><p>v (λ) of second station</p></li></ul><ul><li><p><code>u3</code></p><p>u (λ) of third station</p></li></ul><ul><li><p><code>v3</code></p><p>v (λ) of third station</p></li></ul><ul><li><p><code>time</code></p><p>Measured time of closure phase in hours</p></li></ul><ul><li><p><code>triangle</code></p><p>station baselines used</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/observations/observations.jl#LL401-L409">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.EHTLogClosureAmplitudeDatum" href="#Comrade.EHTLogClosureAmplitudeDatum"><code>Comrade.EHTLogClosureAmplitudeDatum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct EHTLogClosureAmplitudeDatum{T&lt;:Number} &lt;: Comrade.ClosureProducts{T&lt;:Number}</code></pre><p>A Datum for a single log closure amplitude.</p><p><strong></strong></p><ul><li><p><code>amp</code></p><p>log-closure amplitude</p></li></ul><ul><li><p><code>error</code></p><p>log-closure amplitude error in the high-snr limit</p></li></ul><ul><li><p><code>u1</code></p><p>u (λ) of first station</p></li></ul><ul><li><p><code>v1</code></p><p>v (λ) of first station</p></li></ul><ul><li><p><code>u2</code></p><p>u (λ) of second station</p></li></ul><ul><li><p><code>v2</code></p><p>v (λ) of second station</p></li></ul><ul><li><p><code>u3</code></p><p>u (λ) of third station</p></li></ul><ul><li><p><code>v3</code></p><p>v (λ) of third station</p></li></ul><ul><li><p><code>u4</code></p><p>u (λ) of fourth station</p></li></ul><ul><li><p><code>v4</code></p><p>v (λ) of fourth station</p></li></ul><ul><li><p><code>time</code></p><p>Observation time of the quadrangle</p></li></ul><ul><li><p><code>quadrangle</code></p><p>station codes for the quadrangle</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/observations/observations.jl#LL520-L527">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.EHTVisibilityDatum" href="#Comrade.EHTVisibilityDatum"><code>Comrade.EHTVisibilityDatum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct EHTVisibilityDatum{T&lt;:Number} &lt;: Comrade.AbstractVisibilityDatum{T&lt;:Number}</code></pre><p>A struct holding the information for a single measured visibility.</p><p><strong></strong></p><ul><li><p><code>visr</code></p><p>real component of the visibility (Jy)</p></li></ul><ul><li><p><code>visi</code></p><p>imaginary component of the visibility (Jy)</p></li></ul><ul><li><p><code>error</code></p><p>error of the visibility (Jy)</p></li></ul><ul><li><p><code>u</code></p><p>x-direction baseline length in λ</p></li></ul><ul><li><p><code>v</code></p><p>y-direction baseline length in λ</p></li></ul><ul><li><p><code>time</code></p><p>Time of the observation in hours</p></li></ul><ul><li><p><code>baseline</code></p><p>station baseline codes</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/observations/observations.jl#LL251-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.EHTVisibilityAmplitudeDatum" href="#Comrade.EHTVisibilityAmplitudeDatum"><code>Comrade.EHTVisibilityAmplitudeDatum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct EHTVisibilityAmplitudeDatum{T&lt;:Number} &lt;: Comrade.AbstractVisibilityDatum{T&lt;:Number}</code></pre><p>A struct holding the information for a single measured visibility amplitude.</p><p><strong>FIELDS</strong></p><ul><li><p><code>amp</code></p><p>amplitude (Jy)</p></li></ul><ul><li><p><code>error</code></p><p>error of the visibility amplitude (Jy)</p></li></ul><ul><li><p><code>u</code></p><p>x-direction baseline length in λ</p></li></ul><ul><li><p><code>v</code></p><p>y-direction baseline length in λ</p></li></ul><ul><li><p><code>time</code></p><p>Time of the observation in hours</p></li></ul><ul><li><p><code>baseline</code></p><p>station baseline codes</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/observations/observations.jl#LL316-L324">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.Scan" href="#Comrade.Scan"><code>Comrade.Scan</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Scan{T, I, S}</code></pre><p>Composite type that holds information for a single scan of the telescope.</p><p><strong>Fields</strong></p><ul><li><p><code>time</code></p><p>Scan time</p></li></ul><ul><li><p><code>index</code></p><p>Scan indices which are (scan index, data start index, data end index)</p></li></ul><ul><li><p><code>scan</code></p><p>Scan data usually a StructArray of a &lt;:AbstractVisibilityDatum</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/observations/observations.jl#LL720-L727">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.ScanTable" href="#Comrade.ScanTable"><code>Comrade.ScanTable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ScanTable{O&lt;:Union{Comrade.ArrayConfiguration, Comrade.Observation}, T, S}</code></pre><p>Wraps EHTObservation in a table that separates the observation into scans. This implements the table interface. You can access scans by directly indexing into the table. This will create a view into the table not copying the data.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; st = scantable(obs)
julia&gt; st[begin] # grab first scan
julia&gt; st[end]   # grab last scan</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/observations/observations.jl#LL686-L699">source</a></section></article><h2 id="eht-imaging-interface"><a class="docs-heading-anchor" href="#eht-imaging-interface">eht-imaging interface</a><a id="eht-imaging-interface-1"></a><a class="docs-heading-anchor-permalink" href="#eht-imaging-interface" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Comrade.extract_amp" href="#Comrade.extract_amp"><code>Comrade.extract_amp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extract_amp(obs)</code></pre><p>Extracts the visibility amplitudes from an ehtim observation object.</p><p>Any valid keyword arguments to <code>add_amp</code> in ehtim can be passed through extract_amp.</p><p>Returns an EHTObservation with visibility amplitude data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/observations/ehtim.jl#LL145-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.extract_cphase" href="#Comrade.extract_cphase"><code>Comrade.extract_cphase</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extract_cphase(obs)</code></pre><p>Extracts the closure phases from an ehtim observation object</p><p>Any valid keyword arguments to <code>add_cphase</code> in ehtim can be passed through extract_cphase.</p><p>Returns an EHTObservation with closure phases datums</p><p><strong>Special Keyword arguments:</strong></p><ul><li>count: How the closures are formed, the available options are &quot;min-correct&quot;, &quot;min&quot;, &quot;max&quot;</li><li>cut_trivial: Cut the trivial triangles from the closures</li><li>uvmin: The flag to decide what are trivial triangles. Any baseline with ||(u,v)|| &lt; uvmin        are removed.</li><li>kwargs...: Other arguments are forwarded to eht-imaging.</li></ul><p><strong>Warning</strong></p><p>The <code>count</code> keyword argument is treated specially in <code>Comrade</code>. The default option is &quot;min-correct&quot; and should almost always be used. This option construct a minimal set of closure phases that is valid even when the array isn&#39;t fully connected. For testing and legacy reasons we <code>ehtim</code> other count options are also included. However, the current <code>ehtim</code> count=&quot;min&quot; option is broken and does construct proper minimal sets of closure quantities if the array isn&#39;t fully connected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/observations/ehtim.jl#LL580-L604">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.extract_lcamp" href="#Comrade.extract_lcamp"><code>Comrade.extract_lcamp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extract_lcamp(obs)</code></pre><p>Extracts the log-closure amp. from an ehtim observation object</p><p>Any valid keyword arguments to <code>add_logcamp</code> in ehtim can be passed through extract_lcamp.</p><p><strong>Special Keyword arguments:</strong></p><ul><li>count: How the closures are formed, the available options are &quot;min-correct&quot;, &quot;min&quot;, &quot;max&quot;</li><li>kwargs...: Other arguments are forwarded to eht-imaging.</li></ul><p>Returns an EHTObservation with log-closure amp. datums</p><p><strong>Warning</strong></p><p>The <code>count</code> keyword argument is treated specially in <code>Comrade</code>. The default option is &quot;min-correct&quot; and should almost always be used. This option construct a minimal set of closure phases that is valid even when the array isn&#39;t fully connected. For testing and legacy reasons we <code>ehtim</code> other count options are also included. However, the current <code>ehtim</code> count=&quot;min&quot; option is broken and does construct proper minimal sets of closure quantities if the array isn&#39;t fully connected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/observations/ehtim.jl#LL615-L635">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.extract_vis" href="#Comrade.extract_vis"><code>Comrade.extract_vis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extract_vis(obs)</code></pre><p>Extracts the complex visibilities from an ehtim observation object</p><p>This grabs the raw <code>data</code> object from the obs object. Any keyword arguments are ignored.</p><p>Returns an EHTObservation with complex visibility data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/observations/ehtim.jl#LL173-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.load_ehtim" href="#Comrade.load_ehtim"><code>Comrade.load_ehtim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">load_ehtim()</code></pre><p>Loads the <a href="https://github.com/achael/eht-imaging">eht-imaging</a> library and stores it in the exported <code>ehtim</code> variable.</p><p><strong>Notes</strong></p><p>This will fail if ehtim isn&#39;t installed in the python installation that PyCall references.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/Comrade.jl#LL43-L51">source</a></section></article><h2 id="Bayesian-Tools"><a class="docs-heading-anchor" href="#Bayesian-Tools">Bayesian Tools</a><a id="Bayesian-Tools-1"></a><a class="docs-heading-anchor-permalink" href="#Bayesian-Tools" title="Permalink"></a></h2><h3 id="Distributions"><a class="docs-heading-anchor" href="#Distributions">Distributions</a><a id="Distributions-1"></a><a class="docs-heading-anchor-permalink" href="#Distributions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Comrade.AmpNormal" href="#Comrade.AmpNormal"><code>Comrade.AmpNormal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AmpNormal</code></pre><p>Visibility amplitude likelihood distribution. Typically μ, τ=1/σ are vectors to allow for more efficient derivatives.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/distributions/distributions.jl#LL109-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.ComplexNormal" href="#Comrade.ComplexNormal"><code>Comrade.ComplexNormal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ComplexNormal</code></pre><p>Uncorrelated complex Normal Measure. This is the default likelihood used for visibilties.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/distributions/distributions.jl#LL10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.CPVonMises" href="#Comrade.CPVonMises"><code>Comrade.CPVonMises</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CPVonMises</code></pre><p>The von Mises distribution used for closure phases. Typically μ and κ=1/σ² are vectors to allow for simpler derivative rules.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/distributions/distributions.jl#LL58-L63">source</a></section></article><h3 id="Posterior-Constructions"><a class="docs-heading-anchor" href="#Posterior-Constructions">Posterior Constructions</a><a id="Posterior-Constructions-1"></a><a class="docs-heading-anchor-permalink" href="#Posterior-Constructions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="HypercubeTransform.ascube" href="#HypercubeTransform.ascube"><code>HypercubeTransform.ascube</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ascube(post::Posterior)</code></pre><p>Construct a flattened version of the posterior where the parameters are transformed to live in (0, 1), i.e. the unit hypercube.</p><p>This returns a <code>TransformedPosterior</code> that obeys the <code>DensityInterface</code> and can be evaluated in the usual manner, i.e. <code>logdensityof</code>. Note that the transformed posterior automatically includes the terms log-jacobian terms of the transformation.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tpost = ascube(post)
julia&gt; x0 = prior_sample(tpost)
julia&gt; logdensityof(tpost, x0)</code></pre><p><strong>Notes</strong></p><p>This is the transform that should be used if using typical NestedSampling methods, i.e. <code>ComradeNested</code>. For the transformation to unconstrained space see <a href="#HypercubeTransform.asflat"><code>asflat</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/bayes/bayes.jl#LL159-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HypercubeTransform.asflat" href="#HypercubeTransform.asflat"><code>HypercubeTransform.asflat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">asflat(post::Posterior)</code></pre><p>Construct a flattened version of the posterior where the parameters are transformed to live in (-∞, ∞).</p><p>This returns a <code>TransformedPosterior</code> that obeys the <code>DensityInterface</code> and can be evaluated in the usual manner, i.e. <code>logdensityof</code>. Note that the transformed posterior automatically includes the terms log-jacobian terms of the transformation.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tpost = ascube(post)
julia&gt; x0 = prior_sample(tpost)
julia&gt; logdensityof(tpost, x0)</code></pre><p><strong>Notes</strong></p><p>This is the transform that should be used if using typical MCMC methods, i.e. <code>ComradeAHMC</code>. For the transformation to the unit hypercube see <a href="#HypercubeTransform.ascube"><code>ascube</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/bayes/bayes.jl#LL123-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParameterHandling.flatten" href="#ParameterHandling.flatten"><code>ParameterHandling.flatten</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">flatten(post::Posterior)</code></pre><p>Construct a flattened version of the posterior but <strong>do not</strong> transform to any space, i.e. use the support specified by the prior.</p><p>This returns a <code>TransformedPosterior</code> that obeys the <code>DensityInterface</code> and can be evaluated in the usual manner, i.e. <code>logdensityof</code>. Note that the transformed posterior automatically includes the terms log-jacobian terms of the transformation.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tpost = flatten(post)
julia&gt; x0 = prior_sample(tpost)
julia&gt; logdensityof(tpost, x0)</code></pre><p><strong>Notes</strong></p><p>This is the transform that should be used if using typical MCMC methods, i.e. <code>ComradeAHMC</code>. For the transformation to the unit hypercube see <a href="#HypercubeTransform.ascube"><code>ascube</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/bayes/bayes.jl#LL204-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformVariables.inverse" href="#TransformVariables.inverse"><code>TransformVariables.inverse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inverse(posterior::TransformedPosterior, x)</code></pre><p>Transforms the value <code>y</code> from parameter space to the transformed space (e.g. unit hypercube if using <a href="#HypercubeTransform.ascube"><code>ascube</code></a>).</p><p>For the inverse transform see <a href="#TransformVariables.transform"><code>transform</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/bayes/bayes.jl#LL108-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.prior_sample" href="#Comrade.prior_sample"><code>Comrade.prior_sample</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prior_sample(post::Posterior, args...)</code></pre><p>Samples the prior distribution from the posterior. The <code>args...</code> are forwarded to the <code>Base.rand</code> method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/bayes/bayes.jl#LL51-L56">source</a></section><section><div><pre><code class="nohighlight hljs">prior_sample(post::Posterior)</code></pre><p>Returns a single sample from the prior distribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/bayes/bayes.jl#LL61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.sample-Tuple{Posterior}" href="#StatsBase.sample-Tuple{Posterior}"><code>StatsBase.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample(post::Posterior, sampler::S, args...; init_params=nothing, kwargs...)</code></pre><p>Sample a posterior <code>post</code> using the <code>sampler</code>. You can optionally pass the starting location of the sampler using <code>init_params</code>, otherwise a random draw from the prior will be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/inference/inference.jl#LL34-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformVariables.transform" href="#TransformVariables.transform"><code>TransformVariables.transform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform(posterior::TransformedPosterior, x)</code></pre><p>Transforms the value <code>x</code> from the transformed space (e.g. unit hypercube if using <a href="#HypercubeTransform.ascube"><code>ascube</code></a>) to parameter space which is usually encoded as a <code>NamedTuple</code>.</p><p>For the inverse transform see <a href="#TransformVariables.inverse"><code>inverse</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/bayes/bayes.jl#LL97-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.MultiRadioLikelihood" href="#Comrade.MultiRadioLikelihood"><code>Comrade.MultiRadioLikelihood</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MultiRadioLikelihood(lklhd1, lklhd2, ...)</code></pre><p>Combines multiple likelihoods into one object that is useful for fitting multiple days/frequencies.</p><pre><code class="language-julia-repl hljs">julia&gt; lklhd1 = RadioLikelihood(dcphase1, dlcamp1)
julia&gt; lklhd2 = RadioLikelihood(dcphase2, dlcamp2)
julia&gt; MultiRadioLikelihood(lklhd1, lklhd2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/distributions/radiolikelihood.jl#LL32-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.Posterior" href="#Comrade.Posterior"><code>Comrade.Posterior</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Posterior(lklhd, prior, model)</code></pre><p>Creates a Posterior density that follows obeys <a href="https://github.com/JuliaMath/DensityInferface.jl">DensityInferface</a>. The <code>lklhd</code> object is expected to be a <code>MeasureBase.Likelihood</code> object. For instance, these can be created using <a href="#Comrade.RadioLikelihood"><code>RadioLikelihood</code></a>. <code>prior</code> is expected to be a <code>NamedTuple</code> of distributions that reflect the priors on the parameters you are considering. <code>model</code> is a function that takes in a <code>NamedTuple</code> of parameters and returns a <code>Comrade</code> <code>&lt;:AbstractModel</code>.</p><p><strong>Notes</strong></p><p>Since this function obeys <code>DensityInferface</code> you can evaluate it with</p><pre><code class="language-julia-repl hljs">julia&gt; ℓ = logdensityof(post)
julia&gt; ℓ(x)</code></pre><p>or using the 2-argument version directly</p><pre><code class="language-julia-repl hljs">julia&gt; logdensityof(post, x)</code></pre><p>where <code>post::Posterior</code>.</p><p>To generate random draws from the prior see the <a href="#Comrade.prior_sample"><code>prior_sample</code></a> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/bayes/bayes.jl#LL16-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.TransformedPosterior" href="#Comrade.TransformedPosterior"><code>Comrade.TransformedPosterior</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct TransformedPosterior{P&lt;:Posterior, T}</code></pre><p>A transformed version of a <code>Posterior</code> object. This is an internal type that an end user shouldn&#39;t have to directly construct. To construct a transformed posterior see the <a href="#HypercubeTransform.asflat"><code>asflat</code></a>, <a href="#HypercubeTransform.ascube"><code>ascube</code></a>, and <a href="#ParameterHandling.flatten"><code>flatten</code></a> docstrings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/bayes/bayes.jl#LL70-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.RadioLikelihood" href="#Comrade.RadioLikelihood"><code>Comrade.RadioLikelihood</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RadioLikelihood(data1, data2, ...)</code></pre><p>Forms a radio likelihood from a set of data products. These data products must share the same array data/configuration. If you want to form a likelihood from multiple arrays such as when fitting different wavelengths or days, you can combine them using <a href="#Comrade.MultiRadioLikelihood"><code>MultiRadioLikelihood</code></a></p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; RadioLikelihood(dcphase1, dlcamp1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/distributions/radiolikelihood.jl#LL5-L18">source</a></section></article><h2 id="Misc"><a class="docs-heading-anchor" href="#Misc">Misc</a><a id="Misc-1"></a><a class="docs-heading-anchor-permalink" href="#Misc" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Comrade.μas2rad" href="#Comrade.μas2rad"><code>Comrade.μas2rad</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">μas2rad(x)</code></pre><p>Converts a number from micro-arcseconds (μas) to rad</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/Comrade.jl#LL69-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.rad2μas" href="#Comrade.rad2μas"><code>Comrade.rad2μas</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rad2μas(x)</code></pre><p>Converts a number from radians to micro-arcseconds (μas)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/Comrade.jl#LL63-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.fileio_load" href="#Comrade.fileio_load"><code>Comrade.fileio_load</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">load(fitsfile::String, IntensityMap)</code></pre><p>This loads in a fits file that is more robust to the various imaging algorithms in the EHT, i.e. is works with clean, smili, eht-imaging. The function returns an tuple with an intensitymap and a second named tuple with ancillary information about the image, like the source name, location, mjd, and radio frequency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/observations/io.jl#LL3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.fileio_save" href="#Comrade.fileio_save"><code>Comrade.fileio_save</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">save(file::String, img::IntensityMap, obs)</code></pre><p>Saves an image to a fits file. You can optionally pass an EHTObservation so that ancillary information will be added.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/observations/io.jl#LL68-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.make_pullback" href="#Comrade.make_pullback"><code>Comrade.make_pullback</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">make_pullback(ℓ, autodiff::AD.AbstractBackend)</code></pre><p>Create the pullback function using the autodiff backend <code>autodiff</code>.</p><p><strong>Note</strong></p><p>This is an internal function and not part of the public API.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/inference/pullbacks.jl#LL1-L9">source</a></section><section><div><pre><code class="nohighlight hljs">make_pullback(ℓ, grad::Function)</code></pre><p>Create the pullback function using the function <code>grad</code> which should return the gradient of ℓ.</p><p><strong>Note</strong></p><p>This is an internal function and shouldn&#39;t be typically used by an end-user.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/903fe1acfe7d82240bf7dce519bcf226d1bc106f/src/inference/pullbacks.jl#LL25-L34">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Blackburn L., et al &quot;Closure Statistics in Interferometric Data&quot; ApJ 2020</li><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Blackburn L., et al &quot;Closure Statistics in Interferometric Data&quot; ApJ 2020</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../base_api/">« ComradeBase API</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Sunday 31 July 2022 17:47">Sunday 31 July 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
