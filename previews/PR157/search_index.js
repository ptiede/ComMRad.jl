var documenterSearchIndex = {"docs":
[{"location":"base_api/#ComradeBase-API","page":"ComradeBase API","title":"ComradeBase API","text":"","category":"section"},{"location":"base_api/#Contents","page":"ComradeBase API","title":"Contents","text":"","category":"section"},{"location":"base_api/","page":"ComradeBase API","title":"ComradeBase API","text":"Pages = [\"base_api.md\"]","category":"page"},{"location":"base_api/#Index","page":"ComradeBase API","title":"Index","text":"","category":"section"},{"location":"base_api/","page":"ComradeBase API","title":"ComradeBase API","text":"Pages = [\"base_api.md\"]","category":"page"},{"location":"base_api/","page":"ComradeBase API","title":"ComradeBase API","text":"CurrentModule = ComradeBase","category":"page"},{"location":"base_api/#Model-API","page":"ComradeBase API","title":"Model API","text":"","category":"section"},{"location":"base_api/","page":"ComradeBase API","title":"ComradeBase API","text":"ComradeBase.AbstractModel\nComradeBase.flux\nComradeBase.isprimitive\nComradeBase.visanalytic\nComradeBase.imanalytic\nComradeBase.radialextent\nComradeBase.visibility_point\nComradeBase.intensity_point\nComradeBase.PrimitiveTrait\nComradeBase.IsPrimitive\nComradeBase.NotPrimitive\nComradeBase.DensityAnalytic\nComradeBase.IsAnalytic\nComradeBase.NotAnalytic\nComradeBase.IntensityMap","category":"page"},{"location":"base_api/#ComradeBase.AbstractModel","page":"ComradeBase API","title":"ComradeBase.AbstractModel","text":"AbstractModel\n\nThe Comrade abstract model type. To instantiate your own model type you should subtybe from this model. Additionally you need to implement the following methods to satify the interface:\n\nMandatory Methods\n\nisprimitive: defines whether a model is standalone or is defined in terms of other models.  is the model is primitive then this should return IsPrimitive() otherwise it returns  NotPrimitive()\nvisanalytic: defines whether the model visibilities can be computed analytically. If yes  then this should return IsAnalytic() and the user must to define visibility_point.  If not analytic then visanalytic should return NotAnalytic().\nimanalytic: defines whether the model intensities can be computed pointwise. If yes\n\nthen this should return IsAnalytic() and the user must to define intensity_point. If not analytic then imanalytic should return NotAnalytic().\n\nradialextent: Provides a estimate of the radial extent of the model in the image domain.  This is used for estimating the size of the image, and for plotting.\nflux: Returns the total flux of the model.\n\nOptional Methods:\n\nintensity_point: Defines how to compute model intensities pointwise. Note this is must be defined if imanalytic(::Type{YourModel})==IsAnalytic().\nvisibility_point: Defines how to compute model visibilties pointwise. Note this is   must be defined if visanalytic(::Type{YourModel})==IsAnalytic().\n_visibilities: Vectorized version of visibility_point if you can gain additional speed\nintensitymap: Computes the whole image of the model\nintensitymap!: Inplace version of intensitymap\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.flux","page":"ComradeBase API","title":"ComradeBase.flux","text":"flux(im::AbstractIntensityMap)\n\nComputes the flux of a intensity map\n\n\n\n\n\nflux(im)\n\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.isprimitive","page":"ComradeBase API","title":"ComradeBase.isprimitive","text":"isprimitive(::Type)\n\nDispatch function that specifies whether a type is a primitive Comrade model. This function is used for dispatch purposes when composing models.\n\nNotes\n\nIf a user is specifying their own model primitive model outside of Comrade they need to specify if it is primitive\n\nstruct MyPrimitiveModel end\nComradeBase.isprimitive(::Type{MyModel}) = ComradeBase.IsPrimitive()\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.visanalytic","page":"ComradeBase API","title":"ComradeBase.visanalytic","text":"visanalytic(::Type{<:AbstractModel})\n\nDetermines whether the model is pointwise analytic in Fourier domain, i.e. we can evaluate its fourier transform at an arbritrary point.\n\nIf IsAnalytic() then it will try to call visibility_point to calculate the complex visibilities. Otherwise it fallback to using the FFT that works for all models that can compute an image.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.imanalytic","page":"ComradeBase API","title":"ComradeBase.imanalytic","text":"imanalytic(::Type{<:AbstractModel})\n\nDetermines whether the model is pointwise analytic in the image domain, i.e. we can evaluate its intensity at an arbritrary point.\n\nIf IsAnalytic() then it will try to call intensity_point to calculate the intensity.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.radialextent","page":"ComradeBase API","title":"ComradeBase.radialextent","text":"radialextent(model::AbstractModel)\n\nProvides an estimate of the radial size/extent of the model. This is used internally to estimate image size when plotting and using modelimage\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.visibility_point","page":"ComradeBase API","title":"ComradeBase.visibility_point","text":"visibility_point(model::AbstractModel, u, v, args...)\n\nFunction that computes the pointwise visibility. This must be implemented in the model interface if visanalytic(::Type{MyModel}) == IsAnalytic()\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.intensity_point","page":"ComradeBase API","title":"ComradeBase.intensity_point","text":"intensity_point(model::AbstractModel, x, y, args...)\n\nFunction that computes the pointwise intensity if the model has the trait in the image domain IsAnalytic(). Otherwise it will use construct the image in visibility space and invert it.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.PrimitiveTrait","page":"ComradeBase API","title":"ComradeBase.PrimitiveTrait","text":"abstract type PrimitiveTrait\n\nThis trait specifies whether the model is a primitive\n\nNotes\n\nThis will likely turn into a trait in the future so people can inject their models into Comrade more easily.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.IsPrimitive","page":"ComradeBase API","title":"ComradeBase.IsPrimitive","text":"struct IsPrimitive\n\nTrait for primitive model\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.NotPrimitive","page":"ComradeBase API","title":"ComradeBase.NotPrimitive","text":"struct NotPrimitive\n\nTrait for not-primitive model\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.DensityAnalytic","page":"ComradeBase API","title":"ComradeBase.DensityAnalytic","text":"DensityAnalytic\n\nInternal type for specifying the nature of the model functions. Whether they can be easily evaluated pointwise analytic. This is an internal type that may change.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.IsAnalytic","page":"ComradeBase API","title":"ComradeBase.IsAnalytic","text":"struct IsAnalytic <: ComradeBase.DensityAnalytic\n\nDefines a trait that a states that a model is analytic. This is usually used with an abstract model where we use it to specify whether a model has a analytic fourier transform and/or image.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.NotAnalytic","page":"ComradeBase API","title":"ComradeBase.NotAnalytic","text":"struct NotAnalytic <: ComradeBase.DensityAnalytic\n\nDefines a trait that a states that a model is analytic. This is usually used with an abstract model where we use it to specify whether a model has does not have a easy analytic fourier transform and/or intensity function.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.IntensityMap","page":"ComradeBase API","title":"ComradeBase.IntensityMap","text":"struct IntensityMap{T, S<:(AbstractMatrix), F, K<:ComradeBase.Pulse} <: ComradeBase.AbstractIntensityMap{T, S<:(AbstractMatrix)}\n\nImage array type. This is an Matrix with a number of internal fields to describe the field of view, pixel size, and the pulse function that makes the image a continuous quantity.\n\nTo use it you just specify the array and the field of view/pulse julia img = IntensityMap(zeros(512512) 1000 1000 DeltaPulse)`\n\nFields\n\nim\nImage matrix\n\nfovx\nfield of view in x direction\n\nfovy\nfield of view in y direction\n\npsizex\npixel size in the x direction\n\npsizey\npixel size in the y direction\n\npulse\npulse function that turns the image grid into a continuous object\n\n\n\n\n\n","category":"type"},{"location":"base_api/#Image-Pulses","page":"ComradeBase API","title":"Image Pulses","text":"","category":"section"},{"location":"base_api/","page":"ComradeBase API","title":"ComradeBase API","text":"ComradeBase.Pulse\nComradeBase.DeltaPulse\nComradeBase.SqExpPulse\nComradeBase.BSplinePulse","category":"page"},{"location":"base_api/#ComradeBase.Pulse","page":"ComradeBase API","title":"ComradeBase.Pulse","text":"Pulse Pixel response function for a radio image model. This makes a discrete sampling continuous by picking a certain smoothing kernel for the image.\n\nNotes\n\nTo see the implemented Pulses please use the subtypes function i.e. subtypes(Pulse)\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.DeltaPulse","page":"ComradeBase API","title":"ComradeBase.DeltaPulse","text":"struct DeltaPulse{T} <: ComradeBase.Pulse\n\nA dirac comb pulse function. This means the image is just the dicrete Fourier transform\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.SqExpPulse","page":"ComradeBase API","title":"ComradeBase.SqExpPulse","text":"struct SqExpPulse{T} <: ComradeBase.Pulse\n\nNormalized square exponential kernel, i.e. a Gaussian. Note the smoothness is modfied with ϵ which is the inverse variance in units of 1/pixels².\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.BSplinePulse","page":"ComradeBase API","title":"ComradeBase.BSplinePulse","text":"$(TYPEDEF)\n\nUses the basis spline (BSpline) kernel of order N. These are the kernel that come from recursively convolving the tophat kernel\n\n    B_0(x) = begincases 1  x  1  0  otherwise endcases\n\nN times.\n\nNotes\n\nBSpline kernels have a number of nice properties:\n\nSimple frequency response sinc(u2)^N\npreserve total intensity\n\nFor N>1 these kernels aren't actually interpolation kernels however, this doesn't matter for us.\n\nCurrently only the 0,1,3 order kernels are implemented.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#Polarization","page":"ComradeBase API","title":"Polarization","text":"","category":"section"},{"location":"base_api/","page":"ComradeBase API","title":"ComradeBase API","text":"ComradeBase.StokesVector\nComradeBase.CoherencyMatrix\nComradeBase.evpa\nComradeBase.m̆\nComradeBase.SingleStokes","category":"page"},{"location":"base_api/#ComradeBase.StokesVector","page":"ComradeBase API","title":"ComradeBase.StokesVector","text":"struct StokesVector{T} <: StaticArrays.FieldVector{4, T}\n\nStatic vector that holds the stokes parameters of a polarized complex visibility\n\nTo convert between a StokesVector and CoherencyMatrix use the convert function\n\nconvert(::CoherencyMatrix, StokesVector(1.0, 0.1, 0.1, 0.4))\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.CoherencyMatrix","page":"ComradeBase API","title":"ComradeBase.CoherencyMatrix","text":"struct CoherencyMatrix{T} <: StaticArrays.FieldMatrix{2, 2, T}\n\nStatic matrix that holds construct the coherency matrix of a polarized complex visibility\n\nTo convert between a StokesVector and CoherencyMatrix use the convert function\n\nconvert(::StokesVector, CoherencyMatrix(1.0, 0.1, 0.1, 0.4))\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.evpa","page":"ComradeBase API","title":"ComradeBase.evpa","text":"evpa(m)\n\n\nCompute the evpa of a stokes vector or cohereny matrix.\n\n\n\n\n\nevpa(pimg::AbstractPolarizedModel, u, v)\n\nelectric vector position angle or EVPA of the polarized model pimg at u and v\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.m̆","page":"ComradeBase API","title":"ComradeBase.m̆","text":"m̆(m)\n\n\nCompute the fractional linear polarization of a stokes vector or coherency matrix\n\n\n\n\n\nm̆(pimg::AbstractPolarizedModel, u, v)\n\nComputes the fractional linear polarization in the visibility domain\n\nm̆ = (Q + iU)/I\n\nTo create the symbol type m\\breve in the REPL or use the mbreve function.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.SingleStokes","page":"ComradeBase API","title":"ComradeBase.SingleStokes","text":"struct SingleStokes{M, S} <: ComradeBase.AbstractModel\n\nHelper function that converts a model from something that compute polarized images to just a single stokes parameter. This is useful if you just want to fit a single stokes parameter.\n\n\n\n\n\n","category":"type"},{"location":"libs/adaptmcmc/#ComradeAdaptMCMC","page":"ComradeAdaptMCMC","title":"ComradeAdaptMCMC","text":"","category":"section"},{"location":"libs/adaptmcmc/","page":"ComradeAdaptMCMC","title":"ComradeAdaptMCMC","text":"Experimental interface to the `AdaptiveMCMC.jl MCMC package. This uses parallel tempering to sample from the posterior. We typically recommend using one of the nested sampling packages. This interface follows Comrade's usual sampling interface for uniformity.","category":"page"},{"location":"libs/adaptmcmc/#Example","page":"ComradeAdaptMCMC","title":"Example","text":"","category":"section"},{"location":"libs/adaptmcmc/","page":"ComradeAdaptMCMC","title":"ComradeAdaptMCMC","text":"using Comrade\nusing ComradeAdaptMCMC\n\n# Some stuff to create a posterior object\npost # of type Comrade.Posterior\n\n\nsmplr = AdaptMCMC(ntemp=5) # use 5 tempering levels\n\nchain, stats = sample(post, smplr, 500_000, 300_000)","category":"page"},{"location":"libs/adaptmcmc/#API","page":"ComradeAdaptMCMC","title":"API","text":"","category":"section"},{"location":"libs/adaptmcmc/","page":"ComradeAdaptMCMC","title":"ComradeAdaptMCMC","text":"CurrentModule = ComradeAdaptMCMC","category":"page"},{"location":"libs/adaptmcmc/","page":"ComradeAdaptMCMC","title":"ComradeAdaptMCMC","text":"Modules = [ComradeAdaptMCMC]","category":"page"},{"location":"libs/adaptmcmc/#ComradeAdaptMCMC.AdaptMCMC","page":"ComradeAdaptMCMC","title":"ComradeAdaptMCMC.AdaptMCMC","text":"AdaptMCMC(;ntemp,\n          swap=:nonrev,\n          algorithm = :ram,\n          fulladapt = true,\n          acc_sw = 0.234,\n          all_levels = false\n          )\n\nCreate an AdaptMCMC.jl sampler. This sampler uses the AdaptiveMCMC.jl package to sample from the posterior. Namely, this is a parallel tempering algorithm with an adaptive exploration and tempering sampler. For more information please see [https://github.com/mvihola/AdaptiveMCMC.jl].\n\nThe arguments of the function are:\n\nntemp: Number of temperature to run in parallel tempering\nswap: Which temperature swapping strategy to use, options are:\n:norev (default) uses a non-reversible tempering scheme (still ergodic)\n:single single randomly picked swap\n:randperm swap in random order\n:sweep upward or downward sweeps picked at random\nalgorithm: exploration MCMC algorithm (default is :ram which uses robust adaptive metropolis-hastings) options are:\n:ram (default) Robust adaptive metropolis\n:am Adaptive metropolis\n:asm Adaptive scaling metropolis\n:aswam Adaptive scaling within adaptive metropolis\nfulladapt: whether we adapt both the tempering ladder and the exploration kernel (default is true, i.e. adapt everything)\nacc_sw: The target acceptance rate for temperature swaps\nall_levels: Store all tempering levels to memory (warning this can use a lot of memory)\n\n\n\n\n\n","category":"type"},{"location":"libs/adaptmcmc/#StatsBase.sample","page":"ComradeAdaptMCMC","title":"StatsBase.sample","text":"sample(post::Posterior, sampler::AdaptMCMC, nsamples, burnin=nsamples÷2, args...; init_params=nothing, kwargs...)\n\nSample the posterior post using the AdaptMCMC sampler. This will produce nsamples with the first burnin steps removed. The init_params indicate where to start the sampler from and it is expected to be a NamedTuple of parameters.\n\nPossible additional kwargs are:\n\nthin::Int = 1: which says to save only every thin sample to memory\nrng: Specify a random number generator (default uses GLOBAL_RNG)\n\nThis return a tuple where:\n\nFirst element are the chains from the sampler. If all_levels=false the only the unit temperature (posterior) chain is returned\nSecond element is the additional ancilliary information about the samples including the loglikelihood logl, sampler state state, average exploration kernel acceptance rate accexp for each tempering level, and average temperate swap acceptance rates accswp  for each tempering level.\n\n\n\n\n\n","category":"function"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"EditURL = \"https://github.com/ptiede/Comrade.jl/blob/main/docs/src/examples/black_hole_image.jl\"","category":"page"},{"location":"examples/black_hole_image/#Making-an-Image-of-a-Black-Hole","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"","category":"section"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"Comrade has been designed to work with the EHT and ngEHT. In this tutorial we will show how to reproduce some of the results from EHTC VI 2019.","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"In EHTC VI, they considered fitting simple geometric models to the data to estimate the image size, shape, brightness profile etc of the black hole. In this page we will construct a similar model and fit it to the data in under 50 lines of code (sans comments). To start we load some packages we will need","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"using Comrade","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"The next step is to load the data. For this we will use the publically available M 87 data which can be downloaded from cyverse. For an introduction to data loading see Loading Data into Comrade.","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"load_ehtim()\nobs = ehtim.obsdata.load_uvfits(joinpath(@__DIR__, \"../assets/SR1_M87_2017_096_lo_hops_netcal_StokesI.uvfits\"))\nobs.add_scans()","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"kill 0-baselines since we don't care about large scale flux and make scan-average data","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"obs = obs.flag_uvdist(uv_min=0.1e9).avg_coherent(0.0, scan_avg=true)","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"grab data products we want to fit: log closure amplitudes and closure phases","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"dlcamp = extract_lcamp(obs)\ndcphase = extract_cphase(obs)","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"For this demo only consider closure products since these are invariant to station specific gain systematics. Given these data products we can then form our radio likelihood:","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"lklhd = RadioLikelihood(dlcamp, dcphase)","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"The lklhd constructs a measure using MeasureTheory.jl. To evaluate the likelihood we need to pass it a type that implements the Comrade model interface which is described in Model Interface.","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"To finish the construction of our posterior we need to specify an image model and a prior. For the image model we will be using a modified MRing, which is a infinitely thin delta ring with an azimuthal structure given by a Fourier expansion. To give the ring some width we will convolve the ring with a gaussian, and add an additional gaussian to the image to model any non-ring flux. For the model a user must give a function that accepts a named tuple and return the constructed model:","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"function model(θ)\n  (;radius, width, α, β, f, σG, τG, ξG, xG, yG) = θ\n  ring = f*smoothed(stretched(MRing((α,), (β,)), radius, radius), width)\n  g = (1-f)*shifted(rotated(stretched(Gaussian(), σG, σG*(1+τG)), ξG), xG, yG)\n  return ring + g\nend","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"We now need to specify the priors for our model. The easiest way to do this is to specify a NamedTuple of distributions:","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"using Distributions\nprior = (\n          radius = Uniform(μas2rad(10.0), μas2rad(30.0)),\n          width = Uniform(μas2rad(1.0), μas2rad(10.0)),\n          α = Uniform(-0.5, 0.5),\n          β = Uniform(-0.5, 0.5),\n          f = Uniform(0.0, 1.0),\n          σG = Uniform(μas2rad(1.0), μas2rad(40.0)),\n          τG = Uniform(0.0, 0.75),\n          ξG = Uniform(0.0, 1π),\n          xG = Uniform(-μas2rad(80.0), μas2rad(80.0)),\n          yG = Uniform(-μas2rad(80.0), μas2rad(80.0))\n        )","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"To form the posterior we now call","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"post = Posterior(lklhd, prior, model)","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"This constructs a posterior density that can be evaluated by calling logdensityof. For example","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"logdensityof(post, (radius = μas2rad(20.0),\n                  width = μas2rad(10.0),\n                  α = 0.3,\n                  β = 0.3,\n                  f = 0.6,\n                  σG = μas2rad(20.0),\n                  τG = 0.1,\n                  ξG = 0.5,\n                  xG = 0.0,\n                  yG = 0.0))","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"We can now try to sample from our posterior post so that we can make probabilstic inferences about our data.","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"Now this model is in parameter space. Often optimization and sampling algorithms want it in some modified space. For example, nested sampling algorithms want the parameters in the unit hypercube. To transform the posterior to the unit hypercube we can use the ascube function","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"cpost = ascube(post)","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"If we want to flatten the parameter space and move to (-∞, ∞) support we can use the asflat function","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"fpost = asflat(post)","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"These transformed posterior expect a vector of parameters. That is we can evaluate the transformed log density by calling","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"logdensityof(cpost, rand(dimension(cpost)))\nlogdensityof(fpost, randn(dimension(fpost)))","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"Note that this automatically takes care of the jacobian in the parameter transformation.","category":"page"},{"location":"examples/black_hole_image/#Sampling-the-posterior","page":"Making an Image of a Black Hole","title":"Sampling the posterior","text":"","category":"section"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"Our strategy here will be to use Hamiltonian Monte Carlo. However, to lower burn-in time we will first use an optimizer to find a reasonable starting location. Since this is a lower dimensional problem we will use BlackboxOptim or the OptimizationBBO package","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"using ComradeOptimization\nusing OptimizationBBO\n\nndim = dimension(fpost)\nf = OptimizationFunction(fpost)\nprob = OptimizationProblem(f, randn(ndim), nothing, lb=fill(-5.0, ndim), ub=fill(5.0, ndim))\nsol = solve(prob, BBO_adaptive_de_rand_1_bin_radiuslimited(); maxiters=50_000)","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"The sol vector is in the transformed space, so first we need to transform back to parameter space","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"xopt = transform(fpost, sol)","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"And we can also plot the map","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"using Plots\nplot(model(xopt), title=\"MAP image\", xlims=(-60.0,50.0), ylims=(-60.0,50.0))","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"The main goal of Comrade is to explore the posterior of the model parameters. Currently the go to tool is AdvancedHMC.jl. To sample from the posterior you can use the following:","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"using ComradeAHMC\nchain, stats = sample(post, AHMC(metric=DiagEuclideanMetric(ndim)), 2000; nadapts=1000, init_params=xopt)","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"That's it! To finish it up we can then plot some simple visual fit diagnostics.","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"First to plot the image we call","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"plot(model(chain[end]), title=\"Random image\", xlims=(-60.0,50.0), ylims=(-60.0,50.0))","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"What about the mean image? Well let's grab 100 images from the chain","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"meanimg = mean(intensitymap.(model.(sample(chain, 100)), μas2rad(120.0), μas2rad(120.0), 128, 128))\nplot(sqrt.(max.(meanimg, 0.0)), title=\"Mean Image\") #plot on a sqrt color scale to see the Gaussian","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"That looks similar to the EHTC VI, and it took us no time at all!. To see how well the model is fitting the data we can plot the model and data products","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"plot(model(xopt), dlcamp)","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"or even better the residuals","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"residual(model(xopt), dlcamp)","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"These residuals are a little ratty which suggests our model is missing some emission. In fact, this model is slightly too simple to explain the data. Check out EHTC VI 2019 for some ideas what features need to be added to the model to get a better fit!","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"Computing information","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"Julia Version 1.7.3\nCommit 742b9abb4d (2022-05-06 12:58 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: 11th Gen Intel(R) Core(TM) i7-1185G7 @ 3.00GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-12.0.1 (ORCJIT, tigerlake)","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"This page was generated using Literate.jl.","category":"page"},{"location":"benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Comrade was partially designed with performance in mind. Solving imaging inverse problem is traditionally very computational expensive, especially when using Bayesian inference. To benchmark Comrade we will compare it to two of the most common modeling or imaging packages within the EHT:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"eht-imaging\nThemis","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"eht-imaging[1] or ehtim is a Python package that is widely used within the EHT for its imaging and modeling interfaces. It is easy to use and is widely used in the EHT. However, to specify the model the user must specify how to calculate the models complex visibilities and its gradients. This allows eht-imaging's modeling package to achieve acceptable speeds.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Themis is a C++ package that is focused on providing Bayesian estimates of the image structure. In fact, Comrade took some design queue's from Themis.  Additionally, Themis was designed to solely work with distributed computing systems. Themis however, has been used in a variety of EHT publications and is the standard Bayesian modeling tool used in the EHT. However, Themis is quite challenging to use and requires a high level of knowledge from its users, requiring them to understand makefile, C++, and the MPI standard.","category":"page"},{"location":"benchmarks/#Benchmarking-Problem","page":"Benchmarks","title":"Benchmarking Problem","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"For our benchmarking problem we analyze a problem very similar to the problem explained in Making an Image of a Black Hole. Namely we will consider fitting the 2017 M87 April 6 data using an m-ring and a single Gaussian component. To see the code we used for Comrade and eht-imaging please see the end of this page.","category":"page"},{"location":"benchmarks/#Results","page":"Benchmarks","title":"Results","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"All tests were run using the following system","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Julia Version 1.7.3\nPython Version 3.10.5\nComrade Version 0.4.0\neht-imaging Version 1.2.4\nCommit 742b9abb4d (2022-05-06 12:58 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: 11th Gen Intel(R) Core(TM) i7-1185G7 @ 3.00GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-12.0.1 (ORCJIT, tigerlake)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Our benchmark results are the following:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":" Comrade (micro sec) eht-imaging (micro sec) Themis (micro sec)\nposterior eval (min) 31 445 55\nposterior eval (mean) 36 476 60\ngrad posterior eval (min) 105 (ForwardDiff) 1898 1809\ngrad posterior eval (mean) 119 (ForwardDiff) 1971 1866","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Therefore, for this test we found that Comrade was the fastest method in all tests. For the posterior evaluation we found that Comrade is > 10x faster than eht-imaging, and 2x faster then Themis. For gradient evaluations we have Comrade is > 15x faster than both eht-imaging and Themis.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"[1]: Chael A, et al. Inteferometric Imaging Directly with Closure Phases 2018 ApJ 857 1 arXiv:1803/07088","category":"page"},{"location":"benchmarks/#Code","page":"Benchmarks","title":"Code","text":"","category":"section"},{"location":"benchmarks/#Julia-Code","page":"Benchmarks","title":"Julia Code","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using Comrade\nusing Distributions\nusing BenchmarkTools\n\nload_ehtim()\n# To download the data visit https://doi.org/10.25739/g85n-f134\nobs = ehtim.obsdata.load_uvfits(\"SR1_M87_2017_096_lo_hops_netcal_StokesI.uvfits\")\nobs.add_scans()\nobs = obs.avg_coherent(0.0, scan_avg=true)\namp = extract_amp(obs)\nlklhd = RadioLikelihood(amp)\n\nfunction model(θ)\n    (;rad, wid, a, b, f, sig, asy, pa, x, y) = θ\n    ring = f*smoothed(stretched(MRing((a,), (b,)), μas2rad(rad), μas2rad(rad)), μas2rad(wid))\n    g = (1-f)*shifted(rotated(stretched(Gaussian(), μas2rad(sig)*asy, μas2rad(sig)), pa), μas2rad(x), μas2rad(y))\n    return ring + g\nend\nprior = (\n          rad = Uniform(10.0, 30.0),\n          wid = Uniform(1.0, 10.0),\n          a = Uniform(-0.5, 0.5), b = Uniform(-0.5, 0.5),\n          f = Uniform(0.0, 1.0),\n          sig = Uniform((1.0), (60.0)),\n          asy = Uniform(0.0, 0.9),\n          pa = Uniform(0.0, 1π),\n          x = Uniform(-(80.0), (80.0)),\n          y = Uniform(-(80.0), (80.0))\n        )\n# Now form the posterior\npost = Posterior(lklhd, prior, model)\n\nθ = (rad= 22.0, wid= 3.0, a = 0.0, b = 0.15, f=0.8, sig = 20.0, asy=0.2, pa=π/2, x=20.0, y=20.0)\nm = model(θ)\n\npost = Posterior(lklhd, prior, model)\ntpost = asflat(post)\n\n# Transform to the unconstrained space\nx0 = transform(tpost, θ)\n\n# Lets benchmark the posterior evaluation\nℓ = logdensityof(tpost)\n@benchmark ℓ($x0)\n\n# Now we benchmark the gradient\ngℓ = ForwardDiff.gradient(ℓ, x0)\n@benchmark gℓ($x0)","category":"page"},{"location":"benchmarks/#Python-Code","page":"Benchmarks","title":"Python Code","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using BenchmarkTools\n\nload_ehtim()\n# To download the data visit https://doi.org/10.25739/g85n-f134\nobs = ehtim.obsdata.load_uvfits(joinpath(@__DIR__, \"SR1_M87_2017_096_lo_hops_netcal_StokesI.uvfits\"))\nobs.add_scans()\nobs = obs.avg_coherent(0.0, scan_avg=true)\n\n\n\nmeh = ehtim.model.Model()\nmeh = meh.add_thick_mring(F0=θ.f,\n                    d=2*μas2rad(θ.rad),\n                    alpha=2*sqrt(2*log(2))*μas2rad(θ.wid),\n                    x0 = 0.0,\n                    y0 = 0.0,\n                    beta_list=[0.0+θ.b]\n                    )\nmeh = meh.add_gauss(F0=1-θ.f,\n                    FWHM_maj=2*sqrt(2*log(2))*μas2rad(θ.sig),\n                    FWHM_min=2*sqrt(2*log(2))*μas2rad(θ.sig)*θ.asy,\n                    PA = θ.pa,\n                    x0 = μas2rad(20.0),\n                    y0 = μas2rad(20.0)\n                    )\n\npreh = meh.default_prior()\npreh[1][\"F0\"] = Dict(\"prior_type\"=>\"flat\", \"min\"=>0.0, \"max\"=>1.0)\npreh[1][\"d\"] = Dict(\"prior_type\"=>\"flat\", \"min\"=>μas2rad(20.0), \"max\"=>μas2rad(60.0))\npreh[1][\"alpha\"] = Dict(\"prior_type\"=>\"flat\", \"min\"=>μas2rad(2.0), \"max\"=>μas2rad(25.0))\npreh[1][\"x0\"] = Dict(\"prior_type\"=>\"fixed\")\npreh[1][\"y0\"] = Dict(\"prior_type\"=>\"fixed\")\n\npreh[2][\"F0\"] = Dict(\"prior_type\"=>\"flat\", \"min\"=>0.0, \"max\"=>1.0)\npreh[2][\"FWHM_maj\"] = Dict(\"prior_type\"=>\"flat\", \"min\"=>μas2rad(2.0), \"max\"=>μas2rad(120.0))\npreh[2][\"FWHM_min\"] = Dict(\"prior_type\"=>\"flat\", \"min\"=>μas2rad(2.0), \"max\"=>μas2rad(120.0))\npreh[2][\"x0\"] = Dict(\"prior_type\"=>\"flat\", \"min\"=>-μas2rad(40.0), \"max\"=>μas2rad(40.0))\npreh[2][\"y0\"] = Dict(\"prior_type\"=>\"flat\", \"min\"=>-μas2rad(40.0), \"max\"=>μas2rad(40.0))\npreh[2][\"PA\"] = Dict(\"prior_type\"=>\"flat\", \"min\"=>-1π, \"max\"=>1π)\n\nusing PyCall\npy\"\"\"\nimport ehtim\nimport numpy as np\ntransform_param = ehtim.modeling.modeling_utils.transform_param\ndef make_paraminit(param_map, meh, trial_model, model_prior):\n    model_init = meh.copy()\n    param_init = []\n    for j in range(len(param_map)):\n        pm = param_map[j]\n        if param_map[j][1] in trial_model.params[param_map[j][0]].keys():\n            param_init.append(transform_param(model_init.params[pm[0]][pm[1]]/pm[2], model_prior[pm[0]][pm[1]],inverse=False))\n        else: # In this case, the parameter is a list of complex numbers, so the real/imaginary or abs/arg components need to be assigned\n            if param_map[j][1].find('cpol') != -1:\n                param_type = 'beta_list_cpol'\n                idx = int(param_map[j][1].split('_')[0][8:])\n            elif param_map[j][1].find('pol') != -1:\n                param_type = 'beta_list_pol'\n                idx = int(param_map[j][1].split('_')[0][7:]) + (len(trial_model.params[param_map[j][0]][param_type])-1)//2\n            elif param_map[j][1].find('beta') != -1:\n                param_type = 'beta_list'\n                idx = int(param_map[j][1].split('_')[0][4:]) - 1\n            else:\n                raise Exception('Unsure how to interpret ' + param_map[j][1])\n\n            curval = model_init.params[param_map[j][0]][param_type][idx]\n            if '_' not in param_map[j][1]:\n                param_init.append(transform_param(np.real( model_init.params[pm[0]][param_type][idx]/pm[2]), model_prior[pm[0]][pm[1]],inverse=False))\n            elif   param_map[j][1][-2:] == 're':\n                param_init.append(transform_param(np.real( model_init.params[pm[0]][param_type][idx]/pm[2]), model_prior[pm[0]][pm[1]],inverse=False))\n            elif param_map[j][1][-2:] == 'im':\n                param_init.append(transform_param(np.imag( model_init.params[pm[0]][param_type][idx]/pm[2]), model_prior[pm[0]][pm[1]],inverse=False))\n            elif param_map[j][1][-3:] == 'abs':\n                param_init.append(transform_param(np.abs(  model_init.params[pm[0]][param_type][idx]/pm[2]), model_prior[pm[0]][pm[1]],inverse=False))\n            elif param_map[j][1][-3:] == 'arg':\n                param_init.append(transform_param(np.angle(model_init.params[pm[0]][param_type][idx])/pm[2], model_prior[pm[0]][pm[1]],inverse=False))\n            else:\n                if not quiet: print('Parameter ' + param_map[j][1] + ' not understood!')\n    n_params = len(param_init)\n    return n_params, param_init\n\"\"\"\n\n# make the python param map and use optimize so we flatten the parameter space.\npmap, pmask = ehtim.modeling.modeling_utils.make_param_map(meh, preh, \"scipy.optimize.dual_annealing\", fit_model=true)\ntrial_model = meh.copy()\n\n# get initial parameters\nn_params, pinit = py\"make_paraminit\"(pmap, meh, trial_model, preh)\n\n# make data products for the globdict\ndata1, sigma1, uv1, _ = ehtim.modeling.modeling_utils.chisqdata(obs, \"amp\")\ndata2, sigma2, uv2, _ = ehtim.modeling.modeling_utils.chisqdata(obs, false)\ndata3, sigma3, uv3, _ = ehtim.modeling.modeling_utils.chisqdata(obs, false)\n\n# now set the ehtim modeling globdict\n\nehtim.modeling.modeling_utils.globdict = Dict(\"trial_model\"=>trial_model,\n                \"d1\"=>\"amp\", \"d2\"=>false, \"d3\"=>false,\n                \"pol1\"=>\"I\", \"pol2\"=>\"I\", \"pol3\"=>\"I\",\n                \"data1\"=>data1, \"sigma1\"=>sigma1, \"uv1\"=>uv1, \"jonesdict1\"=>nothing,\n                \"data2\"=>data2, \"sigma2\"=>sigma2, \"uv2\"=>uv2, \"jonesdict2\"=>nothing,\n                \"data3\"=>data3, \"sigma3\"=>sigma3, \"uv3\"=>uv3, \"jonesdict3\"=>nothing,\n                \"alpha_d1\"=>0, \"alpha_d2\"=>0, \"alpha_d3\"=>0,\n                \"n_params\"=> n_params, \"n_gains\"=>0, \"n_leakage\"=>0,\n                \"model_prior\"=>preh, \"param_map\"=>pmap, \"param_mask\"=>pmask,\n                \"gain_prior\"=>nothing, \"gain_list\"=>[], \"gain_init\"=>nothing,\n                \"fit_leakage\"=>false, \"leakage_init\"=>[], \"leakage_fit\"=>[],\n                \"station_leakages\"=>nothing, \"leakage_prior\"=>nothing,\n                \"show_updates\"=>false, \"update_interval\"=>1,\n                \"gains_t1\"=>nothing, \"gains_t2\"=>nothing,\n                \"minimizer_func\"=>\"scipy.optimize.dual_annealing\",\n                \"Obsdata\"=>obs,\n                \"fit_pol\"=>false, \"fit_cpol\"=>false,\n                \"flux\"=>1.0, \"alpha_flux\"=>0, \"fit_gains\"=>false,\n                \"marginalize_gains\"=>false, \"ln_norm\"=>1314.33,\n                \"param_init\"=>pinit, \"test_gradient\"=>false\n            )\n\n# This is the negative log-posterior\nfobj = ehtim.modeling.modeling_utils.objfunc\n\n# This is the gradient of the negative log-posterior\ngfobj = ehtim.modeling.modeling_utils.objgrad\n\n# Lets benchmark the posterior evaluation\n@benchmark fobj($pinit)\n\n# Now we benchmark the gradient\n@benchmark gfobj($x0)","category":"page"},{"location":"libs/ahmc/#ComradeAHMC","page":"ComradeAHMC","title":"ComradeAHMC","text":"","category":"section"},{"location":"libs/ahmc/","page":"ComradeAHMC","title":"ComradeAHMC","text":"To sample from the posterior our first choice is typically AdvancedHMC ) which uses Hamiltonian Monte Carlo to sample from the posterior. Specifically we usually use the NUTS algorithm. ","category":"page"},{"location":"libs/ahmc/","page":"ComradeAHMC","title":"ComradeAHMC","text":"The interface to AdvancedHMC is very powerful and general. To simplify  the procedure for Comrade users we have provided a thin interface.  Like all Comrade a user just needs to specify a sampler then call  the sample function.","category":"page"},{"location":"libs/ahmc/","page":"ComradeAHMC","title":"ComradeAHMC","text":"For AdvancedHMC the user can create the sampler by calling the AHMC function. This only has one mandatory argument the metric the sampler uses. There are typically two options:","category":"page"},{"location":"libs/ahmc/","page":"ComradeAHMC","title":"ComradeAHMC","text":"- `DiagEuclideanMetric` which uses a diagonal metric for covariance adaptation\n- `DenseEuclideanMetric` which uses a dense or full rank metric for covariance adaptation","category":"page"},{"location":"libs/ahmc/","page":"ComradeAHMC","title":"ComradeAHMC","text":"We typically recommend a user to start with DiagEuclideanMetric since the dense metric typically requires a lot more samples to properly tune.  The other options for AHMC (sans autodiff) specify exactly which version of HMC to use. Our default options match the choices made by the Stan programming language. The final option to consider is the autodiff optional argument. This specifies which autodifferentiation package to use. For geometric modeling we recommend the AD.ForwardDiffBackend(), while for Bayesian Imaging AD.ZygoteBackend(). ","category":"page"},{"location":"libs/ahmc/#Example","page":"ComradeAHMC","title":"Example","text":"","category":"section"},{"location":"libs/ahmc/","page":"ComradeAHMC","title":"ComradeAHMC","text":"using Comrade\nusing ComradeAHMC\n\n# Some stuff to create a posterior object\npost # of type Comrade.Posterior\n\nmetric = DiagEuclideanMetric(dimension(post))\nsmplr = AHMC(metric=metric, autodiff=AD.ForwardDiffBackend{10}())\n\nchain, stats = sample(post, smplr, 2_000; nadapts=1_000)","category":"page"},{"location":"libs/ahmc/#API","page":"ComradeAHMC","title":"API","text":"","category":"section"},{"location":"libs/ahmc/","page":"ComradeAHMC","title":"ComradeAHMC","text":"CurrentModule = ComradeAHMC","category":"page"},{"location":"libs/ahmc/","page":"ComradeAHMC","title":"ComradeAHMC","text":"Modules = [ComradeAHMC]","category":"page"},{"location":"libs/ahmc/#ComradeAHMC.AHMC","page":"ComradeAHMC","title":"ComradeAHMC.AHMC","text":"AdvancedHMC\n\nCreates a sampler that uses the AdvancedHMC framework to construct an Hamiltonian Monte Carlo NUTS sampler.\n\nThe user must specify the metric they want to use. Typically we recommend DiagEuclideanMetric as a reasonable starting place. The other options are chosen to match the Stan languages defaults and should provide a good starting point. Please see the AdvancedHMC docs for more information.\n\nNotes\n\nFor autodiff the user can either specify an AbstractDifferentiation backend. For smaller geometric models we recommend AD.ForwardDiffBackend while for imaging we recommend AD.Zygote.\n\nFields\n\nstruct AHMC{S,I,P,T,A,D}\n    `AdvancedHMC` metric to use\n    metric::S\n    `AdvancedHMC` integrator\n    Defaults to `AdvancedHMC.Leapfrog`\n    integrator::I = Leapfrog\n    HMC trajectory sampler\n    Defaults to `AdvancedHMC.MultinomialTS`\n    trajectory::P = MultinomialTS\n    HMC termination condition\n    Defaults to `AdvancedHMC.StrictGeneralisedNoUTurn`\n    termination::T = StrictGeneralisedNoUTurn(10, 1000.0)\n    Adaptation strategy for mass matrix and stepsize\n    Defaults to `AdvancedHMC.StanHMCAdaptor`\n    adaptor::A = StanHMCAdaptor\n    Target acceptance rate for all trajectories on the tree\n    Defaults to 0.85\n    targetacc::Float64 = 0.8\n    `AbstractDifferentiation` autodiff backend\n    Defaults to `AbstractDifferentiation.ForwardDiffBackend()`\n    autodiff::D = AD.ForwardDiffBackend()\nend\n\n\n\n\n\n\n","category":"type"},{"location":"libs/ahmc/#StatsBase.sample-Tuple{Comrade.TransformedPosterior, AHMC, Any, Vararg{Any}}","page":"ComradeAHMC","title":"StatsBase.sample","text":"AbstractMCMC.sample(post::Comrade.Posterior,\n                    sampler::AHMC,\n                    nsamples;\n                    init_params=nothing,\n                    kwargs...)\n\nSamples the posterior post using the AdvancedHMC sampler specified by AHMC. This will run the sampler for nsamples.\n\nTo initialize the chain the user can set init_params to Vector{NamedTuple} whose elements are the starting locations for each of the nchains. If no starting location is specified nchains random samples from the prior will be chosen for the starting locations.\n\nFor possible kwargs please see the AdvancedHMC.jl docs\n\nThis returns a tuple where the first element is a TupleVector of the MCMC samples in parameter space and the second argument is a set of ancilliary information about the sampler.\n\nNotes\n\nThis will automatically transform the posterior to the flattened unconstrained space.\n\n\n\n\n\n","category":"method"},{"location":"libs/ahmc/#StatsBase.sample-Union{Tuple{A}, Tuple{Posterior, A, AbstractMCMC.AbstractMCMCEnsemble, Any, Any}} where A<:AHMC","page":"ComradeAHMC","title":"StatsBase.sample","text":"AbstractMCMC.sample(post::Comrade.Posterior,\n                    sampler::AHMC,\n                    parallel::AbstractMCMC.AbstractMCMCEnsemble,\n                    nsamples,\n                    nchainsl;\n                    init_params=nothing,\n                    kwargs...)\n\nSamples the posterior post using the AdvancedHMC sampler specified by AHMC. This will sample nchains copies of the posterior using the parallel scheme. Each chain will be sampled for nsamples.\n\nTo initialize the chain the user can set init_params to Vector{NamedTuple} whose elements are the starting locations for each of the nchains. If no starting location is specified nchains random samples from the prior will be chosen for the starting locations.\n\nFor possible kwargs please see the AdvancedHMC.jl docs\n\nThis returns a tuple where the first element is nchains of TupleVector's each which contains the MCMC samples of one of the parallel chain and the second argument is a set of ancilliary information about each set of samples.\n\nNotes\n\nThis will automatically transform the posterior to the flattened unconstrained space.\n\n\n\n\n\n","category":"method"},{"location":"interface/#Model-Interface","page":"Model Interface","title":"Model Interface","text":"","category":"section"},{"location":"interface/#Primitive-Geometric-Models","page":"Model Interface","title":"Primitive Geometric Models","text":"","category":"section"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Comrade aims to be more modular and extensible than previous VLBI modeling packages. Namely, instead of making many different models, simple models are composed to construct complicated source morphologies. This is accomplished with a type, and trait based hierarchy.","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Additionally, ComradeBase is a low dependency version of this package that defines this type and trait heirarchy, that people can more easily incorporate into their packages without the large Comrade dependency.","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"To see how this works we will go through a simplified implementation the Gaussian model in Comrade. The Gaussian model is a simple compact emission structure model that can be used to constrain the typical characteristic size of a image feature from VLBI data. To construct a Gaussian model we will first a struct:","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"struct MyGaussian <: Comrade.AbstractModel end","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Notice that we don't provide any more information about the model, e.g. size, shape, flux etc. This is because below we will use Comrade's extensive modifier to change the structure of the model. Now a Gaussian is the simplest model structure we can consider. In some sense we can consider this Gaussian to be a primitive model. That means a Gaussian is not a combination or modfication of an existing model. To tell Comrade that this is the case we define the following method:","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"# Tell Comrade Gaussian is a primitive model\nComrade.isprimitive(::Type{<:MyGaussian}) = IsPrimitive()","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"In the actual Gaussian implementation we define Gaussian <: Comrade.GeometricModel which assumes the model is analytic and primitive by default.  Note, that if the Gaussian wasn't a primitive model we could've used NotPrimitive() instead. Now a Gaussian has an analytic expression in the image and Fourier domain. We can tell Comrade this by setting:","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"# Fourier and image domain are analytic\nComrade.visanalytic(::Type{<:MyGaussian}) = IsAnalytic()\nComrade.imanalytic(::Type{<:MyGaussian}) = IsAnalytic()","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Note that again for <: Comrade.GeometricModel this is again automatically defined. However, for models that aren't a subtype of GeometricModel we assume the image domain IsAnalytic() and the Fourier domain is NotAnalytic().","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Since both the image and visibility domain representation of the Gaussian are analytic we need to define a intensity_point and visibility_point method. For a Gaussian these are given by","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"function intensity_point(::MyGaussian, x,y)\n    return exp(-(x^2+y^2)/2)/2π\nend\n\nfunction visibility_point(::MyGaussian, u, v, args...) where {T}\n    return exp(-2π^2*(u^2 + v^2)) + 0im\nend","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Additionally, most models in Comrade has two additional functions one can implement if possible:","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"flux(m::MyGaussian): This defines the flux of a model. If this isn't defined the model won't have a flux until an image is created. For a Gaussian the definition is flux(::MyGaussian) = 1.0.\nradialextent(::MyGaussian): This defines roughly the default radial extent of the model. For a Gaussian we will consider the radial extent to be 5σ, so radialextent(::MyGaussian) = 5.0.","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"This completely defines the model interface for Comrade. With this you can call the usual forward facing API to evaluate, fit, and plot the model. Additionally, we can now start talking about adding multiple Gaussians, and modifying them. For instance suppose you want a elliptical Gaussian with a flux of 2 Jy. This can be created by Comrade as follows:","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"gauss = MyGaussian()\nellgauss = 2.0*rotated(stretched(gauss, 1.0, 0.5), π/4)\nfig = plot(gauss, layout=(1,2), size=(800,300))\nplot!(fig[2], ellgauss, size=(800,350))","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"(Image: Image)","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"u = rand(100)*0.5; v=rand(100)*0.5\nvg  = visibilities(gauss, u, v)\nveg = visibilities(ellgauss, u, v)\n\nscatter(hypot.(u, v), abs.(vg), label=\"Gaussian\")\nscatter!(hypot.(u, v), abs.(veg), label=\"Elliptical Gaussian\")","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"(Image: Image)","category":"page"},{"location":"interface/#Models-without-an-Analytic-Fourier-Transform","page":"Model Interface","title":"Models without an Analytic Fourier Transform","text":"","category":"section"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Now suppose your model does not have an analytic Fourier transform. In this case the procedure is very similar to the above, except you define visanalytic(::Type{<:MyModel}) = NotAnalytic(). However, everything else is the same. To compute visibilities you just then just create a ModelImage type using the modelimage function. To see how this see Modeling with non-analytic Fourier transforms.","category":"page"},{"location":"libs/optimization/#ComradeOptimization","page":"ComradeOptimization","title":"ComradeOptimization","text":"","category":"section"},{"location":"libs/optimization/","page":"ComradeOptimization","title":"ComradeOptimization","text":"To optimize our posterior we use the Optimization.jl package. This provides a global interface to several Julia optimizers. The Comrade wrapper for Optimization.jl is very thin. The only difference addition is that Comrade has provided a method:","category":"page"},{"location":"libs/optimization/","page":"ComradeOptimization","title":"ComradeOptimization","text":"OptimizationFunction(::TransformedPosterior, args...; kwargs...)","category":"page"},{"location":"libs/optimization/","page":"ComradeOptimization","title":"ComradeOptimization","text":"meaning we can pass it a posterior object and it will set up the OptimizationFunction for us. Note that we only specify this for  a transformed version of the posterior. This is because Optimization.jl requires a flattened version of the posterior. Additionally different optimizers may prefer different parameter transformations. For examples if we use OptimizationBBO using ascube is a good choice since it needs a compact region to search over, and ascube convert our parameter space to the unit hypercube. On the other hand gradient based optimizers work best without bounds, so a better choice there would be the asflat transformation.","category":"page"},{"location":"libs/optimization/","page":"ComradeOptimization","title":"ComradeOptimization","text":"To see what optimizers are available and what options are available please see the Optimizations.jl docs.","category":"page"},{"location":"libs/optimization/#Example","page":"ComradeOptimization","title":"Example","text":"","category":"section"},{"location":"libs/optimization/","page":"ComradeOptimization","title":"ComradeOptimization","text":"using Comrade\nusing ComradeOptimization\nusing OptimizationOptimJL\n\n# Some stuff to create a posterior object\npost # of type Comrade.Posterior\n\n# Create a optimization problem using ForwardDiff as the backend\nfflat = OptimizationProblem(asflat(post), Optimization.AutoForwardDiff())\n\n# create the problem from a random point in the prior, nothing is b/c there are no additional arugments to our function.\nprob = OptimizationProblem(fflat, prior_sample(asflat(post)), nothing)\n\n# Now solve! Here we use LBFGS\nsol = solve(prob, LBFGS(); g_tol=1e-2)","category":"page"},{"location":"libs/optimization/#API","page":"ComradeOptimization","title":"API","text":"","category":"section"},{"location":"libs/optimization/","page":"ComradeOptimization","title":"ComradeOptimization","text":"CurrentModule = ComradeOptimization","category":"page"},{"location":"libs/optimization/","page":"ComradeOptimization","title":"ComradeOptimization","text":"Modules = [ComradeOptimization]\nOrder   = [:function, :type]","category":"page"},{"location":"libs/optimization/#ComradeOptimization.laplace-Tuple{OptimizationProblem, Any, Vararg{Any}}","page":"ComradeOptimization","title":"ComradeOptimization.laplace","text":"laplace(prob, opt, args...; kwargs...)\n\nCompute the Laplace or Quadratic approximation to the prob or posterior. The args and kwargs are passed the the SciMLBase.solve function. This will return a Distributions.MvNormal object that approximates the posterior in the transformed space.\n\nNote the quadratic approximation is in the space of the transformed posterior not the usual parameter space. This is better for constrained problems where we may run up against a boundary.\n\n\n\n\n\n","category":"method"},{"location":"libs/optimization/#SciMLBase.OptimizationFunction-Tuple{Comrade.TransformedPosterior, Vararg{Any}}","page":"ComradeOptimization","title":"SciMLBase.OptimizationFunction","text":"SciMLBase.OptimizationFunction(post::Posterior, args...; kwargs...)\n\nConstructs a OptimizationFunction from a Comrade.TransformedPosterior object. Note that a user must transform the posterior first. This is so we know which space is most amenable to optimization.\n\n\n\n\n\n","category":"method"},{"location":"libs/dynesty/#ComradDynesty","page":"ComradDynesty","title":"ComradDynesty","text":"","category":"section"},{"location":"libs/dynesty/","page":"ComradDynesty","title":"ComradDynesty","text":"ComradeDynesty interfaces Comrade to the excellent dynesty package, more specifically the Dynesty.jl Julia wrapper.","category":"page"},{"location":"libs/dynesty/","page":"ComradDynesty","title":"ComradDynesty","text":"We follow Dynesty.jl interface extremely closely. However,  instead of having to pass a log-likelihood function and prior transform we instead just pass a Comrade.Posterior object and Comrade takes care of defining the prior transform and  log-likelihood for us. For more information about Dynesty.jl please see its docs and docstrings.","category":"page"},{"location":"libs/dynesty/#Example","page":"ComradDynesty","title":"Example","text":"","category":"section"},{"location":"libs/dynesty/","page":"ComradDynesty","title":"ComradDynesty","text":"using Comrade\nusing ComradeDynesty\n\n# Some stuff to create a posterior object\npost # of type Comrade.Posterior\n\n# Create sampler using 1000 live points\nsmplr = NestedSampler(dimension(post), 1000)\n\nchain, stats = sample(post, smplr; dlogz=1.0)\n\n# Optionally resample the chain to create an equal weighted output\nusing StatsBase\nequal_weight_chain = sample(chain, Weights(stats.weights), 10_000)","category":"page"},{"location":"libs/dynesty/#API","page":"ComradDynesty","title":"API","text":"","category":"section"},{"location":"libs/dynesty/","page":"ComradDynesty","title":"ComradDynesty","text":"CurrentModule = ComradeDynesty","category":"page"},{"location":"libs/dynesty/","page":"ComradDynesty","title":"ComradDynesty","text":"Modules = [ComradeDynesty]\nOrder   = [:function, :type]","category":"page"},{"location":"libs/dynesty/#StatsBase.sample-Tuple{Comrade.TransformedPosterior, Union{DynamicNestedSampler, NestedSampler}, Vararg{Any}}","page":"ComradDynesty","title":"StatsBase.sample","text":"AbstractMCMC.sample(post::Comrade.Posterior, smplr::Dynesty.NestedSampler, args...; kwargs...)\nAbstractMCMC.sample(post::Comrade.Posterior, smplr::Dynesty.DynamicNestedSampler, args...; kwargs...)\n\nSample the posterior post using Dynesty.jl NestedSampler/DynamicNestedSampler sampler. The args/kwargs are forwarded to Dynesty for more information see its docs\n\nThis returns a tuple where the first element are the weighted samples from dynesty in a TupleVector. The second element includes additional information about the samples, like the log-likelihood, evidence, evidence error, and the sample weights.\n\nTo create equally weighted samples the user can use\n\nusing StatsBase\nchain, stats = sample(post, NestedSampler(dimension(post), 1000))\nequal_weighted_chain = sample(chain, Weights(stats.weights), 10_000)\n\n\n\n\n\n","category":"method"},{"location":"libs/nested/#ComradeNested","page":"ComradeNested","title":"ComradeNested","text":"","category":"section"},{"location":"libs/nested/","page":"ComradeNested","title":"ComradeNested","text":"ComradeNested interfaces Comrade to the excellent NestedSamplers.jl package.","category":"page"},{"location":"libs/nested/","page":"ComradeNested","title":"ComradeNested","text":"We follow NestedSamplers interface extremely closely. The  difference is that instead of creating a NestedModel we  instead just pass a Comrade.Posterior object as our model. Then internally Comrade takes care of defining the prior transform and extracting the log-likelihood function.","category":"page"},{"location":"libs/nested/","page":"ComradeNested","title":"ComradeNested","text":"For more information about NestedSamplers.jl please see its docs.","category":"page"},{"location":"libs/nested/#Example","page":"ComradeNested","title":"Example","text":"","category":"section"},{"location":"libs/nested/","page":"ComradeNested","title":"ComradeNested","text":"using Comrade\nusing ComradeNested\n\n# Some stuff to create a posterior object\npost # of type Comrade.Posterior\n\n# Create sampler using 1000 live points\nsmplr = Nested(dimension(post), 1000)\n\nchain, stats = sample(post, smplr; d_logz=1.0)\n\n# Optionally resample the chain to create an equal weighted output\nusing StatsBase\nequal_weight_chain = sample(chain, Weights(stats.weights), 10_000)","category":"page"},{"location":"libs/nested/#API","page":"ComradeNested","title":"API","text":"","category":"section"},{"location":"libs/nested/","page":"ComradeNested","title":"ComradeNested","text":"CurrentModule = ComradeNested","category":"page"},{"location":"libs/nested/","page":"ComradeNested","title":"ComradeNested","text":"Modules = [ComradeNested]\nOrder   = [:function, :type]","category":"page"},{"location":"libs/nested/#StatsBase.sample-Tuple{Comrade.TransformedPosterior, Nested, Vararg{Any}}","page":"ComradeNested","title":"StatsBase.sample","text":"AbstractMCMC.sample(post::Comrade.Posterior, smplr::Nested, args...; kwargs...)\n\nSample the posterior post using NestedSamplers.jl Nested sampler. The args/kwargs are forwarded to NestedSampler for more information see its docs\n\nThis returns a tuple where the first element are the weighted samples from dynesty in a TupleVector. The second element includes additional information about the samples, like the log-likelihood, evidence, evidence error, and the sample weights.\n\nTo create equally weighted samples the user can use ```julia using StatsBase chain, stats = sample(post, NestedSampler(dimension(post), 1000)) equalweightedchain = sample(chain, Weights(stats.weights), 10_000)\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade-API","page":"Comrade API","title":"Comrade API","text":"","category":"section"},{"location":"api/#Contents","page":"Comrade API","title":"Contents","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api/#Index","page":"Comrade API","title":"Index","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api/#Model-Definitions","page":"Comrade API","title":"Model Definitions","text":"","category":"section"},{"location":"api/#Calibration-Models","page":"Comrade API","title":"Calibration Models","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Comrade.corrupt\nComrade.DesignMatrix\nComrade.GainCache\nComrade.GainCache(::Comrade.ScanTable)\nComrade.GainModel\nComrade.GainPrior\nComrade.GainPrior(::Any, ::Comrade.ScanTable)\nComrade.RIMEModel","category":"page"},{"location":"api/#Comrade.corrupt","page":"Comrade API","title":"Comrade.corrupt","text":"corrupt(vis::AbstractArray, cache::GainCache, gains::AbstractArray)\n\nCorrupt the visibilities vis with the gains gains using a cache.\n\nThis returns an array of corrupted visibilties. This is called internally by the GainModel when producing the visibilties.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.DesignMatrix","page":"Comrade API","title":"Comrade.DesignMatrix","text":"struct DesignMatrix{X, M<:AbstractArray{X, 2}, T, S} <: AbstractArray{X, 2}\n\nInternal type that holds the gain design matrices for visibility corruption. See GainCache.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.GainCache","page":"Comrade API","title":"Comrade.GainCache","text":"struct GainCache{D1<:Comrade.DesignMatrix, D2<:Comrade.DesignMatrix, T, S}\n\nFields\n\nm1\nGain design matrix for the first station\n\nm2\nGain design matrix for the second station\n\ntimes\nSet of times for each gain\n\nstations\nSet of stations for each gain\n\nNotes\n\nInternal type. This should be created using the GainCache(st::ScanTable) method.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.GainCache-Tuple{Comrade.ScanTable}","page":"Comrade API","title":"Comrade.GainCache","text":"GainCache(st::ScanTable)\n\nCreates a cache for the application of gain corruptions to the model visibilities. This cache consists of the gain design matrices for each station and the set of times and stations for each gain.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.GainModel","page":"Comrade API","title":"Comrade.GainModel","text":"struct GainModel{C, G<:AbstractArray, M} <: Comrade.RIMEModel\n\nA model that applies gain corruptions to a Comrade model. This obeys the usual Comrade interface and can be evaluated using visibilities.\n\nFields\n\ncache\nCache for the application of gain. This can be constructed with GainCache.\n\ngains\nArray of the specific gains that are to be applied to the visibilities.\n\nmodel\nBase model that will be used to compute the uncorrupted visibilities.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.GainPrior","page":"Comrade API","title":"Comrade.GainPrior","text":"GainPrior(dists, st::ScanTable)\n\nCreates a distribution for the gain priors for scan table st. The dists should be a NamedTuple of Distributions, where each name corresponds to a telescope or station in the scan table. See scantable. The resulting type if a subtype of the Distributions.AbstractDistribution so the usual Distributions interface should work.\n\nExample\n\nFor the 2017 observations of M87 a common GainPrior call is:\n\njulia> gdist = GainPrior((AA = LogNormal(0.0, 0.1),\n                   AP = LogNormal(0.0, 0.1),\n                   JC = LogNormal(0.0, 0.1),\n                   SM = LogNormal(0.0, 0.1),\n                   AZ = LogNormal(0.0, 0.1),\n                   LM = LogNormal(0.0, 1.0),\n                   PV = LogNormal(0.0, 0.1)\n                ), st)\n\njulia> x = rand(gdist)\njulia> logdensityof(gdist, x)\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.GainPrior-Tuple{Any, Comrade.ScanTable}","page":"Comrade API","title":"Comrade.GainPrior","text":"GainPrior(dists, st::ScanTable)\n\nCreates a distribution for the gain priors for scan table st. The dists should be a NamedTuple of Distributions, where each name corresponds to a telescope or station in the scan table. See scantable. The resulting type if a subtype of the Distributions.AbstractDistribution so the usual Distributions interface should work.\n\nExample\n\nFor the 2017 observations of M87 a common GainPrior call is:\n\njulia> gdist = GainPrior((AA = LogNormal(0.0, 0.1),\n                   AP = LogNormal(0.0, 0.1),\n                   JC = LogNormal(0.0, 0.1),\n                   SM = LogNormal(0.0, 0.1),\n                   AZ = LogNormal(0.0, 0.1),\n                   LM = LogNormal(0.0, 1.0),\n                   PV = LogNormal(0.0, 0.1)\n                ), st)\n\njulia> x = rand(gdist)\njulia> logdensityof(gdist, x)\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.RIMEModel","page":"Comrade API","title":"Comrade.RIMEModel","text":"abstract type RIMEModel <: ComradeBase.AbstractModel\n\nAbstract type that encompasses all RIME style corruptions.\n\n\n\n\n\n","category":"type"},{"location":"api/#Combinators","page":"Comrade API","title":"Combinators","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Base.:+(::Comrade.AbstractModel, ::Comrade.AbstractModel)\nComrade.added\nComrade.convolved\nComrade.components\nComrade.smoothed\nComrade.CompositeModel\nComrade.AddModel\nComrade.ConvolvedModel","category":"page"},{"location":"api/#Base.:+-Tuple{ComradeBase.AbstractModel, ComradeBase.AbstractModel}","page":"Comrade API","title":"Base.:+","text":"Base.:+(m1::AbstractModel, m2::AbstractModel)\n\nCombine two models to create a composite AddModel. This adds two models pointwise, i.e.\n\njulia> m1 = Gaussian()\njulia> m2 = Disk()\njulia> visibility(m1+m2, 1.0, 1.0) == visibility(m1, 1.0, 1.0) + visibility(m2, 1.0, 1.0)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.added","page":"Comrade API","title":"Comrade.added","text":"added(m1::AbstractModel, m2::AbstractModel)\n\nCombine two models to create a composite AddModel. This adds two models pointwise, i.e.\n\njulia> m1 = Gaussian()\njulia> m2 = Disk()\njulia> visibility(added(m1,m2), 1.0, 1.0) == visibility(m1, 1.0, 1.0) + visibility(m2, 1.0, 1.0)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.convolved","page":"Comrade API","title":"Comrade.convolved","text":"convolved(m1::AbstractModel, m2::AbstractModel)\n\nConvolve two models to create a composite ConvolvedModel.\n\njulia> m1 = Ring()\njulia> m2 = Disk()\njulia> convolved(m1, m2)\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.components","page":"Comrade API","title":"Comrade.components","text":"components(m::AbstractModel)\n\nReturns the model components for a composite model. This will return a Tuple with all the models you have constructed.\n\nExample\n\njulia> m = Gaussian() + Disk()\njulia> components(m)\n(Gaussian{Float64}(), Disk{Float64}())\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.smoothed","page":"Comrade API","title":"Comrade.smoothed","text":"smoothed(m::AbstractModel, σ::Number)\n\nSmooths a model m with a Gaussian kernel with standard deviation σ.\n\nNotes\n\nThis uses convolved to created the model, i.e.\n\njulia> m1 = Disk()\njulia> m2 = Gaussian()\njulia> convolved(m1, m2) == smoothed(m1, 1.0)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.CompositeModel","page":"Comrade API","title":"Comrade.CompositeModel","text":"abstract type CompositeModel{M1, M2} <: ComradeBase.AbstractModel\n\nAbstract type that denotes a composite model. Where we have combined two models together.\n\nImplementation\n\nAny implementation of a composite type must define the following methods:\n\nvisibility_point\nuv_combinator\nimanalytic\nvisanalytic\nComradeBase.intensity_point if model intensity is IsAnalytic\nintensitymap! if model intensity is NotAnalytic\nintensitymap if model intensity is NotAnalytic\nflux\nradialextent\nvisibilities (optional)\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.AddModel","page":"Comrade API","title":"Comrade.AddModel","text":"struct AddModel{T1, T2} <: Comrade.CompositeModel{T1, T2}\n\nPointwise addition of two models in the image and visibility domain. An end user should instead call added or Base.+ when constructing a model\n\nExample\n\njulia> m1 = Disk() + Gaussian()\njulia> m2 = added(Disk(), Gaussian()) + Ring()\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ConvolvedModel","page":"Comrade API","title":"Comrade.ConvolvedModel","text":"struct ConvolvedModel{M1, M2} <: Comrade.CompositeModel{M1, M2}\n\nPointwise addition of two models in the image and visibility domain. An end user should instead call convolved. Also see smoothed(m, σ) for a simplified function that convolves a model m with a Gaussian with standard deviation σ.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometricModels","page":"Comrade API","title":"GeometricModels","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Comrade.scale_uv\nComrade.scale_image\nComrade.transform_uv\nComrade.transform_image\nComrade.GeometricModel\nComrade.ConcordanceCrescent\nComrade.Crescent\nComrade.Disk\nComrade.ExtendedRing\nComrade.Gaussian\nComrade.MRing\nComrade.Ring\nComrade.ParabolicSegment","category":"page"},{"location":"api/#Comrade.scale_uv","page":"Comrade API","title":"Comrade.scale_uv","text":"scale_image(model::AbstractModifier, u, u)\n\nReturns a number on how to scale the image visibility at u v for an modified model\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.scale_image","page":"Comrade API","title":"Comrade.scale_image","text":"scale_image(model::AbstractModifier, x, y)\n\nReturns a number of how to to scale the image intensity at x y for an modified model\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.transform_uv","page":"Comrade API","title":"Comrade.transform_uv","text":"transform_uv(model::AbstractModifier, u, u)\n\nReturns a transformed u and v according to the model modifier\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.transform_image","page":"Comrade API","title":"Comrade.transform_image","text":"transform_image(model::AbstractModifier, x, y)\n\nReturns a transformed x and y according to the model modifier\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.GeometricModel","page":"Comrade API","title":"Comrade.GeometricModel","text":"abstract type GeometricModel <: ComradeBase.AbstractModel\n\nA type that defines it is a geometric model. These are usually primitive models, and are usually analytic in Fourier and the image domain. As a result a user only needs to implement the following methods\n\nvisibility_point\nintensity_point\nradialextent\n\nNote that if the geometric model isn't analytic then the usual methods listed in Comrade.AbstractModel for non-analytic models need to be implemented.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ConcordanceCrescent","page":"Comrade API","title":"Comrade.ConcordanceCrescent","text":"struct ConcordanceCrescent{T} <: Comrade.GeometricModel\n\nCreates the ConcordanceCrescent model, i.e. a flat-top crescent with a displacment and a slash. Note this creates a crescent with unit flux. If you want a different flux please use the renomed modifier.\n\nFields\n\nrouter\nOuter radius of the crescent\n\nrinner\nInner radius of the crescent (i.e. inside this radius there is a hole)\n\nshift\nDisplacment of the inner disk radius\n\nslash\nStrength of the linear slash. Note that s∈[0.0,1.0] to ensure positivity in the image.\n\nNotes\n\nUnlike the Gaussian and Disk models this does not create the unit version. In fact, this model could have been created using the Disk and primitives by using Comrade.jl's model composition functionality.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.Crescent","page":"Comrade API","title":"Comrade.Crescent","text":"Creates a Kamruddin and Dexter crescent model. This works by composing two disk models together.\n\nArguments\n\nrouter: The radius of the outer disk\nrinner: The radius of the inner disk\nshift: How much the inner disk radius is shifted (positive is to the right)\nfloor: The floor of the inner disk 0 means the inner intensity is zero and 1 means it is a large disk.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.Disk","page":"Comrade API","title":"Comrade.Disk","text":"Disk{T}() where {T}\n\nTophat disk geometrical model, i.e. the intensity profile\n\n    I(xy) = begincases pi^-1  x^2+y^2  1  0  x^2+y^2 geq 0 endcases\n\ni.e. a unit radius and unit flux disk.\n\nBy default if T isn't given, Disk defaults to Float64\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ExtendedRing","page":"Comrade API","title":"Comrade.ExtendedRing","text":"struct ExtendedRing{F<:Number} <: Comrade.GeometricModel\n\nA symmetric extended ring whose radial profile follows an inverse gamma distributions.\n\nThe formula in the image domain is given by\n\nI(r,θ) = βᵅrᵅ⁻²exp(-β/r)/2πΓ(α)\n\nwhere α = shape and β = shape+1\n\nNote\n\nWe mainly use this as an example of a non-analytic Fourier transform (although it has a complicated expression)\n\nFields\n\nshape\nshape of the radial distribution\n\nNote that if T isn't specified at construction then it defaults to Float64.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.Gaussian","page":"Comrade API","title":"Comrade.Gaussian","text":"struct Gaussian{T} <: Comrade.GeometricModel\n\nGaussian with unit standard deviation and flux.\n\nBy default if T isn't given, Gaussian defaults to Float64\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.MRing","page":"Comrade API","title":"Comrade.MRing","text":"struct MRing{T, V<:AbstractArray{T, 1}} <: Comrade.GeometricModel\n\nm-ring geometric model. This is a infinitely thin unit flux delta ring whose angular structure is given by a Fourier expansion. That is,\n\nI(r,θ) = (2π)⁻¹δ(r-1)∑ₙ(αₙcos(nθ) - βₙsin(nθ))\n\nThe N in the type defines the order of the Fourier expansion.\n\nFields\n\nα\nReal Fourier mode coefficients\n\nβ\nImaginary Fourier mode coefficients\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.Ring","page":"Comrade API","title":"Comrade.Ring","text":"struct Ring{T} <: Comrade.GeometricModel\n\nA infinitely thin ring model, whose expression in the image domain is     I(r,θ) = δ(r - 1)/2π i.e. a unit radius and flux delta ring.\n\nBy default if T isn't given, Gaussian defaults to Float64\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ParabolicSegment","page":"Comrade API","title":"Comrade.ParabolicSegment","text":"struct ParabolicSegment{T} <: Comrade.GeometricModel\n\nA infinitely thin parabolic segment in the image domain. The segment is centered at zero, with roots ±1 and a yintercept of 1.\n\nNote that if T isn't specified at construction then it defaults to Float64.\n\n\n\n\n\n","category":"type"},{"location":"api/#Model-Image-(non-analytic-FFT)","page":"Comrade API","title":"Model Image (non analytic FFT)","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Comrade.create_cache\nComrade.update_cache\nComrade.modelimage\nComrade.uviterator\nComrade.fouriermap\nComrade.ModelImage\nComrade.DFTAlg\nComrade.DFTAlg(::Comrade.EHTObservation)\nComrade.DFTAlg(::AbstractArray. ::AbstractArray)\nComrade.DFTAlg(::Comrade.ArrayConfiguration)\nComrade.FFTAlg\nComrade.FFTCache\nComrade.NFFTAlg\nComrade.NUFTCache\nComrade.ObservedNUFT","category":"page"},{"location":"api/#Comrade.create_cache","page":"Comrade API","title":"Comrade.create_cache","text":"create_cache(alg::AbstractFourierTransform, img::AbstractIntensityMap)\n\nCreates a Fourier transform cache for a img using algorithm alg. For non-analytic visibility models this can significantly speed up computations.\n\nExamples\n\njulia> u,v = rand(100), rand(100)\njulia> cache = create_cache(DFTAlg(u, v), IntensityMap(randn(50,50), 10.0, 10.0))\njulia> cache = create_cache(NFFTAlg(u, v), IntensityMap(randn(50,50), 10.0, 10.0))\njulia> cache = create_cache(FFTAlg(), IntensityMap(randn(50,50), 10.0, 10.0))\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.update_cache","page":"Comrade API","title":"Comrade.update_cache","text":"update_cache(cache, img)\n\nUpdate the Fourier transform cache. This will reuse an FFT/NFFT plan saving some computational time.\n\nNote\n\nThis is an intenal method than an end user shouldn't have to usually call.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.modelimage","page":"Comrade API","title":"Comrade.modelimage","text":"modelimage(model::AbstractIntensityMap, image::AbstractIntensityMap, alg=FFTAlg(), executor=SequentialEx())\n\nConstruct a ModelImage from a model, image and the optionally specified visibility algorithm alg and executor which uses Folds.jl parallelism formalism.\n\nNotes\n\nFor analytic models this is a no-op and returns the model. For non-analytic models this creates a ModelImage object which uses alg to compute the non-analytic Fourier transform.\n\n\n\n\n\nmodelimage(model, cache::AbstractCache, executor=SequentialEx())\n\nConstruct a ModelImage from the model and using a precompute Fourier transform cache. You can optionally specify the executor which will compute the internal image buffer using the executor.\n\nExample\n\njulia> m = ExtendedRing(10.0)\njulia> cache = create_cache(DFTAlg(), IntensityMap(zeros(128, 128), 50.0, 50.0)) # used threads to make the image\njulia> mimg = modelimage(m, cache, ThreadedEx())\n\nNotes\n\nFor analytic models this is a no-op and returns the model.\n\n\n\n\n\nmodelimage(img::IntensityMap, alg=NFFTAlg())\n\nCreate a model image directly using an image, i.e. treating it as the model. You can optionally specify the Fourier transform algorithm using alg\n\nNotes\n\nFor analytic models this is a no-op and returns the model.\n\n\n\n\n\nmodelimage(img::IntensityMap, cache::AbstractCache)\n\nCreate a model image directly using an image, i.e. treating it as the model. Additionally reuse a previously compute image cache. This can be used when directly modeling an image of a fixed size and number of pixels.\n\nNotes\n\nFor analytic models this is a no-op and returns the model.\n\n\n\n\n\nmodelimage(m;\n           fovx=2*radialextent(m),\n           fovy=2*radialextent(m),\n           nx=512,\n           ny=512,\n           pulse=ComradeBase.DeltaPulse(),\n           alg=FFTAlg(),\n           executor=SequentialEx()\n            )\n\nConstruct a ModelImage where just the model m is specified.\n\nIf fovx or fovy aren't given modelimage will guess a reasonable field of view based on the radialextent function. nx and ny are the number of pixels in the x and y direction. The pulse is the pulse used for the image and alg\n\nNotes\n\nFor analytic models this is a no-op and returns the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.uviterator","page":"Comrade API","title":"Comrade.uviterator","text":"uviterator(dx, dy, nnx, nny)\n\nConstruct the u,v iterators for the Fourier transform of the image with pixel sizes dx, dy and number of pixels nx, ny\n\nIf you are extending Fourier transform stuff please use these functions to ensure that the centroid is being properly computed.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.fouriermap","page":"Comrade API","title":"Comrade.fouriermap","text":"fouriermap(m, fovx, fovy, nx, ny)\n\nCreate a Fourier or visibility map of a model m assuming a image with a field of view fovx/fovy and nx/ny pixels in the x/y direction respectively.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.ModelImage","page":"Comrade API","title":"Comrade.ModelImage","text":"struct ModelImage{M, I, C} <: Comrade.AbstractModelImage{M}\n\nContainer for non-analytic model that contains a image cache which will hold the image, a Fourier transform cache, which usually an instance of a <: FourierCache.\n\nNote\n\nThis is an internal implementation detail that shouldn't usually be called directly. Instead the user should use the exported function modelimage, for example\n\nusing Comrade\nm = ExtendedRing(20.0, 5.0)\n\n# This creates an version where the image is dynamically specified according to the\n# radial extent of the image\nmimg = modelimage(m) # you can also optionally pass the number of pixels nx and ny\n\n# Or you can create an IntensityMap\nimg = intensitymap(m, 100.0, 100.0, 512, 512)\nmimg = modelimage(m, img)\n\n# Or precompute a cache\ncache = create_cache(FFTAlg(), img)\nmimg = modelimage(m, cache)\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.DFTAlg","page":"Comrade API","title":"Comrade.DFTAlg","text":"DFTAlg\n\nUses a discrete fourier transform. This is not very efficient for larger images. In those cases  NFFTAlg or FFTAlg are more reasonable. For small images this is a reasonable choice especially since it's easy to define derivatives.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.DFTAlg-Tuple{Comrade.EHTObservation}","page":"Comrade API","title":"Comrade.DFTAlg","text":"DFTAlg(obs::EHTObservation)\n\nCreate an algorithm object using the direct Fourier transform object from the observation obs. This will extract the uv positions from the observation to allow for a more efficient FT cache.\n\n\n\n\n\n","category":"method"},{"location":"api/#Modifiers","page":"Comrade API","title":"Modifiers","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Comrade.basemodel\nComrade.renormed\nComrade.rotated\nComrade.posangle\nComrade.shifted\nComrade.stretched\nComrade.AbstractModifier\nComrade.RenormalizedModel\nComrade.RotatedModel\nComrade.ShiftedModel\nComrade.StretchedModel","category":"page"},{"location":"api/#Comrade.basemodel","page":"Comrade API","title":"Comrade.basemodel","text":"basemodel(model::AbstractModel)\n\nReturns the base model from a modified model. If there is no basemodel this just return the model itself.\n\nExample\n\njulia> basemodel(stretched(Disk(), 1.0, 2.0)) == Disk()\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.renormed","page":"Comrade API","title":"Comrade.renormed","text":"renormed(model, f)\n\n\nRenormalizes the model m to have total flux f*flux(m). This can also be done directly by calling Base.:* i.e.,\n\njulia> renormed(m, f) == f*M\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.rotated","page":"Comrade API","title":"Comrade.rotated","text":"rotated(model, ξ)\n\n\nRotates the model by an amount ξ in radians in the clockwise direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.posangle","page":"Comrade API","title":"Comrade.posangle","text":"posangle(model)\n\n\nReturns the rotation angle of the rotated model\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.shifted","page":"Comrade API","title":"Comrade.shifted","text":"shifted(model, Δx, Δy)\n\n\nShifts the model m in the image domain by an amount Δx,Δy in the x and y directions respectively.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.stretched","page":"Comrade API","title":"Comrade.stretched","text":"stretched(model, α, β)\n\n\nStretches the model m according to the formula     Iₛ(x,y) = 1/(αβ) I(x/α, y/β), where were renormalize the intensity to preserve the models flux.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.AbstractModifier","page":"Comrade API","title":"Comrade.AbstractModifier","text":"abstract type AbstractModifier{M<:ComradeBase.AbstractModel} <: ComradeBase.AbstractModel\n\nAbstract type for image modifiers. These are some model wrappers that can transform any model using simple Fourier transform properties. By default these modified models will have the same analytic properties as the base unmodified model, i.e.\n\njulia> visanalytic(stretched(Disk(), 2.0, 2.0)) == visanalytic(Disk())\ntrue\n\nAdditionally these are classic examples of non-primitive images i.e.,\n\njulia> isprimitive(Comrade.AbstractModifier) == Comrade.NotAnalytic()\n\nAs a result of this the implementation of a model is slightly different\n\ntransform_uv\ntransform_image\nscale_uv\nscale_image\nradialextent\n\nThis methods assume the modifiers are of the form\n\nI(x,y) -> fᵢ(x,y)I(gᵢ(x,y)) V(u,v) -> fᵥ(u,v)V(gᵥ(u,v))\n\nwhere g are the transformimage/uv functions and f are the scaleimage/uv function.\n\nSee those docstrings for guidance on implementation details.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.RenormalizedModel","page":"Comrade API","title":"Comrade.RenormalizedModel","text":"struct RenormalizedModel{M<:ComradeBase.AbstractModel, T} <: Comrade.AbstractModifier{M<:ComradeBase.AbstractModel}\n\nRenormalizes the flux of the model to the new value scale*flux(model). We have also overloaded the Base.:* operator as syntactic sugar although I may get rid of this.\n\nAn end user should not call this directly but instead the renormed function or Base.:* instead.\n\nExample\n\njulia> renormed(Gaussian(), 2.0) == 2.0*Gaussian()\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.RotatedModel","page":"Comrade API","title":"Comrade.RotatedModel","text":"struct RotatedModel{M<:ComradeBase.AbstractModel, T} <: Comrade.AbstractModifier{M<:ComradeBase.AbstractModel}\n\nType for the rotated model. This is more fine grained constrol of rotated model.\n\nAn end user should not call this directly but instead the rotated function instead.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ShiftedModel","page":"Comrade API","title":"Comrade.ShiftedModel","text":"struct ShiftedModel{M<:ComradeBase.AbstractModel, T} <: Comrade.AbstractModifier{M<:ComradeBase.AbstractModel}\n\nShifts the model by Δx units in the x-direction and Δy units in the y-direction.\n\nAn end user should not call this directly but instead the shifted function instead.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.StretchedModel","page":"Comrade API","title":"Comrade.StretchedModel","text":"struct StretchedModel{M<:ComradeBase.AbstractModel, T} <: Comrade.AbstractModifier{M<:ComradeBase.AbstractModel}\n\nStretched the model in the x and y directions, i.e. the new intensity is     Iₛ(x,y) = 1/(αβ) I(x/α, y/β), where were renormalize the intensity to preserve the models flux.\n\nAn end user should not call this directly but instead the stretched function instead.\n\n\n\n\n\n","category":"type"},{"location":"api/#Polarized-Models","page":"Comrade API","title":"Polarized Models","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Comrade.m̆(pimg::ComradeBase.AbstractPolarizedModel, u, v)\nComrade.mbreve\nComrade.evpa(pimg::ComradeBase.AbstractPolarizedModel, u, v)\nComrade.coherencymatrix(pimg::PolarizedModel, u, v)\nComrade.PolarizedModel","category":"page"},{"location":"api/#ComradeBase.m̆-Tuple{ComradeBase.AbstractPolarizedModel, Any, Any}","page":"Comrade API","title":"ComradeBase.m̆","text":"m̆(pimg::AbstractPolarizedModel, u, v)\n\nComputes the fractional linear polarization in the visibility domain\n\nm̆ = (Q + iU)/I\n\nTo create the symbol type m\\breve in the REPL or use the mbreve function.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.mbreve","page":"Comrade API","title":"Comrade.mbreve","text":"mbreve(pimg, u, v)\n\n\nExplicit m̆ function used for convenience.\n\n\n\n\n\n","category":"function"},{"location":"api/#ComradeBase.evpa-Tuple{ComradeBase.AbstractPolarizedModel, Any, Any}","page":"Comrade API","title":"ComradeBase.evpa","text":"evpa(pimg::AbstractPolarizedModel, u, v)\n\nelectric vector position angle or EVPA of the polarized model pimg at u and v\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.coherencymatrix-Tuple{PolarizedModel, Any, Any}","page":"Comrade API","title":"Comrade.coherencymatrix","text":"coherencymatrix(pimg, u, v)\n\n\nComputes the coherency matrix of the polarized model pimg at u and v\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.PolarizedModel","page":"Comrade API","title":"Comrade.PolarizedModel","text":"struct PolarizedModel{TI, TQ, TU, TV} <: ComradeBase.AbstractPolarizedModel\n\nWrapped model for a polarized model. This uses the stokes representation of the image.\n\nFields\n\nI\nStokes I model\n\nQ\nStokes Q Model\n\nU\nStokes U Model\n\nV\nStokes V Model\n\n\n\n\n\n","category":"type"},{"location":"api/#Model-Evaluation","page":"Comrade API","title":"Model Evaluation","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"For more docstrings on how to evaluate models see ComradeBase API.","category":"page"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Comrade.amplitude\nComrade.amplitudes\nComrade.bispectra\nComrade.bispectrum\nComrade.closure_phase\nComrade.closure_phases\nComrade.logclosure_amplitude\nComrade.logclosure_amplitudes\nComrade.visibilities\nComrade.visibility\nComrade.intensitymap\nComrade.intensitymap!","category":"page"},{"location":"api/#Comrade.amplitude","page":"Comrade API","title":"Comrade.amplitude","text":"amplitude(d::EHTVisibilityDatum)\n\nGet the amplitude of a visibility datum\n\n\n\n\n\namplitude(d::EHTVisibilityAmplitudeDatum)\n\nGet the amplitude of a amplitude datum\n\n\n\n\n\namplitude(model, args...)\n\nComputes the visibility amplitude of model m at u,v positions u,v\n\nIf you want to compute the amplitudes at a large number of positions consider using the amplitudes function.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.amplitudes","page":"Comrade API","title":"Comrade.amplitudes","text":"amplitudes(m::AbstractModel, u::AbstractArray, v::AbstractArray)\n\nComputes the amplitudes of the model m at the u,v positions u, v.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.bispectra","page":"Comrade API","title":"Comrade.bispectra","text":"bispectra(m,\n          u1::AbstractArray, v1::AbstractArray,\n          u2::AbstractArray, v2::AbstractArray,\n          u3::AbstractArray, v3::AbstractArray,\n        )\n\nComputes the bispectra of the model m at the triangles (u1,v1), (u2,v2), (u3,v3).\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.bispectrum","page":"Comrade API","title":"Comrade.bispectrum","text":"bispectrum(d1::T, d2::T, d3::T) where {T<:EHTVisibilityDatum}\n\nFinds the bispectrum of three visibilities. We will assume these form closed triangles, i.e. the phase of the bispectrum is a closure phase.\n\n\n\n\n\nbispectrum(model, u1, v1, u2, v2, u3, v3)\n\nComputes the complex bispectrum of model m at the uv-triangle u1,v1 -> u2,v2 -> u3,v3\n\nIf you want to compute the bispectrum over a number of triangles consider using the bispectra function.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.closure_phase","page":"Comrade API","title":"Comrade.closure_phase","text":"closure_phase(D1::EHTVisibilityDatum,\n              D2::EHTVisibilityDatum,\n              D3::EHTVisibilityDatum\n              )\n\nComputes the closure phase of the three visibility datums.\n\nNotes\n\nWe currently use the high SNR Gaussian error approximation for the closure phase. In the future we may use the moment matching from Monte Carlo sampling.\n\n\n\n\n\nclosure_phase(model. u1, v1, u2, v2, u3, v3)\n\nComputes the closure phase of model m at the uv-triangle u1,v1 -> u2,v2 -> u3,v3\n\nIf you want to compute closure phases over a number of triangles consider using the closure_phases function.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.closure_phases","page":"Comrade API","title":"Comrade.closure_phases","text":"closure_phases(m,\n               u1::AbstractArray, v1::AbstractArray,\n               u2::AbstractArray, v2::AbstractArray,\n               u3::AbstractArray, v3::AbstractArray,\n               )\n\nComputes the closure phases of the model m at the triangles (u1,v1), (u2,v2), (u3,v3).\n\n\n\n\n\nclosure_phases(m::AbstractModel, ac::ClosureConfig)\n\nComputes the closure phases of the model m using the array configuration ac.\n\nNotes\n\nThis is faster than the closure_phases(m, u1, v1, ...) method since it only computes as many visibilities as required thanks to the closure design matrix formalism from Blackburn et al.[1]\n\n[1]: Blackburn L., et al \"Closure Statistics in Interferometric Data\" ApJ 2020\n\n\n\n\n\nclosure_phases(vis::AbstractArray, ac::ArrayConfiguration)\n\nCompute the closure phases for a set of visibilities and an array configuration\n\nNotes\n\nThis uses a closure design matrix for the computation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.logclosure_amplitude","page":"Comrade API","title":"Comrade.logclosure_amplitude","text":"logclosure_amplitude(model, u1, v1, u2, v2, u3, v3, u4, v4)\n\nComputes the log-closure amplitude of model m at the uv-quadrangle u1,v1 -> u2,v2 -> u3,v3 -> u4,v4 using the formula\n\nC = logleftfracV(u1v1)V(u2v2)V(u3v3)V(u4v4)right\n\nIf you want to compute log closure amplitudes over a number of triangles consider using the logclosure_amplitudes function.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.logclosure_amplitudes","page":"Comrade API","title":"Comrade.logclosure_amplitudes","text":"logclosure_amplitudes(m::AbstractModel,\n                      u1::AbstractArray, v1::AbstractArray,\n                      u2::AbstractArray, v2::AbstractArray,\n                      u3::AbstractArray, v3::AbstractArray,\n                      u4::AbstractArray, v4::AbstractArray,\n                     )\n\nComputes the log closure amplitudes of the model m at the quadrangles (u1,v1), (u2,v2), (u3,v3), (u4, v4).\n\n\n\n\n\nlogclosure_amplitudes(m::AbstractModel, ac::ClosureConfig)\n\nComputes the log closure amplitudes of the model m using the array configuration ac.\n\nNotes\n\nThis is faster than the logclosure_amplitudes(m, u1, v1, ...) method since it only computes as many visibilities as required thanks to the closure design matrix formalism from Blackburn et al.[1]\n\n[1]: Blackburn L., et al \"Closure Statistics in Interferometric Data\" ApJ 2020\n\n\n\n\n\nlogclosure_amplitudes(vis::AbstractArray, ac::ArrayConfiguration)\n\nCompute the log-closure amplitudes for a set of visibilities and an array configuration\n\nNotes\n\nThis uses a closure design matrix for the computation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.visibilities","page":"Comrade API","title":"Comrade.visibilities","text":"visibilities(m, ac::ArrayConfiguration)\n\nComputes the visibilities of the model m using the array configuration ac. If you want to compute a single visibility you should call visibility.\n\n\n\n\n\nvisibilities(m, u::AbstractArray, v::AbstractArray, args...)\n\nComputes the visibilities of the model m at u v and args.... If you want to compute a single visibility you should call visibility.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.visibility","page":"Comrade API","title":"Comrade.visibility","text":"visibility(d::EHTVisibilityDatum)\n\nReturn the complex visibility of the visibility datum\n\n\n\n\n\nvisibility(mimg, u, v, args...)\n\nComputes the complex visibility of model m at u,v positions u,v and other args... (e.g., frequency, time, etc.)\n\nNotes\n\nIf you want to compute the visibilities at a large number of positions consider using the visibilities.\n\n\n\n\n\nvisibility(mimg, uv::ArrayBaselineDatum)\n\nComputes the complex visibility of a model m at the uv array baseline datum.\n\nNotes\n\nIf you want to compute the visibilities at a large number of positions consider using the visibilities.\n\n\n\n\n\nvisibility(pimg::PolarizedModel, u, v)\n\nComputes the visibility in the stokes basis of the polarized model\n\n\n\n\n\n","category":"function"},{"location":"api/#ComradeBase.intensitymap","page":"Comrade API","title":"ComradeBase.intensitymap","text":"intensitymap(model::AbstractModel, args...)\n\nComputes the intensity map of model. For the inplace version see intensitymap!\n\n\n\n\n\n","category":"function"},{"location":"api/#ComradeBase.intensitymap!","page":"Comrade API","title":"ComradeBase.intensitymap!","text":"intensitymap!(buffer::AbstractMatrix, model::AbstractModel, args...)\n\nComputes the intensity map of model by modifying the buffer\n\n\n\n\n\n","category":"function"},{"location":"api/#Data-Types","page":"Comrade API","title":"Data Types","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Comrade.amplitude(::Comrade.EHTVisibilityDatum)\nComrade.amplitude(::Comrade.EHTVisibilityAmplitudeDatum)\nComrade.baselines\nComrade.arrayconfig\nComrade.closure_phase(::Comrade.EHTVisibilityDatum, ::Comrade.EHTVisibilityDatum, ::Comrade.EHTVisibilityDatum)\nComrade.getdata\nComrade.getuv\nComrade.getuvtimefreq\nComrade.rescaleuv!\nComrade.scantable\nComrade.stations\nComrade.uvpositions\nComrade.ClosureConfig\nComrade.ArrayBaselineDatum\nComrade.EHTObservation\nComrade.EHTArrayConfiguration\nComrade.EHTClosurePhaseDatum\nComrade.EHTLogClosureAmplitudeDatum\nComrade.EHTVisibilityDatum\nComrade.EHTVisibilityAmplitudeDatum\nComrade.Scan\nComrade.ScanTable","category":"page"},{"location":"api/#Comrade.amplitude-Tuple{Comrade.EHTVisibilityDatum}","page":"Comrade API","title":"Comrade.amplitude","text":"amplitude(d::EHTVisibilityDatum)\n\nGet the amplitude of a visibility datum\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.amplitude-Tuple{Comrade.EHTVisibilityAmplitudeDatum}","page":"Comrade API","title":"Comrade.amplitude","text":"amplitude(d::EHTVisibilityAmplitudeDatum)\n\nGet the amplitude of a amplitude datum\n\n\n\n\n\namplitude(model, args...)\n\nComputes the visibility amplitude of model m at u,v positions u,v\n\nIf you want to compute the amplitudes at a large number of positions consider using the amplitudes function.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.baselines","page":"Comrade API","title":"Comrade.baselines","text":"baselines(CP::EHTClosurePhaseDatum)\n\nReturns the baselines used for a single closure phase datum\n\n\n\n\n\nbaselines(CP::EHTLogClosureAmplitudeDatum)\n\nReturns the baselines used for a single closure phase datum\n\n\n\n\n\nbaselines(scan::Scan)\n\nReturn the baselines for each datum in a scan\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.arrayconfig","page":"Comrade API","title":"Comrade.arrayconfig","text":"arrayconfig(vis)\n\n\nExtract the array configuration from a EHT observation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.closure_phase-Tuple{Comrade.EHTVisibilityDatum, Comrade.EHTVisibilityDatum, Comrade.EHTVisibilityDatum}","page":"Comrade API","title":"Comrade.closure_phase","text":"closure_phase(D1::EHTVisibilityDatum,\n              D2::EHTVisibilityDatum,\n              D3::EHTVisibilityDatum\n              )\n\nComputes the closure phase of the three visibility datums.\n\nNotes\n\nWe currently use the high SNR Gaussian error approximation for the closure phase. In the future we may use the moment matching from Monte Carlo sampling.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.getdata","page":"Comrade API","title":"Comrade.getdata","text":"getdata(obs::EHTObservation, s::Symbol)\n\nPass-through function that gets the array of s from the EHTObservation. For example say you want the times of all measurement then\n\ngetdata(obs, :time)\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.getuv","page":"Comrade API","title":"Comrade.getuv","text":"getuv\n\nGet the u, v positions of the array.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.getuvtimefreq","page":"Comrade API","title":"Comrade.getuvtimefreq","text":"getuvtimefreq(ac)\n\n\nGet the u, v, time, freq of the array as a tuple.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.rescaleuv!","page":"Comrade API","title":"Comrade.rescaleuv!","text":"rescaleuv!(data::EHTObservation)\n\nrescale the u-v lengths according to scale. This can be useful when you want the spatial scales to be in 1/μas instead of 1/rad\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.scantable","page":"Comrade API","title":"Comrade.scantable","text":"scantable(obs::EHTObservation)\n\nReorganizes the observation into a table of scans, where scan are defined by unique timestamps. To access the data you can use scalar indexing\n\nExample\n\nst = scantable(obs)\n# Grab the first scan\nscan1 = st[1]\n\n# Acess the detections in the scan\nscan1[1]\n\n# grab e.g. the baselines\nscan1[:baseline]\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.stations","page":"Comrade API","title":"Comrade.stations","text":"stations(d::EHTObservation)\n\nGet all the stations in a observation. The result is a vector of symbols.\n\n\n\n\n\nstations(g::CalTable)\n\nReturn the stations in the calibration table\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.uvpositions","page":"Comrade API","title":"Comrade.uvpositions","text":"uvpositions(datum::AbstractVisibilityDatum)\n\nGet the uvp positions of an inferometric datum.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.ClosureConfig","page":"Comrade API","title":"Comrade.ClosureConfig","text":"struct ClosureConfig{A, D} <: Comrade.ArrayConfiguration\n\nArray config file for closure quantities. This stores the design matrix designmat that transforms from visibilties to closure products.\n\nFields\n\nac\nArray configuration for visibilities\ndesignmat\nClosure design matrix\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ArrayBaselineDatum","page":"Comrade API","title":"Comrade.ArrayBaselineDatum","text":"struct ArrayBaselineDatum{T}\n\nA single datum of an ArrayConfiguration\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.EHTObservation","page":"Comrade API","title":"Comrade.EHTObservation","text":"struct EHTObservation{F, T<:Comrade.AbstractInterferometryDatum{F}, S<:(StructArrays.StructArray{T<:Comrade.AbstractInterferometryDatum{F}}), A, N} <: Comrade.Observation{F}\n\nThe main data product type in Comrade this stores the data which can be a StructArray of any AbstractInterferometryDatum type.\n\nFields\n\ndata\nStructArray of data productts\n\nconfig\nArray config holds ancillary information about array\n\nmjd\nmodified julia date of the observation\n\nra\nRA of the observation in J2000 (deg)\n\ndec\nDEC of the observation in J2000 (deg)\n\nbandwidth\nbandwidth of the observation (Hz)\n\nfrequency\nfrequency of the observation (Hz)\n\nsource\nCommon source name\n\ntimetype\nTime zone used.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.EHTArrayConfiguration","page":"Comrade API","title":"Comrade.EHTArrayConfiguration","text":"struct EHTArrayConfiguration{F, T<:AbstractArray} <: Comrade.ArrayConfiguration\n\nStores all the non-visibility data products for an EHT array. This is useful when evaluating model visibilities.\n\nFields\n\nfrequency\nObserving frequency (Hz)\n\nbandwidth\nObserving bandwith (Hz)\n\ndata\nA struct array of ArrayBaselineDatum holding time, freq, u, v, baselines.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.EHTClosurePhaseDatum","page":"Comrade API","title":"Comrade.EHTClosurePhaseDatum","text":"struct EHTClosurePhaseDatum{T<:Number} <: Comrade.ClosureProducts{T<:Number}\n\nA Datum for a single closure phase.\n\nFields\n\nphase\nclosure phase (rad)\n\nerror\nerror of the closure phase assuming the high-snr limit\n\nu1\nu (λ) of first station\n\nv1\nv (λ) of first station\n\nu2\nu (λ) of second station\n\nv2\nv (λ) of second station\n\nu3\nu (λ) of third station\n\nv3\nv (λ) of third station\n\ntime\nMeasured time of closure phase in hours\n\ntriangle\nstation baselines used\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.EHTLogClosureAmplitudeDatum","page":"Comrade API","title":"Comrade.EHTLogClosureAmplitudeDatum","text":"struct EHTLogClosureAmplitudeDatum{T<:Number} <: Comrade.ClosureProducts{T<:Number}\n\nA Datum for a single log closure amplitude.\n\n\n\namp\nlog-closure amplitude\n\nerror\nlog-closure amplitude error in the high-snr limit\n\nu1\nu (λ) of first station\n\nv1\nv (λ) of first station\n\nu2\nu (λ) of second station\n\nv2\nv (λ) of second station\n\nu3\nu (λ) of third station\n\nv3\nv (λ) of third station\n\nu4\nu (λ) of fourth station\n\nv4\nv (λ) of fourth station\n\ntime\nObservation time of the quadrangle\n\nquadrangle\nstation codes for the quadrangle\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.EHTVisibilityDatum","page":"Comrade API","title":"Comrade.EHTVisibilityDatum","text":"struct EHTVisibilityDatum{T<:Number} <: Comrade.AbstractVisibilityDatum{T<:Number}\n\nA struct holding the information for a single measured visibility.\n\n\n\nvisr\nreal component of the visibility (Jy)\n\nvisi\nimaginary component of the visibility (Jy)\n\nerror\nerror of the visibility (Jy)\n\nu\nx-direction baseline length in λ\n\nv\ny-direction baseline length in λ\n\ntime\nTime of the observation in hours\n\nbaseline\nstation baseline codes\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.EHTVisibilityAmplitudeDatum","page":"Comrade API","title":"Comrade.EHTVisibilityAmplitudeDatum","text":"struct EHTVisibilityAmplitudeDatum{T<:Number} <: Comrade.AbstractVisibilityDatum{T<:Number}\n\nA struct holding the information for a single measured visibility amplitude.\n\nFIELDS\n\namp\namplitude (Jy)\n\nerror\nerror of the visibility amplitude (Jy)\n\nu\nx-direction baseline length in λ\n\nv\ny-direction baseline length in λ\n\ntime\nTime of the observation in hours\n\nbaseline\nstation baseline codes\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.Scan","page":"Comrade API","title":"Comrade.Scan","text":"struct Scan{T, I, S}\n\nComposite type that holds information for a single scan of the telescope.\n\nFields\n\ntime\nScan time\n\nindex\nScan indices which are (scan index, data start index, data end index)\n\nscan\nScan data usually a StructArray of a <:AbstractVisibilityDatum\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ScanTable","page":"Comrade API","title":"Comrade.ScanTable","text":"struct ScanTable{O<:Union{Comrade.ArrayConfiguration, Comrade.Observation}, T, S}\n\nWraps EHTObservation in a table that separates the observation into scans. This implements the table interface. You can access scans by directly indexing into the table. This will create a view into the table not copying the data.\n\nExample\n\njulia> st = scantable(obs)\njulia> st[begin] # grab first scan\njulia> st[end]   # grab last scan\n\n\n\n\n\n","category":"type"},{"location":"api/#eht-imaging-interface","page":"Comrade API","title":"eht-imaging interface","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Comrade.extract_amp\nComrade.extract_cphase\nComrade.extract_lcamp\nComrade.extract_vis\nComrade.load_ehtim","category":"page"},{"location":"api/#Comrade.extract_amp","page":"Comrade API","title":"Comrade.extract_amp","text":"extract_amp(obs)\n\nExtracts the visibility amplitudes from an ehtim observation object.\n\nAny valid keyword arguments to add_amp in ehtim can be passed through extract_amp.\n\nReturns an EHTObservation with visibility amplitude data\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.extract_cphase","page":"Comrade API","title":"Comrade.extract_cphase","text":"extract_cphase(obs)\n\nExtracts the closure phases from an ehtim observation object\n\nAny valid keyword arguments to add_cphase in ehtim can be passed through extract_cphase.\n\nReturns an EHTObservation with closure phases datums\n\nSpecial Keyword arguments:\n\ncount: How the closures are formed, the available options are \"min-correct\", \"min\", \"max\"\ncut_trivial: Cut the trivial triangles from the closures\nuvmin: The flag to decide what are trivial triangles. Any baseline with ||(u,v)|| < uvmin        are removed.\nkwargs...: Other arguments are forwarded to eht-imaging.\n\nWarning\n\nThe count keyword argument is treated specially in Comrade. The default option is \"min-correct\" and should almost always be used. This option construct a minimal set of closure phases that is valid even when the array isn't fully connected. For testing and legacy reasons we ehtim other count options are also included. However, the current ehtim count=\"min\" option is broken and does construct proper minimal sets of closure quantities if the array isn't fully connected.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.extract_lcamp","page":"Comrade API","title":"Comrade.extract_lcamp","text":"extract_lcamp(obs)\n\nExtracts the log-closure amp. from an ehtim observation object\n\nAny valid keyword arguments to add_logcamp in ehtim can be passed through extract_lcamp.\n\nSpecial Keyword arguments:\n\ncount: How the closures are formed, the available options are \"min-correct\", \"min\", \"max\"\nkwargs...: Other arguments are forwarded to eht-imaging.\n\nReturns an EHTObservation with log-closure amp. datums\n\nWarning\n\nThe count keyword argument is treated specially in Comrade. The default option is \"min-correct\" and should almost always be used. This option construct a minimal set of closure phases that is valid even when the array isn't fully connected. For testing and legacy reasons we ehtim other count options are also included. However, the current ehtim count=\"min\" option is broken and does construct proper minimal sets of closure quantities if the array isn't fully connected.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.extract_vis","page":"Comrade API","title":"Comrade.extract_vis","text":"extract_vis(obs)\n\nExtracts the complex visibilities from an ehtim observation object\n\nThis grabs the raw data object from the obs object. Any keyword arguments are ignored.\n\nReturns an EHTObservation with complex visibility data\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.load_ehtim","page":"Comrade API","title":"Comrade.load_ehtim","text":"load_ehtim()\n\nLoads the eht-imaging library and stores it in the exported ehtim variable.\n\nNotes\n\nThis will fail if ehtim isn't installed in the python installation that PyCall references.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bayesian-Tools","page":"Comrade API","title":"Bayesian Tools","text":"","category":"section"},{"location":"api/#Distributions","page":"Comrade API","title":"Distributions","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Comrade.AmpNormal\nComrade.ComplexNormal\nComrade.CPVonMises","category":"page"},{"location":"api/#Comrade.AmpNormal","page":"Comrade API","title":"Comrade.AmpNormal","text":"AmpNormal\n\nVisibility amplitude likelihood distribution. Typically μ, τ=1/σ are vectors to allow for more efficient derivatives.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ComplexNormal","page":"Comrade API","title":"Comrade.ComplexNormal","text":"ComplexNormal\n\nUncorrelated complex Normal Measure. This is the default likelihood used for visibilties.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.CPVonMises","page":"Comrade API","title":"Comrade.CPVonMises","text":"CPVonMises\n\nThe von Mises distribution used for closure phases. Typically μ and κ=1/σ² are vectors to allow for simpler derivative rules.\n\n\n\n\n\n","category":"type"},{"location":"api/#Posterior-Constructions","page":"Comrade API","title":"Posterior Constructions","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Comrade.ascube\nComrade.asflat\nComrade.flatten\nComrade.inverse\nComrade.prior_sample\nComrade.sample(::Posterior)\nComrade.transform\nComrade.MultiRadioLikelihood\nComrade.Posterior\nComrade.TransformedPosterior\nComrade.RadioLikelihood","category":"page"},{"location":"api/#HypercubeTransform.ascube","page":"Comrade API","title":"HypercubeTransform.ascube","text":"ascube(post::Posterior)\n\nConstruct a flattened version of the posterior where the parameters are transformed to live in (0, 1), i.e. the unit hypercube.\n\nThis returns a TransformedPosterior that obeys the DensityInterface and can be evaluated in the usual manner, i.e. logdensityof. Note that the transformed posterior automatically includes the terms log-jacobian terms of the transformation.\n\nExample\n\njulia> tpost = ascube(post)\njulia> x0 = prior_sample(tpost)\njulia> logdensityof(tpost, x0)\n\nNotes\n\nThis is the transform that should be used if using typical NestedSampling methods, i.e. ComradeNested. For the transformation to unconstrained space see asflat\n\n\n\n\n\n","category":"function"},{"location":"api/#HypercubeTransform.asflat","page":"Comrade API","title":"HypercubeTransform.asflat","text":"asflat(post::Posterior)\n\nConstruct a flattened version of the posterior where the parameters are transformed to live in (-∞, ∞).\n\nThis returns a TransformedPosterior that obeys the DensityInterface and can be evaluated in the usual manner, i.e. logdensityof. Note that the transformed posterior automatically includes the terms log-jacobian terms of the transformation.\n\nExample\n\njulia> tpost = ascube(post)\njulia> x0 = prior_sample(tpost)\njulia> logdensityof(tpost, x0)\n\nNotes\n\nThis is the transform that should be used if using typical MCMC methods, i.e. ComradeAHMC. For the transformation to the unit hypercube see ascube\n\n\n\n\n\n","category":"function"},{"location":"api/#ParameterHandling.flatten","page":"Comrade API","title":"ParameterHandling.flatten","text":"flatten(post::Posterior)\n\nConstruct a flattened version of the posterior but do not transform to any space, i.e. use the support specified by the prior.\n\nThis returns a TransformedPosterior that obeys the DensityInterface and can be evaluated in the usual manner, i.e. logdensityof. Note that the transformed posterior automatically includes the terms log-jacobian terms of the transformation.\n\nExample\n\njulia> tpost = flatten(post)\njulia> x0 = prior_sample(tpost)\njulia> logdensityof(tpost, x0)\n\nNotes\n\nThis is the transform that should be used if using typical MCMC methods, i.e. ComradeAHMC. For the transformation to the unit hypercube see ascube\n\n\n\n\n\n","category":"function"},{"location":"api/#TransformVariables.inverse","page":"Comrade API","title":"TransformVariables.inverse","text":"inverse(posterior::TransformedPosterior, x)\n\nTransforms the value y from parameter space to the transformed space (e.g. unit hypercube if using ascube).\n\nFor the inverse transform see transform\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.prior_sample","page":"Comrade API","title":"Comrade.prior_sample","text":"prior_sample(post::Posterior, args...)\n\nSamples the prior distribution from the posterior. The args... are forwarded to the Base.rand method.\n\n\n\n\n\nprior_sample(post::Posterior)\n\nReturns a single sample from the prior distribution.\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsBase.sample-Tuple{Posterior}","page":"Comrade API","title":"StatsBase.sample","text":"sample(post::Posterior, sampler::S, args...; init_params=nothing, kwargs...)\n\nSample a posterior post using the sampler. You can optionally pass the starting location of the sampler using init_params, otherwise a random draw from the prior will be used.\n\n\n\n\n\n","category":"method"},{"location":"api/#TransformVariables.transform","page":"Comrade API","title":"TransformVariables.transform","text":"transform(posterior::TransformedPosterior, x)\n\nTransforms the value x from the transformed space (e.g. unit hypercube if using ascube) to parameter space which is usually encoded as a NamedTuple.\n\nFor the inverse transform see inverse\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.MultiRadioLikelihood","page":"Comrade API","title":"Comrade.MultiRadioLikelihood","text":"MultiRadioLikelihood(lklhd1, lklhd2, ...)\n\nCombines multiple likelihoods into one object that is useful for fitting multiple days/frequencies.\n\njulia> lklhd1 = RadioLikelihood(dcphase1, dlcamp1)\njulia> lklhd2 = RadioLikelihood(dcphase2, dlcamp2)\njulia> MultiRadioLikelihood(lklhd1, lklhd2)\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.Posterior","page":"Comrade API","title":"Comrade.Posterior","text":"Posterior(lklhd, prior, model)\n\nCreates a Posterior density that follows obeys DensityInferface. The lklhd object is expected to be a MeasureBase.Likelihood object. For instance, these can be created using RadioLikelihood. prior is expected to be a NamedTuple of distributions that reflect the priors on the parameters you are considering. model is a function that takes in a NamedTuple of parameters and returns a Comrade <:AbstractModel.\n\nNotes\n\nSince this function obeys DensityInferface you can evaluate it with\n\njulia> ℓ = logdensityof(post)\njulia> ℓ(x)\n\nor using the 2-argument version directly\n\njulia> logdensityof(post, x)\n\nwhere post::Posterior.\n\nTo generate random draws from the prior see the prior_sample function.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.TransformedPosterior","page":"Comrade API","title":"Comrade.TransformedPosterior","text":"struct TransformedPosterior{P<:Posterior, T}\n\nA transformed version of a Posterior object. This is an internal type that an end user shouldn't have to directly construct. To construct a transformed posterior see the asflat, ascube, and flatten docstrings.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.RadioLikelihood","page":"Comrade API","title":"Comrade.RadioLikelihood","text":"RadioLikelihood(data1, data2, ...)\n\nForms a radio likelihood from a set of data products. These data products must share the same array data/configuration. If you want to form a likelihood from multiple arrays such as when fitting different wavelengths or days, you can combine them using MultiRadioLikelihood\n\nExample\n\njulia> RadioLikelihood(dcphase1, dlcamp1)\n\n\n\n\n\n","category":"type"},{"location":"api/#Misc","page":"Comrade API","title":"Misc","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Comrade.μas2rad\nComrade.rad2μas\nComrade.fileio_load\nComrade.fileio_save\nComrade.make_pullback","category":"page"},{"location":"api/#Comrade.μas2rad","page":"Comrade API","title":"Comrade.μas2rad","text":"μas2rad(x)\n\nConverts a number from micro-arcseconds (μas) to rad\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.rad2μas","page":"Comrade API","title":"Comrade.rad2μas","text":"rad2μas(x)\n\nConverts a number from radians to micro-arcseconds (μas)\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.fileio_load","page":"Comrade API","title":"Comrade.fileio_load","text":"load(fitsfile::String, IntensityMap)\n\nThis loads in a fits file that is more robust to the various imaging algorithms in the EHT, i.e. is works with clean, smili, eht-imaging. The function returns an tuple with an intensitymap and a second named tuple with ancillary information about the image, like the source name, location, mjd, and radio frequency.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.fileio_save","page":"Comrade API","title":"Comrade.fileio_save","text":"save(file::String, img::IntensityMap, obs)\n\nSaves an image to a fits file. You can optionally pass an EHTObservation so that ancillary information will be added.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.make_pullback","page":"Comrade API","title":"Comrade.make_pullback","text":"make_pullback(ℓ, autodiff::AD.AbstractBackend)\n\nCreate the pullback function using the autodiff backend autodiff.\n\nNote\n\nThis is an internal function and not part of the public API.\n\n\n\n\n\nmake_pullback(ℓ, grad::Function)\n\nCreate the pullback function using the function grad which should return the gradient of ℓ.\n\nNote\n\nThis is an internal function and shouldn't be typically used by an end-user.\n\n\n\n\n\n","category":"function"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"EditURL = \"https://github.com/ptiede/Comrade.jl/blob/main/docs/src/examples/data.jl\"","category":"page"},{"location":"examples/data/#Loading-Data-into-Comrade","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"","category":"section"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"The VLBI field does not have a standarized data format, and the EHT uses a particular uvfits format that is similar to the optical interferometry oifits format. As a result, we reuse the excellent eht-imaging package to load data into Comrade.","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"Once the data is loaded we then convert the data into the tabular format Comrade expects. Note that in the future this may change to a Julia package as the Julia radio astronomy group grows.","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"To get started we will load Comrade and Plots to enable visualizations of the data","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"using Comrade\nusing Plots","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"Now we load ehtim. This assumes you have a working installation of eht-imaging. To install eht-imaging see the ehtim github repo.","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"load_ehtim()","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"Now we load the data. We will use the 2017 public M87 data which can be downloaded from cyverse","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"obs = ehtim.obsdata.load_uvfits(joinpath(@__DIR__, \"../assets/SR1_M87_2017_096_lo_hops_netcal_StokesI.uvfits\"))","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"Add scan and coherently average over them. The eht data has been phase calibrated so that this is fine to do.","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"obs.add_scans()\nobs = obs.avg_coherent(0.0, scan_avg=true)","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"We can now extract data products that Comrade can use","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"vis = extract_vis(obs) #complex visibilites\namp = extract_amp(obs) # visibility amplitudes\ncphase = extract_cphase(obs) # extract minimal set of closure phases\nlcamp = extract_lcamp(obs) # extract minimal set of log-closure amplitudes","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"We can also recover the array used in the observation using","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"ac = arrayconfig(vis)\nplot(ac) # Plot the baseline coverage","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"To plot the data we just call","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"l = @layout [a b; c d]\npv = plot(vis)\npa = plot(amp)\npcp = plot(cphase)\nplc = plot(lcamp)\n\nplot(pv, pa, pcp, plc; layout=l)","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"EditURL = \"https://github.com/ptiede/Comrade.jl/blob/main/docs/src/examples/nonanalytic.jl\"","category":"page"},{"location":"examples/nonanalytic/#Modeling-with-non-analytic-Fourier-transforms","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"","category":"section"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"using Comrade\nusing Plots","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"While most of the models implemented in Comrade have an analytic Fourier transform this is not required. In this notebook we will describe how a user can do Bayesian model fitting with a non-analytic model.","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"The ExtendedRing model is an example of a non-analytic model. The image structure is given by","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"I(r) = fracbeta^alpha2pi Gamma(alpha) r^-alpha-2e^-betar","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"This can be created as follows","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"m = ExtendedRing(8.0)","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"The argument is \\alpha in the above equation. beta is given by (1+alpha).","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"This is an example of a ring model that has a substantially different flux profile.","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"plot(m, xlims=(-5.0, 5.0), ylims=(-5.0, 5.0), uvscale=identity)","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"This function does not have a simple analytic Fourier transform, e.g.","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"Comrade.visanalytic(ExtendedRing)","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"Therefore, to find the Fourier transform of the image we need to revert to numerical methods. For this notebook we will use the fast Fourier transform or FFT. Specifically we will use FFTW. To compute a numerical Fourier transform we first need to specify the image.","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"image = IntensityMap(zeros(256, 256), 10.0, 10.0)","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"This will serve as our cache to store the image going forward. The next step is to create a model wrapper that holds the model and the image. Comrade provides the modelimage function to do exactly that","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"mimage = modelimage(m, image, Comrade.FFTAlg())","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"the alg keyword argument then specifies that we want to use an FFT to compute the Fourier transform. When modelimage is called, the FFT is performed and then we use a bicubic interpolator on the resulting visibilities to construct a continuous representation of the Fourier transform. Once we have this everything else is the same. Namely we can calculatge the VLBI data products in the usual manner i.e.","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"u = randn(1000)/2\nv = randn(1000)/2\n\nvis = visibilities(mimage, u, v)\namp = amplitudes(mimage, u, v)","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"We can also compute derivatives of these models. However, currently only ForwardDiff is able to propogate derivatives through modelimage. This is due to the interpolation step. In the future this limitation will be removed.","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"This page was generated using Literate.jl.","category":"page"},{"location":"vlbi_imaging_problem/#Introduction-to-the-VLBI-Imaging-Problem","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"","category":"section"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"Very-long baseline interferometry (VLBI) is capable of taking the highest resolution images in the world, achieving angular resolutions of ~20 μas. In 2019, the first ever image of a black hole was produced by the Event Horizon Telescope (EHT). However, while the EHT has unprecedented resolution it is also a very sparse interferometer. As a result, the sampling in the uv or Fourier space of the image is incomplete. This makes the imaging problem uncertain. Namely, infinitely many images are possible given the data. Comrade is a imaging/modeling package that aims to quantify this uncertainty using Bayesian inference.","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"If we denote visibilities by V and the image structure/model by I, Comrade will then compute the posterior or the probability of an image given the visibility data, or in an equation","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"p(IV) = fracp(VI)p(I)p(V)","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"Here p(VI) is known as the likelihood and describes the probability distribution of the data given some image I. The prior p(I) encodes prior knowledge of the image structure. This prior includes distributions of model parameters and even the model itself. Finally, the denominator p(V) is a normalization term and is known as the marginal likelihood or evidence and can be used to assess how well particular models fit the data.","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"The goal of Comrade is to calculate (or approximate) the posterior of a image model. To see how to do that please see the Making an Image of a Black Hole tutorial.","category":"page"},{"location":"vlbi_imaging_problem/#The-Likelihood","page":"Introduction to the VLBI Imaging Problem","title":"The Likelihood","text":"","category":"section"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"Comrade uses the traditional VLBI expression for the data likelihood. Following standard VLBI data analysis[TMS] each complex visibility V_ij follows a complex normal distribution","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"p(V_ij  I) = (2pi sigma^2_ij)^-12expleft(-frac V_ij - hatV_ij^22sigma^2_ijright)","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"where hatV denotes the model visibility that we are comparing to the data. This likelihood forms the basis for all data analysis. The modeled hatV depend specifically on the model chosen. As a result Comrade has implemented a large number of models to describe observations. For a list of potential models please see Comrade API.","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"For other related data products, e.g. visibility amplitudes, closure products, we use the high-signal-to-noise Gaussian approximations of the distributions. For the specific expressions please see EHTC 2022 Paper IV[SgrP4].","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"[TMS]: Thompson, A., Moran, J., Swenson, G. (2017). Interferometry and Synthesis in Radio Astronomy (Third). Springer Cham","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"[SgrP4]: Event Horizon Telescope Collaboration, (2022). First Sagittarius A* Event Horizon Telscope Results. IV. Variability, Morphology, and Black Hole Mass. ApJL 930 L15 doi","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Comrade","category":"page"},{"location":"#Comrade","page":"Home","title":"Comrade","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Comrade is a Bayesian differentiable modular modeling framework for use with very long baseline interferometry. The goal is to allow the user to easily combine and modify a set of primitive models to construct complicated source structures. The benefit of this approach is that is straightforward to construct different source models out of these primitives. Namely, a end-user does not have to create a separate source \"model\" every time they change the model specification. Additionally, most models currently implemented are differentiable with at least ForwardDiff. This allows for gradient accelerated optimization, and sampling (e.g. HMC) to be used with little effort by the end user.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Currently there are two main ways to construct and sample from the posterior. The first is the simple but somewhat more limited native interface. To see how this works see the Making an Image of a Black Hole tutorial. The other method is ComradeSoss.jl which combines Comrade with Soss a probabilistic programming language. This allows for easier composition of models, and provides a more complete Bayesian workflow, including the ability to sample from the posterior predictive distributions. Other interfaces to e.g. Turing, BAT are planned.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This repository has recently moved to ColPrac. If you would like to contribute please feel free to open a issue or pull-request.","category":"page"},{"location":"#Requirements","page":"Home","title":"Requirements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The minimum Julia version we require is 1.6, which is the current LTS release. In the future we may increase this as Julia advances.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"index.md\",\n    \"vlbi_imaging_problem.md\",\n    \"Tutorials\",\n    \"Libraries\",\n    \"interface.md\",\n    \"base_api.md\",\n    \"api.md\"\n]","category":"page"}]
}
