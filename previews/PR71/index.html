<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · ROSEx.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://ptiede.github.io/ROSEx.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>ROSEx.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Requirements"><span>Requirements</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ptiede/ROSEx.jl/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ROSEx"><a class="docs-heading-anchor" href="#ROSEx">ROSEx</a><a id="ROSEx-1"></a><a class="docs-heading-anchor-permalink" href="#ROSEx" title="Permalink"></a></h1><p>ROSEx is a <strong>differentiable</strong> modular modeling framework for use with very long baseline interferometry. The goal is to allow the user to easily combine and modify a set of <em>primitive</em> models to construct complicated source structures. These primitives themselves do not have to  be simple. ROSE itself does not Bayesian inference or optimization itself. Instead it creates all the components needed, i.e. a image/visibility model, some simple likelihoods, and telescope corruption effects (still to be implemented).</p><p>To use perform inferences on data you can then hook into the vast array of different  modeling and optimization packages in Julia. There are some small examples packages defining these interface such as <a href="https://github.com/ptiede/ROSESoss.jl">ROSESoss.jl</a>  which combines ROSE with <code>Soss</code> a probabilistic programming language. Other interfaces to e.g. <a href="https://turing.ml/stable/">Turing</a>, <a href="https://github.com/bat/BAT.jl">BAT</a> are  planned.</p><h2 id="Requirements"><a class="docs-heading-anchor" href="#Requirements">Requirements</a><a id="Requirements-1"></a><a class="docs-heading-anchor-permalink" href="#Requirements" title="Permalink"></a></h2><p>The minimum Julia version we require is 1.6, which is the current LTS release. In the  future we may increase this as Julia advances.</p><ul><li><a href="#ROSEx">ROSEx</a></li><li class="no-marker"><ul><li><a href="#Requirements">Requirements</a></li></ul></li><li><a href="getting_started/#Getting-Started">Getting Started</a></li></ul><article class="docstring"><header><a class="docstring-binding" id="ROSEx.ROSEx" href="#ROSEx.ROSEx"><code>ROSEx.ROSEx</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">ROSEx</code></pre><p>Radio Observation Sampling Exploration</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/ROSEx.jl#LL1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.AbstractCache" href="#ROSEx.AbstractCache"><code>ROSEx.AbstractCache</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractCache</code></pre><p>This defines an abstract cache that can be used to hold or precompute some computations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/fft_alg.jl#LL10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.AbstractModifier" href="#ROSEx.AbstractModifier"><code>ROSEx.AbstractModifier</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractModifier{M&lt;:ROSEx.AbstractModel} &lt;: ROSEx.AbstractModel</code></pre><p>Abstract type for image modifiers. These are some model wrappers that can transform any model using simple Fourier transform properties. To see the implemented modifier</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/modifiers.jl#LL4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.AddModel" href="#ROSEx.AddModel"><code>ROSEx.AddModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct AddModel{T1, T2} &lt;: ROSEx.CompositeModel{T1, T2}</code></pre><p>Adds two models together to create composite models. Note that I may change this in the future so make it easier on the compiler, i.e. make the composite model a fancy model vector and heap allocate stuff. This should help when combining multiple models together.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/combinators.jl#LL33-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.ArrayConfiguration" href="#ROSEx.ArrayConfiguration"><code>ROSEx.ArrayConfiguration</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type ArrayConfiguration</code></pre><p>This defined the abstract type for an array configuration. Namely, baseline times, SEFD&#39;s, bandwidth, observation frequencies, etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/observations/observations.jl#LL19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.BSplinePulse" href="#ROSEx.BSplinePulse"><code>ROSEx.BSplinePulse</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">$(TYPEDEF)</code></pre><p>Uses the basis spline (BSpline) kernel of order <code>N</code>. These are the kernel that come from recursively convolving the tophat kernel</p><p class="math-container">\[    B_0(x) = \begin{cases} 1 &amp; |x| &lt; 1 \\ 0 &amp; otherwise \end{cases}\]</p><p><code>N</code> times.</p><p><strong>Notes</strong></p><p>BSpline kernels have a number of nice properties:</p><ol><li>Simple frequency response <span>$\sinc(u/2)^N$</span></li><li>preserve total intensity</li></ol><p>For <code>N</code>&gt;1 these kernels aren&#39;t actually interpolation kernels however, this doesn&#39;t matter for us.</p><p>Currently only the 0,1,3 order kernels are implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/images/pulse.jl#LL29-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.CompositeModel" href="#ROSEx.CompositeModel"><code>ROSEx.CompositeModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type CompositeModel{M1, M2} &lt;: ROSEx.AbstractModel</code></pre><p>Abstract type that denotes a composite model. Where we have combined two models together.</p><p><strong>Implementation</strong></p><p>Any implementation of a composite type must define the following methods:</p><ul><li>visibility_point</li><li>uv_combinator</li><li>imanalytic</li><li>visanalytic</li><li>intensity_point if model intensity is <code>IsAnalytic</code></li><li>intensitymap! if model intensity is <code>NotAnalytic</code></li><li>flux</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/combinators.jl#LL3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.ConcordanceCrescent" href="#ROSEx.ConcordanceCrescent"><code>ROSEx.ConcordanceCrescent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ConcordanceCrescent{T} &lt;: ROSEx.GeometricModel</code></pre><p>Creates the ConcordanceCrescent model, i.e. a flat-top crescent with a displacment and a slash. Note this creates a crescent with unit flux. If you want a different flux please use the <code>renomed</code> modifier.</p><p><strong>Fields</strong></p><p><strong>Notes</strong></p><p>Unlike the Gaussian and Disk models this does not create the unit version. In fact, this model could have been created using the <code>Disk</code> and primitives by using ROSEx.jl&#39;s model composition functionality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/geometric_models.jl#LL111-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.ConvolvedModel" href="#ROSEx.ConvolvedModel"><code>ROSEx.ConvolvedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ConvolvedModel{M1, M2} &lt;: ROSEx.CompositeModel{M1, M2}</code></pre><p>Smooths a <code>model</code> with a Gaussian kernel with standard deviation of <code>σ</code>.</p><p><strong>Notes</strong></p><pre><code class="language-julia hljs">m = smoothed(Disk(), 5.0)
intensity(m, 2.0, 2.0; fov=10.0, npix=128)</code></pre><p>will compute the intensity of the smoothed disk with using an interpolation with <code>128</code> pixel nodes and a total <code>fov</code> of 10 in x and y direction.</p><p><strong>This needs to be improved</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/combinators.jl#LL90-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.DeltaPulse" href="#ROSEx.DeltaPulse"><code>ROSEx.DeltaPulse</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DeltaPulse{T} &lt;: ROSEx.Pulse</code></pre><p>A dirac comb pulse function. This means the image is just the dicrete Fourier transform</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/images/pulse.jl#LL3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.DensityAnalytic" href="#ROSEx.DensityAnalytic"><code>ROSEx.DensityAnalytic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DensityAnalytic</code></pre><p>Internal type for specifying the nature of the model functions. Whether they can be easily evaluated pointwise analytic. This is an internal type that may change.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/interface.jl#LL34-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.EHTClosurePhaseDatum" href="#ROSEx.EHTClosurePhaseDatum"><code>ROSEx.EHTClosurePhaseDatum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct EHTClosurePhaseDatum{T&lt;:Number} &lt;: ROSEx.ClosureProducts{T&lt;:Number}</code></pre><p>A Datum for a single closure phase. Note in the future this may get replaced with the fully covariant formalism from Blackburn et al. (2020).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/observations/observations.jl#LL147-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.ExtendedRing" href="#ROSEx.ExtendedRing"><code>ROSEx.ExtendedRing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ExtendedRing{F} &lt;: ROSEx.GeometricModel</code></pre><p>A symmetric extended ring whose radial profile follows an inverse gamma distributions.</p><p><strong>Note</strong></p><p>@e mainly use this as an example of a non-analytic Fourier transform (although it has a complicated expression)</p><p><strong>Fields</strong></p><ul><li><p><code>radius</code></p><p>radius of peak emission</p></li><li><p><code>shape</code></p><p>shape of the radial distribution</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/geometric_models.jl#LL185-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.FFT" href="#ROSEx.FFT"><code>ROSEx.FFT</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FFT &lt;: ROSEx.FourierTransform</code></pre><p>Fourier transform type that specifies we will use the FFTW package to compute the Fourier transform.</p><p><strong>Fields</strong></p><ul><li><p><code>padfac</code></p><p>The amount to pad the image by. Note we actually round up to the nearest factor of 2, but this will be improved in the future to use small primes</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/fft_alg.jl#LL25-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.FFTCache" href="#ROSEx.FFTCache"><code>ROSEx.FFTCache</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FFTCache{P, I} &lt;: ROSEx.AbstractCache</code></pre><p>The cache used when the <code>FFT</code> algorithm is used to compute visibilties. This is an internal type and is not part of the public API</p><p><strong>Fields</strong></p><ul><li><p><code>plan</code></p><p>FFTW Plan</p></li><li><p><code>sitp</code></p><p>FFT interpolator function</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/fft_alg.jl#LL51-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.FourierTransform" href="#ROSEx.FourierTransform"><code>ROSEx.FourierTransform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type FourierTransform</code></pre><p>Abstract type that specified which fourier transform to use</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/fft_alg.jl#LL1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.Gaussian" href="#ROSEx.Gaussian"><code>ROSEx.Gaussian</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Gaussian{T} &lt;: ROSEx.GeometricModel</code></pre><p>Gaussian geometrical model. This is a Gaussian with unit flux and standard deviation.</p><p><strong>Notes</strong></p><p>To change the Gaussian flux, and shape please use the modifier functions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/geometric_models.jl#LL18-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.GeometricModel" href="#ROSEx.GeometricModel"><code>ROSEx.GeometricModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type GeometricModel &lt;: ROSEx.AbstractModel</code></pre><p>A type that defines it is a geometric model. These are usually primitive models, and are usually analytic in Fourier and the image domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/geometric_models.jl#LL3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.IsAnalytic" href="#ROSEx.IsAnalytic"><code>ROSEx.IsAnalytic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct IsAnalytic &lt;: ROSEx.DensityAnalytic</code></pre><p>Defines a trait that a states that a model is analytic. This is usually used with an abstract model where we use it to specify whether a model has a analytic fourier transform and/or image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/interface.jl#LL42-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.MRing" href="#ROSEx.MRing"><code>ROSEx.MRing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct MRing{T, N} &lt;: ROSEx.GeometricModel</code></pre><p>m-ring geometric model. This corresponds to a delta ring with a fourier expansion in θ. The m in m-ring refers to the order of the Fourier expansion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/geometric_models.jl#LL58-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.NoCache" href="#ROSEx.NoCache"><code>ROSEx.NoCache</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NoCache &lt;: ROSEx.AbstractCache</code></pre><p>No cache is used. This is typically used when the model is analytic in the Fourier domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/fft_alg.jl#LL17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.NotAnalytic" href="#ROSEx.NotAnalytic"><code>ROSEx.NotAnalytic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NotAnalytic &lt;: ROSEx.DensityAnalytic</code></pre><p>Defines a trait that a states that a model is analytic. This is usually used with an abstract model where we use it to specify whether a model has does not have a easy analytic fourier transform and/or intensity function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/interface.jl#LL51-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.PolarizedModel" href="#ROSEx.PolarizedModel"><code>ROSEx.PolarizedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct PolarizedModel{I, Q, U, V} &lt;: ROSEx.AbstractPolarizedModel</code></pre><p>Wrapped model for a polarized model. This uses the stokes representation of the image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/polarized.jl#LL5-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.PrimitiveTrait" href="#ROSEx.PrimitiveTrait"><code>ROSEx.PrimitiveTrait</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type PrimitiveTrait</code></pre><p>This trait specifies whether the model is a <em>primitive</em></p><p><strong>Notes</strong></p><p>This will likely turn into a trait in the future so people can inject their models into ROSEx more easily.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/interface.jl#LL3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.Pulse" href="#ROSEx.Pulse"><code>ROSEx.Pulse</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Pulse Pixel response function for a radio image model. This makes a discrete sampling continuous by picking a certain <em>smoothing</em> kernel for the image.</p><p><strong>Notes</strong></p><p>To see the implemented Pulses please use the subtypes function i.e. <code>subtypes(Pulse)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/images/images.jl#LL6-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.RImage" href="#ROSEx.RImage"><code>ROSEx.RImage</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">$(TYPEDEF)</code></pre><p>An image model given by a set of coefficients and a kernel response or basis function. This corresponds to a continous image defined by a finite set of points. The defined intensity is given by</p><p class="math-container">\[    I(x,y) = \sum_{ij} c_{ij}κ(x-x_i)κ(y-y_i).\]</p><p>An important thing to note is that the <span>$c_{ij}$</span> do not represent pixel intensities, i.e. the κ doesn&#39;t have to be an interpolating kernel.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">samples = rand(10,10)
model = RImage(samples, BSplineKernel{3})</code></pre><p><strong>Notes</strong></p><p>This is defined in terms of pixel response, so the image size is 1μas. To resize the image use the scale function like with other models.</p><p><strong>Fields</strong></p>FIELDS</div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/radio_image_models.jl#LL7-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.RenormalizedModel" href="#ROSEx.RenormalizedModel"><code>ROSEx.RenormalizedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RenormalizedModel{M&lt;:ROSEx.AbstractModel, T} &lt;: ROSEx.AbstractModifier{M&lt;:ROSEx.AbstractModel}</code></pre><p>Renormalizes the flux of the model to the new value <code>flux</code>. We have also overloaded the Base.:* operator as syntactic sugar although I may get rid of this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/modifiers.jl#LL106-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.RotatedModel" href="#ROSEx.RotatedModel"><code>ROSEx.RotatedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RotatedModel{M&lt;:ROSEx.AbstractModel, T} &lt;: ROSEx.AbstractModifier{M&lt;:ROSEx.AbstractModel}</code></pre><p>Type for the rotated model. This is more fine grained constrol of rotated model. In most use cases the end-user should be using the <code>rotate</code> method e.g.</p><pre><code class="language-julia hljs">rotate(model, ξ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/modifiers.jl#LL172-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.ShiftedModel" href="#ROSEx.ShiftedModel"><code>ROSEx.ShiftedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ShiftedModel{T, M&lt;:ROSEx.AbstractModel} &lt;: ROSEx.AbstractModifier{M&lt;:ROSEx.AbstractModel}</code></pre><p>Shifts the model by <code>Δx</code> units in the x-direction and <code>Δy</code> units in the y-direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/modifiers.jl#LL82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.SqExpPulse" href="#ROSEx.SqExpPulse"><code>ROSEx.SqExpPulse</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SqExpPulse{T} &lt;: ROSEx.Pulse</code></pre><p>Normalized square exponential kernel, i.e. a Gaussian. Note the smoothness is modfied with <code>ϵ</code> which is the inverse variance in units of 1/pixels².</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/images/pulse.jl#LL15-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.StretchedModel" href="#ROSEx.StretchedModel"><code>ROSEx.StretchedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct StretchedModel{M&lt;:ROSEx.AbstractModel, T} &lt;: ROSEx.AbstractModifier{M&lt;:ROSEx.AbstractModel}</code></pre><p>Stretched the model in the x and y directions, i.e. the new intensity is</p><p class="math-container">\[    I_s(x,y) = 1/(αβ) I(x/α, y/β),\]</p><p>where were renormalize the intensity to preserve the models flux.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/modifiers.jl#LL140-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size-Tuple{RImage}" href="#Base.size-Tuple{RImage}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">size(model)
</code></pre><p>return the size of the coefficient matrix for <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/radio_image_models.jl#LL92-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.amplitude-Tuple{Any, Any, Any}" href="#ROSEx.amplitude-Tuple{Any, Any, Any}"><code>ROSEx.amplitude</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">amplitude(model, u, v)
</code></pre><p>Computes the visibility amplitude of model <code>m</code> at u,v positions <code>u,v</code></p><p>If you want to compute the amplitudes at a large number of positions consider using the <code>amplitudes</code> function which uses MappedArrays to compute a lazy, no allocation vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/models.jl#LL23-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.amplitudes-Tuple{Any, AbstractArray, AbstractArray}" href="#ROSEx.amplitudes-Tuple{Any, AbstractArray, AbstractArray}"><code>ROSEx.amplitudes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">amplitudes(m, u, v)
</code></pre><p>Computes the amplitudes of the model <code>m</code> at the u,v positions <code>u</code>, <code>v</code>.</p><p>Note this is done lazily so the visibility is only computed when accessed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/models.jl#LL122-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.basemodel-Tuple{ROSEx.AbstractModifier}" href="#ROSEx.basemodel-Tuple{ROSEx.AbstractModifier}"><code>ROSEx.basemodel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">basemodel(model)
</code></pre><p>Returns the base model from a modified model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/modifiers.jl#LL12-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.bispectra-Tuple{Any, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray}" href="#ROSEx.bispectra-Tuple{Any, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray}"><code>ROSEx.bispectra</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bispectra(m, u1, v1, u2, v2, u3, v3)
</code></pre><p>Computes the bispectra of the model <code>m</code> at the triangles (u1,v1), (u2,v2), (u3,v3).</p><p>Note this is done lazily so the bispectra is only computed when accessed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/models.jl#LL133-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.bispectrum-NTuple{7, Any}" href="#ROSEx.bispectrum-NTuple{7, Any}"><code>ROSEx.bispectrum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bispectrum(model, u1, v1, u2, v2, u3, v3)
</code></pre><p>Computes the complex bispectrum of model <code>m</code> at the uv-triangle u1,v1 -&gt; u2,v2 -&gt; u3,v3</p><p>If you want to compute the bispectrum over a number of triangles consider using the <code>bispectra</code> function which uses MappedArrays to compute a lazy, no allocation vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/models.jl#LL35-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.closure_phase-NTuple{7, Any}" href="#ROSEx.closure_phase-NTuple{7, Any}"><code>ROSEx.closure_phase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">closure_phase(model, u1, v1, u2, v2, u3, v3)
</code></pre><p>Computes the closure phase of model <code>m</code> at the uv-triangle u1,v1 -&gt; u2,v2 -&gt; u3,v3</p><p>If you want to compute closure phases over a number of triangles consider using the <code>closure_phases</code> function which uses MappedArrays to compute a lazy, no allocation vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/models.jl#LL48-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.closure_phase-Tuple{ROSEx.EHTVisibilityDatum, ROSEx.EHTVisibilityDatum, ROSEx.EHTVisibilityDatum}" href="#ROSEx.closure_phase-Tuple{ROSEx.EHTVisibilityDatum, ROSEx.EHTVisibilityDatum, ROSEx.EHTVisibilityDatum}"><code>ROSEx.closure_phase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">closure_phase(D1, D2, D3)
</code></pre><p>Computes the closure phase of the three visibility datums.</p><p><strong>Notes</strong></p><p>We currently use the high SNR Gaussian error approximation for the closure phase. In the future we may use the moment matching from Monte Carlo sampling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/observations/observations.jl#LL166-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.closure_phases-Tuple{Any, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray}" href="#ROSEx.closure_phases-Tuple{Any, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray}"><code>ROSEx.closure_phases</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">closure_phases(m, u1, v1, u2, v2, u3, v3)
</code></pre><p>Computes the closure phases of the model <code>m</code> at the triangles (u1,v1), (u2,v2), (u3,v3).</p><p>Note this is done lazily so the closure_phases is only computed when accessed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/models.jl#LL149-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.coherencymatrix-Tuple{PolarizedModel, Any, Any}" href="#ROSEx.coherencymatrix-Tuple{PolarizedModel, Any, Any}"><code>ROSEx.coherencymatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coherencymatrix(pimg, u, v)
</code></pre><p>Computes the coherency matrix of the polarized model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/polarized.jl#LL40-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.components-Tuple{ROSEx.AbstractModel}" href="#ROSEx.components-Tuple{ROSEx.AbstractModel}"><code>ROSEx.components</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">components(m)
</code></pre><p>Returns the components for a composite model. This will return a Tuple with all the models you have constructed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/combinators.jl#LL51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.create_cache-Tuple{ROSEx.FFT, Any, Any}" href="#ROSEx.create_cache-Tuple{ROSEx.FFT, Any, Any}"><code>ROSEx.create_cache</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_cache(alg, model, img)
</code></pre><p>Creates the model cache given for the algorithm <code>alg</code> using the <code>model</code> and a image cache <code>image</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/fft_alg.jl#LL66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.evpa-Tuple{Any, Any, Any}" href="#ROSEx.evpa-Tuple{Any, Any, Any}"><code>ROSEx.evpa</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evpa(pimg, u, v)
</code></pre><p>electric vector position angle or EVPA of the polarized model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/polarized.jl#LL49-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.extract_cphase-Tuple{Any}" href="#ROSEx.extract_cphase-Tuple{Any}"><code>ROSEx.extract_cphase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extract_cphase(obs)</code></pre><p>Extracts the closure phases from an ehtim observation object</p><p>Returns an EHTObservation with closure phases datums</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/observations/ehtim.jl#LL186-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.extract_lcamp-Tuple{Any}" href="#ROSEx.extract_lcamp-Tuple{Any}"><code>ROSEx.extract_lcamp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extract_lcamp(obs)</code></pre><p>Extracts the log-closure amp. from an ehtim observation object</p><p>Returns an EHTObservation with closure amp. datums</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/observations/ehtim.jl#LL210-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.extract_vis-Tuple{Any}" href="#ROSEx.extract_vis-Tuple{Any}"><code>ROSEx.extract_vis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extract_vis(obs)</code></pre><p>Extracts the complex visibilities from an ehtim observation object</p><p>Returns an EHTObservation with complex visibility data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/observations/ehtim.jl#LL165-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.flux-Union{Tuple{ROSEx.AbstractIntensityMap{T, S}}, Tuple{S}, Tuple{T}} where {T, S}" href="#ROSEx.flux-Union{Tuple{ROSEx.AbstractIntensityMap{T, S}}, Tuple{S}, Tuple{T}} where {T, S}"><code>ROSEx.flux</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Computes the flux of a intensity map</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/images/intensitymap.jl#LL27-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.imanalytic-Tuple{Type{&lt;:ROSEx.AbstractModel}}" href="#ROSEx.imanalytic-Tuple{Type{&lt;:ROSEx.AbstractModel}}"><code>ROSEx.imanalytic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">imanalytic(::Type{&lt;:AbstractModel})</code></pre><p>Determines whether the model is pointwise analytic in the image domain, i.e. we can evaluate its intensity at an arbritrary point.</p><p>If <code>IsAnalytic()</code> then it will try to call <code>intensity_point</code> to calculate the intensity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/interface.jl#LL71-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.intensity_point" href="#ROSEx.intensity_point"><code>ROSEx.intensity_point</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Function that computes the pointwise intensity if the model has the trait in the image domain <code>IsAnalytic()</code>. Otherwise it will use construct the image in visibility space and invert it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/interface.jl#LL110-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.intensitymap" href="#ROSEx.intensitymap"><code>ROSEx.intensitymap</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Computes the intensity map of model. This version requires additional information to construct the grid.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">m = Gaussian()
# field of view
fovx, fovy = 5.0
fovy = 5.0
# number of pixels
nx, ny = 128

img = intensitymap(m, fovx, fovy, nx, ny; pulse=DeltaPulse())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/interface.jl#LL126-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.intensitymap!" href="#ROSEx.intensitymap!"><code>ROSEx.intensitymap!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Computes the intensity map of model by modifying the input IntensityMap object</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/interface.jl#LL119-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.intensitymap!-Tuple{PolarizedMap, PolarizedModel}" href="#ROSEx.intensitymap!-Tuple{PolarizedMap, PolarizedModel}"><code>ROSEx.intensitymap!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intensitymap!(pimg, pmodel)
</code></pre><p>Finds the polarized intensity map of the polarized model pmodel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/polarized.jl#LL29-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.isprimitive" href="#ROSEx.isprimitive"><code>ROSEx.isprimitive</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isprimitive(::Type)</code></pre><p>Dispatch function that specifies whether a type is a primitive ROSEx model. This function is used for dispatch purposes when composing models.</p><p><strong>Notes</strong></p><p>If a user is specifying their own model primitive model outside of ROSEx they need to specify if it is primitive</p><pre><code class="language-julia hljs">struct MyPrimitiveModel end
ROSEx.isprimitive(::Type{MyModel}) = ROSEx.IsPrimitive()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/interface.jl#LL15-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.load_ehtim-Tuple{}" href="#ROSEx.load_ehtim-Tuple{}"><code>ROSEx.load_ehtim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_ehtim()
</code></pre><p>Loads the <a href="https://github.com/achael/eht-imaging">eht-imaging</a> library and stores it in the <code>ehtim</code> variable.</p><p><strong>Notes</strong></p><p>This will fail if ehtim isn&#39;t installed in the python installation that PyCall references.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/ROSEx.jl#LL25-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.load_tpy-Tuple{Any}" href="#ROSEx.load_tpy-Tuple{Any}"><code>ROSEx.load_tpy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_tpy(file)
</code></pre><p>Load a ThemisPy style ascii EHT observation file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/observations/io.jl#LL4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.logclosure_amplitude-NTuple{9, Any}" href="#ROSEx.logclosure_amplitude-NTuple{9, Any}"><code>ROSEx.logclosure_amplitude</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">logclosure_amplitude(model, u1, v1, u2, v2, u3, v3, u4, v4)
</code></pre><p>Computes the log-closure amplitude of model <code>m</code> at the uv-quadrangle u1,v1 -&gt; u2,v2 -&gt; u3,v3 -&gt; u4,v3 using the formula</p><p class="math-container">\[C = \log\left|\frac{V(u1,v1)V(u2,v2)}{V(u3,v3)V(u4,v4)}\right|\]</p><p>If you want to compute log closure amplitudes over a number of triangles consider using the <code>logclosure_amplitudes</code> function which uses MappedArrays to compute a lazy, no allocation vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/models.jl#LL61-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.logclosure_amplitudes-Tuple{Any, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray}" href="#ROSEx.logclosure_amplitudes-Tuple{Any, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray}"><code>ROSEx.logclosure_amplitudes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">logclosure_amplitudes(m, u1, v1, u2, v2, u3, v3, u4, v4)
</code></pre><p>Computes the log closure amplitudes of the model <code>m</code> at the quadrangles (u1,v1), (u2,v2), (u3,v3), (u4, v4).</p><p>Note this is done lazily so the log closure amplitude is only computed when accessed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/models.jl#LL165-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.modelimage-Tuple{M} where M" href="#ROSEx.modelimage-Tuple{M} where M"><code>ROSEx.modelimage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">modelimage(m)</code></pre><p>Construct a <code>ModelImage</code> where just the model <code>m</code> is specified</p><p><strong>Notes</strong></p><p>Currently this is only defined for analytic models. In the future this will <em>guess</em> a reasonable image to use.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/modelimage.jl#LL56-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.modelimage-Union{Tuple{M}, Tuple{M, Any}} where M" href="#ROSEx.modelimage-Union{Tuple{M}, Tuple{M, Any}} where M"><code>ROSEx.modelimage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">modelimage(model, image; alg)
modelimage(m)
</code></pre><p>Construct a <code>ModelImage</code> from a <code>model</code>, <code>image</code> and the optionally specified visibility algorithm <code>alg</code></p><p><strong>Notes</strong></p><p>For analytic models this is a no-op and just return the model. For non-analytic models this wraps the model in a object with an image and precomputes the fourier transform using <code>alg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/modelimage.jl#LL33-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.m̆-Tuple{Any, Any, Any}" href="#ROSEx.m̆-Tuple{Any, Any, Any}"><code>ROSEx.m̆</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">m̆(pimg, u, v)
</code></pre><p>Computes the fractional linear polarization in the visibility domain</p><p class="math-container">\[    \breve{m} = \frac{Q + iU}{I}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/polarized.jl#LL60-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.rad2μas-Tuple{Any}" href="#ROSEx.rad2μas-Tuple{Any}"><code>ROSEx.rad2μas</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rad2μas(x)</code></pre><p>Converts a number from radians to μas</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/ROSEx.jl#LL44-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.renormed-Union{Tuple{M}, Tuple{M, Any}} where M&lt;:ROSEx.AbstractModel" href="#ROSEx.renormed-Union{Tuple{M}, Tuple{M, Any}} where M&lt;:ROSEx.AbstractModel"><code>ROSEx.renormed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">renormed(model, flux)
</code></pre><p>Renormalizes the model <code>m</code> to have total flux <code>flux</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/modifiers.jl#LL118-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.rotated-Tuple{Any, Any}" href="#ROSEx.rotated-Tuple{Any, Any}"><code>ROSEx.rotated</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotated(model, ξ)
</code></pre><p>Rotates the model by an amount <code>ξ</code> in radians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/modifiers.jl#LL192-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.shifted-Tuple{Any, Any, Any}" href="#ROSEx.shifted-Tuple{Any, Any, Any}"><code>ROSEx.shifted</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shifted(model, Δx, Δy)
</code></pre><p>Shifts the model <code>m</code> in the image domain by an amount <code>Δx,Δy</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/modifiers.jl#LL93-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.stretched-Tuple{Any, Any, Any}" href="#ROSEx.stretched-Tuple{Any, Any, Any}"><code>ROSEx.stretched</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stretched(model, α, β)
</code></pre><p>Stretches the model <code>m</code> according to the formula</p><p class="math-container">\[    I_s(x,y) = 1/(αβ) I(x/α, y/β),\]</p><p>where were renormalize the intensity to preserve the models flux.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/modifiers.jl#LL154-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.visanalytic-Tuple{Type{&lt;:ROSEx.AbstractModel}}" href="#ROSEx.visanalytic-Tuple{Type{&lt;:ROSEx.AbstractModel}}"><code>ROSEx.visanalytic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">visanalytic(::Type{&lt;:AbstractModel})</code></pre><p>Determines whether the model is pointwise analytic in Fourier domain, i.e. we can evaluate its fourier transform at an arbritrary point.</p><p>If <code>IsAnalytic()</code> then it will try to call <code>visibility_point</code> to calculate the complex visibilities. Otherwise it fallback to using the FFT that works for all models that can compute an image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/interface.jl#LL60-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.visibilities-Tuple{Any, AbstractArray, AbstractArray}" href="#ROSEx.visibilities-Tuple{Any, AbstractArray, AbstractArray}"><code>ROSEx.visibilities</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">visibilities(m, u, v)
</code></pre><p>Computes the visibilities of the model <code>m</code> at the u,v positions <code>u</code>, <code>v</code>.</p><p>Note this is done lazily so the visibility is only computed when accessed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/models.jl#LL106-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.visibility" href="#ROSEx.visibility"><code>ROSEx.visibility</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Computes the complex visibility of model <code>m</code> at u,v positions <code>u,v</code></p><p>If you want to compute the visibilities at a large number of positions consider using the <code>visibilities</code> function which uses MappedArrays to compute a lazy, no allocation vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/interface.jl#LL93-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.visibility-Tuple{PolarizedModel, Any, Any}" href="#ROSEx.visibility-Tuple{PolarizedModel, Any, Any}"><code>ROSEx.visibility</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">visibility(pimg, u, v)
</code></pre><p>Computes the visibility in the stokes basis of the polarized model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/polarized.jl#LL17-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.visibility-Union{Tuple{M}, Tuple{M, Any, Any}} where M" href="#ROSEx.visibility-Union{Tuple{M}, Tuple{M, Any, Any}} where M"><code>ROSEx.visibility</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">visibility(mimg, u, v)
</code></pre><p>Computes the complex visibility of model <code>m</code> at u,v positions <code>u,v</code></p><p>If you want to compute the visibilities at a large number of positions consider using the <code>visibilities</code> function which uses MappedArrays to compute a lazy, no allocation vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/models/models.jl#LL6-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.visibility_point" href="#ROSEx.visibility_point"><code>ROSEx.visibility_point</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Function that computes the pointwise visibility if the model has the trait in the fourier domain <code>IsAnalytic()</code>. Otherwise it will use the FFTW fallback.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/interface.jl#LL103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ROSEx.μas2rad-Tuple{Any}" href="#ROSEx.μas2rad-Tuple{Any}"><code>ROSEx.μas2rad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">μas2rad(x)</code></pre><p>Converts a number from μas to rad</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ROSEx.jl/blob/50d8774b8246b94f4b25865dcd80c06712bc9fec/src/ROSEx.jl#LL50-L53">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Saturday 8 January 2022 18:42">Saturday 8 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
