var documenterSearchIndex = {"docs":
[{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To get started with ROSE","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using ROSE\n\n#load ehtim\nload_ehtim()\n\n# To load some data we can use\nobs = ehtim.obsdata.load_uvfits(\"FILENAME\")\n\n# Extract various data products from the EHTIM object\ndvis   = extract_vis(obs)\ndcp    = extract_cphase(obs)\ndlcamp = extract_lcamp(obs)\n\n# Just want the array configuration?\nac = arrayconfig(data)\n\n# Want to construct a elliptical Gaussian\nm1 = rotated(stretched(Gaussian(), 20.0, 10.0), π/4)\nm2 = ExtendedRing(20.0)\nmtot = m1+m2\n\n# Lets make an image!\nimg = intensitymap(mtot, 80.0, 80.0, 128, 128)\n\n# Now construct a model image wrapper\n# Since Extended ring doesn't have a simple FT we need to specify an image to hold it.\n# In the future this will be automated.\nmimage = modelimage(mtot, img)\n\n\n#Now evaluate the visibilities\nvis = visibility(mimage, ac)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ROSEx","category":"page"},{"location":"#ROSEx","page":"Home","title":"ROSEx","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ROSEx is a differentiable modular modeling framework for use with very long baseline interferometry. The goal is to allow the user to easily combine and modify a set of primitive models to construct complicated source structures. These primitives themselves do not have to  be simple. ROSE itself does not Bayesian inference or optimization itself. Instead it creates all the components needed, i.e. a image/visibility model, some simple likelihoods, and telescope corruption effects (still to be implemented).","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use perform inferences on data you can then hook into the vast array of different  modeling and optimization packages in Julia. There are some small examples packages defining these interface such as ROSESoss.jl  which combines ROSE with Soss a probabilistic programming language. Other interfaces to e.g. Turing, BAT are  planned.","category":"page"},{"location":"#Requirements","page":"Home","title":"Requirements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The minimum Julia version we require is 1.6, which is the current LTS release. In the  future we may increase this as Julia advances.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"index.md\",\n    \"getting_started.md\",\n    \"model_interface.md\"\n]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [ROSEx]","category":"page"},{"location":"#ROSEx.ROSEx","page":"Home","title":"ROSEx.ROSEx","text":"ROSEx\n\nRadio Observation Sampling Exploration\n\n\n\n\n\n","category":"module"},{"location":"#ROSEx.AbstractCache","page":"Home","title":"ROSEx.AbstractCache","text":"abstract type AbstractCache\n\nThis defines an abstract cache that can be used to hold or precompute some computations.\n\n\n\n\n\n","category":"type"},{"location":"#ROSEx.AbstractModifier","page":"Home","title":"ROSEx.AbstractModifier","text":"abstract type AbstractModifier{M<:ROSEx.AbstractModel} <: ROSEx.AbstractModel\n\nAbstract type for image modifiers. These are some model wrappers that can transform any model using simple Fourier transform properties. To see the implemented modifier\n\n\n\n\n\n","category":"type"},{"location":"#ROSEx.AddModel","page":"Home","title":"ROSEx.AddModel","text":"struct AddModel{T1, T2} <: ROSEx.CompositeModel{T1, T2}\n\nAdds two models together to create composite models. Note that I may change this in the future so make it easier on the compiler, i.e. make the composite model a fancy model vector and heap allocate stuff. This should help when combining multiple models together.\n\n\n\n\n\n","category":"type"},{"location":"#ROSEx.ArrayConfiguration","page":"Home","title":"ROSEx.ArrayConfiguration","text":"abstract type ArrayConfiguration\n\nThis defined the abstract type for an array configuration. Namely, baseline times, SEFD's, bandwidth, observation frequencies, etc.\n\n\n\n\n\n","category":"type"},{"location":"#ROSEx.BSplinePulse","page":"Home","title":"ROSEx.BSplinePulse","text":"$(TYPEDEF)\n\nUses the basis spline (BSpline) kernel of order N. These are the kernel that come from recursively convolving the tophat kernel\n\n    B_0(x) = begincases 1  x  1  0  otherwise endcases\n\nN times.\n\nNotes\n\nBSpline kernels have a number of nice properties:\n\nSimple frequency response sinc(u2)^N\npreserve total intensity\n\nFor N>1 these kernels aren't actually interpolation kernels however, this doesn't matter for us.\n\nCurrently only the 0,1,3 order kernels are implemented.\n\n\n\n\n\n","category":"type"},{"location":"#ROSEx.CompositeModel","page":"Home","title":"ROSEx.CompositeModel","text":"abstract type CompositeModel{M1, M2} <: ROSEx.AbstractModel\n\nAbstract type that denotes a composite model. Where we have combined two models together.\n\nImplementation\n\nAny implementation of a composite type must define the following methods:\n\nvisibility_point\nuv_combinator\nimanalytic\nvisanalytic\nintensity_point if model intensity is IsAnalytic\nintensitymap! if model intensity is NotAnalytic\nflux\n\n\n\n\n\n","category":"type"},{"location":"#ROSEx.ConcordanceCrescent","page":"Home","title":"ROSEx.ConcordanceCrescent","text":"struct ConcordanceCrescent{T} <: ROSEx.GeometricModel\n\nCreates the ConcordanceCrescent model, i.e. a flat-top crescent with a displacment and a slash. Note this creates a crescent with unit flux. If you want a different flux please use the renomed modifier.\n\nFields\n\nNotes\n\nUnlike the Gaussian and Disk models this does not create the unit version. In fact, this model could have been created using the Disk and primitives by using ROSEx.jl's model composition functionality.\n\n\n\n\n\n","category":"type"},{"location":"#ROSEx.ConvolvedModel","page":"Home","title":"ROSEx.ConvolvedModel","text":"struct ConvolvedModel{M1, M2} <: ROSEx.CompositeModel{M1, M2}\n\nSmooths a model with a Gaussian kernel with standard deviation of σ.\n\nNotes\n\nm = smoothed(Disk(), 5.0)\nintensity(m, 2.0, 2.0; fov=10.0, npix=128)\n\nwill compute the intensity of the smoothed disk with using an interpolation with 128 pixel nodes and a total fov of 10 in x and y direction.\n\nThis needs to be improved\n\n\n\n\n\n","category":"type"},{"location":"#ROSEx.DeltaPulse","page":"Home","title":"ROSEx.DeltaPulse","text":"struct DeltaPulse{T} <: ROSEx.Pulse\n\nA dirac comb pulse function. This means the image is just the dicrete Fourier transform\n\n\n\n\n\n","category":"type"},{"location":"#ROSEx.DensityAnalytic","page":"Home","title":"ROSEx.DensityAnalytic","text":"DensityAnalytic\n\nInternal type for specifying the nature of the model functions. Whether they can be easily evaluated pointwise analytic. This is an internal type that may change.\n\n\n\n\n\n","category":"type"},{"location":"#ROSEx.EHTClosurePhaseDatum","page":"Home","title":"ROSEx.EHTClosurePhaseDatum","text":"struct EHTClosurePhaseDatum{T<:Number} <: ROSEx.ClosureProducts{T<:Number}\n\nA Datum for a single closure phase. Note in the future this may get replaced with the fully covariant formalism from Blackburn et al. (2020).\n\n\n\n\n\n","category":"type"},{"location":"#ROSEx.ExtendedRing","page":"Home","title":"ROSEx.ExtendedRing","text":"struct ExtendedRing{F} <: ROSEx.GeometricModel\n\nA symmetric extended ring whose radial profile follows an inverse gamma distributions.\n\nNote\n\n@e mainly use this as an example of a non-analytic Fourier transform (although it has a complicated expression)\n\nFields\n\nradius\nradius of peak emission\nshape\nshape of the radial distribution\n\n\n\n\n\n","category":"type"},{"location":"#ROSEx.FFT","page":"Home","title":"ROSEx.FFT","text":"struct FFT <: ROSEx.FourierTransform\n\nFourier transform type that specifies we will use the FFTW package to compute the Fourier transform.\n\nFields\n\npadfac\nThe amount to pad the image by. Note we actually round up to the nearest factor of 2, but this will be improved in the future to use small primes\n\n\n\n\n\n","category":"type"},{"location":"#ROSEx.FFTCache","page":"Home","title":"ROSEx.FFTCache","text":"struct FFTCache{P, I} <: ROSEx.AbstractCache\n\nThe cache used when the FFT algorithm is used to compute visibilties. This is an internal type and is not part of the public API\n\nFields\n\nplan\nFFTW Plan\nsitp\nFFT interpolator function\n\n\n\n\n\n","category":"type"},{"location":"#ROSEx.FourierTransform","page":"Home","title":"ROSEx.FourierTransform","text":"abstract type FourierTransform\n\nAbstract type that specified which fourier transform to use\n\n\n\n\n\n","category":"type"},{"location":"#ROSEx.Gaussian","page":"Home","title":"ROSEx.Gaussian","text":"struct Gaussian{T} <: ROSEx.GeometricModel\n\nGaussian geometrical model. This is a Gaussian with unit flux and standard deviation.\n\nNotes\n\nTo change the Gaussian flux, and shape please use the modifier functions\n\n\n\n\n\n","category":"type"},{"location":"#ROSEx.GeometricModel","page":"Home","title":"ROSEx.GeometricModel","text":"abstract type GeometricModel <: ROSEx.AbstractModel\n\nA type that defines it is a geometric model. These are usually primitive models, and are usually analytic in Fourier and the image domain.\n\n\n\n\n\n","category":"type"},{"location":"#ROSEx.IsAnalytic","page":"Home","title":"ROSEx.IsAnalytic","text":"struct IsAnalytic <: ROSEx.DensityAnalytic\n\nDefines a trait that a states that a model is analytic. This is usually used with an abstract model where we use it to specify whether a model has a analytic fourier transform and/or image.\n\n\n\n\n\n","category":"type"},{"location":"#ROSEx.MRing","page":"Home","title":"ROSEx.MRing","text":"struct MRing{T, N} <: ROSEx.GeometricModel\n\nm-ring geometric model. This corresponds to a delta ring with a fourier expansion in θ. The m in m-ring refers to the order of the Fourier expansion.\n\n\n\n\n\n","category":"type"},{"location":"#ROSEx.NoCache","page":"Home","title":"ROSEx.NoCache","text":"struct NoCache <: ROSEx.AbstractCache\n\nNo cache is used. This is typically used when the model is analytic in the Fourier domain.\n\n\n\n\n\n","category":"type"},{"location":"#ROSEx.NotAnalytic","page":"Home","title":"ROSEx.NotAnalytic","text":"struct NotAnalytic <: ROSEx.DensityAnalytic\n\nDefines a trait that a states that a model is analytic. This is usually used with an abstract model where we use it to specify whether a model has does not have a easy analytic fourier transform and/or intensity function.\n\n\n\n\n\n","category":"type"},{"location":"#ROSEx.PolarizedModel","page":"Home","title":"ROSEx.PolarizedModel","text":"struct PolarizedModel{I, Q, U, V} <: ROSEx.AbstractPolarizedModel\n\nWrapped model for a polarized model. This uses the stokes representation of the image.\n\n\n\n\n\n","category":"type"},{"location":"#ROSEx.PrimitiveTrait","page":"Home","title":"ROSEx.PrimitiveTrait","text":"abstract type PrimitiveTrait\n\nThis trait specifies whether the model is a primitive\n\nNotes\n\nThis will likely turn into a trait in the future so people can inject their models into ROSEx more easily.\n\n\n\n\n\n","category":"type"},{"location":"#ROSEx.Pulse","page":"Home","title":"ROSEx.Pulse","text":"Pulse Pixel response function for a radio image model. This makes a discrete sampling continuous by picking a certain smoothing kernel for the image.\n\nNotes\n\nTo see the implemented Pulses please use the subtypes function i.e. subtypes(Pulse)\n\n\n\n\n\n","category":"type"},{"location":"#ROSEx.RImage","page":"Home","title":"ROSEx.RImage","text":"$(TYPEDEF)\n\nAn image model given by a set of coefficients and a kernel response or basis function. This corresponds to a continous image defined by a finite set of points. The defined intensity is given by\n\n    I(xy) = sum_ij c_ijκ(x-x_i)κ(y-y_i)\n\nAn important thing to note is that the c_ij do not represent pixel intensities, i.e. the κ doesn't have to be an interpolating kernel.\n\nExample\n\nsamples = rand(10,10)\nmodel = RImage(samples, BSplineKernel{3})\n\nNotes\n\nThis is defined in terms of pixel response, so the image size is 1μas. To resize the image use the scale function like with other models.\n\nFields\n\nFIELDS\n\n\n\n\n\n","category":"type"},{"location":"#ROSEx.RenormalizedModel","page":"Home","title":"ROSEx.RenormalizedModel","text":"struct RenormalizedModel{M<:ROSEx.AbstractModel, T} <: ROSEx.AbstractModifier{M<:ROSEx.AbstractModel}\n\nRenormalizes the flux of the model to the new value flux. We have also overloaded the Base.:* operator as syntactic sugar although I may get rid of this.\n\n\n\n\n\n","category":"type"},{"location":"#ROSEx.RotatedModel","page":"Home","title":"ROSEx.RotatedModel","text":"struct RotatedModel{M<:ROSEx.AbstractModel, T} <: ROSEx.AbstractModifier{M<:ROSEx.AbstractModel}\n\nType for the rotated model. This is more fine grained constrol of rotated model. In most use cases the end-user should be using the rotate method e.g.\n\nrotate(model, ξ)\n\n\n\n\n\n","category":"type"},{"location":"#ROSEx.ShiftedModel","page":"Home","title":"ROSEx.ShiftedModel","text":"struct ShiftedModel{T, M<:ROSEx.AbstractModel} <: ROSEx.AbstractModifier{M<:ROSEx.AbstractModel}\n\nShifts the model by Δx units in the x-direction and Δy units in the y-direction.\n\n\n\n\n\n","category":"type"},{"location":"#ROSEx.SqExpPulse","page":"Home","title":"ROSEx.SqExpPulse","text":"struct SqExpPulse{T} <: ROSEx.Pulse\n\nNormalized square exponential kernel, i.e. a Gaussian. Note the smoothness is modfied with ϵ which is the inverse variance in units of 1/pixels².\n\n\n\n\n\n","category":"type"},{"location":"#ROSEx.StretchedModel","page":"Home","title":"ROSEx.StretchedModel","text":"struct StretchedModel{M<:ROSEx.AbstractModel, T} <: ROSEx.AbstractModifier{M<:ROSEx.AbstractModel}\n\nStretched the model in the x and y directions, i.e. the new intensity is\n\n    I_s(xy) = 1(αβ) I(xα yβ)\n\nwhere were renormalize the intensity to preserve the models flux.\n\n\n\n\n\n","category":"type"},{"location":"#Base.size-Tuple{RImage}","page":"Home","title":"Base.size","text":"size(model)\n\n\nreturn the size of the coefficient matrix for model.\n\n\n\n\n\n","category":"method"},{"location":"#ROSEx.amplitude-Tuple{Any, Any, Any}","page":"Home","title":"ROSEx.amplitude","text":"amplitude(model, u, v)\n\n\nComputes the visibility amplitude of model m at u,v positions u,v\n\nIf you want to compute the amplitudes at a large number of positions consider using the amplitudes function which uses MappedArrays to compute a lazy, no allocation vector.\n\n\n\n\n\n","category":"method"},{"location":"#ROSEx.amplitudes-Tuple{Any, AbstractArray, AbstractArray}","page":"Home","title":"ROSEx.amplitudes","text":"amplitudes(m, u, v)\n\n\nComputes the amplitudes of the model m at the u,v positions u, v.\n\nNote this is done lazily so the visibility is only computed when accessed.\n\n\n\n\n\n","category":"method"},{"location":"#ROSEx.basemodel-Tuple{ROSEx.AbstractModifier}","page":"Home","title":"ROSEx.basemodel","text":"basemodel(model)\n\n\nReturns the base model from a modified model.\n\n\n\n\n\n","category":"method"},{"location":"#ROSEx.bispectra-Tuple{Any, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray}","page":"Home","title":"ROSEx.bispectra","text":"bispectra(m, u1, v1, u2, v2, u3, v3)\n\n\nComputes the bispectra of the model m at the triangles (u1,v1), (u2,v2), (u3,v3).\n\nNote this is done lazily so the bispectra is only computed when accessed.\n\n\n\n\n\n","category":"method"},{"location":"#ROSEx.bispectrum-NTuple{7, Any}","page":"Home","title":"ROSEx.bispectrum","text":"bispectrum(model, u1, v1, u2, v2, u3, v3)\n\n\nComputes the complex bispectrum of model m at the uv-triangle u1,v1 -> u2,v2 -> u3,v3\n\nIf you want to compute the bispectrum over a number of triangles consider using the bispectra function which uses MappedArrays to compute a lazy, no allocation vector.\n\n\n\n\n\n","category":"method"},{"location":"#ROSEx.closure_phase-NTuple{7, Any}","page":"Home","title":"ROSEx.closure_phase","text":"closure_phase(model, u1, v1, u2, v2, u3, v3)\n\n\nComputes the closure phase of model m at the uv-triangle u1,v1 -> u2,v2 -> u3,v3\n\nIf you want to compute closure phases over a number of triangles consider using the closure_phases function which uses MappedArrays to compute a lazy, no allocation vector.\n\n\n\n\n\n","category":"method"},{"location":"#ROSEx.closure_phase-Tuple{ROSEx.EHTVisibilityDatum, ROSEx.EHTVisibilityDatum, ROSEx.EHTVisibilityDatum}","page":"Home","title":"ROSEx.closure_phase","text":"closure_phase(D1, D2, D3)\n\n\nComputes the closure phase of the three visibility datums.\n\nNotes\n\nWe currently use the high SNR Gaussian error approximation for the closure phase. In the future we may use the moment matching from Monte Carlo sampling.\n\n\n\n\n\n","category":"method"},{"location":"#ROSEx.closure_phases-Tuple{Any, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray}","page":"Home","title":"ROSEx.closure_phases","text":"closure_phases(m, u1, v1, u2, v2, u3, v3)\n\n\nComputes the closure phases of the model m at the triangles (u1,v1), (u2,v2), (u3,v3).\n\nNote this is done lazily so the closure_phases is only computed when accessed.\n\n\n\n\n\n","category":"method"},{"location":"#ROSEx.coherencymatrix-Tuple{PolarizedModel, Any, Any}","page":"Home","title":"ROSEx.coherencymatrix","text":"coherencymatrix(pimg, u, v)\n\n\nComputes the coherency matrix of the polarized model.\n\n\n\n\n\n","category":"method"},{"location":"#ROSEx.components-Tuple{ROSEx.AbstractModel}","page":"Home","title":"ROSEx.components","text":"components(m)\n\n\nReturns the components for a composite model. This will return a Tuple with all the models you have constructed.\n\n\n\n\n\n","category":"method"},{"location":"#ROSEx.create_cache-Tuple{ROSEx.FFT, Any, Any}","page":"Home","title":"ROSEx.create_cache","text":"create_cache(alg, model, img)\n\n\nCreates the model cache given for the algorithm alg using the model and a image cache image\n\n\n\n\n\n","category":"method"},{"location":"#ROSEx.evpa-Tuple{Any, Any, Any}","page":"Home","title":"ROSEx.evpa","text":"evpa(pimg, u, v)\n\n\nelectric vector position angle or EVPA of the polarized model\n\n\n\n\n\n","category":"method"},{"location":"#ROSEx.extract_cphase-Tuple{Any}","page":"Home","title":"ROSEx.extract_cphase","text":"extract_cphase(obs)\n\nExtracts the closure phases from an ehtim observation object\n\nReturns an EHTObservation with closure phases datums\n\n\n\n\n\n","category":"method"},{"location":"#ROSEx.extract_lcamp-Tuple{Any}","page":"Home","title":"ROSEx.extract_lcamp","text":"extract_lcamp(obs)\n\nExtracts the log-closure amp. from an ehtim observation object\n\nReturns an EHTObservation with closure amp. datums\n\n\n\n\n\n","category":"method"},{"location":"#ROSEx.extract_vis-Tuple{Any}","page":"Home","title":"ROSEx.extract_vis","text":"extract_vis(obs)\n\nExtracts the complex visibilities from an ehtim observation object\n\nReturns an EHTObservation with complex visibility data\n\n\n\n\n\n","category":"method"},{"location":"#ROSEx.flux-Union{Tuple{ROSEx.AbstractIntensityMap{T, S}}, Tuple{S}, Tuple{T}} where {T, S}","page":"Home","title":"ROSEx.flux","text":"Computes the flux of a intensity map\n\n\n\n\n\n","category":"method"},{"location":"#ROSEx.imanalytic-Tuple{Type{<:ROSEx.AbstractModel}}","page":"Home","title":"ROSEx.imanalytic","text":"imanalytic(::Type{<:AbstractModel})\n\nDetermines whether the model is pointwise analytic in the image domain, i.e. we can evaluate its intensity at an arbritrary point.\n\nIf IsAnalytic() then it will try to call intensity_point to calculate the intensity.\n\n\n\n\n\n","category":"method"},{"location":"#ROSEx.intensity_point","page":"Home","title":"ROSEx.intensity_point","text":"Function that computes the pointwise intensity if the model has the trait in the image domain IsAnalytic(). Otherwise it will use construct the image in visibility space and invert it.\n\n\n\n\n\n","category":"function"},{"location":"#ROSEx.intensitymap","page":"Home","title":"ROSEx.intensitymap","text":"Computes the intensity map of model. This version requires additional information to construct the grid.\n\nExample\n\nm = Gaussian()\n# field of view\nfovx, fovy = 5.0\nfovy = 5.0\n# number of pixels\nnx, ny = 128\n\nimg = intensitymap(m, fovx, fovy, nx, ny; pulse=DeltaPulse())\n\n\n\n\n\n","category":"function"},{"location":"#ROSEx.intensitymap!","page":"Home","title":"ROSEx.intensitymap!","text":"Computes the intensity map of model by modifying the input IntensityMap object\n\n\n\n\n\n","category":"function"},{"location":"#ROSEx.intensitymap!-Tuple{PolarizedMap, PolarizedModel}","page":"Home","title":"ROSEx.intensitymap!","text":"intensitymap!(pimg, pmodel)\n\n\nFinds the polarized intensity map of the polarized model pmodel.\n\n\n\n\n\n","category":"method"},{"location":"#ROSEx.isprimitive","page":"Home","title":"ROSEx.isprimitive","text":"isprimitive(::Type)\n\nDispatch function that specifies whether a type is a primitive ROSEx model. This function is used for dispatch purposes when composing models.\n\nNotes\n\nIf a user is specifying their own model primitive model outside of ROSEx they need to specify if it is primitive\n\nstruct MyPrimitiveModel end\nROSEx.isprimitive(::Type{MyModel}) = ROSEx.IsPrimitive()\n\n\n\n\n\n","category":"function"},{"location":"#ROSEx.load_ehtim-Tuple{}","page":"Home","title":"ROSEx.load_ehtim","text":"load_ehtim()\n\n\nLoads the eht-imaging library and stores it in the ehtim variable.\n\nNotes\n\nThis will fail if ehtim isn't installed in the python installation that PyCall references.\n\n\n\n\n\n","category":"method"},{"location":"#ROSEx.load_tpy-Tuple{Any}","page":"Home","title":"ROSEx.load_tpy","text":"load_tpy(file)\n\n\nLoad a ThemisPy style ascii EHT observation file.\n\n\n\n\n\n","category":"method"},{"location":"#ROSEx.logclosure_amplitude-NTuple{9, Any}","page":"Home","title":"ROSEx.logclosure_amplitude","text":"logclosure_amplitude(model, u1, v1, u2, v2, u3, v3, u4, v4)\n\n\nComputes the log-closure amplitude of model m at the uv-quadrangle u1,v1 -> u2,v2 -> u3,v3 -> u4,v3 using the formula\n\nC = logleftfracV(u1v1)V(u2v2)V(u3v3)V(u4v4)right\n\nIf you want to compute log closure amplitudes over a number of triangles consider using the logclosure_amplitudes function which uses MappedArrays to compute a lazy, no allocation vector.\n\n\n\n\n\n","category":"method"},{"location":"#ROSEx.logclosure_amplitudes-Tuple{Any, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray}","page":"Home","title":"ROSEx.logclosure_amplitudes","text":"logclosure_amplitudes(m, u1, v1, u2, v2, u3, v3, u4, v4)\n\n\nComputes the log closure amplitudes of the model m at the quadrangles (u1,v1), (u2,v2), (u3,v3), (u4, v4).\n\nNote this is done lazily so the log closure amplitude is only computed when accessed.\n\n\n\n\n\n","category":"method"},{"location":"#ROSEx.modelimage-Tuple{M} where M","page":"Home","title":"ROSEx.modelimage","text":"modelimage(m)\n\nConstruct a ModelImage where just the model m is specified\n\nNotes\n\nCurrently this is only defined for analytic models. In the future this will guess a reasonable image to use.\n\n\n\n\n\n","category":"method"},{"location":"#ROSEx.modelimage-Union{Tuple{M}, Tuple{M, Any}} where M","page":"Home","title":"ROSEx.modelimage","text":"modelimage(model, image; alg)\nmodelimage(m)\n\n\nConstruct a ModelImage from a model, image and the optionally specified visibility algorithm alg\n\nNotes\n\nFor analytic models this is a no-op and just return the model. For non-analytic models this wraps the model in a object with an image and precomputes the fourier transform using alg.\n\n\n\n\n\n","category":"method"},{"location":"#ROSEx.m̆-Tuple{Any, Any, Any}","page":"Home","title":"ROSEx.m̆","text":"m̆(pimg, u, v)\n\n\nComputes the fractional linear polarization in the visibility domain\n\n    brevem = fracQ + iUI\n\n\n\n\n\n","category":"method"},{"location":"#ROSEx.rad2μas-Tuple{Any}","page":"Home","title":"ROSEx.rad2μas","text":"rad2μas(x)\n\nConverts a number from radians to μas\n\n\n\n\n\n","category":"method"},{"location":"#ROSEx.renormed-Union{Tuple{M}, Tuple{M, Any}} where M<:ROSEx.AbstractModel","page":"Home","title":"ROSEx.renormed","text":"renormed(model, flux)\n\n\nRenormalizes the model m to have total flux flux.\n\n\n\n\n\n","category":"method"},{"location":"#ROSEx.rotated-Tuple{Any, Any}","page":"Home","title":"ROSEx.rotated","text":"rotated(model, ξ)\n\n\nRotates the model by an amount ξ in radians.\n\n\n\n\n\n","category":"method"},{"location":"#ROSEx.shifted-Tuple{Any, Any, Any}","page":"Home","title":"ROSEx.shifted","text":"shifted(model, Δx, Δy)\n\n\nShifts the model m in the image domain by an amount Δx,Δy.\n\n\n\n\n\n","category":"method"},{"location":"#ROSEx.stretched-Tuple{Any, Any, Any}","page":"Home","title":"ROSEx.stretched","text":"stretched(model, α, β)\n\n\nStretches the model m according to the formula\n\n    I_s(xy) = 1(αβ) I(xα yβ)\n\nwhere were renormalize the intensity to preserve the models flux.\n\n\n\n\n\n","category":"method"},{"location":"#ROSEx.visanalytic-Tuple{Type{<:ROSEx.AbstractModel}}","page":"Home","title":"ROSEx.visanalytic","text":"visanalytic(::Type{<:AbstractModel})\n\nDetermines whether the model is pointwise analytic in Fourier domain, i.e. we can evaluate its fourier transform at an arbritrary point.\n\nIf IsAnalytic() then it will try to call visibility_point to calculate the complex visibilities. Otherwise it fallback to using the FFT that works for all models that can compute an image.\n\n\n\n\n\n","category":"method"},{"location":"#ROSEx.visibilities-Tuple{Any, AbstractArray, AbstractArray}","page":"Home","title":"ROSEx.visibilities","text":"visibilities(m, u, v)\n\n\nComputes the visibilities of the model m at the u,v positions u, v.\n\nNote this is done lazily so the visibility is only computed when accessed.\n\n\n\n\n\n","category":"method"},{"location":"#ROSEx.visibility","page":"Home","title":"ROSEx.visibility","text":"Computes the complex visibility of model m at u,v positions u,v\n\nIf you want to compute the visibilities at a large number of positions consider using the visibilities function which uses MappedArrays to compute a lazy, no allocation vector.\n\n\n\n\n\n","category":"function"},{"location":"#ROSEx.visibility-Tuple{PolarizedModel, Any, Any}","page":"Home","title":"ROSEx.visibility","text":"visibility(pimg, u, v)\n\n\nComputes the visibility in the stokes basis of the polarized model\n\n\n\n\n\n","category":"method"},{"location":"#ROSEx.visibility-Union{Tuple{M}, Tuple{M, Any, Any}} where M","page":"Home","title":"ROSEx.visibility","text":"visibility(mimg, u, v)\n\n\nComputes the complex visibility of model m at u,v positions u,v\n\nIf you want to compute the visibilities at a large number of positions consider using the visibilities function which uses MappedArrays to compute a lazy, no allocation vector.\n\n\n\n\n\n","category":"method"},{"location":"#ROSEx.visibility_point","page":"Home","title":"ROSEx.visibility_point","text":"Function that computes the pointwise visibility if the model has the trait in the fourier domain IsAnalytic(). Otherwise it will use the FFTW fallback.\n\n\n\n\n\n","category":"function"},{"location":"#ROSEx.μas2rad-Tuple{Any}","page":"Home","title":"ROSEx.μas2rad","text":"μas2rad(x)\n\nConverts a number from μas to rad\n\n\n\n\n\n","category":"method"}]
}
