<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Comrade API · Comrade.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Comrade.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../vlbi_imaging_problem/">Introduction to the VLBI Imaging Problem</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../examples/data/">Loading Data into Comrade</a></li><li><a class="tocitem" href="../examples/black_hole_image/">Making an Image of a Black Hole</a></li><li><a class="tocitem" href="../examples/nonanalytic/">Modeling with non-analytic Fourier transforms</a></li></ul></li><li><a class="tocitem" href="../interface/">Model Interface</a></li><li><a class="tocitem" href="../base_api/">ComradeBase API</a></li><li class="is-active"><a class="tocitem" href>Comrade API</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Comrade API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Comrade API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ptiede/Comrade.jl/blob/source/docs/src/api.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Comrade-API"><a class="docs-heading-anchor" href="#Comrade-API">Comrade API</a><a id="Comrade-API-1"></a><a class="docs-heading-anchor-permalink" href="#Comrade-API" title="Permalink"></a></h1><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#Comrade-API">Comrade API</a></li><li class="no-marker"><ul><li><a href="#Contents">Contents</a></li><li><a href="#Index">Index</a></li></ul></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Comrade.AbstractCache"><code>Comrade.AbstractCache</code></a></li><li><a href="#Comrade.AbstractInterferometryDatum"><code>Comrade.AbstractInterferometryDatum</code></a></li><li><a href="#Comrade.AbstractModifier"><code>Comrade.AbstractModifier</code></a></li><li><a href="#Comrade.AddModel"><code>Comrade.AddModel</code></a></li><li><a href="#Comrade.ArrayBaselineDatum"><code>Comrade.ArrayBaselineDatum</code></a></li><li><a href="#Comrade.ArrayConfiguration"><code>Comrade.ArrayConfiguration</code></a></li><li><a href="#Comrade.ClosureConfig"><code>Comrade.ClosureConfig</code></a></li><li><a href="#Comrade.CompositeModel"><code>Comrade.CompositeModel</code></a></li><li><a href="#Comrade.ConcordanceCrescent"><code>Comrade.ConcordanceCrescent</code></a></li><li><a href="#Comrade.ConvolvedModel"><code>Comrade.ConvolvedModel</code></a></li><li><a href="#Comrade.DFTAlg"><code>Comrade.DFTAlg</code></a></li><li><a href="#Comrade.EHTArrayConfiguration"><code>Comrade.EHTArrayConfiguration</code></a></li><li><a href="#Comrade.EHTClosurePhaseDatum"><code>Comrade.EHTClosurePhaseDatum</code></a></li><li><a href="#Comrade.EHTLogClosureAmplitudeDatum"><code>Comrade.EHTLogClosureAmplitudeDatum</code></a></li><li><a href="#Comrade.EHTObservation"><code>Comrade.EHTObservation</code></a></li><li><a href="#Comrade.EHTVisibilityAmplitudeDatum"><code>Comrade.EHTVisibilityAmplitudeDatum</code></a></li><li><a href="#Comrade.EHTVisibilityDatum"><code>Comrade.EHTVisibilityDatum</code></a></li><li><a href="#Comrade.ExtendedRing"><code>Comrade.ExtendedRing</code></a></li><li><a href="#Comrade.FFTAlg"><code>Comrade.FFTAlg</code></a></li><li><a href="#Comrade.FFTCache"><code>Comrade.FFTCache</code></a></li><li><a href="#Comrade.GainModel"><code>Comrade.GainModel</code></a></li><li><a href="#Comrade.Gaussian"><code>Comrade.Gaussian</code></a></li><li><a href="#Comrade.GeometricModel"><code>Comrade.GeometricModel</code></a></li><li><a href="#Comrade.MRing"><code>Comrade.MRing</code></a></li><li><a href="#Comrade.ModelImage"><code>Comrade.ModelImage</code></a></li><li><a href="#Comrade.MultiRadioLikelihood-Tuple{Vararg{RadioLikelihood}}"><code>Comrade.MultiRadioLikelihood</code></a></li><li><a href="#Comrade.NFFTAlg"><code>Comrade.NFFTAlg</code></a></li><li><a href="#Comrade.NonAnalyticTest"><code>Comrade.NonAnalyticTest</code></a></li><li><a href="#Comrade.ParabolicSegment-Tuple{Any, Any}"><code>Comrade.ParabolicSegment</code></a></li><li><a href="#Comrade.ParabolicSegment"><code>Comrade.ParabolicSegment</code></a></li><li><a href="#Comrade.PolarizedModel"><code>Comrade.PolarizedModel</code></a></li><li><a href="#Comrade.Posterior"><code>Comrade.Posterior</code></a></li><li><a href="#Comrade.RadioLikelihood-Tuple{Vararg{Comrade.EHTObservation}}"><code>Comrade.RadioLikelihood</code></a></li><li><a href="#Comrade.RenormalizedModel"><code>Comrade.RenormalizedModel</code></a></li><li><a href="#Comrade.Ring"><code>Comrade.Ring</code></a></li><li><a href="#Comrade.RotatedModel"><code>Comrade.RotatedModel</code></a></li><li><a href="#Comrade.ShiftedModel"><code>Comrade.ShiftedModel</code></a></li><li><a href="#Comrade.StretchedModel"><code>Comrade.StretchedModel</code></a></li><li><a href="#Comrade.TransformedPosterior"><code>Comrade.TransformedPosterior</code></a></li><li><a href="#Comrade.Crescent-NTuple{4, Any}"><code>Comrade.Crescent</code></a></li><li><a href="#Comrade.amplitude-Tuple{Any, Vararg{Any}}"><code>Comrade.amplitude</code></a></li><li><a href="#Comrade.amplitude-Tuple{Comrade.EHTVisibilityDatum}"><code>Comrade.amplitude</code></a></li><li><a href="#Comrade.amplitudes-Tuple{Any, AbstractArray, AbstractArray}"><code>Comrade.amplitudes</code></a></li><li><a href="#Comrade.arrayconfig-Tuple{Comrade.EHTObservation}"><code>Comrade.arrayconfig</code></a></li><li><a href="#Comrade.basemodel-Tuple{Comrade.AbstractModifier}"><code>Comrade.basemodel</code></a></li><li><a href="#Comrade.bispectra-Tuple{Any, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray}"><code>Comrade.bispectra</code></a></li><li><a href="#Comrade.bispectrum-NTuple{7, Any}"><code>Comrade.bispectrum</code></a></li><li><a href="#Comrade.closure_phase-NTuple{7, Any}"><code>Comrade.closure_phase</code></a></li><li><a href="#Comrade.closure_phase-Tuple{Comrade.EHTVisibilityDatum, Comrade.EHTVisibilityDatum, Comrade.EHTVisibilityDatum}"><code>Comrade.closure_phase</code></a></li><li><a href="#Comrade.closure_phases-Tuple{Any, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray}"><code>Comrade.closure_phases</code></a></li><li><a href="#Comrade.coherencymatrix-Tuple{PolarizedModel, Any, Any}"><code>Comrade.coherencymatrix</code></a></li><li><a href="#Comrade.components-Tuple{ComradeBase.AbstractModel}"><code>Comrade.components</code></a></li><li><a href="#Comrade.convolved-Tuple{Any, Any}"><code>Comrade.convolved</code></a></li><li><a href="#Comrade.create_cache-Tuple{FFTAlg, Any}"><code>Comrade.create_cache</code></a></li><li><a href="#Comrade.create_cache"><code>Comrade.create_cache</code></a></li><li><a href="#Comrade.extract_amp-Tuple{Any}"><code>Comrade.extract_amp</code></a></li><li><a href="#Comrade.extract_cphase-Tuple{Any}"><code>Comrade.extract_cphase</code></a></li><li><a href="#Comrade.extract_lcamp-Tuple{Any}"><code>Comrade.extract_lcamp</code></a></li><li><a href="#Comrade.extract_vis-Tuple{Any}"><code>Comrade.extract_vis</code></a></li><li><a href="#Comrade.getuv-Tuple{Comrade.ArrayConfiguration}"><code>Comrade.getuv</code></a></li><li><a href="#Comrade.load_ehtim-Tuple{}"><code>Comrade.load_ehtim</code></a></li><li><a href="#Comrade.load_tpy-Tuple{Any}"><code>Comrade.load_tpy</code></a></li><li><a href="#Comrade.logclosure_amplitude-NTuple{9, Any}"><code>Comrade.logclosure_amplitude</code></a></li><li><a href="#Comrade.logclosure_amplitudes-Tuple{Any, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray}"><code>Comrade.logclosure_amplitudes</code></a></li><li><a href="#Comrade.modelimage-Tuple{M} where M"><code>Comrade.modelimage</code></a></li><li><a href="#Comrade.modelimage-Union{Tuple{M}, Tuple{M, ComradeBase.AbstractIntensityMap}, Tuple{M, ComradeBase.AbstractIntensityMap, Comrade.FourierTransform}, Tuple{M, ComradeBase.AbstractIntensityMap, Comrade.FourierTransform, Any}} where M"><code>Comrade.modelimage</code></a></li><li><a href="#Comrade.prior_sample-Tuple{Posterior, Vararg{Any}}"><code>Comrade.prior_sample</code></a></li><li><a href="#Comrade.rad2μas-Tuple{Any}"><code>Comrade.rad2μas</code></a></li><li><a href="#Comrade.renormed-Union{Tuple{M}, Tuple{M, Any}} where M&lt;:ComradeBase.AbstractModel"><code>Comrade.renormed</code></a></li><li><a href="#Comrade.rescaleuv!-Union{Tuple{D}, Tuple{T}, Tuple{Comrade.EHTObservation{T, D, S} where S&lt;:(StructArrays.StructArray{D}), Any}} where {T, D&lt;:Union{Comrade.EHTVisibilityAmplitudeDatum, Comrade.EHTVisibilityDatum}}"><code>Comrade.rescaleuv!</code></a></li><li><a href="#Comrade.rotated-Tuple{Any, Any}"><code>Comrade.rotated</code></a></li><li><a href="#Comrade.scantable-Tuple{Any}"><code>Comrade.scantable</code></a></li><li><a href="#Comrade.shifted-Tuple{Any, Any, Any}"><code>Comrade.shifted</code></a></li><li><a href="#Comrade.smoothed-Tuple{Any, Number}"><code>Comrade.smoothed</code></a></li><li><a href="#Comrade.stations-Union{Tuple{Comrade.EHTObservation{T, A, S} where S&lt;:(StructArrays.StructArray{A})}, Tuple{A}, Tuple{T}} where {T, A&lt;:Comrade.AbstractInterferometryDatum}"><code>Comrade.stations</code></a></li><li><a href="#Comrade.stretched-Tuple{Any, Any, Any}"><code>Comrade.stretched</code></a></li><li><a href="#Comrade.update_cache"><code>Comrade.update_cache</code></a></li><li><a href="#Comrade.uviterator-NTuple{4, Any}"><code>Comrade.uviterator</code></a></li><li><a href="#Comrade.uvpositions-Tuple{Comrade.AbstractVisibilityDatum}"><code>Comrade.uvpositions</code></a></li><li><a href="#Comrade.uvtimefreq-Tuple{Comrade.EHTArrayConfiguration}"><code>Comrade.uvtimefreq</code></a></li><li><a href="#Comrade.visibility-Union{Tuple{Comrade.EHTVisibilityDatum{T}}, Tuple{T}} where T"><code>Comrade.visibility</code></a></li><li><a href="#Comrade.visibility-Union{Tuple{M}, Tuple{M, Vararg{Any}}} where M"><code>Comrade.visibility</code></a></li><li><a href="#Comrade.visibility-Tuple{PolarizedModel, Any, Any}"><code>Comrade.visibility</code></a></li><li><a href="#Comrade.μas2rad-Tuple{Any}"><code>Comrade.μas2rad</code></a></li><li><a href="#ComradeBase.evpa-Tuple{Any, Any, Any}"><code>ComradeBase.evpa</code></a></li><li><a href="#ComradeBase.intensitymap!-Tuple{IntensityMap{&lt;:StokesVector}, PolarizedModel}"><code>ComradeBase.intensitymap!</code></a></li><li><a href="#ComradeBase.m̆-Tuple{Any, Any, Any}"><code>ComradeBase.m̆</code></a></li><li><a href="#HypercubeTransform.ascube-Tuple{Posterior}"><code>HypercubeTransform.ascube</code></a></li><li><a href="#HypercubeTransform.asflat-Tuple{Posterior}"><code>HypercubeTransform.asflat</code></a></li><li><a href="#ParameterHandling.flatten-Tuple{Posterior}"><code>ParameterHandling.flatten</code></a></li><li><a href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, ComradeBase.AbstractModel}"><code>RecipesBase.apply_recipe</code></a></li><li><a href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, IntensityMap}"><code>RecipesBase.apply_recipe</code></a></li><li><a href="#TransformVariables.inverse-Tuple{Comrade.TransformedPosterior, Any}"><code>TransformVariables.inverse</code></a></li><li><a href="#TransformVariables.transform-Tuple{Comrade.TransformedPosterior, Any}"><code>TransformVariables.transform</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Comrade.Crescent-NTuple{4, Any}" href="#Comrade.Crescent-NTuple{4, Any}"><code>Comrade.Crescent</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Creates a <a href="https://academic.oup.com/mnras/article/434/1/765/1005984">Kamruddin and Dexter</a> crescent model. This works by composing two disk models together.</p><p><strong>Arguments</strong></p><ul><li>router: The radius of the outer disk</li><li>rinner: The radius of the inner disk</li><li>shift: How much the inner disk radius is shifted (positive is to the right)</li><li>floor: The floor of the inner disk 0 means the inner intensity is zero and 1 means it is a large disk.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/geometric_models.jl#LL163-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.amplitude-Tuple{Any, Vararg{Any}}" href="#Comrade.amplitude-Tuple{Any, Vararg{Any}}"><code>Comrade.amplitude</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">amplitude(model, args)
</code></pre><p>Computes the visibility amplitude of model <code>m</code> at u,v positions <code>u,v</code></p><p>If you want to compute the amplitudes at a large number of positions consider using the <code>amplitudes</code> function which uses MappedArrays to compute a lazy, no allocation vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/models.jl#LL32-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.amplitude-Tuple{Comrade.EHTVisibilityDatum}" href="#Comrade.amplitude-Tuple{Comrade.EHTVisibilityDatum}"><code>Comrade.amplitude</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">amplitude(D)
</code></pre><p>Get the amplitude of a visibility datum</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/observations/observations.jl#LL259-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.amplitudes-Tuple{Any, AbstractArray, AbstractArray}" href="#Comrade.amplitudes-Tuple{Any, AbstractArray, AbstractArray}"><code>Comrade.amplitudes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">amplitudes(m, u, v)
</code></pre><p>Computes the amplitudes of the model <code>m</code> at the u,v positions <code>u</code>, <code>v</code>.</p><p><strong>Notes</strong></p><p>If this is a analytic model this is done lazily so the visibilites are only computed when accessed. Otherwise for numerical model computed with NFFT this is eager.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/models.jl#LL131-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.arrayconfig-Tuple{Comrade.EHTObservation}" href="#Comrade.arrayconfig-Tuple{Comrade.EHTObservation}"><code>Comrade.arrayconfig</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">arrayconfig(vis)
</code></pre><p>Extract the array configuration from a visibility EHT observation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/observations/observations.jl#LL587-L590">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.basemodel-Tuple{Comrade.AbstractModifier}" href="#Comrade.basemodel-Tuple{Comrade.AbstractModifier}"><code>Comrade.basemodel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">basemodel(model)
</code></pre><p>Returns the base model from a modified model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/modifiers.jl#LL12-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.bispectra-Tuple{Any, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray}" href="#Comrade.bispectra-Tuple{Any, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray}"><code>Comrade.bispectra</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bispectra(m, u1, v1, u2, v2, u3, v3)
</code></pre><p>Computes the bispectra of the model <code>m</code> at the triangles (u1,v1), (u2,v2), (u3,v3).</p><p>Note this is done lazily so the bispectra is only computed when accessed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/models.jl#LL162-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.bispectrum-NTuple{7, Any}" href="#Comrade.bispectrum-NTuple{7, Any}"><code>Comrade.bispectrum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bispectrum(model, u1, v1, u2, v2, u3, v3)
</code></pre><p>Computes the complex bispectrum of model <code>m</code> at the uv-triangle u1,v1 -&gt; u2,v2 -&gt; u3,v3</p><p>If you want to compute the bispectrum over a number of triangles consider using the <code>bispectra</code> function which uses MappedArrays to compute a lazy, no allocation vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/models.jl#LL44-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.closure_phase-NTuple{7, Any}" href="#Comrade.closure_phase-NTuple{7, Any}"><code>Comrade.closure_phase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">closure_phase(model, u1, v1, u2, v2, u3, v3)
</code></pre><p>Computes the closure phase of model <code>m</code> at the uv-triangle u1,v1 -&gt; u2,v2 -&gt; u3,v3</p><p>If you want to compute closure phases over a number of triangles consider using the <code>closure_phases</code> function which uses MappedArrays to compute a lazy, no allocation vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/models.jl#LL57-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.closure_phase-Tuple{Comrade.EHTVisibilityDatum, Comrade.EHTVisibilityDatum, Comrade.EHTVisibilityDatum}" href="#Comrade.closure_phase-Tuple{Comrade.EHTVisibilityDatum, Comrade.EHTVisibilityDatum, Comrade.EHTVisibilityDatum}"><code>Comrade.closure_phase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">closure_phase(D1, D2, D3)
</code></pre><p>Computes the closure phase of the three visibility datums.</p><p><strong>Notes</strong></p><p>We currently use the high SNR Gaussian error approximation for the closure phase. In the future we may use the moment matching from Monte Carlo sampling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/observations/observations.jl#LL415-L422">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.closure_phases-Tuple{Any, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray}" href="#Comrade.closure_phases-Tuple{Any, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray}"><code>Comrade.closure_phases</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">closure_phases(m, u1, v1, u2, v2, u3, v3)
</code></pre><p>Computes the closure phases of the model <code>m</code> at the triangles (u1,v1), (u2,v2), (u3,v3).</p><p>Note this is done lazily so the closure_phases is only computed when accessed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/models.jl#LL205-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.coherencymatrix-Tuple{PolarizedModel, Any, Any}" href="#Comrade.coherencymatrix-Tuple{PolarizedModel, Any, Any}"><code>Comrade.coherencymatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coherencymatrix(pimg, u, v)
</code></pre><p>Computes the coherency matrix of the polarized model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/polarized.jl#LL67-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.components-Tuple{ComradeBase.AbstractModel}" href="#Comrade.components-Tuple{ComradeBase.AbstractModel}"><code>Comrade.components</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">components(m)
</code></pre><p>Returns the components for a composite model. This will return a Tuple with all the models you have constructed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/combinators.jl#LL87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.convolved-Tuple{Any, Any}" href="#Comrade.convolved-Tuple{Any, Any}"><code>Comrade.convolved</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convolved(m1, m2)
</code></pre><p>Convolves two models <code>m1</code> and <code>m2</code>. This is done lazily.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/combinators.jl#LL175-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.create_cache" href="#Comrade.create_cache"><code>Comrade.create_cache</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_cache(alg, img)</code></pre><p>Creates a Fourier transform cache for a img. This is usually called internally for ModelImage. However, in certain circumstances the end-user can call this to speed up a method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/modelimage/cache.jl#LL15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.create_cache-Tuple{FFTAlg, Any}" href="#Comrade.create_cache-Tuple{FFTAlg, Any}"><code>Comrade.create_cache</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_cache(alg, img)
</code></pre><p>Creates the model cache given for the algorithm <code>alg</code> using the <code>model</code> and a image cache <code>image</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/modelimage/fft_alg.jl#LL120-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.extract_amp-Tuple{Any}" href="#Comrade.extract_amp-Tuple{Any}"><code>Comrade.extract_amp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extract_amp(obs)</code></pre><p>Extracts the visibility amplitudes from an ehtim observation object.</p><p>Any valid keyword arguments to <code>add_amp</code> in ehtim can be passed through extract_amp.</p><p>Returns an EHTObservation with visibility amplitude data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/observations/ehtim.jl#LL145-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.extract_cphase-Tuple{Any}" href="#Comrade.extract_cphase-Tuple{Any}"><code>Comrade.extract_cphase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extract_cphase(obs)</code></pre><p>Extracts the closure phases from an ehtim observation object</p><p>Any valid keyword arguments to <code>add_cphase</code> in ehtim can be passed through extract_cphase.</p><p>Returns an EHTObservation with closure phases datums</p><p><strong>Keyword arguments:</strong></p><ul><li>count: How the closures are formed, the available options are &quot;min-correct&quot;, &quot;min&quot;, &quot;max&quot;</li><li>cut_trivial: Cut the trivial triangles from the closures</li><li>uvmin: The flag to decide what are trivial triangles. Any baseline with ||(u,v)|| &lt; uvmin        are removed.</li></ul><p><strong>Warning</strong></p><p>The <code>count</code> keyword argument is treated specially in <code>Comrade</code>. The default option is &quot;min-correct&quot; and should almost always be used. This option construct a minimal set of closure phases that is valid even when the array isn&#39;t fully connected. For testing and legacy reasons we <code>ehtim</code> other count options are also included. However, the current <code>ehtim</code> count=&quot;min&quot; option is broken and does construct proper minimal sets of closure quantities if the array isn&#39;t fully connected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/observations/ehtim.jl#LL572-L595">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.extract_lcamp-Tuple{Any}" href="#Comrade.extract_lcamp-Tuple{Any}"><code>Comrade.extract_lcamp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extract_lcamp(obs)</code></pre><p>Extracts the log-closure amp. from an ehtim observation object</p><p>Any valid keyword arguments to <code>add_logcamp</code> in ehtim can be passed through extract_lcamp.</p><p>Returns an EHTObservation with log-closure amp. datums</p><p><strong>Warning</strong></p><p>The <code>count</code> keyword argument is treated specially in <code>Comrade</code>. The default option is &quot;min-correct&quot; and should almost always be used. This option construct a minimal set of closure phases that is valid even when the array isn&#39;t fully connected. For testing and legacy reasons we <code>ehtim</code> other count options are also included. However, the current <code>ehtim</code> count=&quot;min&quot; option is broken and does construct proper minimal sets of closure quantities if the array isn&#39;t fully connected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/observations/ehtim.jl#LL606-L623">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.extract_vis-Tuple{Any}" href="#Comrade.extract_vis-Tuple{Any}"><code>Comrade.extract_vis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extract_vis(obs)</code></pre><p>Extracts the complex visibilities from an ehtim observation object</p><p>This grabs the raw <code>data</code> object from the obs object. Any keyword arguments are ignored.</p><p>Returns an EHTObservation with complex visibility data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/observations/ehtim.jl#LL171-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.getuv-Tuple{Comrade.ArrayConfiguration}" href="#Comrade.getuv-Tuple{Comrade.ArrayConfiguration}"><code>Comrade.getuv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getuv(ac)
</code></pre><p>Get the u, v positions of the array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/observations/observations.jl#LL69-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.load_ehtim-Tuple{}" href="#Comrade.load_ehtim-Tuple{}"><code>Comrade.load_ehtim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_ehtim()
</code></pre><p>Loads the <a href="https://github.com/achael/eht-imaging">eht-imaging</a> library and stores it in the <code>ehtim</code> variable.</p><p><strong>Notes</strong></p><p>This will fail if ehtim isn&#39;t installed in the python installation that PyCall references.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/Comrade.jl#LL39-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.load_tpy-Tuple{Any}" href="#Comrade.load_tpy-Tuple{Any}"><code>Comrade.load_tpy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_tpy(file)
</code></pre><p>Load a ThemisPy style ascii EHT observation file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/observations/io.jl#LL4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.logclosure_amplitude-NTuple{9, Any}" href="#Comrade.logclosure_amplitude-NTuple{9, Any}"><code>Comrade.logclosure_amplitude</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">logclosure_amplitude(model, u1, v1, u2, v2, u3, v3, u4, v4)
</code></pre><p>Computes the log-closure amplitude of model <code>m</code> at the uv-quadrangle u1,v1 -&gt; u2,v2 -&gt; u3,v3 -&gt; u4,v3 using the formula</p><p class="math-container">\[C = \log\left|\frac{V(u1,v1)V(u2,v2)}{V(u3,v3)V(u4,v4)}\right|\]</p><p>If you want to compute log closure amplitudes over a number of triangles consider using the <code>logclosure_amplitudes</code> function which uses MappedArrays to compute a lazy, no allocation vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/models.jl#LL70-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.logclosure_amplitudes-Tuple{Any, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray}" href="#Comrade.logclosure_amplitudes-Tuple{Any, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray}"><code>Comrade.logclosure_amplitudes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">logclosure_amplitudes(m, u1, v1, u2, v2, u3, v3, u4, v4)
</code></pre><p>Computes the log closure amplitudes of the model <code>m</code> at the quadrangles (u1,v1), (u2,v2), (u3,v3), (u4, v4).</p><p>Note this is done lazily so the log closure amplitude is only computed when accessed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/models.jl#LL250-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.modelimage-Tuple{M} where M" href="#Comrade.modelimage-Tuple{M} where M"><code>Comrade.modelimage</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct a <code>ModelImage</code> where just the model <code>m</code> is specified</p><p><strong>Notes</strong></p><p>If m <code>IsAnalytic()</code> is the visibility domain this is a no-op and just returns the model itself. Otherwise <code>modelimage</code> will <em>guess</em> a reasonable field of view based on the <code>radialextent</code> function. One can optionally pass the number of pixels nx and ny in each direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/modelimage/modelimage.jl#LL120-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.modelimage-Union{Tuple{M}, Tuple{M, ComradeBase.AbstractIntensityMap}, Tuple{M, ComradeBase.AbstractIntensityMap, Comrade.FourierTransform}, Tuple{M, ComradeBase.AbstractIntensityMap, Comrade.FourierTransform, Any}} where M" href="#Comrade.modelimage-Union{Tuple{M}, Tuple{M, ComradeBase.AbstractIntensityMap}, Tuple{M, ComradeBase.AbstractIntensityMap, Comrade.FourierTransform}, Tuple{M, ComradeBase.AbstractIntensityMap, Comrade.FourierTransform, Any}} where M"><code>Comrade.modelimage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">modelimage(model, image)
modelimage(model, image, alg)
modelimage(model, image, alg, executor)
modelimage(m; fovx, fovy, nx, ny, pulse, alg, executor)
</code></pre><p>Construct a <code>ModelImage</code> from a <code>model</code>, <code>image</code> and the optionally specified visibility algorithm <code>alg</code></p><p><strong>Notes</strong></p><p>For analytic models this is a no-op and just return the model. For non-analytic models this wraps the model in a object with an image and precomputes the fourier transform using <code>alg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/modelimage/modelimage.jl#LL64-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.prior_sample-Tuple{Posterior, Vararg{Any}}" href="#Comrade.prior_sample-Tuple{Posterior, Vararg{Any}}"><code>Comrade.prior_sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prior_sample(post, args)
</code></pre><p>Samples the prior distribution from the posterior <code>nsamples</code> times.</p><p>Returns a Vector{NamedTuple} that can be used to initialize optimization and sample algorithms</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/bayes/bayes.jl#LL41-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.rad2μas-Tuple{Any}" href="#Comrade.rad2μas-Tuple{Any}"><code>Comrade.rad2μas</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rad2μas(x)</code></pre><p>Converts a number from radians to μas</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/Comrade.jl#LL58-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.renormed-Union{Tuple{M}, Tuple{M, Any}} where M&lt;:ComradeBase.AbstractModel" href="#Comrade.renormed-Union{Tuple{M}, Tuple{M, Any}} where M&lt;:ComradeBase.AbstractModel"><code>Comrade.renormed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">renormed(model, f)
</code></pre><p>Renormalizes the model <code>m</code> to have total flux <code>flux</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/modifiers.jl#LL129-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.rescaleuv!-Union{Tuple{D}, Tuple{T}, Tuple{Comrade.EHTObservation{T, D, S} where S&lt;:(StructArrays.StructArray{D}), Any}} where {T, D&lt;:Union{Comrade.EHTVisibilityAmplitudeDatum, Comrade.EHTVisibilityDatum}}" href="#Comrade.rescaleuv!-Union{Tuple{D}, Tuple{T}, Tuple{Comrade.EHTObservation{T, D, S} where S&lt;:(StructArrays.StructArray{D}), Any}} where {T, D&lt;:Union{Comrade.EHTVisibilityAmplitudeDatum, Comrade.EHTVisibilityDatum}}"><code>Comrade.rescaleuv!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rescaleuv!(data)</code></pre><p>rescale the u-v lengths according to scale. This can be useful when you want the spatial scales to be in 1/μas instead of 1/rad</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/observations/observations.jl#LL331-L335">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.rotated-Tuple{Any, Any}" href="#Comrade.rotated-Tuple{Any, Any}"><code>Comrade.rotated</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotated(model, ξ)
</code></pre><p>Rotates the model by an amount <code>ξ</code> in radians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/modifiers.jl#LL210-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.scantable-Tuple{Any}" href="#Comrade.scantable-Tuple{Any}"><code>Comrade.scantable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">`scantable(obs)`</code></pre><p>Reorganizes the observation into a table of scans, where scan are defined by unique timestamps. To access the data you can use scalar indexing</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">st = scantable(obs)
# Grab the first scan
scan1 = st[1]

# Acess the detections in the scan
scan1[1]

# grab e.g. the baselines
scan1[:baseline]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/observations/observations.jl#LL709-L728">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.shifted-Tuple{Any, Any, Any}" href="#Comrade.shifted-Tuple{Any, Any, Any}"><code>Comrade.shifted</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shifted(model, Δx, Δy)
</code></pre><p>Shifts the model <code>m</code> in the image domain by an amount <code>Δx,Δy</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/modifiers.jl#LL101-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.smoothed-Tuple{Any, Number}" href="#Comrade.smoothed-Tuple{Any, Number}"><code>Comrade.smoothed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">smoothed(m, σ)
</code></pre><p>Smooths a model <code>m</code> with a Gaussian kernel with standard deviation <code>σ</code>.</p><p><strong>Notes</strong></p><p>This will created a convolved model under the hood.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/combinators.jl#LL181-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.stations-Union{Tuple{Comrade.EHTObservation{T, A, S} where S&lt;:(StructArrays.StructArray{A})}, Tuple{A}, Tuple{T}} where {T, A&lt;:Comrade.AbstractInterferometryDatum}" href="#Comrade.stations-Union{Tuple{Comrade.EHTObservation{T, A, S} where S&lt;:(StructArrays.StructArray{A})}, Tuple{A}, Tuple{T}} where {T, A&lt;:Comrade.AbstractInterferometryDatum}"><code>Comrade.stations</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get all the stations in a observation. The result is a vector of symbols.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/observations/observations.jl#LL176-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.stretched-Tuple{Any, Any, Any}" href="#Comrade.stretched-Tuple{Any, Any, Any}"><code>Comrade.stretched</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stretched(model, α, β)
</code></pre><p>Stretches the model <code>m</code> according to the formula</p><p class="math-container">\[    I_s(x,y) = 1/(αβ) I(x/α, y/β),\]</p><p>where were renormalize the intensity to preserve the models flux.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/modifiers.jl#LL171-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.update_cache" href="#Comrade.update_cache"><code>Comrade.update_cache</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_cache(cache, img)</code></pre><p>Update the Fourier transform cache. This will reuse an FFT/NFFT plan saving some computational time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/modelimage/cache.jl#LL22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.uviterator-NTuple{4, Any}" href="#Comrade.uviterator-NTuple{4, Any}"><code>Comrade.uviterator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">uviterator(dx, dy, nnx, nny)
</code></pre><p>Construct the u,v iterators for the Fourier transform of the image with pixel sizes <code>dx, dy</code> and number of pixels <code>nx, ny</code></p><p>If you are extending Fourier transform stuff please use these functions to ensure that the centroid is being properly computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/modelimage/fft_alg.jl#LL169-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.uvpositions-Tuple{Comrade.AbstractVisibilityDatum}" href="#Comrade.uvpositions-Tuple{Comrade.AbstractVisibilityDatum}"><code>Comrade.uvpositions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">uvpositions(datum)</code></pre><p>Get the uvp positions of an inferometric datum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/observations/observations.jl#LL106-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.uvtimefreq-Tuple{Comrade.EHTArrayConfiguration}" href="#Comrade.uvtimefreq-Tuple{Comrade.EHTArrayConfiguration}"><code>Comrade.uvtimefreq</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">uvtimefreq(ac)
</code></pre><p>Get the u, v, time, freq of the array as a tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/observations/observations.jl#LL81-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.visibility-Tuple{PolarizedModel, Any, Any}" href="#Comrade.visibility-Tuple{PolarizedModel, Any, Any}"><code>Comrade.visibility</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">visibility(pimg, u, v)
</code></pre><p>Computes the visibility in the stokes basis of the polarized model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/polarized.jl#LL27-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.visibility-Union{Tuple{Comrade.EHTVisibilityDatum{T}}, Tuple{T}} where T" href="#Comrade.visibility-Union{Tuple{Comrade.EHTVisibilityDatum{T}}, Tuple{T}} where T"><code>Comrade.visibility</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the complex visibility of the visibility datum</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/observations/observations.jl#LL250-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.visibility-Union{Tuple{M}, Tuple{M, Vararg{Any}}} where M" href="#Comrade.visibility-Union{Tuple{M}, Tuple{M, Vararg{Any}}} where M"><code>Comrade.visibility</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">visibility(mimg, args)
</code></pre><p>Computes the complex visibility of model <code>m</code> at u,v positions <code>u,v</code></p><p>If you want to compute the visibilities at a large number of positions consider using the <code>visibilities</code> function which uses MappedArrays to compute a lazy, no allocation vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/models.jl#LL15-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.μas2rad-Tuple{Any}" href="#Comrade.μas2rad-Tuple{Any}"><code>Comrade.μas2rad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">μas2rad(x)</code></pre><p>Converts a number from μas to rad</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/Comrade.jl#LL64-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.evpa-Tuple{Any, Any, Any}" href="#ComradeBase.evpa-Tuple{Any, Any, Any}"><code>ComradeBase.evpa</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evpa(pimg, u, v)
</code></pre><p>electric vector position angle or EVPA of the polarized model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/polarized.jl#LL76-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.intensitymap!-Tuple{IntensityMap{&lt;:StokesVector}, PolarizedModel}" href="#ComradeBase.intensitymap!-Tuple{IntensityMap{&lt;:StokesVector}, PolarizedModel}"><code>ComradeBase.intensitymap!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intensitymap!(pimg, pmodel)
</code></pre><p>Finds the polarized intensity map of the polarized model pmodel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/polarized.jl#LL47-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.m̆-Tuple{Any, Any, Any}" href="#ComradeBase.m̆-Tuple{Any, Any, Any}"><code>ComradeBase.m̆</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">m̆(pimg, u, v)
</code></pre><p>Computes the fractional linear polarization in the visibility domain</p><p class="math-container">\[    \breve{m} = \frac{Q + iU}{I}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/polarized.jl#LL87-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HypercubeTransform.ascube-Tuple{Posterior}" href="#HypercubeTransform.ascube-Tuple{Posterior}"><code>HypercubeTransform.ascube</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ascube(post::Posterior)</code></pre><p>Construct a flattened version of the posterior, where the parameters are transformed to live in the unit hypercube. In astronomy parlance, we are transforming the variables to the unit hypercube. This is done using the <a href="https://github.com/ptiede/HypercubeTransform.jl">HypercubeTransform</a> package.</p><p>The transformed posterior can then be evaluated by the <code>logdensityof(transformed_posterior,x)</code> method following the <code>DensityInterface</code>, where <code>x</code> vector that lives in the unit hypercube. <strong>Note</strong> this already includes the jacobian of the transformation so this does not need to be added.</p><p>This transform is useful for NestedSampling methods that often assume that the model is written to live in the unit hypercube.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/bayes/bayes.jl#LL131-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HypercubeTransform.asflat-Tuple{Posterior}" href="#HypercubeTransform.asflat-Tuple{Posterior}"><code>HypercubeTransform.asflat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">asflat(post::Posterior)</code></pre><p>Construct a flattened version of the posterior, where the parameters are transformed so that their support is from (-∞, ∞). This uses <a href="https://github.com/tpapp/TransformVariables.jl">TransformVariables</a></p><p>The transformed posterior can then be evaluated by the <code>logdensityof(transformed_posterior,x)</code> method following the <code>DensityInterface</code>, where <code>x</code> is a flattened vector of the infinite support variables. <strong>Note</strong> this already includes the jacobian of the transformation so this does not need to be added.</p><p>This is useful for optimization and sampling algorithms such as HMC that will use gradients to explore the posterior surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/bayes/bayes.jl#LL104-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParameterHandling.flatten-Tuple{Posterior}" href="#ParameterHandling.flatten-Tuple{Posterior}"><code>ParameterHandling.flatten</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flatten(post::Posterior)</code></pre><p>Flatten the representation of the posterior. Internally this uses ParameterHandling to construct a flattened version of the posterior.</p><p>Note this is distinct from <code>asflat</code> that transforms the variables to live in (-∞,∞). Instead this method just flattens the repsentation of the model from a NamedTuple to a vector. This allows the easier integration to optimization and sampling algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/bayes/bayes.jl#LL169-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, ComradeBase.AbstractModel}" href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, ComradeBase.AbstractModel}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot(image::AbstractModel)</code></pre><p>where <code>image</code> is templated off of EHTImage struct.</p><p><strong>Details</strong></p><p>This was created to be close to the ehtim display object. It takes an EHTImage object and plots it according to EHT conventions.</p><p>Note that is does not save the figure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/visualizations/intensitymap.jl#LL49-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, IntensityMap}" href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, IntensityMap}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot(image::IntensityMap)</code></pre><p>where <code>image</code> is templated off of EHTImage struct.</p><p><strong>Details</strong></p><p>This was created to be close to the ehtim display object. It takes an EHTImage object and plots it according to EHT conventions.</p><p>Note that is does not save the figure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/visualizations/intensitymap.jl#LL5-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformVariables.inverse-Tuple{Comrade.TransformedPosterior, Any}" href="#TransformVariables.inverse-Tuple{Comrade.TransformedPosterior, Any}"><code>TransformVariables.inverse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inverse(posterior::TransformedPosterior, x)</code></pre><p>Transforms the value model parameters <code>x</code> into the flattened transformed space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/bayes/bayes.jl#LL92-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformVariables.transform-Tuple{Comrade.TransformedPosterior, Any}" href="#TransformVariables.transform-Tuple{Comrade.TransformedPosterior, Any}"><code>TransformVariables.transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform(posterior::TransformedPosterior, x)</code></pre><p>Transforms the value <code>x</code> into parameter space, i.e. usually a NamedTuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/bayes/bayes.jl#LL85-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.AbstractCache" href="#Comrade.AbstractCache"><code>Comrade.AbstractCache</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractCache</code></pre><p>This defines an abstract cache that can be used to hold or precompute some computations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/modelimage/cache.jl#LL7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.AbstractInterferometryDatum" href="#Comrade.AbstractInterferometryDatum"><code>Comrade.AbstractInterferometryDatum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractInterferometryDatum{T}</code></pre><p>An abstract type for all VLBI interfermetry data types. See <a href="@ref">EHTVisibilityDatum</a> for an example.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/observations/observations.jl#LL1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.AbstractModifier" href="#Comrade.AbstractModifier"><code>Comrade.AbstractModifier</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractModifier{M&lt;:ComradeBase.AbstractModel} &lt;: ComradeBase.AbstractModel</code></pre><p>Abstract type for image modifiers. These are some model wrappers that can transform any model using simple Fourier transform properties. To see the implemented modifier</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/modifiers.jl#LL4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.AddModel" href="#Comrade.AddModel"><code>Comrade.AddModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct AddModel{T1, T2} &lt;: Comrade.CompositeModel{T1, T2}</code></pre><p>Adds two models together to create composite models. Note that I may change this in the future so make it easier on the compiler, i.e. make the composite model a fancy model vector and heap allocate stuff. This should help when combining multiple models together.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/combinators.jl#LL57-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.ArrayBaselineDatum" href="#Comrade.ArrayBaselineDatum"><code>Comrade.ArrayBaselineDatum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ArrayBaselineDatum{T}</code></pre><p>A single datum of an observing array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/observations/observations.jl#LL92-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.ArrayConfiguration" href="#Comrade.ArrayConfiguration"><code>Comrade.ArrayConfiguration</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type ArrayConfiguration</code></pre><p>This defined the abstract type for an array configuration. Namely, baseline times, SEFD&#39;s, bandwidth, observation frequencies, etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/observations/observations.jl#LL23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.ClosureConfig" href="#Comrade.ClosureConfig"><code>Comrade.ClosureConfig</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ClosureConfig{A, D} &lt;: Comrade.ArrayConfiguration</code></pre><p>Array config file for closure quantities. This stores the design matrix <code>designmat</code> that transforms from visibilties to closure products.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/observations/observations.jl#LL52-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.CompositeModel" href="#Comrade.CompositeModel"><code>Comrade.CompositeModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type CompositeModel{M1, M2} &lt;: ComradeBase.AbstractModel</code></pre><p>Abstract type that denotes a composite model. Where we have combined two models together.</p><p><strong>Implementation</strong></p><p>Any implementation of a composite type must define the following methods:</p><ul><li>visibility_point</li><li>uv_combinator</li><li>imanalytic</li><li>visanalytic</li><li>ComradeBase.intensity_point if model intensity is <code>IsAnalytic</code></li><li>intensitymap! if model intensity is <code>NotAnalytic</code></li><li>intensitymap if model intensity is <code>NotAnalytic</code></li><li>flux</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/combinators.jl#LL3-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.ConcordanceCrescent" href="#Comrade.ConcordanceCrescent"><code>Comrade.ConcordanceCrescent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ConcordanceCrescent{T} &lt;: Comrade.GeometricModel</code></pre><p>Creates the ConcordanceCrescent model, i.e. a flat-top crescent with a displacment and a slash. Note this creates a crescent with unit flux. If you want a different flux please use the <code>renomed</code> modifier.</p><p><strong>Fields</strong></p><ul><li><p><code>router</code></p><p>Outer radius of the crescent</p></li></ul><ul><li><p><code>rinner</code></p><p>Inner radius of the crescent (i.e. inside this radius there is a hole)</p></li></ul><ul><li><p><code>shift</code></p><p>Displacment of the inner disk radius</p></li></ul><ul><li><p><code>slash</code></p><p>Strength of the linear slash. Note that s∈[0.0,1.0] to ensure positivity in the image.</p></li></ul><p><strong>Notes</strong></p><p>Unlike the Gaussian and Disk models this does not create the unit version. In fact, this model could have been created using the <code>Disk</code> and primitives by using Comrade.jl&#39;s model composition functionality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/geometric_models.jl#LL179-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.ConvolvedModel" href="#Comrade.ConvolvedModel"><code>Comrade.ConvolvedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ConvolvedModel{M1, M2} &lt;: Comrade.CompositeModel{M1, M2}</code></pre><p>Convolves two models <code>m1</code> and <code>m2</code>.</p><p><strong>Notes</strong></p><p>This is the non-exported constructor. The user should call the <code>convolved</code> function during use</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/combinators.jl#LL163-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.DFTAlg" href="#Comrade.DFTAlg"><code>Comrade.DFTAlg</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DFTAlg</code></pre><p>Uses a discrete fourier transform. This is not very efficient for larger images. In those cases  NFFTAlg or FFTAlg are more reasonable. For small images this is a reasonable choice especially since it&#39;s easy to define derivatives.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/modelimage/nuft.jl#LL214-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.EHTArrayConfiguration" href="#Comrade.EHTArrayConfiguration"><code>Comrade.EHTArrayConfiguration</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct EHTArrayConfiguration{F, T&lt;:AbstractArray} &lt;: Comrade.ArrayConfiguration</code></pre><p>Stores all the non-visibility data products for an EHT array. This is useful when evaluating model visibilities.</p><p><strong></strong></p><ul><li><p><code>frequency</code></p><p>Observing frequency (Hz)</p></li></ul><ul><li><p><code>bandwidth</code></p><p>Observing bandwith (Hz)</p></li></ul><ul><li><p><code>data</code></p><p>A struct array of <code>ArrayBaselineDatum</code> holding time, u, v, baselines.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/observations/observations.jl#LL30-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.EHTClosurePhaseDatum" href="#Comrade.EHTClosurePhaseDatum"><code>Comrade.EHTClosurePhaseDatum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct EHTClosurePhaseDatum{T&lt;:Number} &lt;: Comrade.ClosureProducts{T&lt;:Number}</code></pre><p>A Datum for a single closure phase.</p><p><strong></strong></p><ul><li><p><code>phase</code></p><p>closure phase (rad)</p></li></ul><ul><li><p><code>error</code></p><p>error of the closure phase assuming the high-snr limit</p></li></ul><ul><li><p><code>u1</code></p><p>u (λ) of first station</p></li></ul><ul><li><p><code>v1</code></p><p>v (λ) of first station</p></li></ul><ul><li><p><code>u2</code></p><p>u (λ) of second station</p></li></ul><ul><li><p><code>v2</code></p><p>v (λ) of second station</p></li></ul><ul><li><p><code>u3</code></p><p>u (λ) of third station</p></li></ul><ul><li><p><code>v3</code></p><p>v (λ) of third station</p></li></ul><ul><li><p><code>time</code></p><p>Measured time of closure phase in hours</p></li></ul><ul><li><p><code>triangle</code></p><p>station baselines used</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/observations/observations.jl#LL344-L351">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.EHTLogClosureAmplitudeDatum" href="#Comrade.EHTLogClosureAmplitudeDatum"><code>Comrade.EHTLogClosureAmplitudeDatum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct EHTLogClosureAmplitudeDatum{T&lt;:Number} &lt;: Comrade.ClosureProducts{T&lt;:Number}</code></pre><p>A Datum for a single log closure amplitude.</p><p><strong></strong></p><ul><li><p><code>amp</code></p><p>log-closure amplitude</p></li></ul><ul><li><p><code>error</code></p><p>log-closure amplitude error in the high-snr limit</p></li></ul><ul><li><p><code>u1</code></p><p>u (λ) of first station</p></li></ul><ul><li><p><code>v1</code></p><p>v (λ) of first station</p></li></ul><ul><li><p><code>u2</code></p><p>u (λ) of second station</p></li></ul><ul><li><p><code>v2</code></p><p>v (λ) of second station</p></li></ul><ul><li><p><code>u3</code></p><p>u (λ) of third station</p></li></ul><ul><li><p><code>v3</code></p><p>v (λ) of third station</p></li></ul><ul><li><p><code>u4</code></p><p>u (λ) of fourth station</p></li></ul><ul><li><p><code>v4</code></p><p>v (λ) of fourth station</p></li></ul><ul><li><p><code>time</code></p><p>Observation time of the quadrangle</p></li></ul><ul><li><p><code>quadrangle</code></p><p>station codes for the quadrangle</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/observations/observations.jl#LL453-L460">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.EHTObservation" href="#Comrade.EHTObservation"><code>Comrade.EHTObservation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The main data product type in <code>Comrade</code> this stores the <code>data</code> which can be a StructArray of any <code>AbstractInterferometryDatum</code> type.</p><p><strong>(</strong></p><ul><li><p><code>data</code></p><p>StructArray of data productts</p></li></ul><ul><li><p><code>config</code></p><p>Array config holds ancillary information about array</p></li></ul><ul><li><p><code>mjd</code></p><p>modified julia date of the observation</p></li></ul><ul><li><p><code>ra</code></p><p>RA of the observation in J2000 (deg)</p></li></ul><ul><li><p><code>dec</code></p><p>DEC of the observation in J2000 (deg)</p></li></ul><ul><li><p><code>bandwidth</code></p><p>bandwidth of the observation (Hz)</p></li></ul><ul><li><p><code>frequency</code></p><p>frequency of the observation (Hz)</p></li></ul><ul><li><p><code>source</code></p><p>Common source name</p></li></ul><ul><li><p><code>timetype</code></p><p>Time zone used.</p></li></ul><p>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/observations/observations.jl#LL112-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.EHTVisibilityAmplitudeDatum" href="#Comrade.EHTVisibilityAmplitudeDatum"><code>Comrade.EHTVisibilityAmplitudeDatum</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A struct holding the information for a single measured visibility amplitude.</p><p><strong></strong></p><ul><li><p><code>amp</code></p><p>amplitude (Jy)</p></li></ul><ul><li><p><code>error</code></p><p>error of the visibility amplitude (Jy)</p></li></ul><ul><li><p><code>u</code></p><p>x-direction baseline length in λ</p></li></ul><ul><li><p><code>v</code></p><p>y-direction baseline length in λ</p></li></ul><ul><li><p><code>time</code></p><p>Time of the observation in hours</p></li></ul><ul><li><p><code>baseline</code></p><p>station baseline codes</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/observations/observations.jl#LL274-L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.EHTVisibilityDatum" href="#Comrade.EHTVisibilityDatum"><code>Comrade.EHTVisibilityDatum</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A struct holding the information for a single measured visibility.</p><p><strong></strong></p><ul><li><p><code>visr</code></p><p>real component of the visibility (Jy)</p></li></ul><ul><li><p><code>visi</code></p><p>imaginary component of the visibility (Jy)</p></li></ul><ul><li><p><code>error</code></p><p>error of the visibility (Jy)</p></li></ul><ul><li><p><code>u</code></p><p>x-direction baseline length in λ</p></li></ul><ul><li><p><code>v</code></p><p>y-direction baseline length in λ</p></li></ul><ul><li><p><code>time</code></p><p>Time of the observation in hours</p></li></ul><ul><li><p><code>baseline</code></p><p>station baseline codes</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/observations/observations.jl#LL212-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.ExtendedRing" href="#Comrade.ExtendedRing"><code>Comrade.ExtendedRing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ExtendedRing{F} &lt;: Comrade.GeometricModel</code></pre><p>A symmetric extended ring whose radial profile follows an inverse gamma distributions.</p><p><strong>Note</strong></p><p>We mainly use this as an example of a non-analytic Fourier transform (although it has a complicated expression)</p><p><strong>Fields</strong></p><ul><li><p><code>shape</code></p><p>shape of the radial distribution</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/geometric_models.jl#LL257-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.FFTAlg" href="#Comrade.FFTAlg"><code>Comrade.FFTAlg</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FFTAlg &lt;: Comrade.FourierTransform</code></pre><p>Fourier transform type that specifies we will use the FFTW package to compute the Fourier transform.</p><p><strong>Fields</strong></p><ul><li><p><code>padfac</code></p><p>The amount to pad the image by. Note we actually round up to the nearest factor of 2, but this will be improved in the future to use small primes</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/modelimage/cache.jl#LL29-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.FFTCache" href="#Comrade.FFTCache"><code>Comrade.FFTCache</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FFTCache{A&lt;:FFTAlg, P, I, S} &lt;: Comrade.AbstractCache</code></pre><p>The cache used when the <code>FFT</code> algorithm is used to compute visibilties. This is an internal type and is not part of the public API</p><p><strong>Fields</strong></p><ul><li><p><code>alg</code></p></li><li><p><code>plan</code></p><p>FFTW Plan</p></li><li><p><code>img</code></p><p>image cache</p></li><li><p><code>sitp</code></p><p>FFT interpolator function</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/modelimage/fft_alg.jl#LL35-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.GainModel" href="#Comrade.GainModel"><code>Comrade.GainModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">`GainModel`</code></pre><p>Construct the corruption model for the telescope gains</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/calibration/gains.jl#LL83-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.Gaussian" href="#Comrade.Gaussian"><code>Comrade.Gaussian</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Gaussian{T} &lt;: Comrade.GeometricModel</code></pre><p>Gaussian geometrical model. This is a Gaussian with unit flux and standard deviation.</p><p><strong>Notes</strong></p><p>To change the Gaussian flux, and shape please use the modifier functions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/geometric_models.jl#LL26-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.GeometricModel" href="#Comrade.GeometricModel"><code>Comrade.GeometricModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type GeometricModel &lt;: ComradeBase.AbstractModel</code></pre><p>A type that defines it is a geometric model. These are usually primitive models, and are usually analytic in Fourier and the image domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/geometric_models.jl#LL11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.MRing" href="#Comrade.MRing"><code>Comrade.MRing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct MRing{T, N} &lt;: Comrade.GeometricModel</code></pre><p>m-ring geometric model. This corresponds to a delta ring with a fourier expansion in θ. The m in m-ring refers to the order of the Fourier expansion. The radius is unity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/geometric_models.jl#LL103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.ModelImage" href="#Comrade.ModelImage"><code>Comrade.ModelImage</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ModelImage{M, I, C} &lt;: Comrade.AbstractModelImage{M}</code></pre><p>Container for non-analytic model that contains a image cache which will hold the image, a Fourier transform cache C, which usually an instance of a &lt;: FourierCache which usually holds a interpolator that allows you to compute visibilities.</p><p><strong>Notes</strong></p><p>This is an internal implementation detail that shouldn&#39;t usually be called directly. Instead the user should use the exported function <code>modelimage</code>, for example</p><pre><code class="language-julia hljs">using Comrade
m = ExtendedRing(20.0, 5.0)

# This creates an version where the image is dynamically specified according to the
# radial extent of the image
mimg = modelimage(m) # you can also optionally pass the number of pixels nx and ny

# Or you can create an IntensityMap
img = intensitymap(m, 100.0, 100.0, 512, 512)
mimg = modelimage(m, img)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/modelimage/modelimage.jl#LL3-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.MultiRadioLikelihood-Tuple{Vararg{RadioLikelihood}}" href="#Comrade.MultiRadioLikelihood-Tuple{Vararg{RadioLikelihood}}"><code>Comrade.MultiRadioLikelihood</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">`MultiRadioLikelihood(lklhd1, lklhd2, ...)`</code></pre><p>Combines multiple likelihoods into one object that is useful for fitting multiple days/frequencies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/distributions/radiolikelihood.jl#LL16-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.NFFTAlg" href="#Comrade.NFFTAlg"><code>Comrade.NFFTAlg</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NFFTAlg</code></pre><p>Uses a non-uniform FFT to compute the visibilities. You can optionally pass uv which are the uv positions you will compute the NFFT at. This can allow for the NFFT plan to be cached improving performance</p><p><strong>Fields</strong></p><ul><li><p><code>padfac</code></p><p>Amount to pad the image</p></li></ul><ul><li><p><code>m</code></p><p>Controls the accuracy of the NFFT usually don&#39;t need to change this</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/modelimage/nuft.jl#LL191-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.NonAnalyticTest" href="#Comrade.NonAnalyticTest"><code>Comrade.NonAnalyticTest</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">`NonAnalyticTest`</code></pre><p>An internal model used primarly for testing. Any model passed to it will be interpreted as not having an analytic Fourier transform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/test.jl#LL2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.ParabolicSegment" href="#Comrade.ParabolicSegment"><code>Comrade.ParabolicSegment</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ParabolicSegment{F} &lt;: Comrade.GeometricModel</code></pre><p>A delta parabolic segment in the image domain. The segment is centered at zero, with roots ±1 and a yintercept of 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/geometric_models.jl#LL287-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.ParabolicSegment-Tuple{Any, Any}" href="#Comrade.ParabolicSegment-Tuple{Any, Any}"><code>Comrade.ParabolicSegment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ParabolicSegment(a, h)</code></pre><p>A parabolic segment with x-intercepts <code>±a</code><code>and a yintercept of</code>h``.</p><p><strong>Note</strong></p><p>This is just a convenience function for <code>stretched(ParabolicSegment(), a, h)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/geometric_models.jl#LL296-L302">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.PolarizedModel" href="#Comrade.PolarizedModel"><code>Comrade.PolarizedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct PolarizedModel{TI, TQ, TU, TV} &lt;: ComradeBase.AbstractPolarizedModel</code></pre><p>Wrapped model for a polarized model. This uses the stokes representation of the image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/polarized.jl#LL5-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.Posterior" href="#Comrade.Posterior"><code>Comrade.Posterior</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Posterior(lklhd, prior, model)</code></pre><p>Posterior density that follows obeys the <a href="https://github.com/JuliaMath/DensityInferface.jl">DensityInferface</a></p><p>The expected arguments are:</p><ul><li>lklhd: Which should be an intance of RadioLikelihood with whatever data products you want to fit</li><li>prior: This should be a <code>NamedTuple</code> with the priors for each model ParameterHandling</li><li>model: Function that takes a <code>NamedTuple</code> of parameters and constructs the <code>Comrade</code> model.</li></ul><p>To evaluate the logdensity of the posterior use can either use <code>DensityInterface.logdensityof</code> or <code>logdensity</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/bayes/bayes.jl#LL10-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.RadioLikelihood-Tuple{Vararg{Comrade.EHTObservation}}" href="#Comrade.RadioLikelihood-Tuple{Vararg{Comrade.EHTObservation}}"><code>Comrade.RadioLikelihood</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">`RadioLikelihood(data1, data2, ...)`</code></pre><p>Forms a radio likelihood from a set of data products. These data products must share the same array data/configuration. If you want to form a likelihood from multiple arrays such as when fitting different wavelengths or days, you can combine them using <code>MultiRadioLikelihood</code></p><pre><code class="language-julia hljs">lklhd1 = RadioLikelihood(dcphase1, dlcamp1)
lklhd2 = RadioLikelihood(dcphase2, dlcamp2)

lklhd = MultiRadioLikelihood(lklhd1, lklhd2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/distributions/radiolikelihood.jl#LL26-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.RenormalizedModel" href="#Comrade.RenormalizedModel"><code>Comrade.RenormalizedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RenormalizedModel{M&lt;:ComradeBase.AbstractModel, T} &lt;: Comrade.AbstractModifier{M&lt;:ComradeBase.AbstractModel}</code></pre><p>Renormalizes the flux of the model to the new value <code>flux</code>. We have also overloaded the Base.:* operator as syntactic sugar although I may get rid of this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/modifiers.jl#LL117-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.Ring" href="#Comrade.Ring"><code>Comrade.Ring</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Ring{T} &lt;: Comrade.GeometricModel</code></pre><p>m-ring geometric model. This corresponds to a delta ring with a fourier expansion in θ. The m in m-ring refers to the order of the Fourier expansion. The radius is unity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/geometric_models.jl#LL72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.RotatedModel" href="#Comrade.RotatedModel"><code>Comrade.RotatedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RotatedModel{M&lt;:ComradeBase.AbstractModel, T} &lt;: Comrade.AbstractModifier{M&lt;:ComradeBase.AbstractModel}</code></pre><p>Type for the rotated model. This is more fine grained constrol of rotated model. In most use cases the end-user should be using the <code>rotate</code> method e.g.</p><pre><code class="language-julia hljs">rotate(model, ξ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/modifiers.jl#LL190-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.ShiftedModel" href="#Comrade.ShiftedModel"><code>Comrade.ShiftedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ShiftedModel{T, M&lt;:ComradeBase.AbstractModel} &lt;: Comrade.AbstractModifier{M&lt;:ComradeBase.AbstractModel}</code></pre><p>Shifts the model by <code>Δx</code> units in the x-direction and <code>Δy</code> units in the y-direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/modifiers.jl#LL90-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.StretchedModel" href="#Comrade.StretchedModel"><code>Comrade.StretchedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct StretchedModel{M&lt;:ComradeBase.AbstractModel, T} &lt;: Comrade.AbstractModifier{M&lt;:ComradeBase.AbstractModel}</code></pre><p>Stretched the model in the x and y directions, i.e. the new intensity is</p><p class="math-container">\[    I_s(x,y) = 1/(αβ) I(x/α, y/β),\]</p><p>where were renormalize the intensity to preserve the models flux.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/models/modifiers.jl#LL157-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.TransformedPosterior" href="#Comrade.TransformedPosterior"><code>Comrade.TransformedPosterior</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">`</code></pre><pre><code class="language-julia hljs">struct TransformedPosterior{P&lt;:Posterior, T}</code></pre><p><code>A transformed version of the posterior</code>lpost`. This is an internal type that an end user shouldn&#39;t have to directly construct.</p><p>To construct a transformed posterior see the <code>asflat</code>, <code>ascube</code>, and <code>flatten</code> functions.</p><p>When evaluating the <code>logdensity</code> of the <code>TransformedPosterior</code>, <code>logdenisty</code> will include any jacobian terms automatically, and expects the argument to be the vector of transformed quantities. This is usually easier to incorporate with samplers, and optimizers, which expect homogenous vectors as arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ab83521fe22b40436d4390ec06972e7f81d20476/src/bayes/bayes.jl#LL55-L67">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../base_api/">« ComradeBase API</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.18 on <span class="colophon-date" title="Sunday 29 May 2022 20:41">Sunday 29 May 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
