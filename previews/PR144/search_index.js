var documenterSearchIndex = {"docs":
[{"location":"base_api/#ComradeBase-API","page":"ComradeBase API","title":"ComradeBase API","text":"","category":"section"},{"location":"base_api/#Contents","page":"ComradeBase API","title":"Contents","text":"","category":"section"},{"location":"base_api/","page":"ComradeBase API","title":"ComradeBase API","text":"Pages = [\"base_api.md\"]","category":"page"},{"location":"base_api/#Index","page":"ComradeBase API","title":"Index","text":"","category":"section"},{"location":"base_api/","page":"ComradeBase API","title":"ComradeBase API","text":"Pages = [\"base_api.md\"]","category":"page"},{"location":"base_api/","page":"ComradeBase API","title":"ComradeBase API","text":"CurrentModule = ComradeBase","category":"page"},{"location":"base_api/","page":"ComradeBase API","title":"ComradeBase API","text":"ComradeBase.PrimitiveTrait\nComradeBase.IsPrimitive\nComradeBase.NotPrimitive\nComradeBase.isprimitive\nComradeBase.DensityAnalytic\nComradeBase.IsAnalytic\nComradeBase.NotAnalytic\nComradeBase.visanalytic\nComradeBase.imanalytic\nComradeBase.visibility_point\nComradeBase.intensity_point\nComradeBase.IntensityMap\nComradeBase.intensitymap!\nComradeBase.intensitymap\nComradeBase.Pulse\nComradeBase.DeltaPulse\nComradeBase.SqExpPulse\nComradeBase.BSplinePulse\nComradeBase.StokesVector\nComradeBase.CoherencyMatrix\nComradeBase.evpa\nComradeBase.m̆\nComradeBase.SingleStokes\nComradeBase.ThreadedModel","category":"page"},{"location":"base_api/#ComradeBase.PrimitiveTrait","page":"ComradeBase API","title":"ComradeBase.PrimitiveTrait","text":"abstract type PrimitiveTrait\n\nThis trait specifies whether the model is a primitive\n\nNotes\n\nThis will likely turn into a trait in the future so people can inject their models into Comrade more easily.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.IsPrimitive","page":"ComradeBase API","title":"ComradeBase.IsPrimitive","text":"struct IsPrimitive\n\nTrait for primitive model\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.NotPrimitive","page":"ComradeBase API","title":"ComradeBase.NotPrimitive","text":"struct NotPrimitive\n\nTrait for not-primitive model\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.isprimitive","page":"ComradeBase API","title":"ComradeBase.isprimitive","text":"isprimitive(::Type)\n\nDispatch function that specifies whether a type is a primitive Comrade model. This function is used for dispatch purposes when composing models.\n\nNotes\n\nIf a user is specifying their own model primitive model outside of Comrade they need to specify if it is primitive\n\nstruct MyPrimitiveModel end\nComradeBase.isprimitive(::Type{MyModel}) = ComradeBase.IsPrimitive()\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.DensityAnalytic","page":"ComradeBase API","title":"ComradeBase.DensityAnalytic","text":"DensityAnalytic\n\nInternal type for specifying the nature of the model functions. Whether they can be easily evaluated pointwise analytic. This is an internal type that may change.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.IsAnalytic","page":"ComradeBase API","title":"ComradeBase.IsAnalytic","text":"struct IsAnalytic <: ComradeBase.DensityAnalytic\n\nDefines a trait that a states that a model is analytic. This is usually used with an abstract model where we use it to specify whether a model has a analytic fourier transform and/or image.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.NotAnalytic","page":"ComradeBase API","title":"ComradeBase.NotAnalytic","text":"struct NotAnalytic <: ComradeBase.DensityAnalytic\n\nDefines a trait that a states that a model is analytic. This is usually used with an abstract model where we use it to specify whether a model has does not have a easy analytic fourier transform and/or intensity function.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.visanalytic","page":"ComradeBase API","title":"ComradeBase.visanalytic","text":"visanalytic(::Type{<:AbstractModel})\n\nDetermines whether the model is pointwise analytic in Fourier domain, i.e. we can evaluate its fourier transform at an arbritrary point.\n\nIf IsAnalytic() then it will try to call visibility_point to calculate the complex visibilities. Otherwise it fallback to using the FFT that works for all models that can compute an image.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.imanalytic","page":"ComradeBase API","title":"ComradeBase.imanalytic","text":"imanalytic(::Type{<:AbstractModel})\n\nDetermines whether the model is pointwise analytic in the image domain, i.e. we can evaluate its intensity at an arbritrary point.\n\nIf IsAnalytic() then it will try to call intensity_point to calculate the intensity.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.visibility_point","page":"ComradeBase API","title":"ComradeBase.visibility_point","text":"Function that computes the pointwise visibility if the model has the trait in the fourier domain IsAnalytic(). Otherwise it will use the FFTW fallback.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.intensity_point","page":"ComradeBase API","title":"ComradeBase.intensity_point","text":"Function that computes the pointwise intensity if the model has the trait in the image domain IsAnalytic(). Otherwise it will use construct the image in visibility space and invert it.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.IntensityMap","page":"ComradeBase API","title":"ComradeBase.IntensityMap","text":"struct IntensityMap{T, S<:(AbstractMatrix), F, K<:ComradeBase.Pulse} <: ComradeBase.AbstractIntensityMap{T, S<:(AbstractMatrix)}\n\nImage array type. This is an Matrix with a number of internal fields to describe the field of view, pixel size, and the pulse function that makes the image a continuous quantity.\n\nTo use it you just specify the array and the field of view/pulse julia img = IntensityMap(zeros(512512) 1000 1000)`\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.intensitymap!","page":"ComradeBase API","title":"ComradeBase.intensitymap!","text":"Computes the intensity map of model by modifying the input IntensityMap object\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.intensitymap","page":"ComradeBase API","title":"ComradeBase.intensitymap","text":"Computes the intensity map of model. This version requires additional information to construct the grid.\n\nExample\n\nm = Gaussian()\n# field of view\nfovx, fovy = 5.0\nfovy = 5.0\n# number of pixels\nnx, ny = 128\n\nimg = intensitymap(m, fovx, fovy, nx, ny; pulse=DeltaPulse())\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.Pulse","page":"ComradeBase API","title":"ComradeBase.Pulse","text":"Pulse Pixel response function for a radio image model. This makes a discrete sampling continuous by picking a certain smoothing kernel for the image.\n\nNotes\n\nTo see the implemented Pulses please use the subtypes function i.e. subtypes(Pulse)\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.DeltaPulse","page":"ComradeBase API","title":"ComradeBase.DeltaPulse","text":"struct DeltaPulse{T} <: ComradeBase.Pulse\n\nA dirac comb pulse function. This means the image is just the dicrete Fourier transform\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.SqExpPulse","page":"ComradeBase API","title":"ComradeBase.SqExpPulse","text":"struct SqExpPulse{T} <: ComradeBase.Pulse\n\nNormalized square exponential kernel, i.e. a Gaussian. Note the smoothness is modfied with ϵ which is the inverse variance in units of 1/pixels².\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.BSplinePulse","page":"ComradeBase API","title":"ComradeBase.BSplinePulse","text":"$(TYPEDEF)\n\nUses the basis spline (BSpline) kernel of order N. These are the kernel that come from recursively convolving the tophat kernel\n\n    B_0(x) = begincases 1  x  1  0  otherwise endcases\n\nN times.\n\nNotes\n\nBSpline kernels have a number of nice properties:\n\nSimple frequency response sinc(u2)^N\npreserve total intensity\n\nFor N>1 these kernels aren't actually interpolation kernels however, this doesn't matter for us.\n\nCurrently only the 0,1,3 order kernels are implemented.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.StokesVector","page":"ComradeBase API","title":"ComradeBase.StokesVector","text":"struct StokesVector{T} <: StaticArrays.FieldVector{4, T}\n\nStatic vector that holds the stokes parameters of a polarized complex visibility\n\nTo convert between a StokesVector and CoherencyMatrix use the convert function\n\nconvert(::CoherencyMatrix, StokesVector(1.0, 0.1, 0.1, 0.4))\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.CoherencyMatrix","page":"ComradeBase API","title":"ComradeBase.CoherencyMatrix","text":"struct CoherencyMatrix{T} <: StaticArrays.FieldMatrix{2, 2, T}\n\nStatic matrix that holds construct the coherency matrix of a polarized complex visibility\n\nTo convert between a StokesVector and CoherencyMatrix use the convert function\n\nconvert(::StokesVector, CoherencyMatrix(1.0, 0.1, 0.1, 0.4))\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.evpa","page":"ComradeBase API","title":"ComradeBase.evpa","text":"evpa(m)\n\n\nCompute the evpa of a stokes vector or cohereny matrix.\n\n\n\n\n\nevpa(pimg, u, v)\n\n\nelectric vector position angle or EVPA of the polarized model\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.m̆","page":"ComradeBase API","title":"ComradeBase.m̆","text":"m̆(m)\n\n\nCompute the fractional linear polarization of a stokes vector or coherency matrix\n\n\n\n\n\nm̆(pimg, u, v)\n\n\nComputes the fractional linear polarization in the visibility domain\n\n    brevem = fracQ + iUI\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.SingleStokes","page":"ComradeBase API","title":"ComradeBase.SingleStokes","text":"struct SingleStokes{M, S} <: ComradeBase.AbstractModel\n\nHelper function that converts a model from something that compute polarized images to just a single stokes parameter. This is useful if you just want to fit a single stokes parameter.\n\n\n\n\n\n","category":"type"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"EditURL = \"https://github.com/ptiede/Comrade.jl/blob/main/docs/src/examples/data.jl\"","category":"page"},{"location":"examples/data/#Loading-Data-into-Comrade","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"","category":"section"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"The VLBI field does not have a standarized data format, and the EHT uses a particular uvfits format that is similar to the optical interferometry oifits format. As a result, we reuse the excellent eht-imaging package to load data into Comrade.","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"Once the data is loaded we then convert the data into the tabular format Comrade expects. Note that in the future this may change to a Julia package as the Julia radio astronomy group grows.","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"To get started we will load Comrade and Plots to enable visualizations of the data","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"using Comrade\nusing Plots","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"Now we load ehtim. This assumes you have a working installation of eht-imaging. To install eht-imaging see the ehtim github repo.","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"load_ehtim()","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"Now we load the data. We will use the 2017 public M87 data which can be downloaded from cyverse","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"obs = ehtim.obsdata.load_uvfits(joinpath(@__DIR__, \"../assets/SR1_M87_2017_096_lo_hops_netcal_StokesI.uvfits\"))","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"Add scan and coherently average over them. The eht data has been phase calibrated so that this is fine to do.","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"obs.add_scans()\nobs = obs.avg_coherent(0.0, scan_avg=true)","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"We can now extract data products that Comrade can use","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"vis = extract_vis(obs) #complex visibilites\namp = extract_amp(obs) # visibility amplitudes\ncphase = extract_cphase(obs) # extract minimal set of closure phases\nlcamp = extract_lcamp(obs) # extract minimal set of log-closure amplitudes","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"We can also recover the array used in the observation using","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"ac = arrayconfig(vis)\nplot(ac) # Plot the baseline coverage","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"To plot the data we just call","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"l = @layout [a b; c d]\npv = plot(vis)\npa = plot(amp)\npcp = plot(cphase)\nplc = plot(lcamp)\n\nplot(pv, pa, pcp, plc; layout=l)","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/#Comrade-API","page":"Comrade API","title":"Comrade API","text":"","category":"section"},{"location":"api/#Contents","page":"Comrade API","title":"Contents","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api/#Index","page":"Comrade API","title":"Index","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Modules = [Comrade]\nOrder   = [:function, :type]","category":"page"},{"location":"api/#Comrade.Crescent-NTuple{4, Any}","page":"Comrade API","title":"Comrade.Crescent","text":"Creates a Kamruddin and Dexter crescent model. This works by composing two disk models together.\n\nArguments\n\nrouter: The radius of the outer disk\nrinner: The radius of the inner disk\nshift: How much the inner disk radius is shifted (positive is to the right)\nfloor: The floor of the inner disk 0 means the inner intensity is zero and 1 means it is a large disk.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.amplitude-Tuple{Any, Vararg{Any}}","page":"Comrade API","title":"Comrade.amplitude","text":"amplitude(model, args)\n\n\nComputes the visibility amplitude of model m at u,v positions u,v\n\nIf you want to compute the amplitudes at a large number of positions consider using the amplitudes function.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.amplitude-Tuple{Comrade.EHTVisibilityDatum}","page":"Comrade API","title":"Comrade.amplitude","text":"amplitude(D)\n\n\nGet the amplitude of a visibility datum\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.amplitudes-Tuple{Any, AbstractArray, AbstractArray}","page":"Comrade API","title":"Comrade.amplitudes","text":"amplitudes(m, u, v)\n\n\nComputes the amplitudes of the model m at the u,v positions u, v.\n\nNotes\n\nIf this is a analytic model this is done lazily so the visibilites are only computed when accessed. Otherwise for numerical model computed with NFFT this is eager.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.arrayconfig-Tuple{Comrade.EHTObservation}","page":"Comrade API","title":"Comrade.arrayconfig","text":"arrayconfig(vis)\n\n\nExtract the array configuration from a visibility EHT observation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.basemodel-Tuple{Comrade.AbstractModifier}","page":"Comrade API","title":"Comrade.basemodel","text":"basemodel(model)\n\n\nReturns the base model from a modified model.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.bispectra-Tuple{Any, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray}","page":"Comrade API","title":"Comrade.bispectra","text":"bispectra(m, u1, v1, u2, v2, u3, v3)\n\n\nComputes the bispectra of the model m at the triangles (u1,v1), (u2,v2), (u3,v3).\n\nNote this is done lazily so the bispectra is only computed when accessed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.bispectrum-NTuple{7, Any}","page":"Comrade API","title":"Comrade.bispectrum","text":"bispectrum(model, u1, v1, u2, v2, u3, v3)\n\n\nComputes the complex bispectrum of model m at the uv-triangle u1,v1 -> u2,v2 -> u3,v3\n\nIf you want to compute the bispectrum over a number of triangles consider using the bispectra function.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.closure_phase-NTuple{7, Any}","page":"Comrade API","title":"Comrade.closure_phase","text":"closure_phase(model, u1, v1, u2, v2, u3, v3)\n\n\nComputes the closure phase of model m at the uv-triangle u1,v1 -> u2,v2 -> u3,v3\n\nIf you want to compute closure phases over a number of triangles consider using the closure_phases function.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.closure_phase-Tuple{Comrade.EHTVisibilityDatum, Comrade.EHTVisibilityDatum, Comrade.EHTVisibilityDatum}","page":"Comrade API","title":"Comrade.closure_phase","text":"closure_phase(D1, D2, D3)\n\n\nComputes the closure phase of the three visibility datums.\n\nNotes\n\nWe currently use the high SNR Gaussian error approximation for the closure phase. In the future we may use the moment matching from Monte Carlo sampling.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.closure_phases-Tuple{AbstractArray{<:Complex}, Comrade.ArrayConfiguration}","page":"Comrade API","title":"Comrade.closure_phases","text":"`closure_phases(vis, ac::ArrayConfiguration)`\n\nCompute the closure phases for a set of visibilities and an array configuration\n\nNotes\n\nThis uses a closure design matrix for the computation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.closure_phases-Tuple{ComradeBase.AbstractModel, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray}","page":"Comrade API","title":"Comrade.closure_phases","text":"closure_phases(m, u1, v1, u2, v2, u3, v3)\n\n\nComputes the closure phases of the model m at the triangles (u1,v1), (u2,v2), (u3,v3).\n\nNote this is done lazily so the closure_phases is only computed when accessed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.coherencymatrix-Tuple{PolarizedModel, Any, Any}","page":"Comrade API","title":"Comrade.coherencymatrix","text":"coherencymatrix(pimg, u, v)\n\n\nComputes the coherency matrix of the polarized model.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.components-Tuple{ComradeBase.AbstractModel}","page":"Comrade API","title":"Comrade.components","text":"components(m)\n\n\nReturns the components for a composite model. This will return a Tuple with all the models you have constructed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.convolved-Tuple{Any, Any}","page":"Comrade API","title":"Comrade.convolved","text":"convolved(m1, m2)\n\n\nConvolves two models m1 and m2. This is done lazily.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.create_cache","page":"Comrade API","title":"Comrade.create_cache","text":"create_cache(alg, img)\n\nCreates a Fourier transform cache for a img. This is usually called internally for ModelImage. However, in certain circumstances the end-user can call this to speed up a method.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.create_cache-Tuple{FFTAlg, Any}","page":"Comrade API","title":"Comrade.create_cache","text":"create_cache(alg, img)\n\n\nCreates the model cache given for the algorithm alg using the model and a image cache image\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.extract_amp-Tuple{Any}","page":"Comrade API","title":"Comrade.extract_amp","text":"extract_amp(obs)\n\nExtracts the visibility amplitudes from an ehtim observation object.\n\nAny valid keyword arguments to add_amp in ehtim can be passed through extract_amp.\n\nReturns an EHTObservation with visibility amplitude data\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.extract_cphase-Tuple{Any}","page":"Comrade API","title":"Comrade.extract_cphase","text":"extract_cphase(obs)\n\nExtracts the closure phases from an ehtim observation object\n\nAny valid keyword arguments to add_cphase in ehtim can be passed through extract_cphase.\n\nReturns an EHTObservation with closure phases datums\n\nKeyword arguments:\n\ncount: How the closures are formed, the available options are \"min-correct\", \"min\", \"max\"\ncut_trivial: Cut the trivial triangles from the closures\nuvmin: The flag to decide what are trivial triangles. Any baseline with ||(u,v)|| < uvmin        are removed.\n\nWarning\n\nThe count keyword argument is treated specially in Comrade. The default option is \"min-correct\" and should almost always be used. This option construct a minimal set of closure phases that is valid even when the array isn't fully connected. For testing and legacy reasons we ehtim other count options are also included. However, the current ehtim count=\"min\" option is broken and does construct proper minimal sets of closure quantities if the array isn't fully connected.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.extract_lcamp-Tuple{Any}","page":"Comrade API","title":"Comrade.extract_lcamp","text":"extract_lcamp(obs)\n\nExtracts the log-closure amp. from an ehtim observation object\n\nAny valid keyword arguments to add_logcamp in ehtim can be passed through extract_lcamp.\n\nReturns an EHTObservation with log-closure amp. datums\n\nWarning\n\nThe count keyword argument is treated specially in Comrade. The default option is \"min-correct\" and should almost always be used. This option construct a minimal set of closure phases that is valid even when the array isn't fully connected. For testing and legacy reasons we ehtim other count options are also included. However, the current ehtim count=\"min\" option is broken and does construct proper minimal sets of closure quantities if the array isn't fully connected.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.extract_vis-Tuple{Any}","page":"Comrade API","title":"Comrade.extract_vis","text":"extract_vis(obs)\n\nExtracts the complex visibilities from an ehtim observation object\n\nThis grabs the raw data object from the obs object. Any keyword arguments are ignored.\n\nReturns an EHTObservation with complex visibility data\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.fileio_load-Tuple{FileIO.File{FileIO.DataFormat{:FITS}}, Type{IntensityMap}}","page":"Comrade API","title":"Comrade.fileio_load","text":"    `load(fitsfile::String, IntensityMap)`\n\nThis loads in a fits file that is more robust to the various imaging algorithms in the EHT, i.e. is works with clean, smili, eht-imaging. The function returns an tuple with an intensitymap and a second named tuple with ancillary information about the image, like the source name, location, mjd, and radio frequency.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.fileio_save","page":"Comrade API","title":"Comrade.fileio_save","text":"`\n\nfileio_save(fname, img)\nfileio_save(fname, img, obs)\n\n\n` Saves an image to a fits file. You can optionally pass an EHTObservation so that ancillary information will be added.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.getuv-Tuple{Comrade.ArrayConfiguration}","page":"Comrade API","title":"Comrade.getuv","text":"getuv(ac)\n\n\nGet the u, v positions of the array.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.load_ehtim-Tuple{}","page":"Comrade API","title":"Comrade.load_ehtim","text":"load_ehtim()\n\n\nLoads the eht-imaging library and stores it in the ehtim variable.\n\nNotes\n\nThis will fail if ehtim isn't installed in the python installation that PyCall references.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.load_tpy-Tuple{Any}","page":"Comrade API","title":"Comrade.load_tpy","text":"load_tpy(file)\n\n\nLoad a ThemisPy style ascii EHT observation file.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.logclosure_amplitude-NTuple{9, Any}","page":"Comrade API","title":"Comrade.logclosure_amplitude","text":"logclosure_amplitude(model, u1, v1, u2, v2, u3, v3, u4, v4)\n\n\nComputes the log-closure amplitude of model m at the uv-quadrangle u1,v1 -> u2,v2 -> u3,v3 -> u4,v3 using the formula\n\nC = logleftfracV(u1v1)V(u2v2)V(u3v3)V(u4v4)right\n\nIf you want to compute log closure amplitudes over a number of triangles consider using the logclosure_amplitudes function.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.logclosure_amplitudes-Tuple{AbstractArray{<:Complex}, Comrade.ArrayConfiguration}","page":"Comrade API","title":"Comrade.logclosure_amplitudes","text":"`logclosure_amplitudes(vis, ac::ArrayConfiguration)`\n\nCompute the log-closure amplitudes for a set of visibilities and an array configuration\n\nNotes\n\nThis uses a closure design matrix for the computation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.logclosure_amplitudes-Tuple{ComradeBase.AbstractModel, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray}","page":"Comrade API","title":"Comrade.logclosure_amplitudes","text":"logclosure_amplitudes(m, u1, v1, u2, v2, u3, v3, u4, v4)\n\n\nComputes the log closure amplitudes of the model m at the quadrangles (u1,v1), (u2,v2), (u3,v3), (u4, v4).\n\nNote this is done lazily so the log closure amplitude is only computed when accessed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.modelimage-Tuple{M} where M","page":"Comrade API","title":"Comrade.modelimage","text":"Construct a ModelImage where just the model m is specified\n\nNotes\n\nIf m IsAnalytic() is the visibility domain this is a no-op and just returns the model itself. Otherwise modelimage will guess a reasonable field of view based on the radialextent function. One can optionally pass the number of pixels nx and ny in each direction.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.modelimage-Union{Tuple{M}, Tuple{M, ComradeBase.AbstractIntensityMap}, Tuple{M, ComradeBase.AbstractIntensityMap, Comrade.FourierTransform}, Tuple{M, ComradeBase.AbstractIntensityMap, Comrade.FourierTransform, Any}} where M","page":"Comrade API","title":"Comrade.modelimage","text":"modelimage(model, image)\nmodelimage(model, image, alg)\nmodelimage(model, image, alg, executor)\nmodelimage(m; fovx, fovy, nx, ny, pulse, alg, executor)\n\n\nConstruct a ModelImage from a model, image and the optionally specified visibility algorithm alg\n\nNotes\n\nFor analytic models this is a no-op and just return the model. For non-analytic models this wraps the model in a object with an image and precomputes the fourier transform using alg.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.prior_sample-Tuple{Posterior, Vararg{Any}}","page":"Comrade API","title":"Comrade.prior_sample","text":"prior_sample(post, args)\n\n\nSamples the prior distribution from the posterior nsamples times.\n\nReturns a Vector{NamedTuple} that can be used to initialize optimization and sample algorithms\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.rad2μas-Tuple{Any}","page":"Comrade API","title":"Comrade.rad2μas","text":"rad2μas(x)\n\nConverts a number from radians to μas\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.renormed-Union{Tuple{M}, Tuple{M, Any}} where M<:ComradeBase.AbstractModel","page":"Comrade API","title":"Comrade.renormed","text":"renormed(model, f)\n\n\nRenormalizes the model m to have total flux flux.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.rescaleuv!-Union{Tuple{D}, Tuple{T}, Tuple{Comrade.EHTObservation{T, D, S} where S<:(StructArrays.StructArray{D}), Any}} where {T, D<:Union{Comrade.EHTVisibilityAmplitudeDatum, Comrade.EHTVisibilityDatum}}","page":"Comrade API","title":"Comrade.rescaleuv!","text":"rescaleuv!(data)\n\nrescale the u-v lengths according to scale. This can be useful when you want the spatial scales to be in 1/μas instead of 1/rad\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.rotated-Tuple{Any, Any}","page":"Comrade API","title":"Comrade.rotated","text":"rotated(model, ξ)\n\n\nRotates the model by an amount ξ in radians.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.scantable-Tuple{Any}","page":"Comrade API","title":"Comrade.scantable","text":"`scantable(obs)`\n\nReorganizes the observation into a table of scans, where scan are defined by unique timestamps. To access the data you can use scalar indexing\n\nExample\n\nst = scantable(obs)\n# Grab the first scan\nscan1 = st[1]\n\n# Acess the detections in the scan\nscan1[1]\n\n# grab e.g. the baselines\nscan1[:baseline]\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.shifted-Tuple{Any, Any, Any}","page":"Comrade API","title":"Comrade.shifted","text":"shifted(model, Δx, Δy)\n\n\nShifts the model m in the image domain by an amount Δx,Δy.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.smoothed-Tuple{Any, Number}","page":"Comrade API","title":"Comrade.smoothed","text":"smoothed(m, σ)\n\n\nSmooths a model m with a Gaussian kernel with standard deviation σ.\n\nNotes\n\nThis will created a convolved model under the hood.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.stations-Union{Tuple{Comrade.EHTObservation{T, A, S} where S<:(StructArrays.StructArray{A})}, Tuple{A}, Tuple{T}} where {T, A<:Comrade.AbstractInterferometryDatum}","page":"Comrade API","title":"Comrade.stations","text":"Get all the stations in a observation. The result is a vector of symbols.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.stretched-Tuple{Any, Any, Any}","page":"Comrade API","title":"Comrade.stretched","text":"stretched(model, α, β)\n\n\nStretches the model m according to the formula\n\n    I_s(xy) = 1(αβ) I(xα yβ)\n\nwhere were renormalize the intensity to preserve the models flux.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.update_cache","page":"Comrade API","title":"Comrade.update_cache","text":"update_cache(cache, img)\n\nUpdate the Fourier transform cache. This will reuse an FFT/NFFT plan saving some computational time.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.uviterator-NTuple{4, Any}","page":"Comrade API","title":"Comrade.uviterator","text":"uviterator(dx, dy, nnx, nny)\n\n\nConstruct the u,v iterators for the Fourier transform of the image with pixel sizes dx, dy and number of pixels nx, ny\n\nIf you are extending Fourier transform stuff please use these functions to ensure that the centroid is being properly computed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.uvpositions-Tuple{Comrade.AbstractVisibilityDatum}","page":"Comrade API","title":"Comrade.uvpositions","text":"uvpositions(datum)\n\nGet the uvp positions of an inferometric datum.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.uvtimefreq-Tuple{Comrade.EHTArrayConfiguration}","page":"Comrade API","title":"Comrade.uvtimefreq","text":"uvtimefreq(ac)\n\n\nGet the u, v, time, freq of the array as a tuple.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.visibility-Tuple{PolarizedModel, Any, Any}","page":"Comrade API","title":"Comrade.visibility","text":"visibility(pimg, u, v)\n\n\nComputes the visibility in the stokes basis of the polarized model\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.visibility-Union{Tuple{Comrade.EHTVisibilityDatum{T}}, Tuple{T}} where T","page":"Comrade API","title":"Comrade.visibility","text":"Return the complex visibility of the visibility datum\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.visibility-Union{Tuple{M}, Tuple{M, Vararg{Any}}} where M","page":"Comrade API","title":"Comrade.visibility","text":"visibility(mimg, args)\n\n\nComputes the complex visibility of model m at u,v positions u,v\n\nIf you want to compute the visibilities at a large number of positions consider using the visibilities function\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.μas2rad-Tuple{Any}","page":"Comrade API","title":"Comrade.μas2rad","text":"μas2rad(x)\n\nConverts a number from μas to rad\n\n\n\n\n\n","category":"method"},{"location":"api/#ComradeBase.evpa-Tuple{Any, Any, Any}","page":"Comrade API","title":"ComradeBase.evpa","text":"evpa(pimg, u, v)\n\n\nelectric vector position angle or EVPA of the polarized model\n\n\n\n\n\n","category":"method"},{"location":"api/#ComradeBase.intensitymap!-Tuple{IntensityMap{<:StokesVector}, PolarizedModel}","page":"Comrade API","title":"ComradeBase.intensitymap!","text":"intensitymap!(pimg, pmodel)\n\n\nFinds the polarized intensity map of the polarized model pmodel.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComradeBase.m̆-Tuple{Any, Any, Any}","page":"Comrade API","title":"ComradeBase.m̆","text":"m̆(pimg, u, v)\n\n\nComputes the fractional linear polarization in the visibility domain\n\n    brevem = fracQ + iUI\n\n\n\n\n\n","category":"method"},{"location":"api/#HypercubeTransform.ascube-Tuple{Posterior}","page":"Comrade API","title":"HypercubeTransform.ascube","text":"ascube(post::Posterior)\n\nConstruct a flattened version of the posterior, where the parameters are transformed to live in the unit hypercube. In astronomy parlance, we are transforming the variables to the unit hypercube. This is done using the HypercubeTransform package.\n\nThe transformed posterior can then be evaluated by the logdensityof(transformed_posterior,x) method following the DensityInterface, where x vector that lives in the unit hypercube. Note this already includes the jacobian of the transformation so this does not need to be added.\n\nThis transform is useful for NestedSampling methods that often assume that the model is written to live in the unit hypercube.\n\n\n\n\n\n","category":"method"},{"location":"api/#HypercubeTransform.asflat-Tuple{Posterior}","page":"Comrade API","title":"HypercubeTransform.asflat","text":"asflat(post::Posterior)\n\nConstruct a flattened version of the posterior, where the parameters are transformed so that their support is from (-∞, ∞). This uses TransformVariables\n\nThe transformed posterior can then be evaluated by the logdensityof(transformed_posterior,x) method following the DensityInterface, where x is a flattened vector of the infinite support variables. Note this already includes the jacobian of the transformation so this does not need to be added.\n\nThis is useful for optimization and sampling algorithms such as HMC that will use gradients to explore the posterior surface.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParameterHandling.flatten-Tuple{Posterior}","page":"Comrade API","title":"ParameterHandling.flatten","text":"flatten(post::Posterior)\n\nFlatten the representation of the posterior. Internally this uses ParameterHandling to construct a flattened version of the posterior.\n\nNote this is distinct from asflat that transforms the variables to live in (-∞,∞). Instead this method just flattens the repsentation of the model from a NamedTuple to a vector. This allows the easier integration to optimization and sampling algorithms.\n\n\n\n\n\n","category":"method"},{"location":"api/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, ComradeBase.AbstractModel}","page":"Comrade API","title":"RecipesBase.apply_recipe","text":"plot(image::AbstractModel)\n\nwhere image is templated off of EHTImage struct.\n\nDetails\n\nThis was created to be close to the ehtim display object. It takes an EHTImage object and plots it according to EHT conventions.\n\nNote that is does not save the figure.\n\n\n\n\n\n","category":"method"},{"location":"api/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, IntensityMap}","page":"Comrade API","title":"RecipesBase.apply_recipe","text":"plot(image::IntensityMap)\n\nwhere image is templated off of EHTImage struct.\n\nDetails\n\nThis was created to be close to the ehtim display object. It takes an EHTImage object and plots it according to EHT conventions.\n\nNote that is does not save the figure.\n\n\n\n\n\n","category":"method"},{"location":"api/#TransformVariables.inverse-Tuple{Comrade.TransformedPosterior, Any}","page":"Comrade API","title":"TransformVariables.inverse","text":"inverse(posterior::TransformedPosterior, x)\n\nTransforms the value model parameters x into the flattened transformed space.\n\n\n\n\n\n","category":"method"},{"location":"api/#TransformVariables.transform-Tuple{Comrade.TransformedPosterior, Any}","page":"Comrade API","title":"TransformVariables.transform","text":"transform(posterior::TransformedPosterior, x)\n\nTransforms the value x into parameter space, i.e. usually a NamedTuple.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.AbstractCache","page":"Comrade API","title":"Comrade.AbstractCache","text":"abstract type AbstractCache\n\nThis defines an abstract cache that can be used to hold or precompute some computations.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.AbstractInterferometryDatum","page":"Comrade API","title":"Comrade.AbstractInterferometryDatum","text":"abstract type AbstractInterferometryDatum{T}\n\nAn abstract type for all VLBI interfermetry data types. See EHTVisibilityDatum for an example.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.AbstractModifier","page":"Comrade API","title":"Comrade.AbstractModifier","text":"abstract type AbstractModifier{M<:ComradeBase.AbstractModel} <: ComradeBase.AbstractModel\n\nAbstract type for image modifiers. These are some model wrappers that can transform any model using simple Fourier transform properties. To see the implemented modifier\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.AddModel","page":"Comrade API","title":"Comrade.AddModel","text":"struct AddModel{T1, T2} <: Comrade.CompositeModel{T1, T2}\n\nAdds two models together to create composite models. Note that I may change this in the future so make it easier on the compiler, i.e. make the composite model a fancy model vector and heap allocate stuff. This should help when combining multiple models together.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ArrayBaselineDatum","page":"Comrade API","title":"Comrade.ArrayBaselineDatum","text":"struct ArrayBaselineDatum{T}\n\nA single datum of an observing array.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ArrayConfiguration","page":"Comrade API","title":"Comrade.ArrayConfiguration","text":"abstract type ArrayConfiguration\n\nThis defined the abstract type for an array configuration. Namely, baseline times, SEFD's, bandwidth, observation frequencies, etc.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ClosureConfig","page":"Comrade API","title":"Comrade.ClosureConfig","text":"struct ClosureConfig{A, D} <: Comrade.ArrayConfiguration\n\nArray config file for closure quantities. This stores the design matrix designmat that transforms from visibilties to closure products.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.CompositeModel","page":"Comrade API","title":"Comrade.CompositeModel","text":"abstract type CompositeModel{M1, M2} <: ComradeBase.AbstractModel\n\nAbstract type that denotes a composite model. Where we have combined two models together.\n\nImplementation\n\nAny implementation of a composite type must define the following methods:\n\nvisibility_point\nuv_combinator\nimanalytic\nvisanalytic\nComradeBase.intensity_point if model intensity is IsAnalytic\nintensitymap! if model intensity is NotAnalytic\nintensitymap if model intensity is NotAnalytic\nflux\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ConcordanceCrescent","page":"Comrade API","title":"Comrade.ConcordanceCrescent","text":"struct ConcordanceCrescent{T} <: Comrade.GeometricModel\n\nCreates the ConcordanceCrescent model, i.e. a flat-top crescent with a displacment and a slash. Note this creates a crescent with unit flux. If you want a different flux please use the renomed modifier.\n\nFields\n\nrouter\nOuter radius of the crescent\n\nrinner\nInner radius of the crescent (i.e. inside this radius there is a hole)\n\nshift\nDisplacment of the inner disk radius\n\nslash\nStrength of the linear slash. Note that s∈[0.0,1.0] to ensure positivity in the image.\n\nNotes\n\nUnlike the Gaussian and Disk models this does not create the unit version. In fact, this model could have been created using the Disk and primitives by using Comrade.jl's model composition functionality.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ConvolvedModel","page":"Comrade API","title":"Comrade.ConvolvedModel","text":"struct ConvolvedModel{M1, M2} <: Comrade.CompositeModel{M1, M2}\n\nConvolves two models m1 and m2.\n\nNotes\n\nThis is the non-exported constructor. The user should call the convolved function during use\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.DFTAlg","page":"Comrade API","title":"Comrade.DFTAlg","text":"DFTAlg\n\nUses a discrete fourier transform. This is not very efficient for larger images. In those cases  NFFTAlg or FFTAlg are more reasonable. For small images this is a reasonable choice especially since it's easy to define derivatives.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.EHTArrayConfiguration","page":"Comrade API","title":"Comrade.EHTArrayConfiguration","text":"struct EHTArrayConfiguration{F, T<:AbstractArray} <: Comrade.ArrayConfiguration\n\nStores all the non-visibility data products for an EHT array. This is useful when evaluating model visibilities.\n\n\n\nfrequency\nObserving frequency (Hz)\n\nbandwidth\nObserving bandwith (Hz)\n\ndata\nA struct array of ArrayBaselineDatum holding time, u, v, baselines.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.EHTClosurePhaseDatum","page":"Comrade API","title":"Comrade.EHTClosurePhaseDatum","text":"struct EHTClosurePhaseDatum{T<:Number} <: Comrade.ClosureProducts{T<:Number}\n\nA Datum for a single closure phase.\n\n\n\nphase\nclosure phase (rad)\n\nerror\nerror of the closure phase assuming the high-snr limit\n\nu1\nu (λ) of first station\n\nv1\nv (λ) of first station\n\nu2\nu (λ) of second station\n\nv2\nv (λ) of second station\n\nu3\nu (λ) of third station\n\nv3\nv (λ) of third station\n\ntime\nMeasured time of closure phase in hours\n\ntriangle\nstation baselines used\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.EHTLogClosureAmplitudeDatum","page":"Comrade API","title":"Comrade.EHTLogClosureAmplitudeDatum","text":"struct EHTLogClosureAmplitudeDatum{T<:Number} <: Comrade.ClosureProducts{T<:Number}\n\nA Datum for a single log closure amplitude.\n\n\n\namp\nlog-closure amplitude\n\nerror\nlog-closure amplitude error in the high-snr limit\n\nu1\nu (λ) of first station\n\nv1\nv (λ) of first station\n\nu2\nu (λ) of second station\n\nv2\nv (λ) of second station\n\nu3\nu (λ) of third station\n\nv3\nv (λ) of third station\n\nu4\nu (λ) of fourth station\n\nv4\nv (λ) of fourth station\n\ntime\nObservation time of the quadrangle\n\nquadrangle\nstation codes for the quadrangle\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.EHTObservation","page":"Comrade API","title":"Comrade.EHTObservation","text":"The main data product type in Comrade this stores the data which can be a StructArray of any AbstractInterferometryDatum type.\n\n(\n\ndata\nStructArray of data productts\n\nconfig\nArray config holds ancillary information about array\n\nmjd\nmodified julia date of the observation\n\nra\nRA of the observation in J2000 (deg)\n\ndec\nDEC of the observation in J2000 (deg)\n\nbandwidth\nbandwidth of the observation (Hz)\n\nfrequency\nfrequency of the observation (Hz)\n\nsource\nCommon source name\n\ntimetype\nTime zone used.\n\n)\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.EHTVisibilityAmplitudeDatum","page":"Comrade API","title":"Comrade.EHTVisibilityAmplitudeDatum","text":"A struct holding the information for a single measured visibility amplitude.\n\n\n\namp\namplitude (Jy)\n\nerror\nerror of the visibility amplitude (Jy)\n\nu\nx-direction baseline length in λ\n\nv\ny-direction baseline length in λ\n\ntime\nTime of the observation in hours\n\nbaseline\nstation baseline codes\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.EHTVisibilityDatum","page":"Comrade API","title":"Comrade.EHTVisibilityDatum","text":"A struct holding the information for a single measured visibility.\n\n\n\nvisr\nreal component of the visibility (Jy)\n\nvisi\nimaginary component of the visibility (Jy)\n\nerror\nerror of the visibility (Jy)\n\nu\nx-direction baseline length in λ\n\nv\ny-direction baseline length in λ\n\ntime\nTime of the observation in hours\n\nbaseline\nstation baseline codes\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ExtendedRing","page":"Comrade API","title":"Comrade.ExtendedRing","text":"struct ExtendedRing{F<:Number} <: Comrade.GeometricModel\n\nA symmetric extended ring whose radial profile follows an inverse gamma distributions.\n\nNote\n\nWe mainly use this as an example of a non-analytic Fourier transform (although it has a complicated expression)\n\nFields\n\nshape\nshape of the radial distribution\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.FFTAlg","page":"Comrade API","title":"Comrade.FFTAlg","text":"struct FFTAlg <: Comrade.FourierTransform\n\nFourier transform type that specifies we will use the FFTW package to compute the Fourier transform.\n\nFields\n\npadfac\nThe amount to pad the image by. Note we actually round up to the nearest factor of 2, but this will be improved in the future to use small primes\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.FFTCache","page":"Comrade API","title":"Comrade.FFTCache","text":"struct FFTCache{A<:FFTAlg, P, I, S} <: Comrade.AbstractCache\n\nThe cache used when the FFT algorithm is used to compute visibilties. This is an internal type and is not part of the public API\n\nFields\n\nalg\nplan\nFFTW Plan\nimg\nimage cache\nsitp\nFFT interpolator function\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.GainModel","page":"Comrade API","title":"Comrade.GainModel","text":"`GainModel`\n\nConstruct the corruption model for the telescope gains\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.Gaussian","page":"Comrade API","title":"Comrade.Gaussian","text":"struct Gaussian{T} <: Comrade.GeometricModel\n\nGaussian geometrical model. This is a Gaussian with unit flux and standard deviation.\n\nNotes\n\nTo change the Gaussian flux, and shape please use the modifier functions\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.GeometricModel","page":"Comrade API","title":"Comrade.GeometricModel","text":"abstract type GeometricModel <: ComradeBase.AbstractModel\n\nA type that defines it is a geometric model. These are usually primitive models, and are usually analytic in Fourier and the image domain.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.MRing","page":"Comrade API","title":"Comrade.MRing","text":"struct MRing{T, N} <: Comrade.GeometricModel\n\nm-ring geometric model. This corresponds to a delta ring with a fourier expansion in θ. The m in m-ring refers to the order of the Fourier expansion. The radius is unity.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ModelImage","page":"Comrade API","title":"Comrade.ModelImage","text":"struct ModelImage{M, I, C} <: Comrade.AbstractModelImage{M}\n\nContainer for non-analytic model that contains a image cache which will hold the image, a Fourier transform cache C, which usually an instance of a <: FourierCache which usually holds a interpolator that allows you to compute visibilities.\n\nNotes\n\nThis is an internal implementation detail that shouldn't usually be called directly. Instead the user should use the exported function modelimage, for example\n\nusing Comrade\nm = ExtendedRing(20.0, 5.0)\n\n# This creates an version where the image is dynamically specified according to the\n# radial extent of the image\nmimg = modelimage(m) # you can also optionally pass the number of pixels nx and ny\n\n# Or you can create an IntensityMap\nimg = intensitymap(m, 100.0, 100.0, 512, 512)\nmimg = modelimage(m, img)\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.MultiRadioLikelihood-Tuple{Vararg{RadioLikelihood}}","page":"Comrade API","title":"Comrade.MultiRadioLikelihood","text":"`MultiRadioLikelihood(lklhd1, lklhd2, ...)`\n\nCombines multiple likelihoods into one object that is useful for fitting multiple days/frequencies.\n\nlklhd1 = RadioLikelihood(dcphase1, dlcamp1)\nlklhd2 = RadioLikelihood(dcphase2, dlcamp2)\n\nlklhd = MultiRadioLikelihood(lklhd1, lklhd2)\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.NFFTAlg","page":"Comrade API","title":"Comrade.NFFTAlg","text":"NFFTAlg\n\nUses a non-uniform FFT to compute the visibilities. You can optionally pass uv which are the uv positions you will compute the NFFT at. This can allow for the NFFT plan to be cached improving performance\n\nFields\n\npadfac\nAmount to pad the image\n\nm\nControls the accuracy of the NFFT usually don't need to change this\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.NonAnalyticTest","page":"Comrade API","title":"Comrade.NonAnalyticTest","text":"`NonAnalyticTest`\n\nAn internal model used primarly for testing. Any model passed to it will be interpreted as not having an analytic Fourier transform.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ParabolicSegment","page":"Comrade API","title":"Comrade.ParabolicSegment","text":"struct ParabolicSegment{F} <: Comrade.GeometricModel\n\nA delta parabolic segment in the image domain. The segment is centered at zero, with roots ±1 and a yintercept of 1.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ParabolicSegment-Tuple{Any, Any}","page":"Comrade API","title":"Comrade.ParabolicSegment","text":"ParabolicSegment(a, h)\n\nA parabolic segment with x-intercepts ±aand a yintercept ofh``.\n\nNote\n\nThis is just a convenience function for stretched(ParabolicSegment(), a, h)\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.PolarizedModel","page":"Comrade API","title":"Comrade.PolarizedModel","text":"struct PolarizedModel{TI, TQ, TU, TV} <: ComradeBase.AbstractPolarizedModel\n\nWrapped model for a polarized model. This uses the stokes representation of the image.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.Posterior","page":"Comrade API","title":"Comrade.Posterior","text":"Posterior(lklhd, prior, model)\n\nPosterior density that follows obeys the DensityInferface\n\nThe expected arguments are:\n\nlklhd: Which should be an intance of RadioLikelihood with whatever data products you want to fit\nprior: This should be a NamedTuple with the priors for each model ParameterHandling\nmodel: Function that takes a NamedTuple of parameters and constructs the Comrade model.\n\nTo evaluate the logdensity of the posterior use can either use DensityInterface.logdensityof or logdensity.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.RadioLikelihood-Tuple{Vararg{Comrade.EHTObservation}}","page":"Comrade API","title":"Comrade.RadioLikelihood","text":"`RadioLikelihood(data1, data2, ...)`\n\nForms a radio likelihood from a set of data products. These data products must share the same array data/configuration. If you want to form a likelihood from multiple arrays such as when fitting different wavelengths or days, you can combine them using MultiRadioLikelihood\n\nlklhd1 = RadioLikelihood(dcphase1, dlcamp1)\nlklhd2 = RadioLikelihood(dcphase2, dlcamp2)\n\nlklhd = MultiRadioLikelihood(lklhd1, lklhd2)\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.RenormalizedModel","page":"Comrade API","title":"Comrade.RenormalizedModel","text":"struct RenormalizedModel{M<:ComradeBase.AbstractModel, T} <: Comrade.AbstractModifier{M<:ComradeBase.AbstractModel}\n\nRenormalizes the flux of the model to the new value flux. We have also overloaded the Base.:* operator as syntactic sugar although I may get rid of this.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.Ring","page":"Comrade API","title":"Comrade.Ring","text":"struct Ring{T} <: Comrade.GeometricModel\n\nm-ring geometric model. This corresponds to a delta ring with a fourier expansion in θ. The m in m-ring refers to the order of the Fourier expansion. The radius is unity.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.RotatedModel","page":"Comrade API","title":"Comrade.RotatedModel","text":"struct RotatedModel{M<:ComradeBase.AbstractModel, T} <: Comrade.AbstractModifier{M<:ComradeBase.AbstractModel}\n\nType for the rotated model. This is more fine grained constrol of rotated model. In most use cases the end-user should be using the rotate method e.g.\n\nrotate(model, ξ)\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ScanTable","page":"Comrade API","title":"Comrade.ScanTable","text":"`\n\nstruct ScanTable{O<:Union{Comrade.ArrayConfiguration, Comrade.Observation}, T, S}\n\n` Wraps EHTObservation in a table that separates the observation into scans. This implements the table interface and is used primarly for keeping track of gains and closure information.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ShiftedModel","page":"Comrade API","title":"Comrade.ShiftedModel","text":"struct ShiftedModel{T, M<:ComradeBase.AbstractModel} <: Comrade.AbstractModifier{M<:ComradeBase.AbstractModel}\n\nShifts the model by Δx units in the x-direction and Δy units in the y-direction.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.StretchedModel","page":"Comrade API","title":"Comrade.StretchedModel","text":"struct StretchedModel{M<:ComradeBase.AbstractModel, T} <: Comrade.AbstractModifier{M<:ComradeBase.AbstractModel}\n\nStretched the model in the x and y directions, i.e. the new intensity is\n\n    I_s(xy) = 1(αβ) I(xα yβ)\n\nwhere were renormalize the intensity to preserve the models flux.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.TransformedPosterior","page":"Comrade API","title":"Comrade.TransformedPosterior","text":"`\n\nstruct TransformedPosterior{P<:Posterior, T}\n\nA transformed version of the posteriorlpost`. This is an internal type that an end user shouldn't have to directly construct.\n\nTo construct a transformed posterior see the asflat, ascube, and flatten functions.\n\nWhen evaluating the logdensity of the TransformedPosterior, logdenisty will include any jacobian terms automatically, and expects the argument to be the vector of transformed quantities. This is usually easier to incorporate with samplers, and optimizers, which expect homogenous vectors as arguments.\n\n\n\n\n\n","category":"type"},{"location":"interface/#Model-Interface","page":"Model Interface","title":"Model Interface","text":"","category":"section"},{"location":"interface/#Primitive-Geometric-Models","page":"Model Interface","title":"Primitive Geometric Models","text":"","category":"section"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Comrade aims to be more modular and extensible than previous VLBI modeling packages. Namely, instead of making many different models, simple models are composed to construct complicated source morphologies. This is accomplished with a type, and trait based hierarchy.","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Additionally, ComradeBase is a low dependency version of this package that defines this type and trait heirarchy, that people can more easily incorporate into their packages without the large Comrade dependency.","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"To see how this works we will go through a simplified implementation the Gaussian model in Comrade. The Gaussian model is a simple compact emission structure model that can be used to constrain the typical characteristic size of a image feature from VLBI data. To construct a Gaussian model we will first a struct:","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"struct Gaussian <: Comrade.AbstractModel end","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Notice that we don't provide any more information about the model, e.g. size, shape, flux etc. This is because below we will use Comrade's extensive modifier to change the structure of the model. Now a Gaussian is the simplest model structure we can consider. In some sense we can consider this Gaussian to be a primitive model. That means a Gaussian is not a combination or modfication of an existing model. To tell Comrade that this is the case we define the following method:","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"# Tell Comrade Gaussian is a primitive model\nComrade.isprimitive(::Type{<:Gaussian}) = IsPrimitive()","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"In the actual Gaussian implementation we define Gaussian <: Comrade.GeometricModel which assumes the model is analytic and primitive by default.  Note, that if the Gaussian wasn't a primitive model we could've used NotPrimitive() instead. Now a Gaussian has an analytic expression in the image and Fourier domain. We can tell Comrade this by setting:","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"# Fourier and image domain are analytic\nComrade.visanalytic(::Type{<:Gaussian}) = IsAnalytic()\nComrade.imanalytic(::Type{<:Gaussian}) = IsAnalytic()","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Note that again for <: Comrade.GeometricModel this is again automatically defined. However, for models that aren't a subtype of GeometricModel we assume the image domain IsAnalytic() and the Fourier domain is NotAnalytic().","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Since both the image and visibility domain representation of the Gaussian are analytic we need to define a intensity_point and visibility_point method. For a Gaussian these are given by","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"function intensity_point(::Gaussian, x,y)\n    return exp(-(x^2+y^2)/2)/2π\nend\n\nfunction visibility_point(::Gaussian, u, v, args...) where {T}\n    return exp(-2π^2*(u^2 + v^2)) + 0im\nend","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Additionally, most models in Comrade has two additional functions one can implement if possible:","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"flux(m::Gaussian): This defines the flux of a model. If this isn't defined the model won't have a flux until an image is created. For a Gaussian the definition is flux(::Gaussian) = 1.0.\nradialextent(::Gaussian): This defines roughly the default radial extent of the model. For a Gaussian we will consider the radial extent to be 5σ, so radialextent(::Gaussian) = 5.0.","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"This completely defines the model interface for Comrade. With this you can call the usual forward facing API to evaluate, fit, and plot the model. Additionally, we can now start talking about adding multiple Gaussians, and modifying them. For instance suppose you want a elliptical Gaussian with a flux of 2 Jy. This can be created by Comrade as follows:","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"gauss = Gaussian()\nellgauss = 2.0*rotated(stretched(gauss, 1.0, 0.5), π/4)\nfig = plot(gauss, layout=(1,2), size=(800,300))\nplot!(fig[2], ellgauss, size=(800,350))","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"(Image: Image)","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"u = rand(100)*0.5; v=rand(100)*0.5\nvg  = visibilities(gauss, u, v)\nveg = visibilities(ellgauss, u, v)\n\nscatter(hypot.(u, v), abs.(vg), label=\"Gaussian\")\nscatter!(hypot.(u, v), abs.(veg), label=\"Elliptical Gaussian\")","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"(Image: Image)","category":"page"},{"location":"interface/#Models-without-an-Analytic-Fourier-Transform","page":"Model Interface","title":"Models without an Analytic Fourier Transform","text":"","category":"section"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Now suppose your model does not have an analytic Fourier transform. In this case the procedure is very similar to the above, except you define visanalytic(::Type{<:MyModel}) = NotAnalytic(). However, everything else is the same. To compute visibilities you just then just create a ModelImage type using the modelimage function. To see how this see Modeling with non-analytic Fourier transforms.","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"EditURL = \"https://github.com/ptiede/Comrade.jl/blob/main/docs/src/examples/nonanalytic.jl\"","category":"page"},{"location":"examples/nonanalytic/#Modeling-with-non-analytic-Fourier-transforms","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"","category":"section"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"using Comrade\nusing Plots","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"While most of the models implemented in Comrade have an analytic Fourier transform this is not required. In this notebook we will describe how a user can do Bayesian model fitting with a non-analytic model.","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"The ExtendedRing model is an example of a non-analytic model. The image structure is given by","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"I(r) = fracbeta^alpha2pi Gamma(alpha) r^-alpha-2e^-betar","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"This can be created as follows","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"m = ExtendedRing(8.0)","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"The argument is \\alpha in the above equation. beta is given by (1+alpha).","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"This is an example of a ring model that has a substantially different flux profile.","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"plot(m, xlims=(-5.0, 5.0), ylims=(-5.0, 5.0), uvscale=identity)","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"This function does not have a simple analytic Fourier transform, e.g.","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"Comrade.visanalytic(ExtendedRing)","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"Therefore, to find the Fourier transform of the image we need to revert to numerical methods. For this notebook we will use the fast Fourier transform or FFT. Specifically we will use FFTW. To compute a numerical Fourier transform we first need to specify the image.","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"image = IntensityMap(zeros(256, 256), 10.0, 10.0)","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"This will serve as our cache to store the image going forward. The next step is to create a model wrapper that holds the model and the image. Comrade provides the modelimage function to do exactly that","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"mimage = modelimage(m, image, Comrade.FFTAlg())","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"the alg keyword argument then specifies that we want to use an FFT to compute the Fourier transform. When modelimage is called, the FFT is performed and then we use a bicubic interpolator on the resulting visibilities to construct a continuous representation of the Fourier transform. Once we have this everything else is the same. Namely we can calculatge the VLBI data products in the usual manner i.e.","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"u = randn(1000)/2\nv = randn(1000)/2\n\nvis = visibilities(mimage, u, v)\namp = amplitudes(mimage, u, v)","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"We can also compute derivatives of these models. However, currently only ForwardDiff is able to propogate derivatives through modelimage. This is due to the interpolation step. In the future this limitation will be removed.","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"EditURL = \"https://github.com/ptiede/Comrade.jl/blob/main/docs/src/examples/black_hole_image.jl\"","category":"page"},{"location":"examples/black_hole_image/#Making-an-Image-of-a-Black-Hole","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"","category":"section"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"Comrade has been designed to work with the EHT and ngEHT. In this tutorial we will show how to reproduce some of the results from EHTC VI 2019.","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"In EHTC VI, they considered fitting simple geometric models to the data to estimate the image size, shape, brightness profile etc of the black hole. In this page we will construct a similar model and fit it to the data in under 50 lines of code (sans comments). To start we load some packages we will need","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"using Comrade","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"The next step is to load the data. For this we will use the publically available M 87 data which can be downloaded from cyverse. For an introduction to data loading see Loading Data into Comrade.","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"load_ehtim()\nobs = ehtim.obsdata.load_uvfits(joinpath(@__DIR__, \"../assets/SR1_M87_2017_096_lo_hops_netcal_StokesI.uvfits\"))\nobs.add_scans()","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"kill 0-baselines since we don't care about large scale flux and make scan-average data","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"obs = obs.flag_uvdist(uv_min=0.1e9).avg_coherent(0.0, scan_avg=true)","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"grab data products we want to fit: log closure amplitudes and closure phases","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"dlcamp = extract_lcamp(obs)\ndcphase = extract_cphase(obs)","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"For this demo only consider closure products since these are invariant to station specific gain systematics. Given these data products we can then form our radio likelihood:","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"lklhd = RadioLikelihood(dlcamp, dcphase)","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"The lklhd constructs a measure using MeasureTheory.jl. To evaluate the likelihood we need to pass it a type that implements the Comrade model interface which is described in Model Interface.","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"To finish the construction of our posterior we need to specify an image model and a prior. For the image model we will be using a modified MRing, which is a infinitely thin delta ring with an azimuthal structure given by a Fourier expansion. To give the ring some width we will convolve the ring with a gaussian, and add an additional gaussian to the image to model any non-ring flux. For the model a user must give a function that accepts a named tuple and return the constructed model:","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"function model(θ)\n  (;radius, width, α, β, f, σG, τG, ξG, xG, yG) = θ\n  ring = f*smoothed(stretched(MRing((α,), (β,)), radius, radius), width)\n  g = (1-f)*shifted(rotated(stretched(Gaussian(), σG, σG*(1+τG)), ξG), xG, yG)\n  return ring + g\nend","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"We now need to specify the priors for our model. The easiest way to do this is to specify a NamedTuple of distributions:","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"using Distributions\nprior = (\n          radius = Uniform(μas2rad(10.0), μas2rad(30.0)),\n          width = Uniform(μas2rad(1.0), μas2rad(10.0)),\n          α = Uniform(-0.5, 0.5),\n          β = Uniform(-0.5, 0.5),\n          f = Uniform(0.0, 1.0),\n          σG = Uniform(μas2rad(1.0), μas2rad(40.0)),\n          τG = Uniform(0.0, 0.75),\n          ξG = Uniform(0.0, 1π),\n          xG = Uniform(-μas2rad(80.0), μas2rad(80.0)),\n          yG = Uniform(-μas2rad(80.0), μas2rad(80.0))\n        )","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"To form the posterior we now call","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"post = Posterior(lklhd, prior, model)","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"This constructs a posterior density that can be evaluated by calling logdensityof. For example","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"logdensityof(post, (radius = μas2rad(20.0),\n                  width = μas2rad(10.0),\n                  α = 0.3,\n                  β = 0.3,\n                  f = 0.6,\n                  σG = μas2rad(20.0),\n                  τG = 0.1,\n                  ξG = 0.5,\n                  xG = 0.0,\n                  yG = 0.0))","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"We can now try to sample from our posterior post so that we can make probabilstic inferences about our data.","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"Now this model is in parameter space. Often optimization and sampling algorithms want it in some modified space. For example, nested sampling algorithms want the parameters in the unit hypercube. To transform the posterior to the unit hypercube we can use the ascube function","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"cpost = ascube(post)","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"If we want to flatten the parameter space and move to (-∞, ∞) support we can use the asflat function","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"fpost = asflat(post)","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"These transformed posterior expect a vector of parameters. That is we can evaluate the transformed log density by calling","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"logdensityof(cpost, rand(dimension(cpost)))\nlogdensityof(fpost, randn(dimension(fpost)))","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"Note that this automatically takes care of the jacobian in the parameter transformation.","category":"page"},{"location":"examples/black_hole_image/#Sampling-the-posterior","page":"Making an Image of a Black Hole","title":"Sampling the posterior","text":"","category":"section"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"Our strategy here will be to use Hamiltonian Monte Carlo. However, to lower burn-in time we will first use an optimizer to find a reasonable starting location. Since this is a lower dimensional problem we will use BlackboxOptim or the GalacticBBO package","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"using ComradeGalactic\nusing GalacticBBO\n\nndim = dimension(fpost)\nf = OptimizationFunction(fpost)\nprob = OptimizationProblem(f, randn(ndim), nothing, lb=fill(-5.0, ndim), ub=fill(5.0, ndim))\nsol = solve(prob, BBO_adaptive_de_rand_1_bin_radiuslimited(); maxiters=50_000)","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"The sol vector is in the transformed space, so first we need to transform back to parameter space","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"xopt = transform(fpost, sol)","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"And we can also plot the map","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"using Plots\nplot(model(xopt), title=\"MAP image\", xlims=(-60.0,50.0), ylims=(-60.0,50.0))","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"The main goal of Comrade is to explore the posterior of the model parameters. Currently the go to tool is AdvancedHMC.jl. To sample from the posterior you can use the following:","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"using ComradeAHMC\nchain, stats = sample(post, AHMC(metric=DiagEuclideanMetric(ndim)), 2000; nadapts=1000, init_params=xopt)","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"That's it! To finish it up we can then plot some simple visual fit diagnostics.","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"First to plot the image we call","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"plot(model(chain[end]), title=\"Random image\", xlims=(-60.0,50.0), ylims=(-60.0,50.0))","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"What about the mean image? Well let's grab 100 images from the chain","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"meanimg = mean(intensitymap.(model.(sample(chain, 100)), μas2rad(120.0), μas2rad(120.0), 128, 128))\nplot(sqrt.(meanimg), title=\"Mean Image\") #plot on a sqrt color scale to see the Gaussian","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"That looks similar to the EHTC VI, and it took us no time at all!. To see how well the model is fitting the data we can plot the model and data products","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"plot(model(xopt), dlcamp)","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"or even better the residuals","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"residual(model(xopt), dlcamp)","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"These residuals are a little ratty which suggests our model is missing some emission. In fact, this model is slightly too simple to explain the data. Check out EHTC VI 2019 for some ideas what features need to be added to the model to get a better fit!","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"This page was generated using Literate.jl.","category":"page"},{"location":"vlbi_imaging_problem/#Introduction-to-the-VLBI-Imaging-Problem","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"","category":"section"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"Very-long baseline interferometry (VLBI) is capable of taking the highest resolution images in the world, achieving angular resolutions of ~20 μas. In 2019, the first ever image of a black hole was produced by the Event Horizon Telescope (EHT). However, while the EHT has unprecedented resolution it is also a very sparse interferometer. As a result, the sampling in the uv or Fourier space of the image is incomplete. This makes the imaging problem uncertain. Namely, infinitely many images are possible given the data. Comrade is a imaging/modeling package that aims to quantify this uncertainty using Bayesian inference.","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"If we denote visibilities by V and the image structure/model by I, Comrade will then compute the posterior or the probability of an image given the visibility data, or in an equation","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"p(IV) = fracp(VI)p(I)p(V)","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"Here p(VI) is known as the likelihood and describes the probability distribution of the data given some image I. The prior p(I) encodes prior knowledge of the image structure. This prior includes distributions of model parameters and even the model itself. Finally, the denominator p(V) is a normalization term and is known as the marginal likelihood or evidence and can be used to assess how well particular models fit the data.","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"The goal of Comrade is to calculate (or approximate) the posterior of a image model. To see how to do that please see the Making an Image of a Black Hole tutorial.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Comrade","category":"page"},{"location":"#Comrade","page":"Home","title":"Comrade","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Comrade is a Bayesian differentiable modular modeling framework for use with very long baseline interferometry. The goal is to allow the user to easily combine and modify a set of primitive models to construct complicated source structures. The benefit of this approach is that is straightforward to construct different source models out of these primitives. Namely, a end-user does not have to create a separate source \"model\" every time they change the model specification. Additionally, most models currently implemented are differentiable with at least ForwardDiff. This allows for gradient accelerated optimization, and sampling (e.g. HMC) to be used with little effort by the end user.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Currently there are two main ways to construct and sample from the posterior. The first is the simple but somewhat more limited native interface. To see how this works see the Making an Image of a Black Hole tutorial. The other method is ComradeSoss.jl which combines Comrade with Soss a probabilistic programming language. This allows for easier composition of models, and provides a more complete Bayesian workflow, including the ability to sample from the posterior predictive distributions. Other interfaces to e.g. Turing, BAT are planned.","category":"page"},{"location":"#Requirements","page":"Home","title":"Requirements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The minimum Julia version we require is 1.6, which is the current LTS release. In the future we may increase this as Julia advances.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"index.md\",\n    \"vlbi_imaging_problem.md\",\n    \"Tutorials\" => [\n    \"examples/data.md\",\n    \"examples/black_hole_image.md\",\n    \"examples/nonanalytic.md\"\n    ]\n    \"interface.md\",\n    \"base_api.md\",\n    \"api.md\"\n]","category":"page"}]
}
