<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Comrade API · Comrade.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Comrade.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../benchmarks/">Benchmarks</a></li><li><a class="tocitem" href="../vlbi_imaging_problem/">Introduction to the VLBI Imaging Problem</a></li><li><a class="tocitem" href="../conventions/">Conventions</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../examples/black_hole_image/">Making an Image of a Black Hole</a></li><li><a class="tocitem" href="../examples/data/">Loading Data into Comrade</a></li><li><a class="tocitem" href="../examples/hybrid_imaging/">Hybrid Imaging of a Black Hole</a></li><li><a class="tocitem" href="../examples/hybrid_imaging_vis/">Hybrid Imaging with of a Black Hole</a></li><li><a class="tocitem" href="../examples/imaging_closures/">Imaging a Black Hole using only Closure Quantities</a></li><li><a class="tocitem" href="../examples/imaging_pol/">Polarized Image and Instrumental Modeling</a></li><li><a class="tocitem" href="../examples/imaging_vis/">Stokes I Simultaneous Image and Instrument Modeling</a></li><li><a class="tocitem" href="../examples/nonanalytic/">Modeling with non-analytic Fourier transforms</a></li></ul></li><li><span class="tocitem">Libraries</span><ul><li><a class="tocitem" href="../libs/optimization/">ComradeOptimization</a></li><li><a class="tocitem" href="../libs/ahmc/">ComradeAHMC</a></li><li><a class="tocitem" href="../libs/nested/">ComradeNested</a></li><li><a class="tocitem" href="../libs/dynesty/">ComradeDynesty</a></li><li><a class="tocitem" href="../libs/adaptmcmc/">ComradeAdaptMCMC</a></li></ul></li><li><a class="tocitem" href="../interface/">Model Interface</a></li><li><a class="tocitem" href="../base_api/">ComradeBase API</a></li><li class="is-active"><a class="tocitem" href>Comrade API</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Model-Definitions"><span>Model Definitions</span></a></li><li><a class="tocitem" href="#Data-Types"><span>Data Types</span></a></li><li><a class="tocitem" href="#eht-imaging-interface"><span>eht-imaging interface</span></a></li><li><a class="tocitem" href="#Bayesian-Tools"><span>Bayesian Tools</span></a></li><li><a class="tocitem" href="#Misc"><span>Misc</span></a></li><li><a class="tocitem" href="#Internal-(Not-Public-API)"><span>Internal (Not Public API)</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Comrade API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Comrade API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ptiede/Comrade.jl/blob/main/docs/src/api.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Comrade-API"><a class="docs-heading-anchor" href="#Comrade-API">Comrade API</a><a id="Comrade-API-1"></a><a class="docs-heading-anchor-permalink" href="#Comrade-API" title="Permalink"></a></h1><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#Comrade-API">Comrade API</a></li><li class="no-marker"><ul><li><a href="#Contents">Contents</a></li><li><a href="#Index">Index</a></li><li><a href="#Model-Definitions">Model Definitions</a></li><li><a href="#Data-Types">Data Types</a></li><li><a href="#eht-imaging-interface">eht-imaging interface</a></li><li><a href="#Bayesian-Tools">Bayesian Tools</a></li><li><a href="#Misc">Misc</a></li><li><a href="#Internal-(Not-Public-API)">Internal (Not Public API)</a></li></ul></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Comrade.AbstractInterferometryDatum"><code>Comrade.AbstractInterferometryDatum</code></a></li><li><a href="#Comrade.AddModel"><code>Comrade.AddModel</code></a></li><li><a href="#Comrade.ArrayBaselineDatum"><code>Comrade.ArrayBaselineDatum</code></a></li><li><a href="#Comrade.ArrayConfiguration"><code>Comrade.ArrayConfiguration</code></a></li><li><a href="#Comrade.BSplinePulse"><code>Comrade.BSplinePulse</code></a></li><li><a href="#Comrade.BicubicPulse"><code>Comrade.BicubicPulse</code></a></li><li><a href="#Comrade.Butterworth"><code>Comrade.Butterworth</code></a></li><li><a href="#Comrade.CalPrior"><code>Comrade.CalPrior</code></a></li><li><a href="#Comrade.CalPrior-Tuple{NamedTuple, JonesCache}"><code>Comrade.CalPrior</code></a></li><li><a href="#Comrade.CalTable"><code>Comrade.CalTable</code></a></li><li><a href="#Comrade.ClosureConfig"><code>Comrade.ClosureConfig</code></a></li><li><a href="#Comrade.CompositeModel"><code>Comrade.CompositeModel</code></a></li><li><a href="#Comrade.ConcordanceCrescent"><code>Comrade.ConcordanceCrescent</code></a></li><li><a href="#Comrade.ContinuousImage"><code>Comrade.ContinuousImage</code></a></li><li><a href="#Comrade.ConvolvedModel"><code>Comrade.ConvolvedModel</code></a></li><li><a href="#Comrade.DFTAlg-Tuple{Comrade.EHTObservation}"><code>Comrade.DFTAlg</code></a></li><li><a href="#Comrade.DFTAlg-Tuple{Comrade.ArrayConfiguration}"><code>Comrade.DFTAlg</code></a></li><li><a href="#Comrade.DFTAlg"><code>Comrade.DFTAlg</code></a></li><li><a href="#Comrade.DFTAlg-Tuple{AbstractArray, AbstractArray}"><code>Comrade.DFTAlg</code></a></li><li><a href="#Comrade.DeltaPulse"><code>Comrade.DeltaPulse</code></a></li><li><a href="#Comrade.DesignMatrix"><code>Comrade.DesignMatrix</code></a></li><li><a href="#Comrade.Disk"><code>Comrade.Disk</code></a></li><li><a href="#Comrade.EHTArrayConfiguration"><code>Comrade.EHTArrayConfiguration</code></a></li><li><a href="#Comrade.EHTClosurePhaseDatum"><code>Comrade.EHTClosurePhaseDatum</code></a></li><li><a href="#Comrade.EHTCoherencyDatum"><code>Comrade.EHTCoherencyDatum</code></a></li><li><a href="#Comrade.EHTLogClosureAmplitudeDatum"><code>Comrade.EHTLogClosureAmplitudeDatum</code></a></li><li><a href="#Comrade.EHTObservation"><code>Comrade.EHTObservation</code></a></li><li><a href="#Comrade.EHTVisibilityAmplitudeDatum"><code>Comrade.EHTVisibilityAmplitudeDatum</code></a></li><li><a href="#Comrade.EHTVisibilityDatum"><code>Comrade.EHTVisibilityDatum</code></a></li><li><a href="#Comrade.ExtendedRing"><code>Comrade.ExtendedRing</code></a></li><li><a href="#Comrade.FFTAlg"><code>Comrade.FFTAlg</code></a></li><li><a href="#Comrade.FFTCache"><code>Comrade.FFTCache</code></a></li><li><a href="#Comrade.FixedSeg"><code>Comrade.FixedSeg</code></a></li><li><a href="#Comrade.Gaussian"><code>Comrade.Gaussian</code></a></li><li><a href="#Comrade.GeometricModel"><code>Comrade.GeometricModel</code></a></li><li><a href="#Comrade.IntegSeg"><code>Comrade.IntegSeg</code></a></li><li><a href="#Comrade.IsCube"><code>Comrade.IsCube</code></a></li><li><a href="#Comrade.IsFlat"><code>Comrade.IsFlat</code></a></li><li><a href="#Comrade.JonesCache"><code>Comrade.JonesCache</code></a></li><li><a href="#Comrade.JonesModel"><code>Comrade.JonesModel</code></a></li><li><a href="#Comrade.JonesPairs"><code>Comrade.JonesPairs</code></a></li><li><a href="#Comrade.MRing"><code>Comrade.MRing</code></a></li><li><a href="#Comrade.ModelImage"><code>Comrade.ModelImage</code></a></li><li><a href="#Comrade.MultiRadioLikelihood"><code>Comrade.MultiRadioLikelihood</code></a></li><li><a href="#Comrade.NFFTAlg"><code>Comrade.NFFTAlg</code></a></li><li><a href="#Comrade.NUFTCache"><code>Comrade.NUFTCache</code></a></li><li><a href="#Comrade.NonAnalyticTest"><code>Comrade.NonAnalyticTest</code></a></li><li><a href="#Comrade.ObsSegmentation"><code>Comrade.ObsSegmentation</code></a></li><li><a href="#Comrade.ObservedNUFT"><code>Comrade.ObservedNUFT</code></a></li><li><a href="#Comrade.ParabolicSegment"><code>Comrade.ParabolicSegment</code></a></li><li><a href="#Comrade.PolarizedModel"><code>Comrade.PolarizedModel</code></a></li><li><a href="#Comrade.Posterior"><code>Comrade.Posterior</code></a></li><li><a href="#Comrade.Pulse"><code>Comrade.Pulse</code></a></li><li><a href="#Comrade.RIMEModel"><code>Comrade.RIMEModel</code></a></li><li><a href="#Comrade.RadioLikelihood"><code>Comrade.RadioLikelihood</code></a></li><li><a href="#Comrade.RaisedCosinePulse"><code>Comrade.RaisedCosinePulse</code></a></li><li><a href="#Comrade.Ring"><code>Comrade.Ring</code></a></li><li><a href="#Comrade.Scan"><code>Comrade.Scan</code></a></li><li><a href="#Comrade.ScanSeg"><code>Comrade.ScanSeg</code></a></li><li><a href="#Comrade.ScanTable"><code>Comrade.ScanTable</code></a></li><li><a href="#Comrade.SlashedDisk"><code>Comrade.SlashedDisk</code></a></li><li><a href="#Comrade.ThreadedModel"><code>Comrade.ThreadedModel</code></a></li><li><a href="#Comrade.TrackSeg"><code>Comrade.TrackSeg</code></a></li><li><a href="#Comrade.TransformCache"><code>Comrade.TransformCache</code></a></li><li><a href="#Comrade.TransformedPosterior"><code>Comrade.TransformedPosterior</code></a></li><li><a href="#Comrade.ZeroModel"><code>Comrade.ZeroModel</code></a></li><li><a href="#Base.:+-Tuple{ComradeBase.AbstractModel, ComradeBase.AbstractModel}"><code>Base.:+</code></a></li><li><a href="#Comrade.Crescent"><code>Comrade.Crescent</code></a></li><li><a href="#Comrade.PoincareSphere2Map"><code>Comrade.PoincareSphere2Map</code></a></li><li><a href="#Comrade.added"><code>Comrade.added</code></a></li><li><a href="#Comrade.amplitude-Tuple{Comrade.EHTVisibilityAmplitudeDatum}"><code>Comrade.amplitude</code></a></li><li><a href="#Comrade.amplitude-Tuple{Comrade.EHTVisibilityDatum}"><code>Comrade.amplitude</code></a></li><li><a href="#Comrade.amplitude"><code>Comrade.amplitude</code></a></li><li><a href="#Comrade.amplitudes"><code>Comrade.amplitudes</code></a></li><li><a href="#Comrade.arrayconfig"><code>Comrade.arrayconfig</code></a></li><li><a href="#Comrade.baselines"><code>Comrade.baselines</code></a></li><li><a href="#Comrade.basemodel"><code>Comrade.basemodel</code></a></li><li><a href="#Comrade.bispectra"><code>Comrade.bispectra</code></a></li><li><a href="#Comrade.bispectrum"><code>Comrade.bispectrum</code></a></li><li><a href="#Comrade.caltable-Tuple{JonesCache, AbstractVector}"><code>Comrade.caltable</code></a></li><li><a href="#Comrade.caltable-Tuple{Comrade.EHTObservation, AbstractVector}"><code>Comrade.caltable</code></a></li><li><a href="#Comrade.caltable"><code>Comrade.caltable</code></a></li><li><a href="#Comrade.closure_phase"><code>Comrade.closure_phase</code></a></li><li><a href="#Comrade.closure_phase-Tuple{Comrade.EHTVisibilityDatum, Comrade.EHTVisibilityDatum, Comrade.EHTVisibilityDatum}"><code>Comrade.closure_phase</code></a></li><li><a href="#Comrade.closure_phases"><code>Comrade.closure_phases</code></a></li><li><a href="#Comrade.components"><code>Comrade.components</code></a></li><li><a href="#Comrade.convolved"><code>Comrade.convolved</code></a></li><li><a href="#Comrade.corrupt"><code>Comrade.corrupt</code></a></li><li><a href="#Comrade.create_cache"><code>Comrade.create_cache</code></a></li><li><a href="#Comrade.extract_FRs"><code>Comrade.extract_FRs</code></a></li><li><a href="#Comrade.extract_amp"><code>Comrade.extract_amp</code></a></li><li><a href="#Comrade.extract_coherency"><code>Comrade.extract_coherency</code></a></li><li><a href="#Comrade.extract_cphase"><code>Comrade.extract_cphase</code></a></li><li><a href="#Comrade.extract_lcamp"><code>Comrade.extract_lcamp</code></a></li><li><a href="#Comrade.extract_vis"><code>Comrade.extract_vis</code></a></li><li><a href="#Comrade.fouriermap"><code>Comrade.fouriermap</code></a></li><li><a href="#Comrade.getdata"><code>Comrade.getdata</code></a></li><li><a href="#Comrade.getuv"><code>Comrade.getuv</code></a></li><li><a href="#Comrade.getuvtimefreq"><code>Comrade.getuvtimefreq</code></a></li><li><a href="#Comrade.jonesD"><code>Comrade.jonesD</code></a></li><li><a href="#Comrade.jonesG"><code>Comrade.jonesG</code></a></li><li><a href="#Comrade.jonesStokes"><code>Comrade.jonesStokes</code></a></li><li><a href="#Comrade.jonesT"><code>Comrade.jonesT</code></a></li><li><a href="#Comrade.likelihood"><code>Comrade.likelihood</code></a></li><li><a href="#Comrade.load"><code>Comrade.load</code></a></li><li><a href="#Comrade.load_ehtim"><code>Comrade.load_ehtim</code></a></li><li><a href="#Comrade.load_ehtim_uvfits"><code>Comrade.load_ehtim_uvfits</code></a></li><li><a href="#Comrade.logclosure_amplitude"><code>Comrade.logclosure_amplitude</code></a></li><li><a href="#Comrade.logclosure_amplitudes"><code>Comrade.logclosure_amplitudes</code></a></li><li><a href="#Comrade.modelimage"><code>Comrade.modelimage</code></a></li><li><a href="#Comrade.posangle"><code>Comrade.posangle</code></a></li><li><a href="#Comrade.prior_sample"><code>Comrade.prior_sample</code></a></li><li><a href="#Comrade.rad2μas"><code>Comrade.rad2μas</code></a></li><li><a href="#Comrade.renormed"><code>Comrade.renormed</code></a></li><li><a href="#Comrade.rotated"><code>Comrade.rotated</code></a></li><li><a href="#Comrade.save"><code>Comrade.save</code></a></li><li><a href="#Comrade.scale_image"><code>Comrade.scale_image</code></a></li><li><a href="#Comrade.scale_uv"><code>Comrade.scale_uv</code></a></li><li><a href="#Comrade.scan_average"><code>Comrade.scan_average</code></a></li><li><a href="#Comrade.scantable"><code>Comrade.scantable</code></a></li><li><a href="#Comrade.shifted"><code>Comrade.shifted</code></a></li><li><a href="#Comrade.smoothed"><code>Comrade.smoothed</code></a></li><li><a href="#Comrade.stations"><code>Comrade.stations</code></a></li><li><a href="#Comrade.stretched"><code>Comrade.stretched</code></a></li><li><a href="#Comrade.transform_image"><code>Comrade.transform_image</code></a></li><li><a href="#Comrade.transform_uv"><code>Comrade.transform_uv</code></a></li><li><a href="#Comrade.unmodified"><code>Comrade.unmodified</code></a></li><li><a href="#Comrade.update_cache"><code>Comrade.update_cache</code></a></li><li><a href="#Comrade.uviterator"><code>Comrade.uviterator</code></a></li><li><a href="#Comrade.uvpositions"><code>Comrade.uvpositions</code></a></li><li><a href="#Comrade.visibility"><code>Comrade.visibility</code></a></li><li><a href="#Comrade.μas2rad"><code>Comrade.μas2rad</code></a></li><li><a href="#ComradeBase.evpa-Tuple{ComradeBase.AbstractPolarizedModel, Any}"><code>ComradeBase.evpa</code></a></li><li><a href="#ComradeBase.mbreve"><code>ComradeBase.mbreve</code></a></li><li><a href="#HypercubeTransform.ascube"><code>HypercubeTransform.ascube</code></a></li><li><a href="#HypercubeTransform.asflat"><code>HypercubeTransform.asflat</code></a></li><li><a href="#ParameterHandling.flatten"><code>ParameterHandling.flatten</code></a></li><li><a href="#StatsBase.sample-Tuple{Posterior}"><code>StatsBase.sample</code></a></li><li><a href="#TransformVariables.inverse"><code>TransformVariables.inverse</code></a></li><li><a href="#TransformVariables.transform"><code>TransformVariables.transform</code></a></li></ul><h2 id="Model-Definitions"><a class="docs-heading-anchor" href="#Model-Definitions">Model Definitions</a><a id="Model-Definitions-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Definitions" title="Permalink"></a></h2><h3 id="Calibration-Models"><a class="docs-heading-anchor" href="#Calibration-Models">Calibration Models</a><a id="Calibration-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Calibration-Models" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Comrade.corrupt" href="#Comrade.corrupt"><code>Comrade.corrupt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">corrupt(vis, j1, j2)</code></pre><p>Corrupts the model coherency matrices with the Jones matrices <code>j1</code> for station 1 and <code>j2</code> for station 2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/calibration/jones.jl#L741-L746">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.CalTable" href="#Comrade.CalTable"><code>Comrade.CalTable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CalTable{T, G&lt;:(AbstractVecOrMat)}</code></pre><p>A Tabes of calibration quantities. The columns of the table are the telescope station codes. The rows are the calibration quantities at a specific time stamp. This user should not use this struct directly. Instead that should call <a href="#Comrade.caltable"><code>caltable</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/calibration/caltable.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.caltable-Tuple{JonesCache, AbstractVector}" href="#Comrade.caltable-Tuple{JonesCache, AbstractVector}"><code>Comrade.caltable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">caltable(g::JonesCache, jterms::AbstractVector)</code></pre><p>Convert the JonesCache <code>g</code> and recovered Jones/corruption elements <code>jterms</code> into a <code>CalTable</code> which satisfies the <code>Tables.jl</code> interface.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">ct = caltable(gcache, gains)

# Access a particular station (here ALMA)
ct[:AA]
ct.AA

# Access a the first row
ct[1, :]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/calibration/caltable.jl#L251-L269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.caltable-Tuple{Comrade.EHTObservation, AbstractVector}" href="#Comrade.caltable-Tuple{Comrade.EHTObservation, AbstractVector}"><code>Comrade.caltable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">caltable(obs::EHTObservation, gains::AbstractVector)</code></pre><p>Create a calibration table for the observations <code>obs</code> with <code>gains</code>. This returns a <a href="#Comrade.CalTable"><code>CalTable</code></a> object that satisfies the <code>Tables.jl</code> interface. This table is very similar to the <code>DataFrames</code> interface.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">ct = caltable(obs, gains)

# Access a particular station (here ALMA)
ct[:AA]
ct.AA

# Access a the first row
ct[1, :]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/calibration/caltable.jl#L200-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.DesignMatrix" href="#Comrade.DesignMatrix"><code>Comrade.DesignMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DesignMatrix{X, M&lt;:AbstractArray{X, 2}, T, S} &lt;: AbstractArray{X, 2}</code></pre><p>Internal type that holds the gain design matrices for visibility corruption.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/calibration/gains.jl#L24-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.JonesCache" href="#Comrade.JonesCache"><code>Comrade.JonesCache</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct JonesCache{D1, D2, S, Sc} &lt;: Comrade.AbstractJonesCache</code></pre><p>Holds the ancillary information for a the design matrix cache for Jones matrices. That is, it defines the cached map that moves from model visibilities to the corrupted voltages that are measured from the telescope.</p><p><strong>Fields</strong></p><ul><li><code>m1</code>: Design matrix for the first station</li></ul><ul><li><code>m2</code>: Design matrix for the second station</li></ul><ul><li><code>seg</code>: Segmentation schemes for this cache</li></ul><ul><li><code>schema</code>: Gain Schema</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/calibration/jones.jl#L81-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.TransformCache" href="#Comrade.TransformCache"><code>Comrade.TransformCache</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct TransformCache{M, B&lt;:PolBasis} &lt;: Comrade.AbstractJonesCache</code></pre><p>Holds various transformations that move from the measured telescope basis to the <strong>chosen</strong> on sky reference basis.</p><p><strong>Fields</strong></p><ul><li><code>T1</code>: Transform matrices for the first stations</li></ul><ul><li><code>T2</code>: Transform matrices for the second stations</li></ul><ul><li><code>refbasis</code>: Reference polarization basis</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/calibration/jones.jl#L623-L631">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.JonesModel" href="#Comrade.JonesModel"><code>Comrade.JonesModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">JonesModel(jones::JonesPairs, model, tcache::TransformCache)
JonesModel(jones::JonesPairs, model, refbasis::PolBasis=CirBasis())</code></pre><p>Constructs a <code>JonesModel</code> from a <code>jones</code> pairs that describe the intrument model and the <code>model</code> which describes the on-sky polarized visibilities. The third argument can either be the <code>tcache</code> that converts from the model coherency basis to the instrumental basis, or just the <code>refbasis</code> that will be used when constructing the model coherency matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/calibration/jones.jl#L711-L719">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.CalPrior" href="#Comrade.CalPrior"><code>Comrade.CalPrior</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CalPrior(dists, cache::JonesCache, reference=:none)</code></pre><p>Creates a distribution for the gain priors for gain cache <code>cache</code>. The <code>dists</code> should be a NamedTuple of <code>Distributions</code>, where each name corresponds to a telescope or station in the observation. The resulting type is a subtype of the <code>Distributions.AbstractDistribution</code> so the usual <code>Distributions</code> interface should work.</p><p><strong>Example</strong></p><p>For the 2017 observations of M87 a common CalPrior call is:</p><pre><code class="language-julia-repl hljs">julia&gt; gdist = CalPrior((AA = LogNormal(0.0, 0.1),
                   AP = LogNormal(0.0, 0.1),
                   JC = LogNormal(0.0, 0.1),
                   SM = LogNormal(0.0, 0.1),
                   AZ = LogNormal(0.0, 0.1),
                   LM = LogNormal(0.0, 1.0),
                   PV = LogNormal(0.0, 0.1)
                ), cache)

julia&gt; x = rand(gdist)
julia&gt; logdensityof(gdist, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/calibration/priors.jl#L8-L33">source</a></section><section><div><pre><code class="nohighlight hljs">CalPrior(dist0::NamedTuple, dist_transition::NamedTuple, jcache::SegmentedJonesCache)</code></pre><p>Constructs a calibration prior in two steps. The first two arguments have to be a named tuple of distributions, where each name corresponds to a site. The first argument is gain prior for the first time stamp. The second argument is the segmented gain prior for each subsequent time stamp. For instance, if we have</p><pre><code class="language-julia hljs">dist0 = (AA = Normal(0.0, 1.0), )
distt = (AA = Normal(0.0, 0.1), )</code></pre><p>then the gain prior for first time stamp that AA obserserves will be <code>Normal(0.0, 1.0)</code>. The next time stamp gain is the construted from</p><pre><code class="nohighlight hljs">g2 = g1 + ϵ1</code></pre><p>where <code>ϵ1 ~ Normal(0.0, 0.1) = distt.AA</code>, and <code>g1</code> is the gain from the first time stamp. In other words <code>distt</code> is the uncorrelated transition probability when moving from timestamp i to timestamp i+1. For the typical pre-calibrated dataset the gain prior on <code>distt</code> can be tighter than the prior on <code>dist0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/calibration/priors.jl#L46-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.CalPrior-Tuple{NamedTuple, JonesCache}" href="#Comrade.CalPrior-Tuple{NamedTuple, JonesCache}"><code>Comrade.CalPrior</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CalPrior(dists, cache::JonesCache, reference=:none)</code></pre><p>Creates a distribution for the gain priors for gain cache <code>cache</code>. The <code>dists</code> should be a NamedTuple of <code>Distributions</code>, where each name corresponds to a telescope or station in the observation. The resulting type is a subtype of the <code>Distributions.AbstractDistribution</code> so the usual <code>Distributions</code> interface should work.</p><p><strong>Example</strong></p><p>For the 2017 observations of M87 a common CalPrior call is:</p><pre><code class="language-julia-repl hljs">julia&gt; gdist = CalPrior((AA = LogNormal(0.0, 0.1),
                   AP = LogNormal(0.0, 0.1),
                   JC = LogNormal(0.0, 0.1),
                   SM = LogNormal(0.0, 0.1),
                   AZ = LogNormal(0.0, 0.1),
                   LM = LogNormal(0.0, 1.0),
                   PV = LogNormal(0.0, 0.1)
                ), cache)

julia&gt; x = rand(gdist)
julia&gt; logdensityof(gdist, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/calibration/priors.jl#L8-L33">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Comrade.CalPrior(::NamedTuple, ::NamedTuple, ::Comrade.SegmentedJonesCache)</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Comrade.RIMEModel" href="#Comrade.RIMEModel"><code>Comrade.RIMEModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type RIMEModel &lt;: ComradeBase.AbstractModel</code></pre><p>Abstract type that encompasses all RIME style corruptions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/calibration/gains.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.ObsSegmentation" href="#Comrade.ObsSegmentation"><code>Comrade.ObsSegmentation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type ObsSegmentation</code></pre><p>The data segmentation scheme to use. This is important for constructing a <a href="#Comrade.JonesCache"><code>JonesCache</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/calibration/jones.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.IntegSeg" href="#Comrade.IntegSeg"><code>Comrade.IntegSeg</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct IntegSeg{S} &lt;: Comrade.ObsSegmentation</code></pre><p>Data segmentation such that the quantity is constant over a correlation integration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/calibration/jones.jl#L34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.ScanSeg" href="#Comrade.ScanSeg"><code>Comrade.ScanSeg</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ScanSeg{S} &lt;: Comrade.ObsSegmentation</code></pre><p>Data segmentation such that the quantity is constant over a <code>scan</code>.</p><p><strong>Warning</strong></p><p>Currently we do not explicity track the telescope scans. This will be fixed in a future version. Right now <code>ScanSeg</code> and <code>TrackSeg</code> are the same</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/calibration/jones.jl#L20-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.TrackSeg" href="#Comrade.TrackSeg"><code>Comrade.TrackSeg</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct TrackSeg &lt;: Comrade.ObsSegmentation</code></pre><p>Data segmentation such that the quantity is constant over a <code>track</code>, i.e., the observation &quot;night&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/calibration/jones.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.FixedSeg" href="#Comrade.FixedSeg"><code>Comrade.FixedSeg</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FixedSeg{T} &lt;: Comrade.ObsSegmentation</code></pre><p>Enforces that the station calibraton value will have a fixed <code>value</code>. This is most commonly used when enforcing a reference station for gain phases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/calibration/jones.jl#L41-L46">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Comrade.jonescache(::Comrade.EHTObservation, ::NamedTuple)</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Comrade.jonesStokes" href="#Comrade.jonesStokes"><code>Comrade.jonesStokes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">jonesStokes(g1::AbstractArray, gcache::AbstractJonesCache)
jonesStokes(f, g1::AbstractArray, gcache::AbstractJonesCache)</code></pre><p>Construct the Jones Pairs for the stokes I image only. That is, we only need to pass a single vector corresponding to the gain for the stokes I visibility. This is for when you only want to image Stokes I. The first argument is optional and denotes a function that is applied to every element of jones cache. For instance if <code>g1</code> and <code>g2</code> are the log-gains then <code>f=exp</code> will convert them into the gains.</p><p><strong>Warning</strong></p><p>In the future this functionality may be removed when stokes I fitting is replaced with the more correct <code>trace(coherency)</code>, i.e. RR+LL for a circular basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/calibration/jones.jl#L541-L556">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.jonesG" href="#Comrade.jonesG"><code>Comrade.jonesG</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">jonesG(g1::AbstractVector, g2::AbstractVector, jcache::AbstractJonesCache)
jonesG(f, g1::AbstractVector, g2::AbstractVector, jcache::AbstractJonesCache)</code></pre><p>Constructs the pairs Jones <code>G</code> matrices for each pair of stations. The <code>g1</code> are the gains for the first polarization basis and <code>g2</code> are the gains for the other polarization. The first argument is optional and denotes a function that is applied to every element of jones cache. For instance if <code>g1</code> and <code>g2</code> are the log-gains then <code>f=exp</code> will convert them into the gains.</p><p>The layout for each matrix is as follows:</p><pre><code class="nohighlight hljs">    g1 0
    0  g2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/calibration/jones.jl#L479-L494">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.jonesD" href="#Comrade.jonesD"><code>Comrade.jonesD</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">jonesD(d1::AbstractVector, d2::AbstractVector, jcache::AbstractJonesCache)
jonesD(f, d1::AbstractVector, d2::AbstractVector, jcache::AbstractJonesCache)</code></pre><p>Constructs the pairs Jones <code>D</code> matrices for each pair of stations. The <code>d1</code> are the d-termsfor the first polarization basis and <code>d2</code> are the d-terms for the other polarization. The first argument is optional and denotes a function that is applied to every element of jones cache. For instance if <code>d1</code> and <code>d2</code> are the log-dterms then <code>f=exp</code> will convert them into the dterms.</p><p>The layout for each matrix is as follows:</p><pre><code class="nohighlight hljs">    1  d1
    d2 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/calibration/jones.jl#L517-L532">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.jonesT" href="#Comrade.jonesT"><code>Comrade.jonesT</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">jonesT(tcache::TransformCache)</code></pre><p>Returns a <code>JonesPair</code> of matrices that transform from the model coherency matrices basis to the on-sky coherency basis, this includes the feed rotation and choice of polarization feeds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/calibration/jones.jl#L679-L684">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.PoincareSphere2Map" href="#Comrade.PoincareSphere2Map"><code>Comrade.PoincareSphere2Map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">PoincareSphere2Map(I, p, X, grid)
PoincareSphere2Map(I::IntensityMap, p, X)</code></pre><p>Constructs an polarized intensity map model using the Poincare parameterization. The arguments are:</p><ul><li><code>I</code> is a grid of fluxes for each pixel.</li><li><code>p</code> is a grid of numbers between 0, 1 and the represent the total fractional polarization</li><li><code>X</code> is a grid, where each element is 3 numbers that represents the point on the Poincare sphere that is, X[1,1] is a NTuple{3} such that <code>||X[1,1]|| == 1</code>.</li><li><code>grid</code> is the dimensional grid that gives the pixels locations of the intensity map.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If <code>I</code> is an <code>IntensityMap</code> then grid is not required since the same grid that was use for <code>I</code> will be used to construct the polarized intensity map</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The return type for this function is a polarized image object, however what we return is not considered to be part of the stable API so it may change suddenly.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/polarized.jl#L153-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.caltable" href="#Comrade.caltable"><code>Comrade.caltable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">caltable(args...)</code></pre><p>Creates a calibration table from a set of arguments. The specific arguments depend on what calibration you are applying.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/calibration/caltable.jl#L17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.JonesPairs" href="#Comrade.JonesPairs"><code>Comrade.JonesPairs</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct JonesPairs{T, M1&lt;:AbstractArray{T, 1}, M2&lt;:AbstractArray{T, 1}}</code></pre><p>Holds the pairs of Jones matrices for the first and second station of a baseline.</p><p><strong>Fields</strong></p><ul><li><code>m1</code>: Vector of jones matrices for station 1</li></ul><ul><li><code>m2</code>: Vector of jones matrices for station 2</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/calibration/jones.jl#L350-L357">source</a></section></article><h3 id="Combinators"><a class="docs-heading-anchor" href="#Combinators">Combinators</a><a id="Combinators-1"></a><a class="docs-heading-anchor-permalink" href="#Combinators" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Tuple{ComradeBase.AbstractModel, ComradeBase.AbstractModel}" href="#Base.:+-Tuple{ComradeBase.AbstractModel, ComradeBase.AbstractModel}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.:+(m1::AbstractModel, m2::AbstractModel)</code></pre><p>Combine two models to create a composite <a href="#Comrade.AddModel"><code>AddModel</code></a>. This adds two models pointwise, i.e.</p><pre><code class="language-julia-repl hljs">julia&gt; m1 = Gaussian()
julia&gt; m2 = Disk()
julia&gt; visibility(m1+m2, 1.0, 1.0) == visibility(m1, 1.0, 1.0) + visibility(m2, 1.0, 1.0)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/combinators.jl#L110-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.added" href="#Comrade.added"><code>Comrade.added</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">added(m1::AbstractModel, m2::AbstractModel)</code></pre><p>Combine two models to create a composite <a href="#Comrade.AddModel"><code>AddModel</code></a>. This adds two models pointwise, i.e.</p><pre><code class="language-julia-repl hljs">julia&gt; m1 = Gaussian()
julia&gt; m2 = Disk()
julia&gt; visibility(added(m1,m2), 1.0, 1.0) == visibility(m1, 1.0, 1.0) + visibility(m2, 1.0, 1.0)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/combinators.jl#L95-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.convolved" href="#Comrade.convolved"><code>Comrade.convolved</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">convolved(m1::AbstractModel, m2::AbstractModel)</code></pre><p>Convolve two models to create a composite <a href="#Comrade.ConvolvedModel"><code>ConvolvedModel</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; m1 = Ring()
julia&gt; m2 = Disk()
julia&gt; convolved(m1, m2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/combinators.jl#L274-L284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.components" href="#Comrade.components"><code>Comrade.components</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">components(m::AbstractModel)</code></pre><p>Returns the model components for a composite model. This will return a Tuple with all the models you have constructed.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m = Gaussian() + Disk()
julia&gt; components(m)
(Gaussian{Float64}(), Disk{Float64}())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/combinators.jl#L143-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.smoothed" href="#Comrade.smoothed"><code>Comrade.smoothed</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">smoothed(m::AbstractModel, σ::Number)</code></pre><p>Smooths a model <code>m</code> with a Gaussian kernel with standard deviation <code>σ</code>.</p><p><strong>Notes</strong></p><p>This uses <a href="#Comrade.convolved"><code>convolved</code></a> to created the model, i.e.</p><pre><code class="language-julia-repl hljs">julia&gt; m1 = Disk()
julia&gt; m2 = Gaussian()
julia&gt; convolved(m1, m2) == smoothed(m1, 1.0)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/combinators.jl#L287-L299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.CompositeModel" href="#Comrade.CompositeModel"><code>Comrade.CompositeModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type CompositeModel{M1, M2} &lt;: ComradeBase.AbstractModel</code></pre><p>Abstract type that denotes a composite model. Where we have combined two models together.</p><p><strong>Implementation</strong></p><p>Any implementation of a composite type must define the following methods:</p><ul><li>visibility_point</li><li>uv_combinator</li><li>imanalytic</li><li>visanalytic</li><li>ComradeBase.intensity_point if model intensity is <code>IsAnalytic</code></li><li>intensitymap_numeric! if model intensity is <code>NotAnalytic</code></li><li>intensitymap_numeric if model intensity is <code>NotAnalytic</code></li><li>flux</li><li>radialextent</li></ul><p>In addition there are additional optional methods a person can define if needed:</p><ul><li>intensitymap_analytic! if model intensity is <code>IsAnalytic</code>  (optional)</li><li>intensitymap_analytic if model intensity is <code>IsAnalytic</code> (optional)</li><li>visibilities_analytic if visanalytic is <code>IsAnalytic</code> (optional)</li><li>visibilities_numeric  if visanalytic is <code>Not Analytic</code> (optional)</li><li>visibilities_analytic! if visanalytic is <code>IsAnalytic</code> (optional)</li><li>visibilities_numeric!  if visanalytic is <code>Not Analytic</code> (optional)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/combinators.jl#L3-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.AddModel" href="#Comrade.AddModel"><code>Comrade.AddModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct AddModel{T1, T2} &lt;: Comrade.CompositeModel{T1, T2}</code></pre><p>Pointwise addition of two models in the image and visibility domain. An end user should instead call <a href="#Comrade.added"><code>added</code></a> or <code>Base.+</code> when constructing a model</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m1 = Disk() + Gaussian()
julia&gt; m2 = added(Disk(), Gaussian()) + Ring()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/combinators.jl#L76-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.ConvolvedModel" href="#Comrade.ConvolvedModel"><code>Comrade.ConvolvedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ConvolvedModel{M1, M2} &lt;: Comrade.CompositeModel{M1, M2}</code></pre><p>Pointwise addition of two models in the image and visibility domain. An end user should instead call <a href="#Comrade.convolved"><code>convolved</code></a>. Also see <a href="#Comrade.smoothed"><code>smoothed(m, σ)</code></a> for a simplified function that convolves a model <code>m</code> with a Gaussian with standard deviation <code>σ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/combinators.jl#L261-L268">source</a></section></article><h3 id="Geometric-and-Image-Models"><a class="docs-heading-anchor" href="#Geometric-and-Image-Models">Geometric and Image Models</a><a id="Geometric-and-Image-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Geometric-and-Image-Models" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Comrade.GeometricModel" href="#Comrade.GeometricModel"><code>Comrade.GeometricModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type GeometricModel &lt;: ComradeBase.AbstractModel</code></pre><p>A type that defines it is a geometric model. These are usually primitive models, and are usually analytic in Fourier and the image domain. As a result a user only needs to implement the following methods</p><ul><li><code>visibility_point</code></li><li><code>intensity_point</code></li><li><code>radialextent</code></li></ul><p>Note that if the geometric model isn&#39;t <strong>analytic</strong> then the usual methods listed in <a href="../base_api/#ComradeBase.AbstractModel"><code>Comrade.AbstractModel</code></a> for non-analytic models need to be implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/geometric_models.jl#L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.ConcordanceCrescent" href="#Comrade.ConcordanceCrescent"><code>Comrade.ConcordanceCrescent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ConcordanceCrescent{T} &lt;: Comrade.GeometricModel</code></pre><p>Creates the ConcordanceCrescent model, i.e. a flat-top crescent with a displacment and a slash and shadow depth. Note this creates a crescent with unit flux. If you want a different flux please use the <code>renomed</code> modifier.</p><p><strong>Fields</strong></p><ul><li><code>router</code>: Outer radius of the crescent</li></ul><ul><li><code>rinner</code>: Inner radius of the crescent (i.e. inside this radius there is a hole)</li></ul><ul><li><code>shift</code>: Displacment of the inner disk radius</li></ul><ul><li><code>slash</code>: Strength of the linear slash. Note that s∈[0.0,1.0] to ensure positivity in the image.</li></ul><p><strong>Notes</strong></p><p>Unlike the Gaussian and Disk models this does not create the unit version. In fact, this model could have been created using the <code>Disk</code> and primitives by using Comrade.jl&#39;s model composition functionality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/geometric_models.jl#L361-L377">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.Crescent" href="#Comrade.Crescent"><code>Comrade.Crescent</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Creates a <a href="https://academic.oup.com/mnras/article/434/1/765/1005984">Kamruddin and Dexter</a> crescent model. This works by composing two disk models together.</p><p><strong>Arguments</strong></p><ul><li><code>router</code>: The radius of the outer disk</li><li><code>rinner</code>: The radius of the inner disk</li><li><code>shift</code>: How much the inner disk radius is shifted (positive is to the right)</li><li><code>floor</code>: The floor of the inner disk 0 means the inner intensity is zero and 1 means it is a large disk.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/geometric_models.jl#L344-L355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.Disk" href="#Comrade.Disk"><code>Comrade.Disk</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Disk{T}() where {T}</code></pre><p>Tophat disk geometrical model, i.e. the intensity profile</p><p class="math-container">\[    I(x,y) = \begin{cases} \pi^{-1} &amp; x^2+y^2 &lt; 1 \\ 0 &amp; x^2+y^2 \geq 0 \end{cases}\]</p><p>i.e. a unit radius and unit flux disk.</p><p>By default if T isn&#39;t given, <code>Disk</code> defaults to <code>Float64</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/geometric_models.jl#L65-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.SlashedDisk" href="#Comrade.SlashedDisk"><code>Comrade.SlashedDisk</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SlashedDisk{T}(slash::T) where {T}</code></pre><p>Tophat disk geometrical model, i.e. the intensity profile</p><p class="math-container">\[    I(x,y) = \begin{cases} \pi^{-1} &amp; x^2+y^2 &lt; 1 \\ 0 &amp; x^2+y^2 \geq 0 \end{cases}\]</p><p>i.e. a unit radius and unit flux disk.</p><p>By default if T isn&#39;t given, <code>Disk</code> defaults to <code>Float64</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/geometric_models.jl#L93-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.ExtendedRing" href="#Comrade.ExtendedRing"><code>Comrade.ExtendedRing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ExtendedRing{F&lt;:Number} &lt;: Comrade.GeometricModel</code></pre><p>A symmetric extended ring whose radial profile follows an inverse gamma distributions.</p><p>The formula in the image domain is given by</p><pre><code class="nohighlight hljs">I(r,θ) = βᵅrᵅ⁻²exp(-β/r)/2πΓ(α)</code></pre><p>where <code>α = shape</code> and <code>β = shape+1</code></p><p><strong>Note</strong></p><p>We mainly use this as an example of a non-analytic Fourier transform (although it has a complicated expression)</p><p><strong>Fields</strong></p><ul><li><code>shape</code>: shape of the radial distribution</li></ul><p>Note that if <code>T</code> isn&#39;t specified at construction then it defaults to <code>Float64</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/geometric_models.jl#L441-L460">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.Gaussian" href="#Comrade.Gaussian"><code>Comrade.Gaussian</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Gaussian{T} &lt;: Comrade.GeometricModel</code></pre><p>Gaussian with unit standard deviation and flux.</p><p>By default if T isn&#39;t given, <code>Gaussian</code> defaults to <code>Float64</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/geometric_models.jl#L41-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.MRing" href="#Comrade.MRing"><code>Comrade.MRing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct MRing{T, V&lt;:Union{AbstractArray{T, 1}, Tuple{Vararg{T, N}} where {N, T}}} &lt;: Comrade.GeometricModel</code></pre><p>m-ring geometric model. This is a infinitely thin unit flux delta ring whose angular structure is given by a Fourier expansion. That is,</p><pre><code class="nohighlight hljs">I(r,θ) = (2π)⁻¹δ(r-1)∑ₙ(αₙcos(nθ) - βₙsin(nθ))</code></pre><p>The <code>N</code> in the type defines the order of the Fourier expansion.</p><p><strong>Fields</strong></p><ul><li><code>α</code>: Real Fourier mode coefficients</li></ul><ul><li><code>β</code>: Imaginary Fourier mode coefficients</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/geometric_models.jl#L198-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.Ring" href="#Comrade.Ring"><code>Comrade.Ring</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Ring{T} &lt;: Comrade.GeometricModel</code></pre><p>A infinitely thin ring model, whose expression in the image domain is     I(r,θ) = δ(r - 1)/2π i.e. a unit radius and flux delta ring.</p><p>By default if <code>T</code> isn&#39;t given, <code>Gaussian</code> defaults to <code>Float64</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/geometric_models.jl#L138-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.ParabolicSegment" href="#Comrade.ParabolicSegment"><code>Comrade.ParabolicSegment</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ParabolicSegment{T} &lt;: Comrade.GeometricModel</code></pre><p>A infinitely thin parabolic segment in the image domain. The segment is centered at zero, with roots ±1 and a yintercept of 1.</p><p>Note that if <code>T</code> isn&#39;t specified at construction then it defaults to <code>Float64</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/geometric_models.jl#L478-L485">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.ContinuousImage" href="#Comrade.ContinuousImage"><code>Comrade.ContinuousImage</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ContinuousImage{A&lt;:IntensityMap, P} &lt;: AbstractModel
ContinuousImage(img::Intensitymap, kernel)</code></pre><p>The basic continuous image model for Comrade. This expects a IntensityMap style object as its imag as well as a image kernel or pulse that allows you to evaluate the image at any image and visibility location. The image model is</p><pre><code class="nohighlight hljs">I(x,y) = ∑ᵢ Iᵢⱼ κ(x-xᵢ, y-yᵢ)</code></pre><p>where <code>Iᵢⱼ</code> are the flux densities of the image <code>img</code> and κ is the intensity function for the <code>kernel</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/continuous_image.jl#L3-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.ZeroModel" href="#Comrade.ZeroModel"><code>Comrade.ZeroModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ZeroModel{T} &lt;: ComradeBase.AbstractModel</code></pre><p>Defines a model that is <code>empty</code> that is it return zero for everything.</p><p><strong>Notes</strong></p><p>This returns 0 by using <code>FillArrays</code> so everything should be non-allocating</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/misc.jl#L3-L10">source</a></section></article><h3 id="Image-Pulses"><a class="docs-heading-anchor" href="#Image-Pulses">Image Pulses</a><a id="Image-Pulses-1"></a><a class="docs-heading-anchor-permalink" href="#Image-Pulses" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Comrade.Pulse" href="#Comrade.Pulse"><code>Comrade.Pulse</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Pulse</code></pre><p>Pixel response function for a radio image model. This makes a discrete sampling continuous by picking a certain <em>smoothing</em> kernel for the image.</p><p><strong>Notes</strong></p><p>To see the implemented Pulses please use the subtypes function i.e. <code>subtypes(Pulse)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/pulse.jl#L3-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.DeltaPulse" href="#Comrade.DeltaPulse"><code>Comrade.DeltaPulse</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DeltaPulse{T} &lt;: Comrade.Pulse</code></pre><p>A dirac comb pulse function. This means the image is just the dicrete Fourier transform</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/pulse.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.BSplinePulse" href="#Comrade.BSplinePulse"><code>Comrade.BSplinePulse</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">$(TYPEDEF)</code></pre><p>Uses the basis spline (BSpline) kernel of order <code>N</code>. These are the kernel that come from recursively convolving the tophat kernel</p><p class="math-container">\[    B_0(x) = \begin{cases} 1 &amp; |x| &lt; 1 \\ 0 &amp; otherwise \end{cases}\]</p><p><code>N</code> times.</p><p><strong>Notes</strong></p><p>BSpline kernels have a number of nice properties:</p><ol><li>Simple frequency response <span>$\sinc(u/2)^N$</span></li><li>preserve total intensity</li></ol><p>For <code>N</code>&gt;1 these kernels aren&#39;t actually interpolation kernels however, this doesn&#39;t matter for us.</p><p>Currently only the 0,1,3 order kernels are implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/pulse.jl#L39-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.RaisedCosinePulse" href="#Comrade.RaisedCosinePulse"><code>Comrade.RaisedCosinePulse</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RaisedCosinePulse{T} &lt;: Comrade.Pulse</code></pre><pre><code class="nohighlight hljs">RaisedCosinePulse()
RaisedCosinePulse(rolloff)</code></pre><p>Raised cosine pulse function. This tends to be a very flat response, where the roll off controls the speed of decay. By default we set <code>rolloff = 0.5</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/pulse.jl#L118-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.BicubicPulse" href="#Comrade.BicubicPulse"><code>Comrade.BicubicPulse</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct BicubicPulse{T} &lt;: Comrade.Pulse</code></pre><pre><code class="nohighlight hljs">BicubicPulse(b = 0.5)</code></pre><p>The bicubic pulse for imaging. This pulse tends to have a flat spectrum but for most values of <code>b</code> can produce negative intensities in an image. This is the pulse used in <a href="https://iopscience.iop.org/article/10.3847/1538-4357/ab9c1f"><code>Broderick et al. 2020</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/pulse.jl#L81-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.Butterworth" href="#Comrade.Butterworth"><code>Comrade.Butterworth</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Butterworth{N}()
Butterworth{N, T}()</code></pre><p>Construct a model that corresponds to the Butterworth filter of order <code>N</code>. The type of the output is given by <code>T</code> and if not given defaults to <code>Float64</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/geometric_models.jl#L174-L180">source</a></section></article><h3 id="Model-Image-(non-analytic-FFT)"><a class="docs-heading-anchor" href="#Model-Image-(non-analytic-FFT)">Model Image (non analytic FFT)</a><a id="Model-Image-(non-analytic-FFT)-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Image-(non-analytic-FFT)" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Comrade.create_cache" href="#Comrade.create_cache"><code>Comrade.create_cache</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_cache(alg::AbstractFourierTransform, img::AbstractIntensityMap)</code></pre><p>Creates a Fourier transform cache for a img using algorithm <code>alg</code>. For non-analytic visibility models this can significantly speed up computations.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; u,v = rand(100), rand(100)
julia&gt; cache = create_cache(DFTAlg(u, v), IntensityMap(randn(50,50), 10.0, 10.0))
julia&gt; cache = create_cache(NFFTAlg(u, v), IntensityMap(randn(50,50), 10.0, 10.0))
julia&gt; cache = create_cache(FFTAlg(), IntensityMap(randn(50,50), 10.0, 10.0))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/modelimage/cache.jl#L16-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.update_cache" href="#Comrade.update_cache"><code>Comrade.update_cache</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_cache(cache, img)</code></pre><p>Update the Fourier transform cache. This will reuse an FFT/NFFT plan saving some computational time.</p><p><strong>Note</strong></p><p>This is an intenal method than an end user shouldn&#39;t have to usually call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/modelimage/cache.jl#L33-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.modelimage" href="#Comrade.modelimage"><code>Comrade.modelimage</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">modelimage(model::AbstractModel, image::AbstractIntensityMap, alg=FFTAlg())</code></pre><p>Construct a <code>ModelImage</code> from a <code>model</code>, <code>image</code> and the optionally specified visibility algorithm <code>alg</code></p><p><strong>Notes</strong></p><p>For analytic models this is a no-op and returns the model. For non-analytic models this creates a <code>ModelImage</code> object which uses <code>alg</code> to compute the non-analytic Fourier transform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/modelimage/modelimage.jl#L74-L84">source</a></section><section><div><pre><code class="nohighlight hljs">modelimage(model, cache::AbstractCach))</code></pre><p>Construct a <code>ModelImage</code> from the <code>model</code> and using a precompute Fourier transform <code>cache</code>. You can optionally specify th which will compute the internal image buffer using the`.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m = ExtendedRing(10.0)
julia&gt; cache = create_cache(DFTAlg(), IntensityMap(zeros(128, 128), 50.0, 50.0)) # used threads to make the image
julia&gt; mimg = modelimage(m, cache, true)</code></pre><p><strong>Notes</strong></p><p>For analytic models this is a no-op and returns the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/modelimage/modelimage.jl#L118-L136">source</a></section><section><div><pre><code class="nohighlight hljs">modelimage(m;
           fovx=2*radialextent(m),
           fovy=2*radialextent(m),
           nx=512,
           ny=512,
           alg=FFTAlg(),
           pulse=ComradeBase.DeltaPulse(),
            )</code></pre><p>Construct a <code>ModelImage</code> where just the model <code>m</code> is specified.</p><p>If <code>fovx</code> or <code>fovy</code> aren&#39;t given <code>modelimage</code> will <em>guess</em> a reasonable field of view based on the <code>radialextent</code> function. <code>nx</code> and <code>ny</code> are the number of pixels in the x and y direction. The <code>pulse</code> is the pulse used for the image and <code>alg</code></p><p><strong>Notes</strong></p><p>For analytic models this is a no-op and returns the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/modelimage/modelimage.jl#L150-L169">source</a></section><section><div><pre><code class="nohighlight hljs">modelimage(img::ContinuousImage, alg=NFFTAlg())</code></pre><p>Create a model image directly using an image, i.e. treating it as the model. You can optionally specify the Fourier transform algorithm using <code>alg</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/continuous_image.jl#L102-L107">source</a></section><section><div><pre><code class="nohighlight hljs">modelimage(img::ContinuousImage, cache::AbstractCache)</code></pre><p>Create a model image directly using an image, i.e. treating it as the model. Additionally reuse a previously compute image <code>cache</code>. This can be used when directly modeling an image of a fixed size and number of pixels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/continuous_image.jl#L113-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.uviterator" href="#Comrade.uviterator"><code>Comrade.uviterator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">uviterator(nx, dx, ny dy)</code></pre><p>Construct the u,v iterators for the Fourier transform of the image with pixel sizes <code>dx, dy</code> and number of pixels <code>nx, ny</code></p><p>If you are extending Fourier transform stuff please use these functions to ensure that the centroid is being properly computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/modelimage/fft_alg.jl#L196-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.fouriermap" href="#Comrade.fouriermap"><code>Comrade.fouriermap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fouriermap(m, x)</code></pre><p>Create a Fourier or visibility map of a model <code>m</code> where the image is specified in the image domain by the pixel locations <code>x</code> and <code>y</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/modelimage/fft_alg.jl#L221-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.ModelImage" href="#Comrade.ModelImage"><code>Comrade.ModelImage</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ModelImage{M, I, C} &lt;: Comrade.AbstractModelImage{M}</code></pre><p>Container for non-analytic model that contains a image cache which will hold the image, a Fourier transform cache, which usually an instance of a &lt;: FourierCache.</p><p><strong>Note</strong></p><p>This is an internal implementation detail that shouldn&#39;t usually be called directly. Instead the user should use the exported function <code>modelimage</code>, for example</p><pre><code class="language-julia hljs">using Comrade
m = ExtendedRing(20.0, 5.0)

# This creates an version where the image is dynamically specified according to the
# radial extent of the image
mimg = modelimage(m) # you can also optionally pass the number of pixels nx and ny

# Or you can create an IntensityMap
img = intensitymap(m, 100.0, 100.0, 512, 512)
mimg = modelimage(m, img)

# Or precompute a cache
cache = create_cache(FFTAlg(), img)
mimg = modelimage(m, cache)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/modelimage/modelimage.jl#L3-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.DFTAlg" href="#Comrade.DFTAlg"><code>Comrade.DFTAlg</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DFTAlg</code></pre><p>Uses a discrete fourier transform. This is not very efficient for larger images. In those cases  NFFTAlg or FFTAlg are more reasonable. For small images this is a reasonable choice especially since it&#39;s easy to define derivatives.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/modelimage/nuft.jl#L157-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.DFTAlg-Tuple{Comrade.EHTObservation}" href="#Comrade.DFTAlg-Tuple{Comrade.EHTObservation}"><code>Comrade.DFTAlg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DFTAlg(obs::EHTObservation)</code></pre><p>Create an algorithm object using the direct Fourier transform object from the observation <code>obs</code>. This will extract the uv positions from the observation to allow for a more efficient FT cache.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/modelimage/dft_alg.jl#L6-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.DFTAlg-Tuple{AbstractArray, AbstractArray}" href="#Comrade.DFTAlg-Tuple{AbstractArray, AbstractArray}"><code>Comrade.DFTAlg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DFTAlg(u::AbstractArray, v::AbstractArray)</code></pre><p>Create an algorithm object using the direct Fourier transform object using the uv positions <code>u</code>, <code>v</code> allowing for a more efficient transform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/modelimage/dft_alg.jl#L30-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.DFTAlg-Tuple{Comrade.ArrayConfiguration}" href="#Comrade.DFTAlg-Tuple{Comrade.ArrayConfiguration}"><code>Comrade.DFTAlg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DFTAlg(ac::ArrayConfiguration)</code></pre><p>Create an algorithm object using the direct Fourier transform object from the array configuration <code>ac</code>. This will extract the uv positions from the observation to allow for a more efficient FT cache.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/modelimage/dft_alg.jl#L18-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.FFTAlg" href="#Comrade.FFTAlg"><code>Comrade.FFTAlg</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FFTAlg &lt;: Comrade.FourierTransform</code></pre><p>Use an FFT to compute the approximate numerical visibilities of a model. For a DTFT see <a href="#Comrade.DFTAlg"><code>DFTAlg</code></a> or for an NFFT <a href="#Comrade.NFFTAlg"><code>NFFTAlg</code></a></p><p><strong>Fields</strong></p><ul><li><code>padfac</code>: The amount to pad the image by. Note we actually round up to the nearest factor of 2, but this will be improved in the future to use small primes</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/modelimage/cache.jl#L45-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.FFTCache" href="#Comrade.FFTCache"><code>Comrade.FFTCache</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FFTCache{A&lt;:FFTAlg, P, I, Pu, S} &lt;: Comrade.AbstractCache</code></pre><p>The cache used when the <code>FFT</code> algorithm is used to compute visibilties. This is an internal type and is not part of the public API</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/modelimage/fft_alg.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.NFFTAlg" href="#Comrade.NFFTAlg"><code>Comrade.NFFTAlg</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NFFTAlg</code></pre><p>Uses a non-uniform FFT to compute the visibilities. You can optionally pass uv which are the uv positions you will compute the NFFT at. This can allow for the NFFT plan to be cached improving performance</p><p><strong>Fields</strong></p><ul><li><code>padfac</code>: Amount to pad the image</li></ul><ul><li><code>m</code>: Kernel size parameters. This controls the accuracy of NFFT you do not usually need to change this</li></ul><ul><li><code>σ</code>: Over sampling factor. This controls the accuracy of NFFT you do not usually need to change this.</li></ul><ul><li><code>window</code>: Window function for the NFFT. You do not usually need to change this</li></ul><ul><li><code>precompute</code>: NFFT interpolation algorithm. TENSOR is the fastest but takes the longest to precompute</li></ul><ul><li><code>blocking</code>: Flag blcok partioning should be used to speed up computation</li></ul><ul><li><code>sortNodes</code>: Flag if the node should be sorted in a lexicographic way</li></ul><ul><li><code>storeDeconvolutionIdx</code>: Flag if the deconvolve indices should be stored, Currently required for GPU</li></ul><ul><li><code>fftflags</code>: Flag passed to inner AbstractFFT. The fastest FFTW is FFTW.MEASURE but takes the longest to precompute</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/modelimage/nuft.jl#L105-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.NUFTCache" href="#Comrade.NUFTCache"><code>Comrade.NUFTCache</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NUFTCache{A, P, M, PI, I} &lt;: Comrade.AbstractCache</code></pre><p>Internal type used to store the cache for a non-uniform Fourier transform (NUFT).</p><p>The user should instead create this using the <a href="#Comrade.create_cache"><code>create_cache</code></a> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/modelimage/cache.jl#L88-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.ObservedNUFT" href="#Comrade.ObservedNUFT"><code>Comrade.ObservedNUFT</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ObservedNUFT{A&lt;:Comrade.NUFT, T} &lt;: Comrade.NUFT</code></pre><p>Container type for a non-uniform Fourier transform (NUFT). This stores the uv-positions that the model will be sampled at in the Fourier domain, allowing certain transformtion factors (e.g., NUFT matrix) to be cached.</p><p>This is an internal type, an end user should instead create this using <a href="#Comrade.NFFTAlg"><code>NFFTAlg</code></a> or <a href="#Comrade.DFTAlg"><code>DFTAlg</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/modelimage/cache.jl#L66-L75">source</a></section></article><h3 id="Modifiers"><a class="docs-heading-anchor" href="#Modifiers">Modifiers</a><a id="Modifiers-1"></a><a class="docs-heading-anchor-permalink" href="#Modifiers" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Comrade.basemodel" href="#Comrade.basemodel"><code>Comrade.basemodel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basemodel(model::ModifiedModel)</code></pre><p>Returns the ModifiedModel with the last transformation stripped.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; basemodel(stretched(Disk(), 1.0, 2.0)) == Disk()
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/modifiers.jl#L106-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.unmodified" href="#Comrade.unmodified"><code>Comrade.unmodified</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unmodified(model::ModifiedModel)</code></pre><p>Returns the un-modified model</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m = stretched(rotated(Gaussian(), π/4), 2.0, 1.0)
julia&gt; umodified(m) == Gaussian()
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/modifiers.jl#L91-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.renormed" href="#Comrade.renormed"><code>Comrade.renormed</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">renormed(model, f)
</code></pre><p>Renormalizes the model <code>m</code> to have total flux <code>f*flux(m)</code>. This can also be done directly by calling <code>Base.:*</code> i.e.,</p><pre><code class="language-julia-repl hljs">julia&gt; renormed(m, f) == f*M
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/modifiers.jl#L468-L478">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.rotated" href="#Comrade.rotated"><code>Comrade.rotated</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotated(model, ξ)
</code></pre><p>Rotates the model by an amount <code>ξ</code> in radians in the clockwise direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/modifiers.jl#L553-L557">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.posangle" href="#Comrade.posangle"><code>Comrade.posangle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">posangle(model)
</code></pre><p>Returns the rotation angle of the rotated <code>model</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/modifiers.jl#L560-L564">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.shifted" href="#Comrade.shifted"><code>Comrade.shifted</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">shifted(model, Δx, Δy)
</code></pre><p>Shifts the model <code>m</code> in the image domain by an amount <code>Δx,Δy</code> in the x and y directions respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/modifiers.jl#L427-L432">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.stretched" href="#Comrade.stretched"><code>Comrade.stretched</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stretched(model, α, β)
</code></pre><p>Stretches the model <code>m</code> according to the formula     Iₛ(x,y) = 1/(αβ) I(x/α, y/β), where were renormalize the intensity to preserve the models flux.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/modifiers.jl#L516-L522">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Comrade.AbstractModifier</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Comrade.RenormalizedModel</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Comrade.RotatedModel</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Comrade.ShiftedModel</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Comrade.StretchedModel</code>. Check Documenter&#39;s build log for details.</p></div></div><h3 id="Polarized-Models"><a class="docs-heading-anchor" href="#Polarized-Models">Polarized Models</a><a id="Polarized-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Polarized-Models" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.mbreve" href="#ComradeBase.mbreve"><code>ComradeBase.mbreve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mbreve(pimg, p)
</code></pre><p>Explicit m̆ function used for convenience.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/polarized.jl#L214-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.evpa-Tuple{ComradeBase.AbstractPolarizedModel, Any}" href="#ComradeBase.evpa-Tuple{ComradeBase.AbstractPolarizedModel, Any}"><code>ComradeBase.evpa</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evpa(pimg::AbstractPolarizedModel, p)</code></pre><p>electric vector position angle or EVPA of the polarized model <code>pimg</code> at <code>u</code> and <code>v</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/polarized.jl#L184-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.PolarizedModel" href="#Comrade.PolarizedModel"><code>Comrade.PolarizedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct PolarizedModel{TI, TQ, TU, TV} &lt;: ComradeBase.AbstractPolarizedModel</code></pre><p>Wrapped model for a polarized model. This uses the stokes representation of the image.</p><p><strong>Fields</strong></p><ul><li><code>I</code>: Stokes I model</li></ul><ul><li><code>Q</code>: Stokes Q Model</li></ul><ul><li><code>U</code>: Stokes U Model</li></ul><ul><li><code>V</code>: Stokes V Model</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/polarized.jl#L5-L12">source</a></section></article><h3 id="Model-Evaluation"><a class="docs-heading-anchor" href="#Model-Evaluation">Model Evaluation</a><a id="Model-Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Evaluation" title="Permalink"></a></h3><p>For more docstrings on how to evaluate models see <a href="../base_api/#ComradeBase-API">ComradeBase API</a>.</p><article class="docstring"><header><a class="docstring-binding" id="Comrade.amplitude" href="#Comrade.amplitude"><code>Comrade.amplitude</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">amplitude(d::EHTVisibilityDatum)</code></pre><p>Get the amplitude of a visibility datum</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/observations.jl#L333-L337">source</a></section><section><div><pre><code class="language-julia hljs">amplitude(d::EHTVisibilityAmplitudeDatum)</code></pre><p>Get the amplitude of a amplitude datum</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/observations.jl#L401-L405">source</a></section><section><div><pre><code class="nohighlight hljs">amplitude(model, p)</code></pre><p>Computes the visibility amplitude of model <code>m</code> at the coordinate <code>p</code>. The coordinate <code>p</code> is expected to have the properties <code>U</code>, <code>V</code>, and sometimes <code>Ti</code> and <code>Fr</code>.</p><p>If you want to compute the amplitudes at a large number of positions consider using the <code>amplitudes</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/methods.jl#L18-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.amplitudes" href="#Comrade.amplitudes"><code>Comrade.amplitudes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">amplitudes(m::AbstractModel, u::AbstractArray, v::AbstractArray)</code></pre><p>Computes the visibility amplitudes of the model <code>m</code> at the coordinates <code>p</code>. The coordinates <code>p</code> are expected to have the properties <code>U</code>, <code>V</code>, and sometimes <code>Ti</code> and <code>Fr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/methods.jl#L142-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.bispectra" href="#Comrade.bispectra"><code>Comrade.bispectra</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bispectra(m, p1, p2, p3)</code></pre><p>Computes the closure phases of the model <code>m</code> at the triangles p1, p2, p3, where <code>pi</code> are coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/methods.jl#L173-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.bispectrum" href="#Comrade.bispectrum"><code>Comrade.bispectrum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bispectrum(d1::T, d2::T, d3::T) where {T&lt;:EHTVisibilityDatum}</code></pre><p>Finds the bispectrum of three visibilities. We will assume these form closed triangles, i.e. the phase of the bispectrum is a closure phase.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/observations.jl#L411-L416">source</a></section><section><div><pre><code class="nohighlight hljs">bispectrum(model, p1, p2, p3)</code></pre><p>Computes the complex bispectrum of model <code>m</code> at the uv-triangle p1 -&gt; p2 -&gt; p3</p><p>If you want to compute the bispectrum over a number of triangles consider using the <code>bispectra</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/methods.jl#L32-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.closure_phase" href="#Comrade.closure_phase"><code>Comrade.closure_phase</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">closure_phase(D1::EHTVisibilityDatum,
              D2::EHTVisibilityDatum,
              D3::EHTVisibilityDatum
              )</code></pre><p>Computes the closure phase of the three visibility datums.</p><p><strong>Notes</strong></p><p>We currently use the high SNR Gaussian error approximation for the closure phase. In the future we may use the moment matching from Monte Carlo sampling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/observations.jl#L534-L545">source</a></section><section><div><pre><code class="nohighlight hljs">closure_phase(model, p1, p2, p3, p4)</code></pre><p>Computes the closure phase of model <code>m</code> at the uv-triangle u1,v1 -&gt; u2,v2 -&gt; u3,v3</p><p>If you want to compute closure phases over a number of triangles consider using the <code>closure_phases</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/methods.jl#L45-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.closure_phases" href="#Comrade.closure_phases"><code>Comrade.closure_phases</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">closure_phases(m,
               p1::AbstractArray
               p2::AbstractArray
               p3::AbstractArray
               )</code></pre><p>Computes the closure phases of the model <code>m</code> at the triangles p1, p2, p3, where <code>pi</code> are coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/methods.jl#L216-L225">source</a></section><section><div><pre><code class="nohighlight hljs">closure_phases(m::AbstractModel, ac::ClosureConfig)</code></pre><p>Computes the closure phases of the model <code>m</code> using the array configuration <code>ac</code>.</p><p><strong>Notes</strong></p><p>This is faster than the <code>closure_phases(m, u1, v1, ...)</code> method since it only computes as many visibilities as required thanks to the closure design matrix formalism from Blackburn et al.<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/methods.jl#L232-L243">source</a></section><section><div><pre><code class="nohighlight hljs">closure_phases(vis::AbstractArray, ac::ArrayConfiguration)</code></pre><p>Compute the closure phases for a set of visibilities and an array configuration</p><p><strong>Notes</strong></p><p>This uses a closure design matrix for the computation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/distributions/radiolikelihood.jl#L143-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.logclosure_amplitude" href="#Comrade.logclosure_amplitude"><code>Comrade.logclosure_amplitude</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">logclosure_amplitude(model, p1, p2, p3, p4)</code></pre><p>Computes the log-closure amplitude of model <code>m</code> at the uv-quadrangle u1,v1 -&gt; u2,v2 -&gt; u3,v3 -&gt; u4,v4 using the formula</p><p class="math-container">\[C = \log\left|\frac{V(u1,v1)V(u2,v2)}{V(u3,v3)V(u4,v4)}\right|\]</p><p>If you want to compute log closure amplitudes over a number of triangles consider using the <code>logclosure_amplitudes</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/methods.jl#L58-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.logclosure_amplitudes" href="#Comrade.logclosure_amplitudes"><code>Comrade.logclosure_amplitudes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">logclosure_amplitudes(m::AbstractModel,
                      p1,
                      p2,
                      p3,
                      p4
                     )</code></pre><p>Computes the log closure amplitudes of the model <code>m</code> at the quadrangles p1, p2, p3, p4.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/methods.jl#L268-L278">source</a></section><section><div><pre><code class="nohighlight hljs">logclosure_amplitudes(m::AbstractModel, ac::ClosureConfig)</code></pre><p>Computes the log closure amplitudes of the model <code>m</code> using the array configuration <code>ac</code>.</p><p><strong>Notes</strong></p><p>This is faster than the <code>logclosure_amplitudes(m, u1, v1, ...)</code> method since it only computes as many visibilities as required thanks to the closure design matrix formalism from Blackburn et al.<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/methods.jl#L288-L299">source</a></section><section><div><pre><code class="nohighlight hljs">logclosure_amplitudes(vis::AbstractArray, ac::ArrayConfiguration)</code></pre><p>Compute the log-closure amplitudes for a set of visibilities and an array configuration</p><p><strong>Notes</strong></p><p>This uses a closure design matrix for the computation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/distributions/radiolikelihood.jl#L130-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.visibility" href="#Comrade.visibility"><code>Comrade.visibility</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">visibility(d::EHTVisibilityDatum)</code></pre><p>Return the complex visibility of the visibility datum</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/observations.jl#L323-L327">source</a></section><section><div><pre><code class="nohighlight hljs">visibility(mimg, p)</code></pre><p>Computes the complex visibility of model <code>m</code> at coordinates <code>p</code>. <code>p</code> corresponds to the coordinates of the model. These need to have the properties <code>U</code>, <code>V</code> and sometimes <code>Ti</code> for time and <code>Fr</code> for frequency.</p><p><strong>Notes</strong></p><p>If you want to compute the visibilities at a large number of positions consider using the <a href="../base_api/#ComradeBase.visibilities"><code>visibilities</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/methods.jl#L1-L11">source</a></section></article><h2 id="Data-Types"><a class="docs-heading-anchor" href="#Data-Types">Data Types</a><a id="Data-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Comrade.amplitude-Tuple{Comrade.EHTVisibilityDatum}" href="#Comrade.amplitude-Tuple{Comrade.EHTVisibilityDatum}"><code>Comrade.amplitude</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">amplitude(d::EHTVisibilityDatum)</code></pre><p>Get the amplitude of a visibility datum</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/observations.jl#L333-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.amplitude-Tuple{Comrade.EHTVisibilityAmplitudeDatum}" href="#Comrade.amplitude-Tuple{Comrade.EHTVisibilityAmplitudeDatum}"><code>Comrade.amplitude</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">amplitude(d::EHTVisibilityAmplitudeDatum)</code></pre><p>Get the amplitude of a amplitude datum</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/observations.jl#L401-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.baselines" href="#Comrade.baselines"><code>Comrade.baselines</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">baselines(CP::EHTClosurePhaseDatum)</code></pre><p>Returns the baselines used for a single closure phase datum</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/observations.jl#L569-L573">source</a></section><section><div><pre><code class="nohighlight hljs">baselines(CP::EHTLogClosureAmplitudeDatum)</code></pre><p>Returns the baselines used for a single closure phase datum</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/observations.jl#L645-L649">source</a></section><section><div><pre><code class="nohighlight hljs">baselines(scan::Scan)</code></pre><p>Return the baselines for each datum in a scan</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/observations.jl#L753-L757">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.arrayconfig" href="#Comrade.arrayconfig"><code>Comrade.arrayconfig</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">arrayconfig(vis)
</code></pre><p>Extract the array configuration from a EHT observation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/observations.jl#L663-L667">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.closure_phase-Tuple{Comrade.EHTVisibilityDatum, Comrade.EHTVisibilityDatum, Comrade.EHTVisibilityDatum}" href="#Comrade.closure_phase-Tuple{Comrade.EHTVisibilityDatum, Comrade.EHTVisibilityDatum, Comrade.EHTVisibilityDatum}"><code>Comrade.closure_phase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">closure_phase(D1::EHTVisibilityDatum,
              D2::EHTVisibilityDatum,
              D3::EHTVisibilityDatum
              )</code></pre><p>Computes the closure phase of the three visibility datums.</p><p><strong>Notes</strong></p><p>We currently use the high SNR Gaussian error approximation for the closure phase. In the future we may use the moment matching from Monte Carlo sampling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/observations.jl#L534-L545">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.getdata" href="#Comrade.getdata"><code>Comrade.getdata</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getdata(obs::EHTObservation, s::Symbol)</code></pre><p>Pass-through function that gets the array of <code>s</code> from the EHTObservation. For example say you want the times of all measurement then</p><pre><code class="language-julia hljs">getdata(obs, :time)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/observations.jl#L218-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.getuv" href="#Comrade.getuv"><code>Comrade.getuv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getuv</code></pre><p>Get the u, v positions of the array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/observations.jl#L83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.getuvtimefreq" href="#Comrade.getuvtimefreq"><code>Comrade.getuvtimefreq</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getuvtimefreq(ac)
</code></pre><p>Get the u, v, time, freq of the array as a tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/observations.jl#L98-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.scantable" href="#Comrade.scantable"><code>Comrade.scantable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">scantable(obs::EHTObservation)</code></pre><p>Reorganizes the observation into a table of scans, where scan are defined by unique timestamps. To access the data you can use scalar indexing</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">st = scantable(obs)
# Grab the first scan
scan1 = st[1]

# Acess the detections in the scan
scan1[1]

# grab e.g. the baselines
scan1[:baseline]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/observations.jl#L833-L852">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.stations" href="#Comrade.stations"><code>Comrade.stations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stations(d::EHTObservation)</code></pre><p>Get all the stations in a observation. The result is a vector of symbols.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/observations.jl#L256-L260">source</a></section><section><div><pre><code class="nohighlight hljs">stations(g::CalTable)</code></pre><p>Return the stations in the calibration table</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/calibration/caltable.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.uvpositions" href="#Comrade.uvpositions"><code>Comrade.uvpositions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">uvpositions(datum::AbstractVisibilityDatum)</code></pre><p>Get the uvp positions of an inferometric datum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/observations.jl#L167-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.ArrayConfiguration" href="#Comrade.ArrayConfiguration"><code>Comrade.ArrayConfiguration</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type ArrayConfiguration</code></pre><p>This defined the abstract type for an array configuration. Namely, baseline times, SEFD&#39;s, bandwidth, observation frequencies, etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/observations.jl#L22-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.ClosureConfig" href="#Comrade.ClosureConfig"><code>Comrade.ClosureConfig</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ClosureConfig{A, D} &lt;: Comrade.ArrayConfiguration</code></pre><p>Array config file for closure quantities. This stores the design matrix <code>designmat</code> that transforms from visibilties to closure products.</p><p><strong>Fields</strong></p><ul><li><p><code>ac</code>: Array configuration for visibilities</p></li><li><p><code>designmat</code>: Closure design matrix</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/observations.jl#L61-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.AbstractInterferometryDatum" href="#Comrade.AbstractInterferometryDatum"><code>Comrade.AbstractInterferometryDatum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractInterferometryDatum{T}</code></pre><p>An abstract type for all VLBI interfermetry data types. See <a href="@ref">Comrade.EHTVisibilityDatum</a> for an example.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/observations.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.ArrayBaselineDatum" href="#Comrade.ArrayBaselineDatum"><code>Comrade.ArrayBaselineDatum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ArrayBaselineDatum{T, E, V}</code></pre><p>A single datum of an <code>ArrayConfiguration</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/observations.jl#L115-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.EHTObservation" href="#Comrade.EHTObservation"><code>Comrade.EHTObservation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct EHTObservation{F, T&lt;:Comrade.AbstractInterferometryDatum{F}, S&lt;:(StructArrays.StructArray{T&lt;:Comrade.AbstractInterferometryDatum{F}}), A, N} &lt;: Comrade.Observation{F}</code></pre><p>The main data product type in <code>Comrade</code> this stores the <code>data</code> which can be a StructArray of any <code>AbstractInterferometryDatum</code> type.</p><p><strong>Fields</strong></p><ul><li><code>data</code>: StructArray of data productts</li></ul><ul><li><code>config</code>: Array config holds ancillary information about array</li></ul><ul><li><code>mjd</code>: modified julia date of the observation</li></ul><ul><li><code>ra</code>: RA of the observation in J2000 (deg)</li></ul><ul><li><code>dec</code>: DEC of the observation in J2000 (deg)</li></ul><ul><li><code>bandwidth</code>: bandwidth of the observation (Hz)</li></ul><ul><li><code>source</code>: Common source name</li></ul><ul><li><code>timetype</code>: Time zone used.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/observations.jl#L174-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.EHTArrayConfiguration" href="#Comrade.EHTArrayConfiguration"><code>Comrade.EHTArrayConfiguration</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct EHTArrayConfiguration{F, T, S, D&lt;:AbstractArray} &lt;: Comrade.ArrayConfiguration</code></pre><p>Stores all the non-visibility data products for an EHT array. This is useful when evaluating model visibilities.</p><p><strong>Fields</strong></p><ul><li><code>bandwidth</code>: Observing bandwith (Hz)</li></ul><ul><li><code>tarr</code>: Telescope array file</li></ul><ul><li><code>scans</code>: Scan times</li></ul><ul><li><code>data</code>: A struct array of <code>ArrayBaselineDatum</code> holding time, freq, u, v, baselines.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/observations.jl#L30-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.EHTCoherencyDatum" href="#Comrade.EHTCoherencyDatum"><code>Comrade.EHTCoherencyDatum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct EHTCoherencyDatum{S, B1, B2, M&lt;:(StaticArraysCore.SArray{Tuple{2, 2}, Complex{S}, 2}), E&lt;:(StaticArraysCore.SArray{Tuple{2, 2}, S, 2})} &lt;: Comrade.AbstractInterferometryDatum{S}</code></pre><p>A Datum for a single coherency matrix</p><p><strong>Fields</strong></p><ul><li><code>measurement</code>: coherency matrix, with entries in Jy</li></ul><ul><li><code>error</code>: visibility uncertainty matrix, with entries in Jy</li></ul><ul><li><code>U</code>: x-direction baseline length, in λ</li></ul><ul><li><code>V</code>: y-direction baseline length, in λ</li></ul><ul><li><code>T</code>: Timestamp, in hours</li></ul><ul><li><code>F</code>: Frequency, in Hz</li></ul><ul><li><code>baseline</code>: station baseline codes</li></ul><ul><li><code>polbasis</code>: polarization basis for each station</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/observations.jl#L481-L489">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.EHTClosurePhaseDatum" href="#Comrade.EHTClosurePhaseDatum"><code>Comrade.EHTClosurePhaseDatum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct EHTClosurePhaseDatum{S&lt;:Number} &lt;: Comrade.ClosureProducts{S&lt;:Number}</code></pre><p>A Datum for a single closure phase.</p><p><strong>Fields</strong></p><ul><li><code>measurement</code>: closure phase (rad)</li></ul><ul><li><code>error</code>: error of the closure phase assuming the high-snr limit</li></ul><ul><li><code>U1</code>: u (λ) of first station</li></ul><ul><li><code>V1</code>: v (λ) of first station</li></ul><ul><li><code>U2</code>: u (λ) of second station</li></ul><ul><li><code>V2</code>: v (λ) of second station</li></ul><ul><li><code>U3</code>: u (λ) of third station</li></ul><ul><li><code>V3</code>: v (λ) of third station</li></ul><ul><li><code>T</code>: Measured time of closure phase in hours</li></ul><ul><li><code>F</code>: Measured frequency of closure phase in Hz</li></ul><ul><li><code>triangle</code>: station baselines used</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/observations.jl#L424-L432">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.EHTLogClosureAmplitudeDatum" href="#Comrade.EHTLogClosureAmplitudeDatum"><code>Comrade.EHTLogClosureAmplitudeDatum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct EHTLogClosureAmplitudeDatum{S&lt;:Number} &lt;: Comrade.ClosureProducts{S&lt;:Number}</code></pre><p>A Datum for a single log closure amplitude.</p><p><strong></strong></p><ul><li><code>measurement</code>: log-closure amplitude</li></ul><ul><li><code>error</code>: log-closure amplitude error in the high-snr limit</li></ul><ul><li><code>U1</code>: u (λ) of first station</li></ul><ul><li><code>V1</code>: v (λ) of first station</li></ul><ul><li><code>U2</code>: u (λ) of second station</li></ul><ul><li><code>V2</code>: v (λ) of second station</li></ul><ul><li><code>U3</code>: u (λ) of third station</li></ul><ul><li><code>V3</code>: v (λ) of third station</li></ul><ul><li><code>U4</code>: u (λ) of fourth station</li></ul><ul><li><code>V4</code>: v (λ) of fourth station</li></ul><ul><li><code>T</code>: Measured time of closure phase in hours</li></ul><ul><li><code>F</code>: Measured frequency of closure phase in Hz</li></ul><ul><li><code>quadrangle</code>: station codes for the quadrangle</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/observations.jl#L581-L588">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.EHTVisibilityDatum" href="#Comrade.EHTVisibilityDatum"><code>Comrade.EHTVisibilityDatum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct EHTVisibilityDatum{S&lt;:Number} &lt;: Comrade.AbstractVisibilityDatum{S&lt;:Number}</code></pre><p>A struct holding the information for a single measured visibility.</p><p><strong></strong></p><ul><li><code>measurement</code>: real component of the visibility (Jy)</li></ul><ul><li><code>error</code>: error of the visibility (Jy)</li></ul><ul><li><code>U</code>: u position of the data point in λ</li></ul><ul><li><code>V</code>: v position of the data point in λ</li></ul><ul><li><code>T</code>: time of the data point in (Hr)</li></ul><ul><li><code>F</code>: frequency of the data point (Hz)</li></ul><ul><li><code>baseline</code>: station baseline codes</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/observations.jl#L284-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.EHTVisibilityAmplitudeDatum" href="#Comrade.EHTVisibilityAmplitudeDatum"><code>Comrade.EHTVisibilityAmplitudeDatum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct EHTVisibilityAmplitudeDatum{S&lt;:Number} &lt;: Comrade.AbstractVisibilityDatum{S&lt;:Number}</code></pre><p>A struct holding the information for a single measured visibility amplitude.</p><p><strong>FIELDS</strong></p><ul><li><code>measurement</code>: amplitude (Jy)</li></ul><ul><li><code>error</code>: error of the visibility amplitude (Jy)</li></ul><ul><li><code>U</code>: u position of the data point in λ</li></ul><ul><li><code>V</code>: v position of the data point in λ</li></ul><ul><li><code>T</code>: time of the data point in (Hr)</li></ul><ul><li><code>F</code>: frequency of the data point (Hz)</li></ul><ul><li><code>baseline</code>: station baseline codes</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/observations.jl#L348-L356">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.Scan" href="#Comrade.Scan"><code>Comrade.Scan</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Scan{T, I, S}</code></pre><p>Composite type that holds information for a single scan of the telescope.</p><p><strong>Fields</strong></p><ul><li><code>time</code>: Scan time</li></ul><ul><li><code>index</code>: Scan indices which are (scan index, data start index, data end index)</li></ul><ul><li><code>scan</code>: Scan data usually a StructArray of a &lt;:AbstractVisibilityDatum</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/observations.jl#L728-L735">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.ScanTable" href="#Comrade.ScanTable"><code>Comrade.ScanTable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ScanTable{O&lt;:Union{Comrade.ArrayConfiguration, Comrade.Observation}, T, S}</code></pre><p>Wraps EHTObservation in a table that separates the observation into scans. This implements the table interface. You can access scans by directly indexing into the table. This will create a view into the table not copying the data.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; st = scantable(obs)
julia&gt; st[begin] # grab first scan
julia&gt; st[end]   # grab last scan</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/observations.jl#L694-L707">source</a></section></article><h2 id="eht-imaging-interface"><a class="docs-heading-anchor" href="#eht-imaging-interface">eht-imaging interface</a><a id="eht-imaging-interface-1"></a><a class="docs-heading-anchor-permalink" href="#eht-imaging-interface" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Comrade.extract_coherency" href="#Comrade.extract_coherency"><code>Comrade.extract_coherency</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extract_coherency(obs)</code></pre><p>Extracts the coherency matrix from an ehtim observation object</p><p>This grabs the raw <code>data</code> object from the obs object. Any keyword arguments are ignored.</p><p>Returns an EHTObservation with coherency matrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/ehtim.jl#L311-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.extract_amp" href="#Comrade.extract_amp"><code>Comrade.extract_amp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extract_amp(obs)</code></pre><p>Extracts the visibility amplitudes from an ehtim observation object.</p><p>Any valid keyword arguments to <code>add_amp</code> in ehtim can be passed through extract_amp.</p><p>Returns an EHTObservation with visibility amplitude data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/ehtim.jl#L223-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.extract_cphase" href="#Comrade.extract_cphase"><code>Comrade.extract_cphase</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extract_cphase(obs)</code></pre><p>Extracts the closure phases from an ehtim observation object</p><p>Any valid keyword arguments to <code>add_cphase</code> in ehtim can be passed through extract_cphase.</p><p>Returns an EHTObservation with closure phases datums</p><p><strong>Special Keyword arguments:</strong></p><ul><li>count: How the closures are formed, the available options are &quot;min-correct&quot;, &quot;min&quot;, &quot;max&quot;</li><li>cut_trivial: Cut the trivial triangles from the closures</li><li>uvmin: The flag to decide what are trivial triangles. Any baseline with ||(u,v)|| &lt; uvmin        are removed.</li><li>kwargs...: Other arguments are forwarded to eht-imaging.</li></ul><p><strong>Warning</strong></p><p>The <code>count</code> keyword argument is treated specially in <code>Comrade</code>. The default option is &quot;min-correct&quot; and should almost always be used. This option construct a minimal set of closure phases that is valid even when the array isn&#39;t fully connected. For testing and legacy reasons we <code>ehtim</code> other count options are also included. However, the current <code>ehtim</code> count=&quot;min&quot; option is broken and does construct proper minimal sets of closure quantities if the array isn&#39;t fully connected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/ehtim.jl#L750-L774">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.extract_lcamp" href="#Comrade.extract_lcamp"><code>Comrade.extract_lcamp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extract_lcamp(obs)</code></pre><p>Extracts the log-closure amp. from an ehtim observation object</p><p>Any valid keyword arguments to <code>add_logcamp</code> in ehtim can be passed through extract_lcamp.</p><p><strong>Special Keyword arguments:</strong></p><ul><li>count: How the closures are formed, the available options are &quot;min-correct&quot;, &quot;min&quot;, &quot;max&quot;</li><li>kwargs...: Other arguments are forwarded to eht-imaging.</li></ul><p>Returns an EHTObservation with log-closure amp. datums</p><p><strong>Warning</strong></p><p>The <code>count</code> keyword argument is treated specially in <code>Comrade</code>. The default option is &quot;min-correct&quot; and should almost always be used. This option construct a minimal set of closure phases that is valid even when the array isn&#39;t fully connected. For testing and legacy reasons we <code>ehtim</code> other count options are also included. However, the current <code>ehtim</code> count=&quot;min&quot; option is broken and does construct proper minimal sets of closure quantities if the array isn&#39;t fully connected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/ehtim.jl#L785-L805">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.extract_vis" href="#Comrade.extract_vis"><code>Comrade.extract_vis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extract_vis(obs)</code></pre><p>Extracts the complex visibilities from an ehtim observation object</p><p>This grabs the raw <code>data</code> object from the obs object. Any keyword arguments are ignored.</p><p>Returns an EHTObservation with complex visibility data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/ehtim.jl#L279-L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.load_ehtim_uvfits" href="#Comrade.load_ehtim_uvfits"><code>Comrade.load_ehtim_uvfits</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">load_ehtim_uvfits(uvfile, arrayfile=nothing; kwargs...)</code></pre><p>Load a uvfits file with eht-imaging and returns a eht-imaging <code>Obsdata</code> object. You can optionally pass an array file as well that will load additional information such at the telescopes field rotation information with the arrayfile. This is expected to be an eht-imaging produced array or antenna file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/ehtim.jl#L6-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.load_ehtim" href="#Comrade.load_ehtim"><code>Comrade.load_ehtim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">load_ehtim()</code></pre><p>Loads the <a href="https://github.com/achael/eht-imaging">eht-imaging</a> library and stores it in the exported <code>ehtim</code> variable.</p><p><strong>Notes</strong></p><p>This will fail if ehtim isn&#39;t installed in the python installation that PyCall references.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/Comrade.jl#L46-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.scan_average" href="#Comrade.scan_average"><code>Comrade.scan_average</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">scan_average(obs; homogenize=true)</code></pre><p>This homogenizes the scan times for an eht-imaging <code>Obsdata</code> object. This is needed because eht-imaging has a bug that will sometimes create very small scans and this can mess up both the closure construction and the gain scan times. Note that this is only a problem if we are fitting <strong>scan averaged</strong> data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/ehtim.jl#L600-L608">source</a></section></article><h2 id="Bayesian-Tools"><a class="docs-heading-anchor" href="#Bayesian-Tools">Bayesian Tools</a><a id="Bayesian-Tools-1"></a><a class="docs-heading-anchor-permalink" href="#Bayesian-Tools" title="Permalink"></a></h2><h3 id="Posterior-Constructions"><a class="docs-heading-anchor" href="#Posterior-Constructions">Posterior Constructions</a><a id="Posterior-Constructions-1"></a><a class="docs-heading-anchor-permalink" href="#Posterior-Constructions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="HypercubeTransform.ascube" href="#HypercubeTransform.ascube"><code>HypercubeTransform.ascube</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ascube(post::Posterior)</code></pre><p>Construct a flattened version of the posterior where the parameters are transformed to live in (0, 1), i.e. the unit hypercube.</p><p>This returns a <code>TransformedPosterior</code> that obeys the <code>DensityInterface</code> and can be evaluated in the usual manner, i.e. <code>logdensityof</code>. Note that the transformed posterior automatically includes the terms log-jacobian terms of the transformation.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tpost = ascube(post)
julia&gt; x0 = prior_sample(tpost)
julia&gt; logdensityof(tpost, x0)</code></pre><p><strong>Notes</strong></p><p>This is the transform that should be used if using typical NestedSampling methods, i.e. <code>ComradeNested</code>. For the transformation to unconstrained space see <a href="#HypercubeTransform.asflat"><code>asflat</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/bayes/bayes.jl#L170-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HypercubeTransform.asflat" href="#HypercubeTransform.asflat"><code>HypercubeTransform.asflat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">asflat(post::Posterior)</code></pre><p>Construct a flattened version of the posterior where the parameters are transformed to live in (-∞, ∞).</p><p>This returns a <code>TransformedPosterior</code> that obeys the <code>DensityInterface</code> and can be evaluated in the usual manner, i.e. <code>logdensityof</code>. Note that the transformed posterior automatically includes the terms log-jacobian terms of the transformation.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tpost = ascube(post)
julia&gt; x0 = prior_sample(tpost)
julia&gt; logdensityof(tpost, x0)</code></pre><p><strong>Notes</strong></p><p>This is the transform that should be used if using typical MCMC methods, i.e. <code>ComradeAHMC</code>. For the transformation to the unit hypercube see <a href="#HypercubeTransform.ascube"><code>ascube</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/bayes/bayes.jl#L134-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParameterHandling.flatten" href="#ParameterHandling.flatten"><code>ParameterHandling.flatten</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">flatten(post::Posterior)</code></pre><p>Construct a flattened version of the posterior but <strong>do not</strong> transform to any space, i.e. use the support specified by the prior.</p><p>This returns a <code>TransformedPosterior</code> that obeys the <code>DensityInterface</code> and can be evaluated in the usual manner, i.e. <code>logdensityof</code>. Note that the transformed posterior automatically includes the terms log-jacobian terms of the transformation.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tpost = flatten(post)
julia&gt; x0 = prior_sample(tpost)
julia&gt; logdensityof(tpost, x0)</code></pre><p><strong>Notes</strong></p><p>This is the transform that should be used if using typical MCMC methods, i.e. <code>ComradeAHMC</code>. For the transformation to the unit hypercube see <a href="#HypercubeTransform.ascube"><code>ascube</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/bayes/bayes.jl#L215-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformVariables.inverse" href="#TransformVariables.inverse"><code>TransformVariables.inverse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inverse(posterior::TransformedPosterior, x)</code></pre><p>Transforms the value <code>y</code> from parameter space to the transformed space (e.g. unit hypercube if using <a href="#HypercubeTransform.ascube"><code>ascube</code></a>).</p><p>For the inverse transform see <a href="#TransformVariables.transform"><code>transform</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/bayes/bayes.jl#L119-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.prior_sample" href="#Comrade.prior_sample"><code>Comrade.prior_sample</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prior_sample([rng::AbstractRandom], post::Posterior, args...)</code></pre><p>Samples the prior distribution from the posterior. The <code>args...</code> are forwarded to the <code>Base.rand</code> method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/bayes/bayes.jl#L56-L61">source</a></section><section><div><pre><code class="nohighlight hljs">prior_sample([rng::AbstractRandom], post::Posterior)</code></pre><p>Returns a single sample from the prior distribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/bayes/bayes.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.likelihood" href="#Comrade.likelihood"><code>Comrade.likelihood</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">likelihood(d::ConditionedLikelihood, μ)</code></pre><p>Returns the likelihood of the model, with parameters μ. That is, we return the distribution of the data given the model parameters μ. This is an actual probability distribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/distributions/radiolikelihood.jl#L194-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.sample-Tuple{Posterior}" href="#StatsBase.sample-Tuple{Posterior}"><code>StatsBase.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample(post::Posterior, sampler::S, args...; init_params=nothing, kwargs...)</code></pre><p>Sample a posterior <code>post</code> using the <code>sampler</code>. You can optionally pass the starting location of the sampler using <code>init_params</code>, otherwise a random draw from the prior will be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/inference/inference.jl#L32-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransformVariables.transform" href="#TransformVariables.transform"><code>TransformVariables.transform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform(posterior::TransformedPosterior, x)</code></pre><p>Transforms the value <code>x</code> from the transformed space (e.g. unit hypercube if using <a href="#HypercubeTransform.ascube"><code>ascube</code></a>) to parameter space which is usually encoded as a <code>NamedTuple</code>.</p><p>For the inverse transform see <a href="#TransformVariables.inverse"><code>inverse</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/bayes/bayes.jl#L108-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.MultiRadioLikelihood" href="#Comrade.MultiRadioLikelihood"><code>Comrade.MultiRadioLikelihood</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MultiRadioLikelihood(lklhd1, lklhd2, ...)</code></pre><p>Combines multiple likelihoods into one object that is useful for fitting multiple days/frequencies.</p><pre><code class="language-julia-repl hljs">julia&gt; lklhd1 = RadioLikelihood(dcphase1, dlcamp1)
julia&gt; lklhd2 = RadioLikelihood(dcphase2, dlcamp2)
julia&gt; MultiRadioLikelihood(lklhd1, lklhd2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/distributions/radiolikelihood.jl#L92-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.Posterior" href="#Comrade.Posterior"><code>Comrade.Posterior</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Posterior(lklhd, prior)</code></pre><p>Creates a Posterior density that follows obeys <a href="https://github.com/JuliaMath/DensityInterface.jl">DensityInterface</a>. The <code>lklhd</code> object is expected to be a <code>VLB</code> object. For instance, these can be created using <a href="#Comrade.RadioLikelihood"><code>RadioLikelihood</code></a>. <code>prior</code> is expected to be a <code>NamedTuple</code> of distributions that reflect the priors on the parameters you are considering.</p><p><strong>Notes</strong></p><p>Since this function obeys <code>DensityInterface</code> you can evaluate it with</p><pre><code class="language-julia-repl hljs">julia&gt; ℓ = logdensityof(post)
julia&gt; ℓ(x)</code></pre><p>or using the 2-argument version directly</p><pre><code class="language-julia-repl hljs">julia&gt; logdensityof(post, x)</code></pre><p>where <code>post::Posterior</code>.</p><p>To generate random draws from the prior see the <a href="#Comrade.prior_sample"><code>prior_sample</code></a> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/bayes/bayes.jl#L22-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.TransformedPosterior" href="#Comrade.TransformedPosterior"><code>Comrade.TransformedPosterior</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct TransformedPosterior{P&lt;:Posterior, T} &lt;: Comrade.AbstractPosterior</code></pre><p>A transformed version of a <code>Posterior</code> object. This is an internal type that an end user shouldn&#39;t have to directly construct. To construct a transformed posterior see the <a href="#HypercubeTransform.asflat"><code>asflat</code></a>, <a href="#HypercubeTransform.ascube"><code>ascube</code></a>, and <a href="#ParameterHandling.flatten"><code>flatten</code></a> docstrings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/bayes/bayes.jl#L80-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.RadioLikelihood" href="#Comrade.RadioLikelihood"><code>Comrade.RadioLikelihood</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RadioLikelihood(model, data1, data2, ...)</code></pre><p>Forms a radio likelihood from a set of data products. These data products must share the same array data/configuration. If you want to form a likelihood from multiple arrays such as when fitting different wavelengths or days, you can combine them using <a href="#Comrade.MultiRadioLikelihood"><code>MultiRadioLikelihood</code></a></p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; RadioLikelihood(model, dcphase1, dlcamp1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/distributions/radiolikelihood.jl#L9-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.IsFlat" href="#Comrade.IsFlat"><code>Comrade.IsFlat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct IsFlat</code></pre><p>Specifies that the sampling algorithm usually expects a uncontrained transform</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/inference/inference.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.IsCube" href="#Comrade.IsCube"><code>Comrade.IsCube</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct IsCube</code></pre><p>Specifies that the sampling algorithm usually expects a hypercube transform</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/inference/inference.jl#L4-L8">source</a></section></article><h2 id="Misc"><a class="docs-heading-anchor" href="#Misc">Misc</a><a id="Misc-1"></a><a class="docs-heading-anchor-permalink" href="#Misc" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Comrade.μas2rad" href="#Comrade.μas2rad"><code>Comrade.μas2rad</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">μas2rad(x)</code></pre><p>Converts a number from micro-arcseconds (μas) to rad</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/Comrade.jl#L72-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.rad2μas" href="#Comrade.rad2μas"><code>Comrade.rad2μas</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rad2μas(x)</code></pre><p>Converts a number from radians to micro-arcseconds (μas)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/Comrade.jl#L66-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.load" href="#Comrade.load"><code>Comrade.load</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Comrade.load(fitsfile::String, IntensityMap)</code></pre><p>This loads in a fits file that is more robust to the various imaging algorithms in the EHT, i.e. is works with clean, smili, eht-imaging. The function returns an tuple with an intensitymap and a second named tuple with ancillary information about the image, like the source name, location, mjd, and radio frequency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/io.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.save" href="#Comrade.save"><code>Comrade.save</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Comrade.save(file::String, img::IntensityMap, obs)</code></pre><p>Saves an image to a fits file. You can optionally pass an EHTObservation so that ancillary information will be added.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/observations/io.jl#L105-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.NonAnalyticTest" href="#Comrade.NonAnalyticTest"><code>Comrade.NonAnalyticTest</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">`NonAnalyticTest`</code></pre><p>An internal model used primarly for testing. Any model passed to it will be interpreted as not having an analytic Fourier transform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/test.jl#L2-L6">source</a></section></article><h2 id="Internal-(Not-Public-API)"><a class="docs-heading-anchor" href="#Internal-(Not-Public-API)">Internal (Not Public API)</a><a id="Internal-(Not-Public-API)-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-(Not-Public-API)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Comrade.scale_uv" href="#Comrade.scale_uv"><code>Comrade.scale_uv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">scale_image(model::AbstractModifier, u, u)</code></pre><p>Returns a number on how to scale the image visibility at <code>u</code> <code>v</code> for an modified <code>model</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/modifiers.jl#L56-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.scale_image" href="#Comrade.scale_image"><code>Comrade.scale_image</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">scale_image(model::AbstractModifier, x, y)</code></pre><p>Returns a number of how to to scale the image intensity at <code>x</code> <code>y</code> for an modified <code>model</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/modifiers.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.transform_uv" href="#Comrade.transform_uv"><code>Comrade.transform_uv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform_uv(model::AbstractModifier, u, u)</code></pre><p>Returns a transformed <code>u</code> and <code>v</code> according to the <code>model</code> modifier</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/modifiers.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.transform_image" href="#Comrade.transform_image"><code>Comrade.transform_image</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform_image(model::AbstractModifier, x, y)</code></pre><p>Returns a transformed <code>x</code> and <code>y</code> according to the <code>model</code> modifier</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/modifiers.jl#L49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.ThreadedModel" href="#Comrade.ThreadedModel"><code>Comrade.ThreadedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ThreadedModel</code></pre><p>Experimental model wrapper than enables multi-threading when evaluating <code>intensitymap</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/models/threaded.jl#L3-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Comrade.extract_FRs" href="#Comrade.extract_FRs"><code>Comrade.extract_FRs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extract_FRs</code></pre><p>Extracts the feed rotation Jones matrices (returned as a <code>JonesPair</code>) from an EHT observation <code>obs</code>.</p><p><strong>Warning</strong></p><p>eht-imaging can sometimes pre-rotate the coherency matrices. As a result the field rotation can sometimes be applied twice. To compensate for this we have added a <code>ehtim_fr_convention</code> which will fix this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/07e0397e3f135014fa34387ed7a3cf0b02286ffe/src/calibration/jones.jl#L810-L820">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Blackburn L., et al &quot;Closure Statistics in Interferometric Data&quot; ApJ 2020</li><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Blackburn L., et al &quot;Closure Statistics in Interferometric Data&quot; ApJ 2020</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../base_api/">« ComradeBase API</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Saturday 11 March 2023 00:11">Saturday 11 March 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
