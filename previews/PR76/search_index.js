var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [Comrade]","category":"page"},{"location":"api/#Comrade.Comrade","page":"API","title":"Comrade.Comrade","text":"Comrade\n\nRadio Observation Sampling Exploration\n\n\n\n\n\n","category":"module"},{"location":"api/#Comrade.AbstractCache","page":"API","title":"Comrade.AbstractCache","text":"abstract type AbstractCache\n\nThis defines an abstract cache that can be used to hold or precompute some computations.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.AbstractModifier","page":"API","title":"Comrade.AbstractModifier","text":"abstract type AbstractModifier{M<:ComradeBase.AbstractModel} <: ComradeBase.AbstractModel\n\nAbstract type for image modifiers. These are some model wrappers that can transform any model using simple Fourier transform properties. To see the implemented modifier\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.AddModel","page":"API","title":"Comrade.AddModel","text":"struct AddModel{T1, T2} <: Comrade.CompositeModel{T1, T2}\n\nAdds two models together to create composite models. Note that I may change this in the future so make it easier on the compiler, i.e. make the composite model a fancy model vector and heap allocate stuff. This should help when combining multiple models together.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ArrayConfiguration","page":"API","title":"Comrade.ArrayConfiguration","text":"abstract type ArrayConfiguration\n\nThis defined the abstract type for an array configuration. Namely, baseline times, SEFD's, bandwidth, observation frequencies, etc.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.CompositeModel","page":"API","title":"Comrade.CompositeModel","text":"abstract type CompositeModel{M1, M2} <: ComradeBase.AbstractModel\n\nAbstract type that denotes a composite model. Where we have combined two models together.\n\nImplementation\n\nAny implementation of a composite type must define the following methods:\n\nvisibility_point\nuv_combinator\nimanalytic\nvisanalytic\nComradeBase.intensity_point if model intensity is IsAnalytic\nintensitymap! if model intensity is NotAnalytic\nflux\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ConcordanceCrescent","page":"API","title":"Comrade.ConcordanceCrescent","text":"struct ConcordanceCrescent{T} <: Comrade.GeometricModel\n\nCreates the ConcordanceCrescent model, i.e. a flat-top crescent with a displacment and a slash. Note this creates a crescent with unit flux. If you want a different flux please use the renomed modifier.\n\nFields\n\nNotes\n\nUnlike the Gaussian and Disk models this does not create the unit version. In fact, this model could have been created using the Disk and primitives by using Comrade.jl's model composition functionality.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ConvolvedModel","page":"API","title":"Comrade.ConvolvedModel","text":"struct ConvolvedModel{M1, M2} <: Comrade.CompositeModel{M1, M2}\n\nSmooths a model with a Gaussian kernel with standard deviation of σ.\n\nNotes\n\nm = smoothed(Disk(), 5.0)\nintensity(m, 2.0, 2.0; fov=10.0, npix=128)\n\nwill compute the intensity of the smoothed disk with using an interpolation with 128 pixel nodes and a total fov of 10 in x and y direction.\n\nThis needs to be improved\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.EHTClosurePhaseDatum","page":"API","title":"Comrade.EHTClosurePhaseDatum","text":"struct EHTClosurePhaseDatum{T<:Number} <: Comrade.ClosureProducts{T<:Number}\n\nA Datum for a single closure phase. Note in the future this may get replaced with the fully covariant formalism from Blackburn et al. (2020).\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ExtendedRing","page":"API","title":"Comrade.ExtendedRing","text":"struct ExtendedRing{F} <: Comrade.GeometricModel\n\nA symmetric extended ring whose radial profile follows an inverse gamma distributions.\n\nNote\n\n@e mainly use this as an example of a non-analytic Fourier transform (although it has a complicated expression)\n\nFields\n\nradius\nradius of peak emission\nshape\nshape of the radial distribution\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.FFT","page":"API","title":"Comrade.FFT","text":"struct FFT <: Comrade.FourierTransform\n\nFourier transform type that specifies we will use the FFTW package to compute the Fourier transform.\n\nFields\n\npadfac\nThe amount to pad the image by. Note we actually round up to the nearest factor of 2, but this will be improved in the future to use small primes\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.FFTCache","page":"API","title":"Comrade.FFTCache","text":"struct FFTCache{P, I} <: Comrade.AbstractCache\n\nThe cache used when the FFT algorithm is used to compute visibilties. This is an internal type and is not part of the public API\n\nFields\n\nplan\nFFTW Plan\nsitp\nFFT interpolator function\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.FourierTransform","page":"API","title":"Comrade.FourierTransform","text":"abstract type FourierTransform\n\nAbstract type that specified which fourier transform to use\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.Gaussian","page":"API","title":"Comrade.Gaussian","text":"struct Gaussian{T} <: Comrade.GeometricModel\n\nGaussian geometrical model. This is a Gaussian with unit flux and standard deviation.\n\nNotes\n\nTo change the Gaussian flux, and shape please use the modifier functions\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.GeometricModel","page":"API","title":"Comrade.GeometricModel","text":"abstract type GeometricModel <: ComradeBase.AbstractModel\n\nA type that defines it is a geometric model. These are usually primitive models, and are usually analytic in Fourier and the image domain.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.MRing","page":"API","title":"Comrade.MRing","text":"struct MRing{T, N} <: Comrade.GeometricModel\n\nm-ring geometric model. This corresponds to a delta ring with a fourier expansion in θ. The m in m-ring refers to the order of the Fourier expansion. The radius is unity.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ModelImage","page":"API","title":"Comrade.ModelImage","text":"struct ModelImage{M, I, C} <: Comrade.AbstractModelImage{M}\n\nContainer for non-analytic model that contains a image cache which will hold the image, a Fourier transform cache C, which usually an instance of a <: FourierCache which usually holds a interpolator that allows you to compute visibilities.\n\nNotes\n\nThis is an internal implementation detail that shouldn't usually be called directly. Instead the user should use the exported function modelimage, for example\n\nusing Comrade\nm = ExtendedRing(20.0, 5.0)\n\n# This creates an version where the image is dynamically specified according to the\n# radial extent of the image\nmimg = modelimage(m) # you can also optionally pass the number of pixels nx and ny\n\n# Or you can create an IntensityMap\nimg = intensitymap(m, 100.0, 100.0, 512, 512)\nmimg = modelimage(m, img)\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.NoCache","page":"API","title":"Comrade.NoCache","text":"struct NoCache <: Comrade.AbstractCache\n\nNo cache is used. This is typically used when the model is analytic in the Fourier domain.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.PolarizedModel","page":"API","title":"Comrade.PolarizedModel","text":"struct PolarizedModel{TI, TQ, TU, TV} <: ComradeBase.AbstractPolarizedModel\n\nWrapped model for a polarized model. This uses the stokes representation of the image.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.RImage","page":"API","title":"Comrade.RImage","text":"$(TYPEDEF)\n\nAn image model given by a set of coefficients and a kernel response or basis function. This corresponds to a continous image defined by a finite set of points. The defined intensity is given by\n\n    I(xy) = sum_ij c_ijκ(x-x_i)κ(y-y_i)\n\nAn important thing to note is that the c_ij do not represent pixel intensities, i.e. the κ doesn't have to be an interpolating kernel.\n\nExample\n\nsamples = rand(10,10)\nmodel = RImage(samples, BSplineKernel{3})\n\nNotes\n\nThis is defined in terms of pixel response, so the image size is 1μas. To resize the image use the scale function like with other models.\n\nFields\n\nFIELDS\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.RenormalizedModel","page":"API","title":"Comrade.RenormalizedModel","text":"struct RenormalizedModel{M<:ComradeBase.AbstractModel, T} <: Comrade.AbstractModifier{M<:ComradeBase.AbstractModel}\n\nRenormalizes the flux of the model to the new value flux. We have also overloaded the Base.:* operator as syntactic sugar although I may get rid of this.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.RotatedModel","page":"API","title":"Comrade.RotatedModel","text":"struct RotatedModel{M<:ComradeBase.AbstractModel, T} <: Comrade.AbstractModifier{M<:ComradeBase.AbstractModel}\n\nType for the rotated model. This is more fine grained constrol of rotated model. In most use cases the end-user should be using the rotate method e.g.\n\nrotate(model, ξ)\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ShiftedModel","page":"API","title":"Comrade.ShiftedModel","text":"struct ShiftedModel{T, M<:ComradeBase.AbstractModel} <: Comrade.AbstractModifier{M<:ComradeBase.AbstractModel}\n\nShifts the model by Δx units in the x-direction and Δy units in the y-direction.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.StretchedModel","page":"API","title":"Comrade.StretchedModel","text":"struct StretchedModel{M<:ComradeBase.AbstractModel, T} <: Comrade.AbstractModifier{M<:ComradeBase.AbstractModel}\n\nStretched the model in the x and y directions, i.e. the new intensity is\n\n    I_s(xy) = 1(αβ) I(xα yβ)\n\nwhere were renormalize the intensity to preserve the models flux.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.size-Tuple{RImage}","page":"API","title":"Base.size","text":"size(model)\n\n\nreturn the size of the coefficient matrix for model.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.Crescent-NTuple{4, Any}","page":"API","title":"Comrade.Crescent","text":"Creates a Kamruddin and Dexter crescent model. This works by composing two disk models together.\n\nArguments\n\nrouter: The radius of the outer disk\nrinner: The radius of the inner disk\nshift: How much the inner disk radius is shifted (positive is to the right)\nfloor: The floor of the inner disk 0 means the inner intensity is zero and 1 means it is a large disk.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade._visibilities-Tuple{Any, AbstractArray, AbstractArray}","page":"API","title":"Comrade._visibilities","text":"_visibilities(m, u, v)\n\n\nComputes the visibilities of the model m at the u,v positions u, v.\n\nNote this is done lazily so the visibility is only computed when accessed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.amplitude-Tuple{Any, Any, Any}","page":"API","title":"Comrade.amplitude","text":"amplitude(model, u, v)\n\n\nComputes the visibility amplitude of model m at u,v positions u,v\n\nIf you want to compute the amplitudes at a large number of positions consider using the amplitudes function which uses MappedArrays to compute a lazy, no allocation vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.amplitudes-Tuple{Any, AbstractArray, AbstractArray}","page":"API","title":"Comrade.amplitudes","text":"amplitudes(m, u, v)\n\n\nComputes the amplitudes of the model m at the u,v positions u, v.\n\nNote this is done lazily so the visibility is only computed when accessed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.basemodel-Tuple{Comrade.AbstractModifier}","page":"API","title":"Comrade.basemodel","text":"basemodel(model)\n\n\nReturns the base model from a modified model.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.bispectra-Tuple{Any, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray}","page":"API","title":"Comrade.bispectra","text":"bispectra(m, u1, v1, u2, v2, u3, v3)\n\n\nComputes the bispectra of the model m at the triangles (u1,v1), (u2,v2), (u3,v3).\n\nNote this is done lazily so the bispectra is only computed when accessed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.bispectrum-NTuple{7, Any}","page":"API","title":"Comrade.bispectrum","text":"bispectrum(model, u1, v1, u2, v2, u3, v3)\n\n\nComputes the complex bispectrum of model m at the uv-triangle u1,v1 -> u2,v2 -> u3,v3\n\nIf you want to compute the bispectrum over a number of triangles consider using the bispectra function which uses MappedArrays to compute a lazy, no allocation vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.closure_phase-NTuple{7, Any}","page":"API","title":"Comrade.closure_phase","text":"closure_phase(model, u1, v1, u2, v2, u3, v3)\n\n\nComputes the closure phase of model m at the uv-triangle u1,v1 -> u2,v2 -> u3,v3\n\nIf you want to compute closure phases over a number of triangles consider using the closure_phases function which uses MappedArrays to compute a lazy, no allocation vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.closure_phase-Tuple{Comrade.EHTVisibilityDatum, Comrade.EHTVisibilityDatum, Comrade.EHTVisibilityDatum}","page":"API","title":"Comrade.closure_phase","text":"closure_phase(D1, D2, D3)\n\n\nComputes the closure phase of the three visibility datums.\n\nNotes\n\nWe currently use the high SNR Gaussian error approximation for the closure phase. In the future we may use the moment matching from Monte Carlo sampling.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.closure_phases-Tuple{Any, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray}","page":"API","title":"Comrade.closure_phases","text":"closure_phases(m, u1, v1, u2, v2, u3, v3)\n\n\nComputes the closure phases of the model m at the triangles (u1,v1), (u2,v2), (u3,v3).\n\nNote this is done lazily so the closure_phases is only computed when accessed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.coherencymatrix-Tuple{PolarizedModel, Any, Any}","page":"API","title":"Comrade.coherencymatrix","text":"coherencymatrix(pimg, u, v)\n\n\nComputes the coherency matrix of the polarized model.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.components-Tuple{ComradeBase.AbstractModel}","page":"API","title":"Comrade.components","text":"components(m)\n\n\nReturns the components for a composite model. This will return a Tuple with all the models you have constructed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.create_cache-Tuple{Comrade.FFT, Any}","page":"API","title":"Comrade.create_cache","text":"create_cache(alg, img)\n\n\nCreates the model cache given for the algorithm alg using the model and a image cache image\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.extract_cphase-Tuple{Any}","page":"API","title":"Comrade.extract_cphase","text":"extract_cphase(obs)\n\nExtracts the closure phases from an ehtim observation object\n\nReturns an EHTObservation with closure phases datums\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.extract_lcamp-Tuple{Any}","page":"API","title":"Comrade.extract_lcamp","text":"extract_lcamp(obs)\n\nExtracts the log-closure amp. from an ehtim observation object\n\nReturns an EHTObservation with closure amp. datums\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.extract_vis-Tuple{Any}","page":"API","title":"Comrade.extract_vis","text":"extract_vis(obs)\n\nExtracts the complex visibilities from an ehtim observation object\n\nReturns an EHTObservation with complex visibility data\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.load_ehtim-Tuple{}","page":"API","title":"Comrade.load_ehtim","text":"load_ehtim()\n\n\nLoads the eht-imaging library and stores it in the ehtim variable.\n\nNotes\n\nThis will fail if ehtim isn't installed in the python installation that PyCall references.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.load_tpy-Tuple{Any}","page":"API","title":"Comrade.load_tpy","text":"load_tpy(file)\n\n\nLoad a ThemisPy style ascii EHT observation file.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.logclosure_amplitude-NTuple{9, Any}","page":"API","title":"Comrade.logclosure_amplitude","text":"logclosure_amplitude(model, u1, v1, u2, v2, u3, v3, u4, v4)\n\n\nComputes the log-closure amplitude of model m at the uv-quadrangle u1,v1 -> u2,v2 -> u3,v3 -> u4,v3 using the formula\n\nC = logleftfracV(u1v1)V(u2v2)V(u3v3)V(u4v4)right\n\nIf you want to compute log closure amplitudes over a number of triangles consider using the logclosure_amplitudes function which uses MappedArrays to compute a lazy, no allocation vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.logclosure_amplitudes-Tuple{Any, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray}","page":"API","title":"Comrade.logclosure_amplitudes","text":"logclosure_amplitudes(m, u1, v1, u2, v2, u3, v3, u4, v4)\n\n\nComputes the log closure amplitudes of the model m at the quadrangles (u1,v1), (u2,v2), (u3,v3), (u4, v4).\n\nNote this is done lazily so the log closure amplitude is only computed when accessed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.modelimage-Tuple{M} where M","page":"API","title":"Comrade.modelimage","text":"modelimage(m)\n\nConstruct a ModelImage where just the model m is specified\n\nNotes\n\nIf m IsAnalytic() is the visibility domain this is a no-op and just returns the model itself. Otherwise modelimage will guess a reasonable field of view based on the radialextent function. One can optionally pass the number of pixels nx and ny in each direction.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.modelimage-Union{Tuple{M}, Tuple{M, ComradeBase.AbstractIntensityMap}} where M","page":"API","title":"Comrade.modelimage","text":"modelimage(model, image; alg)\nmodelimage(m; fovx, fovy, nx, ny, alg)\n\n\nConstruct a ModelImage from a model, image and the optionally specified visibility algorithm alg\n\nNotes\n\nFor analytic models this is a no-op and just return the model. For non-analytic models this wraps the model in a object with an image and precomputes the fourier transform using alg.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.rad2μas-Tuple{Any}","page":"API","title":"Comrade.rad2μas","text":"rad2μas(x)\n\nConverts a number from radians to μas\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.renormed-Union{Tuple{M}, Tuple{M, Any}} where M<:ComradeBase.AbstractModel","page":"API","title":"Comrade.renormed","text":"renormed(model, f)\n\n\nRenormalizes the model m to have total flux flux.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.rotated-Tuple{Any, Any}","page":"API","title":"Comrade.rotated","text":"rotated(model, ξ)\n\n\nRotates the model by an amount ξ in radians.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.shifted-Tuple{Any, Any, Any}","page":"API","title":"Comrade.shifted","text":"shifted(model, Δx, Δy)\n\n\nShifts the model m in the image domain by an amount Δx,Δy.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.stretched-Tuple{Any, Any, Any}","page":"API","title":"Comrade.stretched","text":"stretched(model, α, β)\n\n\nStretches the model m according to the formula\n\n    I_s(xy) = 1(αβ) I(xα yβ)\n\nwhere were renormalize the intensity to preserve the models flux.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.visibility-Tuple{PolarizedModel, Any, Any}","page":"API","title":"Comrade.visibility","text":"visibility(pimg, u, v)\n\n\nComputes the visibility in the stokes basis of the polarized model\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.visibility-Union{Tuple{M}, Tuple{M, Any, Any}} where M","page":"API","title":"Comrade.visibility","text":"visibility(mimg, u, v)\n\n\nComputes the complex visibility of model m at u,v positions u,v\n\nIf you want to compute the visibilities at a large number of positions consider using the visibilities function which uses MappedArrays to compute a lazy, no allocation vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.μas2rad-Tuple{Any}","page":"API","title":"Comrade.μas2rad","text":"μas2rad(x)\n\nConverts a number from μas to rad\n\n\n\n\n\n","category":"method"},{"location":"api/#ComradeBase.evpa-Tuple{Any, Any, Any}","page":"API","title":"ComradeBase.evpa","text":"evpa(pimg, u, v)\n\n\nelectric vector position angle or EVPA of the polarized model\n\n\n\n\n\n","category":"method"},{"location":"api/#ComradeBase.intensitymap!-Tuple{IntensityMap{<:StokesVector}, PolarizedModel}","page":"API","title":"ComradeBase.intensitymap!","text":"intensitymap!(pimg, pmodel)\n\n\nFinds the polarized intensity map of the polarized model pmodel.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComradeBase.m̆-Tuple{Any, Any, Any}","page":"API","title":"ComradeBase.m̆","text":"m̆(pimg, u, v)\n\n\nComputes the fractional linear polarization in the visibility domain\n\n    brevem = fracQ + iUI\n\n\n\n\n\n","category":"method"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To get started with Comrade","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Comrade\n\n#load ehtim\nload_ehtim()\n\n# To load some data we can use\nobs = ehtim.obsdata.load_uvfits(\"FILENAME\")\n\n# Extract various data products from the EHTIM object\ndvis   = extract_vis(obs)\ndcp    = extract_cphase(obs)\ndlcamp = extract_lcamp(obs)\n\n# Just want the array configuration?\nac = arrayconfig(data)\n\n# Want to construct a elliptical Gaussian\nm1 = rotated(stretched(Gaussian(), 20.0, 10.0), π/4)\nm2 = ExtendedRing(20.0)\nmtot = m1+m2\n\n# Lets make an image!\nimg = intensitymap(mtot, 80.0, 80.0, 128, 128)\n\n# Now construct a model image wrapper\n# Since Extended ring doesn't have a simple FT we need to specify an image to hold it.\n# In the future this will be automated.\nmimage = modelimage(mtot, img)\n\n\n#Now evaluate the visibilities\nvis = visibility(mimage, ac)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Comrade","category":"page"},{"location":"#Comrade","page":"Home","title":"Comrade","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Comrade is a differentiable modular modeling framework for use with very long baseline interferometry. The goal is to allow the user to easily combine and modify a set of primitive models to construct complicated source structures. These primitives themselves do not have to  be simple. Comrade itself does not Bayesian inference or optimization itself. Instead it creates all the components needed, i.e. a image/visibility model, some simple likelihoods, and telescope corruption effects (still to be implemented).","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use perform inferences on data you can then hook into the vast array of different  modeling and optimization packages in Julia. There are some small examples packages defining these interface such as ComradeSoss.jl  which combines Comrade with Soss a probabilistic programming language. Other interfaces to e.g. Turing, BAT are  planned.","category":"page"},{"location":"#Requirements","page":"Home","title":"Requirements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The minimum Julia version we require is 1.6, which is the current LTS release. In the  future we may increase this as Julia advances.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"index.md\",\n    \"getting_started.md\",\n    \"model_interface.md\",\n    \"api.md\"\n]","category":"page"}]
}
