<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Polarized Image and Instrumental Modeling · Comrade.jl</title><meta name="title" content="Polarized Image and Instrumental Modeling · Comrade.jl"/><meta property="og:title" content="Polarized Image and Instrumental Modeling · Comrade.jl"/><meta property="twitter:title" content="Polarized Image and Instrumental Modeling · Comrade.jl"/><meta name="description" content="Documentation for Comrade.jl."/><meta property="og:description" content="Documentation for Comrade.jl."/><meta property="twitter:description" content="Documentation for Comrade.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Comrade.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../benchmarks/">Benchmarks</a></li><li><a class="tocitem" href="../../vlbi_imaging_problem/">Introduction to the VLBI Imaging Problem</a></li><li><a class="tocitem" href="../../conventions/">Conventions</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../ClosureImaging/">Imaging a Black Hole using only Closure Quantities</a></li><li><a class="tocitem" href="../GeometricModeling/">Geometric Modeling of EHT Data</a></li><li><a class="tocitem" href="../HybridImaging/">Hybrid Imaging of a Black Hole</a></li><li><a class="tocitem" href="../LoadingData/">Loading Data into Comrade</a></li><li class="is-active"><a class="tocitem" href>Polarized Image and Instrumental Modeling</a><ul class="internal"><li><a class="tocitem" href="#Introduction-to-Polarized-Imaging"><span>Introduction to Polarized Imaging</span></a></li><li><a class="tocitem" href="#Load-the-Data"><span>Load the Data</span></a></li><li><a class="tocitem" href="#Load-the-Data-2"><span>Load the Data</span></a></li><li><a class="tocitem" href="#Reconstructing-the-Image-and-Instrument-Effects"><span>Reconstructing the Image and Instrument Effects</span></a></li></ul></li><li><a class="tocitem" href="../StokesIImaging/">Stokes I Simultaneous Image and Instrument Modeling</a></li></ul></li><li><span class="tocitem">Extensions</span><ul><li><a class="tocitem" href="../../ext/optimization/">Optimization Extension</a></li><li><a class="tocitem" href="../../ext/ahmc/">AdvancedHMC Extension</a></li><li><a class="tocitem" href="../../ext/nested/">NestedSamples Extension</a></li><li><a class="tocitem" href="../../ext/dynesty/">Dynesty Extension</a></li></ul></li><li><a class="tocitem" href="../../base_api/">Base API</a></li><li><a class="tocitem" href="../../api/">Comrade API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Polarized Image and Instrumental Modeling</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Polarized Image and Instrumental Modeling</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ptiede/Comrade.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ptiede/Comrade.jl/blob/main/examples/PolarizedImaging/main.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Polarized-Image-and-Instrumental-Modeling"><a class="docs-heading-anchor" href="#Polarized-Image-and-Instrumental-Modeling">Polarized Image and Instrumental Modeling</a><a id="Polarized-Image-and-Instrumental-Modeling-1"></a><a class="docs-heading-anchor-permalink" href="#Polarized-Image-and-Instrumental-Modeling" title="Permalink"></a></h1><p>In this tutorial, we will analyze a simulated simple polarized dataset to demonstrate Comrade&#39;s polarized imaging capabilities.</p><h2 id="Introduction-to-Polarized-Imaging"><a class="docs-heading-anchor" href="#Introduction-to-Polarized-Imaging">Introduction to Polarized Imaging</a><a id="Introduction-to-Polarized-Imaging-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction-to-Polarized-Imaging" title="Permalink"></a></h2><p>The EHT is a polarized interferometer. However, like all VLBI interferometers, it does not directly measure the Stokes parameters (I, Q, U, V). Instead, it measures components related to the electric field at the telescope along two <em>directions</em> using feeds. There are two types of feeds at telescopes: circular, which measure <span>$R/L$</span> components of the electric field, and linear feeds, which measure <span>$X/Y$</span> components of the electric field. Most sites in the EHT use circular feeds, meaning they measure the right (R) and left electric field (L) at each telescope. Although note that ALMA actually uses linear feeds. Currently Comrade has the ability to fit natively mixed polarization data however, the publically released EHT data has been converted to circular polarization. For a VLBI array whose feeds are purely circluar the <strong>coherency matrices</strong> are given by,</p><p class="math-container">\[ C_{ij} = \begin{pmatrix}
       RR^* &amp;  RL^*\\
       LR^* &amp;  LL^*
     \end{pmatrix}.\]</p><p>These coherency matrices are the fundamental object in interferometry and what the telescope observes. For a perfect interferometer, these circular coherency matrices are related to the usual Fourier transform of the stokes parameters by</p><p class="math-container">\[  \begin{pmatrix}
      \tilde{I}\\ \tilde{Q} \\ \tilde{U} \\ \tilde{V}
  \end{pmatrix}
  =\frac{1}{2}
  \begin{pmatrix}
     RR^* + LL^* \\
     RL^* + LR^* \\
     i(LR^* - RL^*)\\
     RR^* - LL^*
  \end{pmatrix}.\]</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In this tutorial, we stick to circular feeds but Comrade has the capabilities to model linear (XX,XY, ...) and mixed basis coherencies (e.g., RX, RY, ...).</p></div></div><p>In reality, the measure coherencies are corrupted by both the atmosphere and the telescope itself. In <code>Comrade</code> we use the RIME formalism <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> to represent these corruptions, namely our measured coherency matrices <span>$V_{ij}$</span> are given by</p><p class="math-container">\[   V_{ij} = J_iC_{ij}J_j^\dagger\]</p><p>where <span>$J$</span> is known as a <em>Jones matrix</em> and <span>$ij$</span> denotes the baseline <span>$ij$</span> with sites <span>$i$</span> and <span>$j$</span>.</p><p><code>Comrade</code> is highly flexible with how the Jones matrices are formed and provides several convenience functions that parameterize standard Jones matrices. These matrices include:</p><ul><li><a href="../../api/#Comrade.JonesG"><code>JonesG</code></a> which builds the set of complex gain Jones matrices</li></ul><p class="math-container">\[  G = \begin{pmatrix}
          g_a   &amp;0\\
          0     &amp;g_b\\
      \end{pmatrix}\]</p><ul><li><a href="../../api/#Comrade.JonesD"><code>JonesD</code></a> which builds the set of complex d-terms Jones matrices</li></ul><p class="math-container">\[  D = \begin{pmatrix}
          1   &amp; d_a\\
          d_b     &amp;1\\
      \end{pmatrix}\]</p><ul><li><a href="../../api/#Comrade.JonesR"><code>JonesR</code></a> is the basis transform matrix <span>$T$</span>. This transformation is special and  combines two things using the decomposition <span>$T=FB$</span>. The first, <span>$B$</span>, is the transformation from  some reference basis to the observed coherency basis (this allows for mixed basis measurements).  The second is the feed rotation, <span>$F$</span>, that transforms from some reference axis to the axis of the  telescope as the source moves in the sky. The feed rotation matrix <code>F</code> for circular feeds  in terms of the per station feed rotation angle <span>$\varphi$</span> is</li></ul><p class="math-container">\[  F = \begin{pmatrix}
          e^{-i\varphi}   &amp; 0\\
          0     &amp; e^{i\varphi}\\
      \end{pmatrix}\]</p><p>In the rest of the tutorial, we are going to solve for all of these instrument model terms on  in addition to our image structure to reconstruct a polarized image of a synthetic dataset.</p><h2 id="Load-the-Data"><a class="docs-heading-anchor" href="#Load-the-Data">Load the Data</a><a id="Load-the-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Load-the-Data" title="Permalink"></a></h2><p>To get started we will load Comrade</p><pre><code class="language-julia hljs">using Comrade</code></pre><h2 id="Load-the-Data-2"><a class="docs-heading-anchor" href="#Load-the-Data-2">Load the Data</a><a class="docs-heading-anchor-permalink" href="#Load-the-Data-2" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Pyehtim</code></pre><p>For reproducibility we use a stable random number genreator</p><pre><code class="language-julia hljs">using StableRNGs
rng = StableRNG(42)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">StableRNGs.LehmerRNG(state=0x00000000000000000000000000000055)</code></pre><p>Now we will load some synthetic polarized data.</p><pre><code class="language-julia hljs">obs = Pyehtim.load_uvfits_and_array(
        joinpath(__DIR, &quot;../Data&quot;, &quot;polarized_gaussian_all_corruptions.uvfits&quot;),
        joinpath(__DIR, &quot;../Data&quot;, &quot;array.txt&quot;), polrep=&quot;circ&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Python: &lt;ehtim.obsdata.Obsdata object at 0x7fc4a2f06ce0&gt;</code></pre><p>Notice that, unlike other non-polarized tutorials, we need to include a second argument. This is the <strong>array file</strong> of the observation and is required to determine the feed rotation of the array.</p><p>Now we scan average the data since the data to boost the SNR and reduce the total data volume.</p><pre><code class="language-julia hljs">obs = scan_average(obs)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Python: &lt;ehtim.obsdata.Obsdata object at 0x7fc541115630&gt;</code></pre><p>Now we extract our observed/corrupted coherency matrices.</p><pre><code class="language-julia hljs">dvis = extract_table(obs, Coherencies())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EHTObservationTable{Comrade.EHTCoherencyDatum{Float64}}
  source:      17.761122472222223:-28.992189444444445
  mjd:         51544
  bandwidth:   1.0e9
  sites:       [:AA, :AP, :AZ, :JC, :LM, :PV, :SM]
  nsamples:    315</code></pre><p>##Building the Model/Posterior</p><p>To build the model, we first break it down into two parts:</p><ol><li><strong>The image or sky model</strong>. In Comrade, all polarized image models are written in terms of the Stokes parameters. In this tutorial, we will use a polarized image model based on Pesce (2021)<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>, and parameterizes each pixel in terms of the <a href="https://en.wikipedia.org/wiki/Unpolarized_light#Poincar%C3%A9_sphere"><code>Poincare sphere</code></a>. This parameterization ensures that we have all the physical properties of stokes parameters. Note that we also have a parameterization in terms of hyperbolic trig functions <code>VLBISkyModels.PolExp2Map</code></li><li><strong>The instrument model</strong>. The instrument model specifies the model that describes the impact of instrumental and atmospheric effects. We will be using the <span>$J = GDR$</span> decomposition we described above. However, to parameterize the R/L complex gains, we will be using a gain product and ratio decomposition. The reason for this decomposition is that in realistic measurements, the gain ratios and products have different temporal characteristics. Namely, many of the EHT observations tend to demonstrate constant R/L gain ratios across an nights observations, compared to the gain products, which vary every scan. Additionally, the gain ratios tend to be smaller (i.e., closer to unity) than the gain products. Using this apriori knowledge, we can build this into our model and reduce the total number of parameters we need to model.</li></ol><p>First we specify our sky model. As always <code>Comrade</code> requires this to be a two argument function where the first argument is typically a NamedTuple of parameters we will fit and the second are additional metadata required to build the model.</p><pre><code class="language-julia hljs">using StatsFuns: logistic
function sky(θ, metadata)
    (;c, σ, p, p0, pσ, angparams) = θ
    (;ftot, grid) = metadata
    # Build the stokes I model
    rast = ftot*to_simplex(CenteredLR(), σ.*c.params)
    # The total polarization fraction is modeled in logit space so we transform it back
    pim = logistic.(p0 .+ pσ.*p.params)
    # Build our IntensityMap
    pmap = PoincareSphere2Map(rast, pim, angparams, grid)
    # Construct the actual image model which uses a third order B-spline pulse
    m = ContinuousImage(pmap, BSplinePulse{3}())
    # Finally find the image centroid and shift it to be at the center
    x0, y0 = centroid(pmap)
    ms = shifted(m, -x0, -y0)
    return ms
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">sky (generic function with 1 method)</code></pre><p>Now, we define the model metadata required to build the model. We specify our image grid and cache model needed to define the polarimetric image model. Our image will be a 10x10 raster with a 60μas FOV.</p><pre><code class="language-julia hljs">using Distributions, DistributionsAD
using VLBIImagePriors
fovx = μas2rad(60.0)
fovy = μas2rad(60.0)
nx = 10
ny = floor(Int, fovy/fovx*nx)
grid = imagepixels(fovx, fovy, nx, ny)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">RectiGrid(
executor: Serial()
Dimensions: 
<span class="sgr38_5" style="color:#ff875f">↓ X</span> Sampled{Float64} <span class="sgr38_5" style="color:#ff875f">LinRange{Float64}(-1.3089969389957472e-10, 1.3089969389957472e-10, 10)</span> <span class="sgr38_5" style="color:#808080">ForwardOrdered</span> <span class="sgr38_5" style="color:#808080">Regular</span> <span class="sgr38_5" style="color:#808080">Points</span>,
<span class="sgr38_5" style="color:#0087d7">→ Y</span> Sampled{Float64} <span class="sgr38_5" style="color:#0087d7">LinRange{Float64}(-1.3089969389957472e-10, 1.3089969389957472e-10, 10)</span> <span class="sgr38_5" style="color:#808080">ForwardOrdered</span> <span class="sgr38_5" style="color:#808080">Regular</span> <span class="sgr38_5" style="color:#808080">Points</span>
)</code></pre><p>For the image metadata we specify the grid and the total flux of the image, which is 1.0. Note that we specify the total flux out front since it is degenerate with an overall shift in the gain amplitudes.</p><pre><code class="language-julia hljs">skymeta = (;ftot=1.0, grid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(ftot = 1.0, grid = RectiGrid{Tuple{X{DimensionalData.Dimensions.Lookups.Sampled{Float64, LinRange{Float64, Int64}, DimensionalData.Dimensions.Lookups.ForwardOrdered, DimensionalData.Dimensions.Lookups.Regular{Float64}, DimensionalData.Dimensions.Lookups.Points, DimensionalData.Dimensions.Lookups.NoMetadata}}, Y{DimensionalData.Dimensions.Lookups.Sampled{Float64, LinRange{Float64, Int64}, DimensionalData.Dimensions.Lookups.ForwardOrdered, DimensionalData.Dimensions.Lookups.Regular{Float64}, DimensionalData.Dimensions.Lookups.Points, DimensionalData.Dimensions.Lookups.NoMetadata}}}, Serial, ComradeBase.NoHeader}((X{DimensionalData.Dimensions.Lookups.Sampled{Float64, LinRange{Float64, Int64}, DimensionalData.Dimensions.Lookups.ForwardOrdered, DimensionalData.Dimensions.Lookups.Regular{Float64}, DimensionalData.Dimensions.Lookups.Points, DimensionalData.Dimensions.Lookups.NoMetadata}}([-1.3089969389957472e-10, -1.0181087303300256e-10, -7.27220521664304e-11, -4.363323129985825e-11, -1.454441043328608e-11, 1.454441043328608e-11, 4.363323129985823e-11, 7.27220521664304e-11, 1.0181087303300256e-10, 1.3089969389957472e-10]), Y{DimensionalData.Dimensions.Lookups.Sampled{Float64, LinRange{Float64, Int64}, DimensionalData.Dimensions.Lookups.ForwardOrdered, DimensionalData.Dimensions.Lookups.Regular{Float64}, DimensionalData.Dimensions.Lookups.Points, DimensionalData.Dimensions.Lookups.NoMetadata}}([-1.3089969389957472e-10, -1.0181087303300256e-10, -7.27220521664304e-11, -4.363323129985825e-11, -1.454441043328608e-11, 1.454441043328608e-11, 4.363323129985823e-11, 7.27220521664304e-11, 1.0181087303300256e-10, 1.3089969389957472e-10])), Serial(), ComradeBase.NoHeader()))</code></pre><p>For our image prior we will use a simpler prior than</p><ul><li>We use a Dirichlet prior, <code>ImageDirichlet</code>, with unit concentration for our stokes I image pixels, <code>c</code>.</li><li>For the total polarization fraction, <code>p</code>, we assume an uncorrelated uniform prior <code>ImageUniform</code> for each pixel.</li><li>To specify the orientation of the polarization, <code>angparams</code>, on the Poincare sphere, we use a uniform spherical distribution, <code>ImageSphericalUniform</code>.</li></ul><pre><code class="language-julia hljs">rat = beamsize(dvis)/step(grid.X)
cmarkov = ConditionalMarkov(GMRF, grid; order=1)
dρ = truncated(InverseGamma(1.0, -log(0.1)*rat); lower=2.0, upper=max(nx, ny))
cprior = HierarchicalPrior(cmarkov, dρ)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">HierarchicalPrior(
	map: 
	ConditionalMarkov(
Random Field: GaussMarkovRandomField
Graph: MarkovRandomFieldGraph{1}(
dims: (10, 10)
)
)	hyper prior: 
	Truncated(Distributions.InverseGamma{Float64}(
invd: Distributions.Gamma{Float64}(α=1.0, θ=0.09157612316984907)
θ: 10.919876987424647
)
; lower=2.0, upper=10.0)

)
</code></pre><p>For all the calibration parameters, we use a helper function <code>CalPrior</code> which builds the prior given the named tuple of station priors and a <code>JonesCache</code> that specifies the segmentation scheme. For the gain products, we use the <code>scancache</code>, while for every other quantity, we use the <code>trackcache</code>.</p><pre><code class="language-julia hljs">fwhmfac = 2.0*sqrt(2.0*log(2.0))
skyprior = (
    c = cprior,
    σ  = truncated(Normal(0.0, 1.0); lower=0.0),
    p  = cprior,
    p0 = Normal(-2.0, 2.0),
    pσ =  truncated(Normal(0.0, 1.0); lower=0.01),
    angparams = ImageSphericalUniform(nx, ny),
    )

skym = SkyModel(sky, skyprior, grid; metadata=skymeta)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr34"><span class="sgr1"> SkyModel</span></span>
  with map: sky
   on grid: RectiGrid</code></pre><p>Now we build the instrument model. Due to the complexity of VLBI the instrument model is critical to the success of imaging and getting reliable results. For this example we will use the standard instrument model used in polarized EHT analyses expressed in the RIME formalism. Our Jones decomposition will be given by <code>GDR</code>, where <code>G</code> are the complex gains, <code>D</code> are the d-terms, and <code>R</code> is what we call the <em>ideal instrument response</em>, which is how an ideal interferometer using the feed basis we observe relative to some reference basis.</p><p>Given the possible flexibility in different parameterizations of the individual Jones matrices each Jones matrix requires the user to specify a function that converts from parameters to specific parameterization f the jones matrices.</p><p>For the complex gain matrix, we used the <code>JonesG</code> jones matrix. The first argument is now a function that converts from the parameters to the complex gain matrix. In this case, we will use a amplitude and phase decomposition of the complex gain matrix. Note that since the gain matrix is a diagonal 2x2 matrix the function must return a 2-element tuple. The first element of the tuple is the gain for the first polarization feed (R) and the second is the gain for the second polarization feed (L).</p><pre><code class="language-julia hljs">G = JonesG() do x
    gR = exp(x.lgR + 1im*x.gpR)
    gL = gR*exp(x.lgrat + 1im*x.gprat)
    return gR, gL
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">JonesG{Main.var&quot;#1#2&quot;}(Main.var&quot;#1#2&quot;())</code></pre><p>Note that we are using the Julia <code>do</code> syntax here to define an anonymous function. This could&#39;ve also been written as</p><pre><code class="language-julia hljs">fgain(x) = (exp(x.lgR + 1im*x.gpR), exp(x.lgR + x.lgrat + 1im*(x.gpR + x.gprat)))
G = JonesG(fgain)</code></pre><p>Similarly we provide a <code>JonesD</code> function for the leakage terms. Since we assume that we are in the small leakage limit, we will use the decomposition 1 d1 d2 1 Therefore, there are 2 free parameters for the JonesD our parameterization function must return a 2-element tuple. For d-terms we will use a re-im parameterization.</p><pre><code class="language-julia hljs">D = JonesD() do x
    dR = complex(x.dRx, x.dRy)
    dL = complex(x.dLx, x.dLy)
    return dR, dL
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">JonesD{Main.var&quot;#3#4&quot;}(Main.var&quot;#3#4&quot;())</code></pre><p>Finally we define our response Jones matrix. This matrix is a basis transform matrix plus the feed rotation angle for each station. These are typically set by the telescope so there are no free parameters, so no parameterization is necessary.</p><pre><code class="language-julia hljs">R = JonesR(;add_fr=true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">JonesR{Nothing}(nothing, true)</code></pre><p>Finally, we build our total Jones matrix by using the <code>JonesSandwich</code> function. The first argument is a function that specifies how to combine each Jones matrix. In this case, we are completely standard so we just need to multiply the different jones matrices. Note that if no function is provided, the default is to multiply the Jones matrices, so we could&#39;ve removed the splat(*) argument in this case.</p><pre><code class="language-julia hljs">J = JonesSandwich(splat(*), G, D, R)


intprior = (
    lgR  = ArrayPrior(IIDSitePrior(ScanSeg(), Normal(0.0, 0.1))),
    gpR  = ArrayPrior(IIDSitePrior(ScanSeg(), DiagonalVonMises(0.0, inv(π  ^2))); refant=SEFDReference(0.0), phase=false),
    lgrat= ArrayPrior(IIDSitePrior(ScanSeg(), Normal(0.0, 0.1)), phase=true),
    gprat= ArrayPrior(IIDSitePrior(ScanSeg(), Normal(0.0, 0.1)); refant = SingleReference(:AA, 0.0)),
    dRx  = ArrayPrior(IIDSitePrior(TrackSeg(), Normal(0.0, 0.2))),
    dRy  = ArrayPrior(IIDSitePrior(TrackSeg(), Normal(0.0, 0.2))),
    dLx  = ArrayPrior(IIDSitePrior(TrackSeg(), Normal(0.0, 0.2))),
    dLy  = ArrayPrior(IIDSitePrior(TrackSeg(), Normal(0.0, 0.2))),
)

intmodel = InstrumentModel(J, intprior)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr96"><span class="sgr1">InstrumentModel</span></span>
  with Jones:  JonesSandwich
  with reference basis: CirBasis()</code></pre><p>Putting it all together, we form our likelihood and posterior objects for optimization and sampling.</p><pre><code class="language-julia hljs">post = VLBIPosterior(skym, intmodel, dvis)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr95"><span class="sgr1">VLBIPosterior</span></span>
<span class="sgr34"><span class="sgr1">ObservedSkyModel</span></span>
  with map: sky
   on grid: FourierDualDomain<span class="sgr96"><span class="sgr1">ObservedInstrumentModel</span></span>
  with Jones:  JonesSandwich
  with reference basis: CirBasis()<span class="sgr92">Data Products: </span>Comrade.EHTCoherencyDatum
</code></pre><h2 id="Reconstructing-the-Image-and-Instrument-Effects"><a class="docs-heading-anchor" href="#Reconstructing-the-Image-and-Instrument-Effects">Reconstructing the Image and Instrument Effects</a><a id="Reconstructing-the-Image-and-Instrument-Effects-1"></a><a class="docs-heading-anchor-permalink" href="#Reconstructing-the-Image-and-Instrument-Effects" title="Permalink"></a></h2><p>To sample from this posterior, it is convenient to move from our constrained parameter space to an unconstrained one (i.e., the support of the transformed posterior is (-∞, ∞)). This transformation is done using the <code>asflat</code> function.</p><pre><code class="language-julia hljs">tpost = asflat(post)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">TransformedVLBIPosterior(
<span class="sgr95"><span class="sgr1">VLBIPosterior</span></span>
<span class="sgr34"><span class="sgr1">ObservedSkyModel</span></span>
  with map: sky
   on grid: FourierDualDomain<span class="sgr96"><span class="sgr1">ObservedInstrumentModel</span></span>
  with Jones:  JonesSandwich
  with reference basis: CirBasis()<span class="sgr92">Data Products: </span>Comrade.EHTCoherencyDatum
Transform: Params to ℝ^1329
)</code></pre><p>We can also query the dimension of our posterior or the number of parameters we will sample.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This can often be different from what you would expect. This difference is especially true when using angular variables, where we often artificially increase the dimension of the parameter space to make sampling easier.</p></div></div><pre><code class="language-julia hljs">ndim = dimension(tpost)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1329</code></pre><p>Now we optimize. Unlike other imaging examples, we move straight to gradient optimizers due to the higher dimension of the space. In addition the only AD package that can currently work with the polarized Comrade posterior is Zygote. Note that in the future we expect to shift entirely to Enzyme, and in fact large portions of Comrade&#39;s AD already uses Enzyme through custom rules.</p><pre><code class="language-julia hljs">using Optimization
using OptimizationOptimisers
using Zygote
xopt, sol = comrade_opt(post, Optimisers.Adam(), Optimization.AutoZygote(); initial_params=prior_sample(rng, post), maxiters=20_000)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">((sky = (c = (params = [0.5405071077179985 0.29407244853688996 … -0.440265691017168 1.2860588129163897; 1.0232806321659111 2.3043971720504492 … -0.6360238040227072 -0.03910881908668177; … ; 0.9586896243495711 -0.22395173093350418 … 0.2793926095458474 1.1715085070010842; -0.22978639183303154 -0.11146700594995629 … -0.3816162476172373 0.6817854956193123], hyperparams = 6.7393337209969255), σ = 2.549913936105935, p = (params = [0.23601504458388456 0.40114299345628346 … 0.14543972196854402 -0.21515629841215053; 0.5333479864013821 -0.1313040228658878 … 0.21507853407493305 0.03914296039043801; … ; 0.15268850415342866 0.24781310396087575 … 0.21741656356277325 -0.21075633466579113; 0.2559333420340862 0.33998912676157184 … 0.14759364104921135 0.03668346526704152], hyperparams = 3.8731986603325383), p0 = -0.9687336197759727, pσ = 3.9067703734725394, angparams = ([0.717085649673967 -0.30046683005424785 … -0.752036549693373 -0.23840557961895187; -0.11372299851435405 0.032159926180890024 … -0.3714058456008628 0.8699482837147723; … ; 0.02197266169759093 0.7044900950303464 … -0.4821164029683881 -0.32038289256347346; 0.6112558063418078 0.6193890495689184 … -0.22013521056354474 0.1880004530428347], [0.42791488466042643 0.48147215782813707 … 0.26190176926814546 0.9437755879032288; -0.9903391847213593 0.915877082106218 … -0.8182228987268605 0.46759446888019307; … ; 0.9909435988048669 -0.3080353483157484 … -0.6256501195311964 0.7432651904968074; -0.7733774348555179 -0.7328487957373131 … -0.36133446709415445 0.40342814661297904], [0.550160906024518 -0.8233494065543918 … 0.6048541073511049 0.22902056519986677; -0.07934342325824786 0.40016860149272027 … 0.4388268290026508 0.15666970458379037; … ; -0.1324688118976759 0.6393808960174907 … -0.6132908787185919 -0.5872918003415394; -0.16808831746949449 0.28158453057737803 … -0.9060783034373614 0.8954895645266369])), instrument = (lgR = [-0.037213514466525696, -0.03721351446225659, -0.02863367640421776, -0.028633676188043206, -0.05407702509886834, -0.05407702504982165, -0.048529002425165724, -0.04852900238710936, 0.006758377428029435, 0.006758377269764951  …  -0.02667494690797689, -0.02667494690823651, -0.010496705926740854, -0.010496705926660282, -0.005614590786601319, -0.005614590786400138, 0.0059949160296776756, 0.005994916073402724, -0.010428584002033735, -0.010428584000859577], gpR = [0.0, 2.2075061934102216, 0.0, -0.7286177044096422, 0.0, -1.7176736855497077, 0.0, 1.1655778088461437, 0.0, 0.9175846331077033  …  0.0, -0.7103479482072343, 0.0, 3.0786030120894794, 0.0, -1.7081804768066913, 0.0, -2.4545871534408708, 0.0, 2.9066651901227476], lgrat = [0.03190537082108004, 0.004453730658966689, 0.06186836200588556, -0.03154854454215768, 0.015597806129038994, 0.018557027680076082, 0.05896739732061494, -0.020528032129316726, 0.07351334603913628, -0.036021035415110286  …  0.06056421043402649, -0.011316976759635812, 0.040741500790913446, 0.012054888392338821, 0.003701005687933103, 0.0425898054453296, -0.010106053794467322, 0.056225875220979785, 0.009259557784456404, 0.03389222330681377], gprat = [-0.02821164699234893, -0.005975323083032573, -0.11596424095346952, -0.22986684802579888, 0.19340116090593767, -0.1133253798193785, 0.05087363435220457, 0.013678324586842332, -0.11369944666672202, 0.020074743185844755  …  -0.10435705777902851, 0.07765810152605042, 0.14473492069576774, 0.020419057507143568, -0.0017984173048480668, -0.1355004940664628, -0.12457396022588188, -0.03225454030208266, 0.09978524951072652, 0.1035647454793101], dRx = [0.01018710466145751, -0.08144015729179922, 0.09181134484968327, -0.04295602773404708, 0.030906860811114514, -0.007080061666299155, 0.07970626413474731], dRy = [-0.020027938107832318, 0.0715016478478077, -0.10163729298268111, 0.04966915767606127, -0.02043611142846448, 0.018205565576276346, -0.0710225673365679], dLx = [0.02929332174489666, -0.058608369032811636, 0.08878733875652262, -0.058677557550266275, 0.009856198394781704, -0.024017188805737274, 0.05888979047960511], dLy = [-0.03922494653246748, 0.04877069784577891, -0.07852496292548015, 0.06879334999997226, -0.0002937862300576198, 0.039624561766043925, -0.051871814261681595])), retcode: Default
u: [0.5405071077179985, 1.0232806321659111, 2.477977239202668, 2.349884929898386, 2.285862832641327, 2.1700776357867433, -0.005415768161609059, 0.08910628783146313, 0.9586896243495711, -0.22978639183303154  …  0.009856198394781704, -0.024017188805737274, 0.05888979047960511, -0.03922494653246748, 0.04877069784577891, -0.07852496292548015, 0.06879334999997226, -0.0002937862300576198, 0.039624561766043925, -0.051871814261681595]
Final objective value:     1231.752359629489
)</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Fitting polarized images is generally much harder than Stokes I imaging. This difficulty means that optimization can take a long time, and starting from a good starting location is often required.</p></div></div><p>Now let&#39;s evaluate our fits by plotting the residuals</p><pre><code class="language-julia hljs">using Plots
residual(post, xopt)</code></pre><img src="d2516528.svg" alt="Example block output"/><p>These look reasonable, although there may be some minor overfitting. Let&#39;s compare our results to the ground truth values we know in this example. First, we will load the polarized truth</p><pre><code class="language-julia hljs">imgtrue = Comrade.load(joinpath(__DIR, &quot;..&quot;, &quot;Data&quot;, &quot;polarized_gaussian.fits&quot;), IntensityMap{StokesParams})</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr90">╭─────────────────────────────────────────────────╮</span>
<span class="sgr90">│ </span><span class="sgr38_5" style="color:#ff875f">1024</span>×<span class="sgr38_5" style="color:#0087d7">1024</span> IntensityMap{StokesParams{Float64},2}<span class="sgr90"> │</span>
<span class="sgr90">├─────────────────────────────────────────────────┴────────────────────── dims ┐</span>
  <span class="sgr38_5" style="color:#ff875f">↓ X</span> Sampled{Float64} <span class="sgr38_5" style="color:#ff875f">LinRange{Float64}(-4.843402302490755e-10, 4.843402302490755e-10, 1024)</span> <span class="sgr38_5" style="color:#808080">ForwardOrdered</span> <span class="sgr38_5" style="color:#808080">Regular</span> <span class="sgr38_5" style="color:#808080">Points</span>,
  <span class="sgr38_5" style="color:#0087d7">→ Y</span> Sampled{Float64} <span class="sgr38_5" style="color:#0087d7">LinRange{Float64}(-4.843402302490772e-10, 4.843402302490772e-10, 1024)</span> <span class="sgr38_5" style="color:#808080">ForwardOrdered</span> <span class="sgr38_5" style="color:#808080">Regular</span> <span class="sgr38_5" style="color:#808080">Points</span>
<span class="sgr90">├──────────────────────────────────────────────────────────────────── metadata ┤</span>
  ComradeBase.MinimalHeader{Float64}(&quot;SgrA&quot;, 266.4168370833333, -28.99218944444445, 51544.0, 2.3e11)
<span class="sgr90">└──────────────────────────────────────────────────────────────────────────────┘</span>
  <span class="sgr38_5" style="color:#ff875f">↓</span> <span class="sgr38_5" style="color:#0087d7">→</span>          …  <span class="sgr38_5" style="color:#0087d7">4.8434e-10</span>
 <span class="sgr38_5" style="color:#ff875f">-4.8434e-10</span>       [6.86545e-65, 4.08459e-78, 1.02982e-65, 1.02982e-66]
 <span class="sgr38_5" style="color:#ff875f">-4.83393e-10</span>      [8.99558e-65, 5.35191e-78, 1.34934e-65, 1.34934e-66]
 <span class="sgr38_5" style="color:#ff875f">-4.82446e-10</span>      [1.17804e-64, 7.00873e-78, 1.76706e-65, 1.76706e-66]
  ⋮            ⋱  
  <span class="sgr38_5" style="color:#ff875f">4.82446e-10</span>      [1.17804e-64, 7.00873e-78, 1.76706e-65, 1.76706e-66]
  <span class="sgr38_5" style="color:#ff875f">4.83393e-10</span>      [8.99558e-65, 5.35191e-78, 1.34934e-65, 1.34934e-66]
  <span class="sgr38_5" style="color:#ff875f">4.8434e-10</span>       [6.86545e-65, 4.08459e-78, 1.02982e-65, 1.02982e-66]</code></pre><p>Select a reasonable zoom in of the image.</p><pre><code class="language-julia hljs">imgtruesub = regrid(imgtrue, imagepixels(fovx, fovy, nx*4, ny*4))
img = intensitymap(Comrade.skymodel(post, xopt), axisdims(imgtruesub))

#Plotting the results gives
import CairoMakie as CM
fig = CM.Figure(;size=(450, 350));
polimage(fig[1,1], imgtruesub,
                   axis=(xreversed=true, aspect=1, title=&quot;Truth&quot;),
                   nvec = 8,
                   length_norm=1/2, plot_total=true, pcolormap=:RdBu,
                   pcolorrange=(-0.25, 0.25),)
polimage(fig[1,2], img,
                   axis=(xreversed=true, aspect=1, title=&quot;Recon.&quot;,),
                   nvec = 8,
                   length_norm=1/2, plot_total=true, pcolormap=:RdBu,
                   pcolorrange=(-0.25, 0.25),)
CM.Colorbar(fig[2,:], colormap=:RdBu, vertical=false, colorrange=(-0.25, 0.25), label=&quot;Signed Polarization Fraction sign(V)*|p|&quot;, flipaxis=false)
CM.colgap!(fig.layout, 3)
CM.rowgap!(fig.layout, 3)
CM.hidedecorations!.(fig.content[1:2])
fig</code></pre><img src="3c2bff33.png" alt="Example block output"/><p>Let&#39;s compare some image statics, like the total linear polarization fraction</p><pre><code class="language-julia hljs">ftrue = flux(imgtruesub);
@info &quot;Linear polarization true image: $(abs(linearpol(ftrue))/ftrue.I)&quot;
frecon = flux(img);
@info &quot;Linear polarization recon image: $(abs(linearpol(frecon))/frecon.I)&quot;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[ Info: Linear polarization true image: 0.14999999999999963
[ Info: Linear polarization recon image: 0.15137128524521454</code></pre><p>And the Circular polarization fraction</p><pre><code class="language-julia hljs">@info &quot;Circular polarization true image: $(ftrue.V/ftrue.I)&quot;
@info &quot;Circular polarization recon image: $(frecon.V/frecon.I)&quot;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[ Info: Circular polarization true image: 0.014999999999999986
[ Info: Circular polarization recon image: 0.03502306703097718</code></pre><p>Because we also fit the instrument model, we can inspect their parameters. To do this, <code>Comrade</code> provides a <code>caltable</code> function that converts the flattened gain parameters to a tabular format based on the time and its segmentation.</p><pre><code class="language-julia hljs">dR = caltable(complex.(xopt.instrument.dRx, xopt.instrument.dRy))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">───────────────────────────────────────────────────┬────────────────────────────
<span class="sgr1">                                              time │                    AA     ⋯
───────────────────────────────────────────────────┼────────────────────────────
 IntegrationTime{Float64}(51544, 11.8333, 23.6667) │ 0.0101871-0.0200279im  -0 ⋯
───────────────────────────────────────────────────┴────────────────────────────
<span class="sgr36">                                                               6 columns omitted
</span></span></code></pre><p>We can compare this to the ground truth d-terms</p><table><tr><th style="text-align: right">time</th><th style="text-align: right">AA</th><th style="text-align: right">AP</th><th style="text-align: right">AZ</th><th style="text-align: right">JC</th><th style="text-align: right">LM</th><th style="text-align: right">PV</th><th style="text-align: right">SM</th></tr><tr><td style="text-align: right">0.0</td><td style="text-align: right">0.01-0.02im</td><td style="text-align: right">-0.08+0.07im</td><td style="text-align: right">0.09-0.10im</td><td style="text-align: right">-0.04+0.05im</td><td style="text-align: right">0.03-0.02im</td><td style="text-align: right">-0.01+0.02im</td><td style="text-align: right">0.08-0.07im</td></tr></table><p>And same for the left-handed dterms</p><pre><code class="language-julia hljs">dL = caltable(complex.(xopt.instrument.dLx, xopt.instrument.dLy))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">───────────────────────────────────────────────────┬────────────────────────────
<span class="sgr1">                                              time │                    AA     ⋯
───────────────────────────────────────────────────┼────────────────────────────
 IntegrationTime{Float64}(51544, 11.8333, 23.6667) │ 0.0292933-0.0392249im  -0 ⋯
───────────────────────────────────────────────────┴────────────────────────────
<span class="sgr36">                                                               6 columns omitted
</span></span></code></pre><table><tr><th style="text-align: right">time</th><th style="text-align: right">AA</th><th style="text-align: right">AP</th><th style="text-align: right">AZ</th><th style="text-align: right">JC</th><th style="text-align: right">LM</th><th style="text-align: right">PV</th><th style="text-align: right">SM</th></tr><tr><td style="text-align: right">0.0</td><td style="text-align: right">0.03-0.04im</td><td style="text-align: right">-0.06+0.05im</td><td style="text-align: right">0.09-0.08im</td><td style="text-align: right">-0.06+0.07im</td><td style="text-align: right">0.01-0.00im</td><td style="text-align: right">-0.03+0.04im</td><td style="text-align: right">0.06-0.05im</td></tr></table><p>Looking at the gain phase ratio</p><pre><code class="language-julia hljs">gphase_ratio = caltable(xopt.instrument.gprat)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">───────────────────────────────────────────────────┬────────────────────────────
<span class="sgr1">                                              time │      AA           AP      ⋯
───────────────────────────────────────────────────┼────────────────────────────
      IntegrationTime{Float64}(51544, 0.0, 0.0002) │ missing      missing    m ⋯
 IntegrationTime{Float64}(51544, 0.333333, 0.0002) │ missing      missing    m ⋯
 IntegrationTime{Float64}(51544, 0.666667, 0.0002) │ missing      missing    m ⋯
      IntegrationTime{Float64}(51544, 1.0, 0.0002) │ missing      missing    m ⋯
  IntegrationTime{Float64}(51544, 1.33333, 0.0002) │ missing      missing    m ⋯
  IntegrationTime{Float64}(51544, 1.66667, 0.0002) │ missing      missing    m ⋯
  IntegrationTime{Float64}(51544, 9.66667, 0.0002) │     0.0     0.217321    m ⋯
     IntegrationTime{Float64}(51544, 10.0, 0.0002) │     0.0   0.00102234    m ⋯
  IntegrationTime{Float64}(51544, 10.3333, 0.0002) │     0.0   -0.0776836    m ⋯
  IntegrationTime{Float64}(51544, 10.6667, 0.0002) │     0.0    0.0412057    m ⋯
     IntegrationTime{Float64}(51544, 11.0, 0.0002) │     0.0    -0.121324    m ⋯
  IntegrationTime{Float64}(51544, 11.3333, 0.0002) │     0.0    0.0600187    m ⋯
  IntegrationTime{Float64}(51544, 11.6667, 0.0002) │     0.0   -0.0913802    m ⋯
     IntegrationTime{Float64}(51544, 12.0, 0.0002) │     0.0    0.0359796    m ⋯
  IntegrationTime{Float64}(51544, 12.3333, 0.0002) │     0.0   -0.0163909    m ⋯
  IntegrationTime{Float64}(51544, 12.6667, 0.0002) │     0.0    0.0631081    m ⋯
                         ⋮                         │    ⋮          ⋮           ⋱
───────────────────────────────────────────────────┴────────────────────────────
<span class="sgr36">                                                   5 columns and 33 rows omitted
</span></span></code></pre><p>we see that they are all very small. Which should be the case since this data doesn&#39;t have gain corruptions! Similarly our gain ratio amplitudes are also very close to unity as expected.</p><pre><code class="language-julia hljs">gamp_ratio   = caltable(exp.(xopt.instrument.lgrat))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">───────────────────────────────────────────────────┬────────────────────────────
<span class="sgr1">                                              time │      AA       AP       AZ ⋯
───────────────────────────────────────────────────┼────────────────────────────
      IntegrationTime{Float64}(51544, 0.0, 0.0002) │ missing  missing  missing ⋯
 IntegrationTime{Float64}(51544, 0.333333, 0.0002) │ missing  missing  missing ⋯
 IntegrationTime{Float64}(51544, 0.666667, 0.0002) │ missing  missing  missing ⋯
      IntegrationTime{Float64}(51544, 1.0, 0.0002) │ missing  missing  missing ⋯
  IntegrationTime{Float64}(51544, 1.33333, 0.0002) │ missing  missing  missing ⋯
  IntegrationTime{Float64}(51544, 1.66667, 0.0002) │ missing  missing  missing ⋯
  IntegrationTime{Float64}(51544, 9.66667, 0.0002) │  1.0162  1.04846  missing ⋯
     IntegrationTime{Float64}(51544, 10.0, 0.0002) │ 1.01739  1.02809  missing ⋯
  IntegrationTime{Float64}(51544, 10.3333, 0.0002) │ 1.02108  1.02871  missing ⋯
  IntegrationTime{Float64}(51544, 10.6667, 0.0002) │ 1.00783  1.03513  missing ⋯
     IntegrationTime{Float64}(51544, 11.0, 0.0002) │ 1.02003   1.0109  missing ⋯
  IntegrationTime{Float64}(51544, 11.3333, 0.0002) │ 1.01467  1.04773  missing ⋯
  IntegrationTime{Float64}(51544, 11.6667, 0.0002) │ 1.01982  1.00455  missing ⋯
     IntegrationTime{Float64}(51544, 12.0, 0.0002) │ 1.01941  1.02903  missing ⋯
  IntegrationTime{Float64}(51544, 12.3333, 0.0002) │ 1.02246  1.00859  missing ⋯
  IntegrationTime{Float64}(51544, 12.6667, 0.0002) │ 1.01813  1.00138  missing ⋯
                         ⋮                         │    ⋮        ⋮        ⋮    ⋱
───────────────────────────────────────────────────┴────────────────────────────
<span class="sgr36">                                                   4 columns and 33 rows omitted
</span></span></code></pre><p>Plotting the gain phases, we see some offsets from zero. This is because the prior on the gain product phases is very broad, so we can&#39;t phase center the image. For realistic data this is always the case since the atmosphere effectively scrambles the phases.</p><pre><code class="language-julia hljs">gphaseR = caltable(xopt.instrument.gpR)
plot(gphaseR, layout=(3,3), size=(650,500))
plot!(gphase_ratio, layout=(3,3), size=(650,500))</code></pre><img src="8a627389.svg" alt="Example block output"/><p>Finally, the product gain amplitudes are all very close to unity as well, as expected since gain corruptions have not been added to the data.</p><pre><code class="language-julia hljs">gampr = caltable(exp.(xopt.instrument.lgR))
plot(gampr, layout=(3,3), size=(650,500))
plot!(gamp_ratio, layout=(3,3), size=(650,500))</code></pre><img src="c061397e.svg" alt="Example block output"/><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Hamaker J.P, Bregman J.D., Sault R.J. (1996) [https://articles.adsabs.harvard.edu/pdf/1996A%26AS..117..137H]</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>Pesce D. (2021) [https://ui.adsabs.harvard.edu/abs/2021AJ....161..178P/abstract]</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../LoadingData/">« Loading Data into Comrade</a><a class="docs-footer-nextpage" href="../StokesIImaging/">Stokes I Simultaneous Image and Instrument Modeling »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Thursday 16 May 2024 16:14">Thursday 16 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
