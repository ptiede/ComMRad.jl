<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Stokes I Simultaneous Image and Instrument Modeling · Comrade.jl</title><meta name="title" content="Stokes I Simultaneous Image and Instrument Modeling · Comrade.jl"/><meta property="og:title" content="Stokes I Simultaneous Image and Instrument Modeling · Comrade.jl"/><meta property="twitter:title" content="Stokes I Simultaneous Image and Instrument Modeling · Comrade.jl"/><meta name="description" content="Documentation for Comrade.jl."/><meta property="og:description" content="Documentation for Comrade.jl."/><meta property="twitter:description" content="Documentation for Comrade.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Comrade.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../benchmarks/">Benchmarks</a></li><li><a class="tocitem" href="../../vlbi_imaging_problem/">Introduction to the VLBI Imaging Problem</a></li><li><a class="tocitem" href="../../conventions/">Conventions</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../ClosureImaging/">Imaging a Black Hole using only Closure Quantities</a></li><li><a class="tocitem" href="../GeometricModeling/">Geometric Modeling of EHT Data</a></li><li><a class="tocitem" href="../HybridImaging/">Hybrid Imaging of a Black Hole</a></li><li><a class="tocitem" href="../LoadingData/">Loading Data into Comrade</a></li><li><a class="tocitem" href="../PolarizedImaging/">Polarized Image and Instrumental Modeling</a></li><li class="is-active"><a class="tocitem" href>Stokes I Simultaneous Image and Instrument Modeling</a><ul class="internal"><li><a class="tocitem" href="#Load-the-Data"><span>Load the Data</span></a></li></ul></li></ul></li><li><span class="tocitem">Extensions</span><ul><li><a class="tocitem" href="../../ext/optimization/">Optimization Extension</a></li><li><a class="tocitem" href="../../ext/ahmc/">AdvancedHMC Extension</a></li><li><a class="tocitem" href="../../ext/nested/">NestedSamples Extension</a></li><li><a class="tocitem" href="../../ext/dynesty/">Dynesty Extension</a></li></ul></li><li><a class="tocitem" href="../../base_api/">Base API</a></li><li><a class="tocitem" href="../../api/">Comrade API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Stokes I Simultaneous Image and Instrument Modeling</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Stokes I Simultaneous Image and Instrument Modeling</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ptiede/Comrade.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ptiede/Comrade.jl/blob/main/examples/StokesIImaging/main.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Stokes-I-Simultaneous-Image-and-Instrument-Modeling"><a class="docs-heading-anchor" href="#Stokes-I-Simultaneous-Image-and-Instrument-Modeling">Stokes I Simultaneous Image and Instrument Modeling</a><a id="Stokes-I-Simultaneous-Image-and-Instrument-Modeling-1"></a><a class="docs-heading-anchor-permalink" href="#Stokes-I-Simultaneous-Image-and-Instrument-Modeling" title="Permalink"></a></h1><p>In this tutorial, we will create a preliminary reconstruction of the 2017 M87 data on April 6 by simultaneously creating an image and model for the instrument. By instrument model, we mean something akin to self-calibration in traditional VLBI imaging terminology. However, unlike traditional self-cal, we will solve for the gains each time we update the image self-consistently. This allows us to model the correlations between gains and the image.</p><p>To get started we load Comrade.</p><pre><code class="language-julia hljs">using Comrade



using Pyehtim
using LinearAlgebra</code></pre><p>For reproducibility we use a stable random number genreator</p><pre><code class="language-julia hljs">using StableRNGs
rng = StableRNG(12)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">StableRNGs.LehmerRNG(state=0x00000000000000000000000000000019)</code></pre><h2 id="Load-the-Data"><a class="docs-heading-anchor" href="#Load-the-Data">Load the Data</a><a id="Load-the-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Load-the-Data" title="Permalink"></a></h2><p>To download the data visit https://doi.org/10.25739/g85n-f134 First we will load our data:</p><pre><code class="language-julia hljs">obs = ehtim.obsdata.load_uvfits(joinpath(__DIR, &quot;../Data/SR1_M87_2017_096_lo_hops_netcal_StokesI.uvfits&quot;))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Python: &lt;ehtim.obsdata.Obsdata object at 0x7f9f95121f30&gt;</code></pre><p>Now we do some minor preprocessing:</p><ul><li>Scan average the data since the data have been preprocessed so that the gain phases  coherent.</li><li>Add 1% systematic noise to deal with calibration issues that cause 1% non-closing errors.</li></ul><pre><code class="language-julia hljs">obs = scan_average(obs).add_fractional_noise(0.01)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Python: &lt;ehtim.obsdata.Obsdata object at 0x7fa03352ba60&gt;</code></pre><p>Now we extract our complex visibilities.</p><pre><code class="language-julia hljs">dvis = extract_table(obs, Visibilities())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EHTObservationTable{Comrade.EHTVisibilityDatum{:I}}
  source:      M87
  mjd:         57849
  bandwidth:   1.856e9
  sites:       [:AA, :AP, :AZ, :JC, :LM, :PV, :SM]
  nsamples:    274</code></pre><p>##Building the Model/Posterior</p><p>Now, we must build our intensity/visibility model. That is, the model that takes in a named tuple of parameters and perhaps some metadata required to construct the model. For our model, we will use a raster or <code>ContinuousImage</code> for our image model. The model is given below:</p><p>The model construction is very similar to <a href="../ClosureImaging/#Imaging-a-Black-Hole-using-only-Closure-Quantities">Imaging a Black Hole using only Closure Quantities</a>, except we include a large scale gaussian since we want to model the zero baselines. For more information about the image model please read the closure-only example.</p><pre><code class="language-julia hljs">function sky(θ, metadata)
    (;fg, c, σimg) = θ
    (;ftot, mimg) = metadata
    # Apply the GMRF fluctuations to the image
    rast = apply_fluctuations(CenteredLR(), mimg, σimg.*c.params)
    m = ContinuousImage((ftot*(1-fg)).*rast, BSplinePulse{3}())
    x0, y0 = centroid(m)
    # Add a large-scale gaussian to deal with the over-resolved mas flux
    g = modify(Gaussian(), Stretch(μas2rad(250.0), μas2rad(250.0)), Renormalize(ftot*fg))
    return shifted(m, -x0, -y0) + g
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">sky (generic function with 1 method)</code></pre><p>Now, let&#39;s set up our image model. The EHT&#39;s nominal resolution is 20-25 μas. Additionally, the EHT is not very sensitive to a larger field of view. Typically 60-80 μas is enough to describe the compact flux of M87. Given this, we only need to use a small number of pixels to describe our image.</p><pre><code class="language-julia hljs">npix = 32
fovx = μas2rad(150.0)
fovy = μas2rad(150.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">7.27220521664304e-10</code></pre><p>Now let&#39;s form our cache&#39;s. First, we have our usual image cache which is needed to numerically compute the visibilities.</p><pre><code class="language-julia hljs">grid = imagepixels(fovx, fovy, npix, npix)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">RectiGrid(
executor: Serial()
Dimensions: 
<span class="sgr38_5" style="color:#ff875f">↓ X</span> Sampled{Float64} <span class="sgr38_5" style="color:#ff875f">LinRange{Float64}(-3.5224744018114725e-10, 3.5224744018114725e-10, 32)</span> <span class="sgr38_5" style="color:#808080">ForwardOrdered</span> <span class="sgr38_5" style="color:#808080">Regular</span> <span class="sgr38_5" style="color:#808080">Points</span>,
<span class="sgr38_5" style="color:#0087d7">→ Y</span> Sampled{Float64} <span class="sgr38_5" style="color:#0087d7">LinRange{Float64}(-3.5224744018114725e-10, 3.5224744018114725e-10, 32)</span> <span class="sgr38_5" style="color:#808080">ForwardOrdered</span> <span class="sgr38_5" style="color:#808080">Regular</span> <span class="sgr38_5" style="color:#808080">Points</span>
)</code></pre><p>Now we need to specify our image prior. For this work we will use a Gaussian Markov Random field prior Since we are using a Gaussian Markov random field prior we need to first specify our <code>mean</code> image. This behaves somewhat similary to a entropy regularizer in that it will start with an initial guess for the image structure. For this tutorial we will use a a symmetric Gaussian with a FWHM of 50 μas</p><pre><code class="language-julia hljs">using VLBIImagePriors
using Distributions, DistributionsAD
fwhmfac = 2*sqrt(2*log(2))
mpr  = modify(Gaussian(), Stretch(μas2rad(50.0)./fwhmfac))
mimg = intensitymap(mpr, grid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr90">╭───────────────────────────────╮</span>
<span class="sgr90">│ </span><span class="sgr38_5" style="color:#ff875f">32</span>×<span class="sgr38_5" style="color:#0087d7">32</span> IntensityMap{Float64,2}<span class="sgr90"> │</span>
<span class="sgr90">├───────────────────────────────┴──────────────────────────────────────── dims ┐</span>
  <span class="sgr38_5" style="color:#ff875f">↓ X</span> Sampled{Float64} <span class="sgr38_5" style="color:#ff875f">LinRange{Float64}(-3.5224744018114725e-10, 3.5224744018114725e-10, 32)</span> <span class="sgr38_5" style="color:#808080">ForwardOrdered</span> <span class="sgr38_5" style="color:#808080">Regular</span> <span class="sgr38_5" style="color:#808080">Points</span>,
  <span class="sgr38_5" style="color:#0087d7">→ Y</span> Sampled{Float64} <span class="sgr38_5" style="color:#0087d7">LinRange{Float64}(-3.5224744018114725e-10, 3.5224744018114725e-10, 32)</span> <span class="sgr38_5" style="color:#808080">ForwardOrdered</span> <span class="sgr38_5" style="color:#808080">Regular</span> <span class="sgr38_5" style="color:#808080">Points</span>
<span class="sgr90">├──────────────────────────────────────────────────────────────────── metadata ┤</span>
  ComradeBase.NoHeader()
<span class="sgr90">└──────────────────────────────────────────────────────────────────────────────┘</span>
  <span class="sgr38_5" style="color:#ff875f">↓</span> <span class="sgr38_5" style="color:#0087d7">→</span>          <span class="sgr38_5" style="color:#0087d7">-3.52247e-10</span>  <span class="sgr38_5" style="color:#0087d7">-3.29522e-10</span>  …  <span class="sgr38_5" style="color:#0087d7">3.29522e-10</span>  <span class="sgr38_5" style="color:#0087d7">3.52247e-10</span>
 <span class="sgr38_5" style="color:#ff875f">-3.52247e-10</span>   6.37537e-8    1.32434e-7      1.32434e-7   6.37537e-8
 <span class="sgr38_5" style="color:#ff875f">-3.29522e-10</span>   1.32434e-7    2.751e-7        2.751e-7     1.32434e-7
 <span class="sgr38_5" style="color:#ff875f">-3.06796e-10</span>   2.62014e-7    5.44273e-7      5.44273e-7   2.62014e-7
  ⋮                                        ⋱  ⋮            
  <span class="sgr38_5" style="color:#ff875f">3.06796e-10</span>   2.62014e-7    5.44273e-7      5.44273e-7   2.62014e-7
  <span class="sgr38_5" style="color:#ff875f">3.29522e-10</span>   1.32434e-7    2.751e-7        2.751e-7     1.32434e-7
  <span class="sgr38_5" style="color:#ff875f">3.52247e-10</span>   6.37537e-8    1.32434e-7      1.32434e-7   6.37537e-8</code></pre><p>Now we can form our metadata we need to fully define our model. We will also fix the total flux to be the observed value 1.1. This is because total flux is degenerate with a global shift in the gain amplitudes making the problem degenerate. To fix this we use the observed total flux as our value.</p><pre><code class="language-julia hljs">skymeta = (;ftot = 1.1, mimg = mimg./flux(mimg))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(ftot = 1.1, mimg = [6.380486931986174e-8 1.3253982629359533e-7 … 1.3253982629359533e-7 6.380486931986174e-8; 1.3253982629359533e-7 2.7532076691313077e-7 … 2.7532076691313077e-7 1.3253982629359533e-7; … ; 1.3253982629359533e-7 2.7532076691313077e-7 … 2.7532076691313077e-7 1.3253982629359533e-7; 6.380486931986174e-8 1.3253982629359533e-7 … 1.3253982629359533e-7 6.380486931986174e-8])</code></pre><p>In addition we want a reasonable guess for what the resolution of our image should be. For radio astronomy this is given by roughly the longest baseline in the image. To put this into pixel space we then divide by the pixel size.</p><pre><code class="language-julia hljs">beam = beamsize(dvis)
rat = (beam/(step(grid.X)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5.326336637737519</code></pre><p>To make the Gaussian Markov random field efficient we first precompute a bunch of quantities that allow us to scale things linearly with the number of image pixels. The returns a functional that accepts a single argument related to the correlation length of the field. The second argument defines the underlying random field of the Markov process. Here we are using a zero mean and unit variance Gaussian Markov random field. The keyword argument specifies the order of the Gaussian field. Currently, we recommend using order</p><ul><li>1 which is identical to TSV variation and L₂ regularization</li><li>2 which is identical to a Matern 1 process in 2D and is really the convolution of two order 1 processes</li></ul><p>For this tutorial we will use the first order random field</p><pre><code class="language-julia hljs">crcache = ConditionalMarkov(GMRF, grid; order=1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConditionalMarkov(
Random Field: GaussMarkovRandomField
Graph: MarkovRandomFieldGraph{1}(
dims: (32, 32)
)
)</code></pre><p>To demonstrate the prior let create a few random realizations</p><p>Now we can finally form our image prior. For this we use a heirarchical prior where the inverse correlation length is given by a Half-Normal distribution whose peak is at zero and standard deviation is <code>0.1/rat</code> where recall <code>rat</code> is the beam size per pixel. For the variance of the random field we use another half normal prior with standard deviation 0.1. The reason we use the half-normal priors is to prefer &quot;simple&quot; structures. Gaussian Markov random fields are extremly flexible models, and to prevent overfitting it is common to use priors that penalize complexity. Therefore, we want to use priors that enforce similarity to our mean image. If the data wants more complexity then it will drive us away from the prior.</p><pre><code class="language-julia hljs">cprior = HierarchicalPrior(crcache, truncated(InverseGamma(1.0, -log(0.1)*rat); upper=2*npix))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">HierarchicalPrior(
	map: 
	ConditionalMarkov(
Random Field: GaussMarkovRandomField
Graph: MarkovRandomFieldGraph{1}(
dims: (32, 32)
)
)	hyper prior: 
	Truncated(Distributions.InverseGamma{Float64}(
invd: Distributions.Gamma{Float64}(α=1.0, θ=0.0815371823902832)
θ: 12.264343342322437
)
; upper=64.0)

)
</code></pre><p>We can now form our model parameter priors. Like our other imaging examples, we use a Dirichlet prior for our image pixels. For the log gain amplitudes, we use the <code>CalPrior</code> which automatically constructs the prior for the given jones cache <code>gcache</code>.</p><pre><code class="language-julia hljs">prior = (
         c = cprior,
         fg = Uniform(0.0, 1.0),
         σimg = truncated(Normal(0.0, 0.1), lower=0.0)
        )

skym = SkyModel(sky, prior, grid; metadata=skymeta)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr34"><span class="sgr1"> SkyModel</span></span>
  with map: sky
   on grid: RectiGrid</code></pre><p>Unlike other imaging examples (e.g., <a href="../ClosureImaging/#Imaging-a-Black-Hole-using-only-Closure-Quantities">Imaging a Black Hole using only Closure Quantities</a>) we also need to include a model for the instrument, i.e., gains. The gains will be broken into two components</p><ul><li>Gain amplitudes which are typically known to 10-20%, except for LMT, which has amplitudes closer to 50-100%.</li><li>Gain phases which are more difficult to constrain and can shift rapidly.</li></ul><pre><code class="language-julia hljs">G = SingleStokesGain() do x
    lg = x.lg
    gp = x.gp
    return exp(lg + 1im*gp)
end

intpr = (
    lg= ArrayPrior(IIDSitePrior(ScanSeg(), Normal(0.0, 0.2)); LM = IIDSitePrior(ScanSeg(), Normal(0.0, 1.0))),
    gp= ArrayPrior(IIDSitePrior(ScanSeg(), DiagonalVonMises(0.0, inv(π^2))); refant=SEFDReference(0.0), phase=true)
        )
intmodel = InstrumentModel(G, intpr)


post = VLBIPosterior(skym, intmodel, dvis)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr95"><span class="sgr1">VLBIPosterior</span></span>
<span class="sgr34"><span class="sgr1">ObservedSkyModel</span></span>
  with map: sky
   on grid: FourierDualDomain<span class="sgr96"><span class="sgr1">ObservedInstrumentModel</span></span>
  with Jones:  SingleStokesGain
  with reference basis: CirBasis()<span class="sgr92">Data Products: </span>Comrade.EHTVisibilityDatum
</code></pre><p>done using the <code>asflat</code> function.</p><pre><code class="language-julia hljs">tpost = asflat(post)
ndim = dimension(tpost)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1355</code></pre><p>We can now also find the dimension of our posterior or the number of parameters we are going to sample.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This can often be different from what you would expect. This is especially true when using angular variables where we often artificially increase the dimension of the parameter space to make sampling easier.</p></div></div><p>To initialize our sampler we will use optimize using Adam</p><pre><code class="language-julia hljs">using Optimization
using OptimizationOptimisers
using Zygote
xopt, sol = comrade_opt(post, Optimisers.Adam(), Optimization.AutoZygote(); initial_params=prior_sample(rng, post), maxiters=15_000, g_tol=1e-1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">((sky = (c = (params = [0.014809919830021136 0.030218569497580228 … 0.014532655364331806 0.007337368917686212; 0.02908817887333872 0.059324831681151186 … 0.029319781831353253 0.014816411734746255; … ; 0.06042189715370591 0.12013371896832485 … 0.1086801154718255 0.05518507860894769; 0.029970812414400475 0.059549781863458155 … 0.053418558273180844 0.02714010517432163], hyperparams = 18.972533780332835), fg = 0.208206602381417, σimg = 1.0540652687582415), instrument = (lg = [0.04790476755536501, 0.047901777340494466, 0.01135558078331717, 0.02490133446059525, -0.38471654123356885, 0.1688254243536223, 0.006563708164680397, 0.028804705725387694, -0.22076917121065417, 0.12745418244175544  …  -0.21303511410151593, 0.01722606073755325, -0.9245049661025593, 0.015342624051242, 0.009461299540996794, 0.02672067302918265, -0.27210295592717193, 0.01794408583324283, -0.9740830364163068, 0.014793327668307002], gp = [0.0, -2.684276285678294, 0.0, -2.1743424099043933, -0.10092137785269834, -2.8953768753175564, 0.0, -2.230572815369771, -0.039375294193173996, -3.131544518825903  …  -3.431117996494658, -0.759051410466919, -4.11612544636433, 2.4020235102406806, 0.0, -1.8274690836272411, -3.5501092551302578, -0.7126004916034463, -4.264737563495865, 2.450945585023354])), retcode: Default
u: [0.014809919830021136, 0.02908817887333872, 0.042320352302632, 0.054031422672210956, 0.06374550886550374, 0.07109961938660736, 0.07597106284490947, 0.07862577261425935, 0.0796426919042384, 0.07967524577884287  …  0.05881002556434292, 0.9375823992586871, -0.11151604993156224, 0.9327511796505921, 0.04361996561111509, 0.9383794638952676, -0.13910011787743123, 0.9290936356728522, 0.045937939654097405, 0.9382530317725748]
Final objective value:     -1626.7013463178935
)</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Fitting gains tends to be very difficult, meaning that optimization can take a lot longer. The upside is that we usually get nicer images.</p></div></div><p>First we will evaluate our fit by plotting the residuals</p><pre><code class="language-julia hljs">using Plots
residual(post, xopt)</code></pre><img src="a6579ba0.svg" alt="Example block output"/><p>These look reasonable, although there may be some minor overfitting. This could be improved in a few ways, but that is beyond the goal of this quick tutorial. Plotting the image, we see that we have a much cleaner version of the closure-only image from <a href="../ClosureImaging/#Imaging-a-Black-Hole-using-only-Closure-Quantities">Imaging a Black Hole using only Closure Quantities</a>.</p><pre><code class="language-julia hljs">import CairoMakie as CM
g = imagepixels(fovx, fovy, 128, 128)
img = intensitymap(skymodel(post, xopt), g)
imageviz(img, size=(500, 400))</code></pre><img src="7f8b3efd.png" alt="Example block output"/><p>Because we also fit the instrument model, we can inspect their parameters. To do this, <code>Comrade</code> provides a <code>caltable</code> function that converts the flattened gain parameters to a tabular format based on the time and its segmentation.</p><pre><code class="language-julia hljs">gt = Comrade.caltable(xopt.instrument.gp)
plot(gt, layout=(3,3), size=(600,500))</code></pre><img src="48965068.svg" alt="Example block output"/><p>The gain phases are pretty random, although much of this is due to us picking a random reference sites for each scan.</p><p>Moving onto the gain amplitudes, we see that most of the gain variation is within 10% as expected except LMT, which has massive variations.</p><pre><code class="language-julia hljs">gt = Comrade.caltable(exp.(xopt.instrument.lg))
plot(gt, layout=(3,3), size=(600,500))</code></pre><img src="da836ac7.svg" alt="Example block output"/><p>To sample from the posterior, we will use HMC, specifically the NUTS algorithm. For information about NUTS, see Michael Betancourt&#39;s <a href="https://arxiv.org/abs/1701.02434">notes</a>. However, due to the need to sample a large number of gain parameters, constructing the posterior is rather time-consuming. Therefore, for this tutorial, we will only do a quick preliminary run</p><pre><code class="language-julia hljs">using AdvancedHMC
chain = sample(rng, post, NUTS(0.8), 700; n_adapts=500, progress=true, initial_params=xopt)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PosteriorSamples
  Samples size: (700,)
  sampler used: AHMC
<span class="sgr1">Mean
┌───────────────────────────────────────────────────────────────────────────────
│ sky                                                                          ⋯
│<span class="sgr90"> @NamedTuple{c::@NamedTuple{params::Matrix{Float64}, hyperparams::Float64}, f ⋯
├───────────────────────────────────────────────────────────────────────────────
│ (c = (params = [0.0426677 0.105529 … -0.00312862 -0.00289273; 0.078815 0.147 ⋯
└───────────────────────────────────────────────────────────────────────────────
</span><span class="sgr36">                                                               2 columns omitted
Std. Dev.
┌───────────────────────────────────────────────────────────────────────────────
│ sky                                                                          ⋯
│</span><span class="sgr90"> @NamedTuple{c::@NamedTuple{params::Matrix{Float64}, hyperparams::Float64}, f ⋯
├───────────────────────────────────────────────────────────────────────────────
│ (c = (params = [0.541455 0.595749 … 0.61634 0.535278; 0.548152 0.602381 … 0. ⋯
└───────────────────────────────────────────────────────────────────────────────
</span><span class="sgr36">                                                               2 columns omitted
</span></span></code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The above sampler will store the samples in memory, i.e. RAM. For large models this can lead to out-of-memory issues. To fix that you can include the keyword argument <code>saveto = DiskStore()</code> which periodically saves the samples to disk limiting memory useage. You can load the chain using <code>load_samples(diskout)</code> where <code>diskout</code> is the object returned from sample.</p></div></div><p>Now we prune the adaptation phase</p><pre><code class="language-julia hljs">chain = chain[501:end]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PosteriorSamples
  Samples size: (200,)
  sampler used: AHMC
<span class="sgr1">Mean
┌───────────────────────────────────────────────────────────────────────────────
│ sky                                                                          ⋯
│<span class="sgr90"> @NamedTuple{c::@NamedTuple{params::Matrix{Float64}, hyperparams::Float64}, f ⋯
├───────────────────────────────────────────────────────────────────────────────
│ (c = (params = [0.00913958 0.047051 … 0.0514477 0.042646; 0.0799286 0.051488 ⋯
└───────────────────────────────────────────────────────────────────────────────
</span><span class="sgr36">                                                               2 columns omitted
Std. Dev.
┌───────────────────────────────────────────────────────────────────────────────
│ sky                                                                          ⋯
│</span><span class="sgr90"> @NamedTuple{c::@NamedTuple{params::Matrix{Float64}, hyperparams::Float64}, f ⋯
├───────────────────────────────────────────────────────────────────────────────
│ (c = (params = [0.559922 0.547989 … 0.626184 0.587288; 0.569565 0.552565 … 0 ⋯
└───────────────────────────────────────────────────────────────────────────────
</span><span class="sgr36">                                                               2 columns omitted
</span></span></code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This should be run for likely an order of magnitude more steps to properly estimate expectations of the posterior</p></div></div><p>Now that we have our posterior, we can put error bars on all of our plots above. Let&#39;s start by finding the mean and standard deviation of the gain phases</p><pre><code class="language-julia hljs">mchain = Comrade.rmap(mean, chain)
schain = Comrade.rmap(std, chain)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(sky = (c = (params = [0.5599216910069714 0.5479892765891033 … 0.6261839053954975 0.5872883960710638; 0.5695647692077103 0.5525649865469472 … 0.6883749247912436 0.5355687548979448; … ; 0.6761232169554748 0.7026597923726172 … 0.6191335553879735 0.6279256624398273; 0.5975739380313881 0.5598444606255407 … 0.5820408539687946 0.5695517463375745], hyperparams = 14.986288530387926), fg = 0.05452642212155023, σimg = 0.05600353078283102), instrument = (lg = [0.14426333901671498, 0.13983544953389038, 0.014796451101815329, 0.01546498132495227, 0.05784849187552646, 0.04724551342105775, 0.013903472404398164, 0.0158705022002874, 0.04941375654902335, 0.04911587055965134  …  0.038452112914172935, 0.01126407716228645, 0.05173586923268089, 0.011970504313877212, 0.013194414660259716, 0.014407028478646102, 0.036768998361796965, 0.01221665325002723, 0.05013119172380785, 0.010802200856406074], gp = [0.0, 0.30414178069442116, 0.0, 0.008864785393229862, 0.17386062207271052, 0.3060822087764432, 0.0, 0.010623112235853027, 0.17246088220016523, 0.3104683087113264  …  0.19862998318111674, 0.2755806302976909, 0.17562951709465313, 0.27619221521303694, 0.0, 0.00955464631846076, 0.19120671939443667, 0.273945792873162, 0.17225504355391988, 0.2723027929489443]))</code></pre><p>Now we can use the measurements package to automatically plot everything with error bars. First we create a <code>caltable</code> the same way but making sure all of our variables have errors attached to them.</p><pre><code class="language-julia hljs">using Measurements
gmeas_am = Measurements.measurement.(mchain.instrument.lg, schain.instrument.lg)
ctable_am = caltable(exp.(gmeas_am)) # caltable expects gmeas_am to be a Vector
gmeas_ph = Measurements.measurement.(mchain.instrument.gp, schain.instrument.gp)
ctable_ph = caltable(gmeas_ph)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">───────────────────────────────────────────────────┬────────────────────────────
<span class="sgr1">                                              time │      AA              AP   ⋯
───────────────────────────────────────────────────┼────────────────────────────
 IntegrationTime{Float64}(57849, 0.916667, 0.0002) │ 0.0±0.0         missing   ⋯
  IntegrationTime{Float64}(57849, 1.21667, 0.0002) │ 0.0±0.0  -2.1755±0.0089   ⋯
  IntegrationTime{Float64}(57849, 1.51667, 0.0002) │ 0.0±0.0    -2.231±0.011   ⋯
  IntegrationTime{Float64}(57849, 1.81667, 0.0002) │ 0.0±0.0      -2.27±0.01   ⋯
  IntegrationTime{Float64}(57849, 2.11667, 0.0002) │ 0.0±0.0  -2.3193±0.0096   ⋯
     IntegrationTime{Float64}(57849, 2.45, 0.0002) │ missing  -2.3193±0.0096   ⋯
     IntegrationTime{Float64}(57849, 2.75, 0.0002) │ 0.0±0.0  -2.3993±0.0084   ⋯
     IntegrationTime{Float64}(57849, 3.05, 0.0002) │ 0.0±0.0   -2.431±0.0097   ⋯
     IntegrationTime{Float64}(57849, 3.35, 0.0002) │ 0.0±0.0  -2.4556±0.0096   ⋯
  IntegrationTime{Float64}(57849, 3.68333, 0.0002) │ 0.0±0.0  -2.4654±0.0096   ⋯
  IntegrationTime{Float64}(57849, 3.98333, 0.0002) │ 0.0±0.0    -2.436±0.011   ⋯
  IntegrationTime{Float64}(57849, 4.28333, 0.0002) │ 0.0±0.0    -2.457±0.011   ⋯
  IntegrationTime{Float64}(57849, 4.58333, 0.0002) │ 0.0±0.0  -2.3704±0.0099   ⋯
  IntegrationTime{Float64}(57849, 4.91667, 0.0002) │ 0.0±0.0   -2.416±0.0099   ⋯
  IntegrationTime{Float64}(57849, 5.18333, 0.0002) │ 0.0±0.0  -2.3785±0.0087   ⋯
     IntegrationTime{Float64}(57849, 5.45, 0.0002) │ 0.0±0.0  -2.3004±0.0096   ⋯
                         ⋮                         │    ⋮           ⋮          ⋱
───────────────────────────────────────────────────┴────────────────────────────
<span class="sgr36">                                                    5 columns and 9 rows omitted
</span></span></code></pre><p>Now let&#39;s plot the phase curves</p><pre><code class="language-julia hljs">plot(ctable_ph, layout=(3,3), size=(600,500))</code></pre><img src="cc1acd7b.svg" alt="Example block output"/><p>and now the amplitude curves</p><pre><code class="language-julia hljs">plot(ctable_am, layout=(3,3), size=(600,500))</code></pre><img src="5375431f.svg" alt="Example block output"/><p>Finally let&#39;s construct some representative image reconstructions.</p><pre><code class="language-julia hljs">samples = skymodel.(Ref(post), chain[begin:2:end])
imgs = intensitymap.(samples, Ref(g))

mimg = mean(imgs)
simg = std(imgs)
fig = CM.Figure(;resolution=(400, 400))
CM.image(fig[1,1], mimg,
                   axis=(xreversed=true, aspect=1, title=&quot;Mean Image&quot;),
                   colormap=:afmhot)
CM.image(fig[1,2], simg./mimg,
                   axis=(xreversed=true, aspect=1, title=&quot;1/SNR&quot;,),
                   colormap=:afmhot)
CM.image(fig[2,1], imgs[1],
                   axis=(xreversed=true, aspect=1,title=&quot;Draw 1&quot;),
                   colormap=:afmhot)
CM.image(fig[2,2], imgs[end],
                   axis=(xreversed=true, aspect=1,title=&quot;Draw 2&quot;),
                   colormap=:afmhot)
CM.hidedecorations!.(fig.content)
fig</code></pre><img src="895b4bdb.png" alt="Example block output"/><p>And viola, you have just finished making a preliminary image and instrument model reconstruction. In reality, you should run the <code>sample</code> step for many more MCMC steps to get a reliable estimate for the reconstructed image and instrument model parameters.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../PolarizedImaging/">« Polarized Image and Instrumental Modeling</a><a class="docs-footer-nextpage" href="../../ext/optimization/">Optimization Extension »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Thursday 16 May 2024 01:50">Thursday 16 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
