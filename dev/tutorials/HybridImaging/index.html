<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Hybrid Imaging of a Black Hole · Comrade.jl</title><meta name="title" content="Hybrid Imaging of a Black Hole · Comrade.jl"/><meta property="og:title" content="Hybrid Imaging of a Black Hole · Comrade.jl"/><meta property="twitter:title" content="Hybrid Imaging of a Black Hole · Comrade.jl"/><meta name="description" content="Documentation for Comrade.jl."/><meta property="og:description" content="Documentation for Comrade.jl."/><meta property="twitter:description" content="Documentation for Comrade.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Comrade.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../benchmarks/">Benchmarks</a></li><li><a class="tocitem" href="../../vlbi_imaging_problem/">Introduction to the VLBI Imaging Problem</a></li><li><a class="tocitem" href="../../conventions/">Conventions</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../ClosureImaging/">Imaging a Black Hole using only Closure Quantities</a></li><li><a class="tocitem" href="../GeometricModeling/">Geometric Modeling of EHT Data</a></li><li class="is-active"><a class="tocitem" href>Hybrid Imaging of a Black Hole</a><ul class="internal"><li><a class="tocitem" href="#Introduction-to-Hybrid-modeling-and-imaging"><span>Introduction to Hybrid modeling and imaging</span></a></li><li><a class="tocitem" href="#Loading-the-Data"><span>Loading the Data</span></a></li><li><a class="tocitem" href="#Load-the-Data"><span>Load the Data</span></a></li><li><a class="tocitem" href="#Building-the-Model/Posterior"><span>Building the Model/Posterior</span></a></li><li><a class="tocitem" href="#Reconstructing-the-Image"><span>Reconstructing the Image</span></a></li></ul></li><li><a class="tocitem" href="../LoadingData/">Loading Data into Comrade</a></li><li><a class="tocitem" href="../PolarizedImaging/">Polarized Image and Instrumental Modeling</a></li><li><a class="tocitem" href="../StokesIImaging/">Stokes I Simultaneous Image and Instrument Modeling</a></li></ul></li><li><span class="tocitem">Extensions</span><ul><li><a class="tocitem" href="../../ext/optimization/">Optimization Extension</a></li><li><a class="tocitem" href="../../ext/ahmc/">AdvancedHMC Extension</a></li><li><a class="tocitem" href="../../ext/nested/">NestedSamples Extension</a></li><li><a class="tocitem" href="../../ext/dynesty/">Dynesty Extension</a></li></ul></li><li><a class="tocitem" href="../../base_api/">Base API</a></li><li><a class="tocitem" href="../../api/">Comrade API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Hybrid Imaging of a Black Hole</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Hybrid Imaging of a Black Hole</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ptiede/Comrade.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ptiede/Comrade.jl/blob/main/examples/HybridImaging/main.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Hybrid-Imaging-of-a-Black-Hole"><a class="docs-heading-anchor" href="#Hybrid-Imaging-of-a-Black-Hole">Hybrid Imaging of a Black Hole</a><a id="Hybrid-Imaging-of-a-Black-Hole-1"></a><a class="docs-heading-anchor-permalink" href="#Hybrid-Imaging-of-a-Black-Hole" title="Permalink"></a></h1><p>In this tutorial, we will use <strong>hybrid imaging</strong> to analyze the 2017 EHT data. By hybrid imaging, we mean decomposing the model into simple geometric models, e.g., rings and such, plus a rasterized image model to soak up the additional structure. This approach was first developed in <a href="https://iopscience.iop.org/article/10.3847/1538-4357/ab9c1f"><code>BB20</code></a> and applied to EHT 2017 data. We will use a similar model in this tutorial.</p><h2 id="Introduction-to-Hybrid-modeling-and-imaging"><a class="docs-heading-anchor" href="#Introduction-to-Hybrid-modeling-and-imaging">Introduction to Hybrid modeling and imaging</a><a id="Introduction-to-Hybrid-modeling-and-imaging-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction-to-Hybrid-modeling-and-imaging" title="Permalink"></a></h2><p>The benefit of using a hybrid-based modeling approach is the effective compression of information/parameters when fitting the data. Hybrid modeling requires the user to incorporate specific knowledge of how you expect the source to look like. For instance for M87, we expect the image to be dominated by a ring-like structure. Therefore, instead of using a high-dimensional raster to recover the ring, we can use a ring model plus a raster to soak up the additional degrees of freedom. This is the approach we will take in this tutorial to analyze the April 6 2017 EHT data of M87.</p><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;nul&quot;</code></pre><h2 id="Loading-the-Data"><a class="docs-heading-anchor" href="#Loading-the-Data">Loading the Data</a><a id="Loading-the-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-the-Data" title="Permalink"></a></h2><p>To get started we will load Comrade</p><pre><code class="language-julia hljs">using Comrade</code></pre><h2 id="Load-the-Data"><a class="docs-heading-anchor" href="#Load-the-Data">Load the Data</a><a id="Load-the-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Load-the-Data" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Pyehtim</code></pre><p>For reproducibility we use a stable random number genreator</p><pre><code class="language-julia hljs">using StableRNGs
rng = StableRNG(42)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">StableRNGs.LehmerRNG(state=0x00000000000000000000000000000055)</code></pre><p>To download the data visit https://doi.org/10.25739/g85n-f134 To load the eht-imaging obsdata object we do:</p><pre><code class="language-julia hljs">obs = ehtim.obsdata.load_uvfits(joinpath(__DIR, &quot;../Data/SR1_M87_2017_096_lo_hops_netcal_StokesI.uvfits&quot;))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Python: &lt;ehtim.obsdata.Obsdata object at 0x7fc7aef2ba30&gt;</code></pre><p>Now we do some minor preprocessing:</p><ul><li>Scan average the data since the data have been preprocessed so that the gain phases  coherent.</li></ul><pre><code class="language-julia hljs">obs = scan_average(obs).add_fractional_noise(0.02)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Python: &lt;ehtim.obsdata.Obsdata object at 0x7fc792eabeb0&gt;</code></pre><p>For this tutorial we will once again fit complex visibilities since they provide the most information once the telescope/instrument model are taken into account.</p><pre><code class="language-julia hljs">dvis  = extract_table(obs, Visibilities())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EHTObservationTable{Comrade.EHTVisibilityDatum{:I}}
  source:      M87
  mjd:         57849
  bandwidth:   1.856e9
  sites:       [:AA, :AP, :AZ, :JC, :LM, :PV, :SM]
  nsamples:    274</code></pre><h2 id="Building-the-Model/Posterior"><a class="docs-heading-anchor" href="#Building-the-Model/Posterior">Building the Model/Posterior</a><a id="Building-the-Model/Posterior-1"></a><a class="docs-heading-anchor-permalink" href="#Building-the-Model/Posterior" title="Permalink"></a></h2><p>Now we build our intensity/visibility model. That is, the model that takes in a named tuple of parameters and perhaps some metadata required to construct the model. For our model, we will use a raster or <code>ContinuousImage</code> model, an <code>m-ring</code> model, and a large asymmetric Gaussian component to model the unresolved short-baseline flux.</p><pre><code class="language-julia hljs">function sky(θ, metadata)
    (;c, σimg, f, r, σ, τ, ξτ, ma, mp, fg) = θ
    (;ftot, grid) = metadata
    # Form the image model
    # First transform to simplex space first applying the non-centered transform
    rast = (ftot*f*(1-fg)).*to_simplex(CenteredLR(), σimg.*c)
    mimg = ContinuousImage(rast, grid, BSplinePulse{3}())
    # Form the ring model
    α = ma.*cos.(mp .- ξτ)
    β = ma.*sin.(mp .- ξτ)
    ring = smoothed(modify(MRing(α, β), Stretch(r, r*(1+τ)), Rotate(ξτ), Renormalize((ftot*(1-f)*(1-fg)))), σ)
    gauss = modify(Gaussian(), Stretch(μas2rad(250.0)), Renormalize(ftot*f*fg))
    # We group the geometric models together for improved efficiency. This will be
    # automated in future versions.
    return mimg + (ring + gauss)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">sky (generic function with 1 method)</code></pre><p>Unlike other imaging examples (e.g., <a href="../ClosureImaging/#Imaging-a-Black-Hole-using-only-Closure-Quantities">Imaging a Black Hole using only Closure Quantities</a>) we also need to include a model for the instrument, i.e., gains as well. The gains will be broken into two components</p><ul><li>Gain amplitudes which are typically known to 10-20%, except for LMT, which has amplitudes closer to 50-100%.</li><li>Gain phases which are more difficult to constrain and can shift rapidly.</li></ul><pre><code class="language-julia hljs">using VLBIImagePriors
using Distributions, DistributionsAD
G = SingleStokesGain() do x
    lg = x.lg
    gp = x.gp
    return exp(lg + 1im*gp)
end

intpr = (
    lg= ArrayPrior(IIDSitePrior(ScanSeg(), Normal(0.0, 0.2)); LM = IIDSitePrior(ScanSeg(), Normal(0.0, 1.0))),
    gp= ArrayPrior(IIDSitePrior(ScanSeg(), DiagonalVonMises(0.0, inv(π^2))); refant=SEFDReference(0.0))
        )
intmodel = InstrumentModel(G, intpr)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr96"><span class="sgr1">InstrumentModel</span></span>
  with Jones:  SingleStokesGain
  with reference basis: CirBasis()</code></pre><p>Before we move on, let&#39;s go into the <code>model</code> function a bit. This function takes two arguments <code>θ</code> and <code>metadata</code>. The <code>θ</code> argument is a named tuple of parameters that are fit to the data. The <code>metadata</code> argument is all the ancillary information we need to construct the model. For our hybrid model, we will need two variables for the metadata, a <code>grid</code> that specifies the locations of the image pixels and a <code>cache</code> that defines the algorithm used to calculate the visibilities given the image model. This is required since <code>ContinuousImage</code> is most easily computed using number Fourier transforms like the <a href="https://github.com/JuliaMath/NFFT.jl"><code>NFFT</code></a> or <a href="https://github.com/JuliaMath/FFTW.jl">FFT</a>. To combine the models, we use <code>Comrade</code>&#39;s overloaded <code>+</code> operators, which will combine the images such that their intensities and visibilities are added pointwise.</p><p>Now let&#39;s define our metadata. First we will define the cache for the image. This is required to compute the numerical Fourier transform.</p><pre><code class="language-julia hljs">fovxy  = μas2rad(200.0)
npix   = 32
g      = imagepixels(fovxy, fovxy, npix, npix)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">RectiGrid(
executor: Serial()
Dimensions: 
<span class="sgr38_5" style="color:#ff875f">↓ X</span> Sampled{Float64} <span class="sgr38_5" style="color:#ff875f">LinRange{Float64}(-4.69663253574863e-10, 4.69663253574863e-10, 32)</span> <span class="sgr38_5" style="color:#808080">ForwardOrdered</span> <span class="sgr38_5" style="color:#808080">Regular</span> <span class="sgr38_5" style="color:#808080">Points</span>,
<span class="sgr38_5" style="color:#0087d7">→ Y</span> Sampled{Float64} <span class="sgr38_5" style="color:#0087d7">LinRange{Float64}(-4.69663253574863e-10, 4.69663253574863e-10, 32)</span> <span class="sgr38_5" style="color:#808080">ForwardOrdered</span> <span class="sgr38_5" style="color:#808080">Regular</span> <span class="sgr38_5" style="color:#808080">Points</span>
)</code></pre><p>Part of hybrid imaging is to force a scale separation between the different model components to make them identifiable. To enforce this we will set the length scale of the raster component equal to the beam size of the telescope in units of pixel length, which is given by</p><pre><code class="language-julia hljs">beam = beamsize(dvis)
rat = (beam/(step(g.X)))
cprior = GaussMarkovRandomField(rat, size(g); order=2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GaussMarkovRandomField(
Graph: MarkovRandomFieldGraph{2}(
dims: (32, 32)
)
Correlation Parameter: 3.9947524783031394
)</code></pre><p>additionlly we will fix the standard deviation of the field to unity and instead use a pseudo non-centered parameterization for the field. GaussMarkovRandomField(meanpr, 0.1*rat, 1.0, crcache)</p><p>Finally we can put form the total model prior</p><pre><code class="language-julia hljs">skyprior = (
    # We use a strong smoothing prior since we want to limit the amount of high-frequency structure in the raster.
          c  = cprior,
          σimg = truncated(Normal(0.0, 1.0); lower=0.01),
          f  = Uniform(0.0, 1.0),
          r  = Uniform(μas2rad(10.0), μas2rad(30.0)),
          σ  = Uniform(μas2rad(0.1), μas2rad(10.0)),
          τ  = truncated(Normal(0.0, 0.1); lower=0.0, upper=1.0),
          ξτ = Uniform(-π/2, π/2),
          ma = ntuple(_-&gt;Uniform(0.0, 0.5), 2),
          mp = ntuple(_-&gt;Uniform(0.0, 2π), 2),
          fg = Uniform(0.0, 1.0),
        )</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(c = GaussMarkovRandomField(
Graph: MarkovRandomFieldGraph{2}(
dims: (32, 32)
)
Correlation Parameter: 3.9947524783031394
), σimg = Truncated(Distributions.Normal{Float64}(μ=0.0, σ=1.0); lower=0.01), f = Distributions.Uniform{Float64}(a=0.0, b=1.0), r = Distributions.Uniform{Float64}(a=4.84813681109536e-11, b=1.454441043328608e-10), σ = Distributions.Uniform{Float64}(a=4.848136811095359e-13, b=4.84813681109536e-11), τ = Truncated(Distributions.Normal{Float64}(μ=0.0, σ=0.1); lower=0.0, upper=1.0), ξτ = Distributions.Uniform{Float64}(a=-1.5707963267948966, b=1.5707963267948966), ma = (Distributions.Uniform{Float64}(a=0.0, b=0.5), Distributions.Uniform{Float64}(a=0.0, b=0.5)), mp = (Distributions.Uniform{Float64}(a=0.0, b=6.283185307179586), Distributions.Uniform{Float64}(a=0.0, b=6.283185307179586)), fg = Distributions.Uniform{Float64}(a=0.0, b=1.0))</code></pre><p>Now we form the metadata</p><pre><code class="language-julia hljs">skymetadata = (;ftot=1.1, grid = g)
skym = SkyModel(sky, skyprior, g; metadata=skymetadata)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr34"><span class="sgr1"> SkyModel</span></span>
  with map: sky
   on grid: RectiGrid</code></pre><p>This is everything we need to specify our posterior distribution, which our is the main object of interest in image reconstructions when using Bayesian inference.</p><pre><code class="language-julia hljs">post = VLBIPosterior(skym, intmodel, dvis)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr95"><span class="sgr1">VLBIPosterior</span></span>
<span class="sgr34"><span class="sgr1">ObservedSkyModel</span></span>
  with map: sky
   on grid: FourierDualDomain<span class="sgr96"><span class="sgr1">ObservedInstrumentModel</span></span>
  with Jones:  SingleStokesGain
  with reference basis: CirBasis()<span class="sgr92">Data Products: </span>Comrade.EHTVisibilityDatum
</code></pre><p>To sample from our prior we can do</p><pre><code class="language-julia hljs">xrand = prior_sample(rng, post)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(sky = (c = [-2.1962796581148964 -1.1243036995667173 … 0.1809752675358745 0.5228771323078414; -0.3425595294889296 0.875841911517527 … -1.7473734958334282 -0.04613166448214303; … ; -1.0346864752090177 -0.3318267589886823 … 1.8169964745030398 0.9883988762644694; -0.17570171401278734 -1.1226297884080063 … 0.23776676295262178 -0.12297534720788651], σimg = 0.42179682054864803, f = 0.5609945096442908, r = 6.822575941314203e-11, σ = 1.3552947886307434e-11, τ = 0.06730160453188876, ξτ = -1.4000761734573677, ma = (0.34647334815942743, 0.2990582529227658), mp = (4.539841547826114, 0.12993729152293854), fg = 0.37817042117774347), instrument = (lg = [-0.05442203326486966, -0.06854489109756777, -0.03494199200648159, 0.01466628222962606, -0.5344934234689837, 0.06909851514694904, 0.16895161284675558, -0.35730974364294593, 2.2297802017289468, 0.14330481934854625  …  -0.2562770339996219, -0.13260692566162727, -0.3754572129527364, 0.13202624897901952, -0.22070992008362902, -0.14044807385292715, 0.08434814836495083, -0.16645257431733257, 0.07930960115946253, 0.09730314408987739], gp = [0.0, 0.801726817174358, 0.0, 0.5352791204380771, 1.2147806619090493, 1.8380953555627066, 0.0, -1.2091566463464445, 0.4316140924972767, 2.8356106901992013  …  0.6797921035265353, 1.5869294029613246, 1.9179548979911933, -0.7937725614627756, 0.0, -2.1551512461478652, -1.4071803931922073, -0.3657978469609746, -2.891016934890005, -1.059347481121196]))</code></pre><p>and then plot the results</p><pre><code class="language-julia hljs">import CairoMakie as CM
gpl = imagepixels(μas2rad(200.0), μas2rad(200.0), 128, 128)
fig = imageviz(intensitymap(skymodel(post, xrand), gpl), size=(400, 400));</code></pre><img src="7b5a4a25.png" alt="Example block output"/><h2 id="Reconstructing-the-Image"><a class="docs-heading-anchor" href="#Reconstructing-the-Image">Reconstructing the Image</a><a id="Reconstructing-the-Image-1"></a><a class="docs-heading-anchor-permalink" href="#Reconstructing-the-Image" title="Permalink"></a></h2><p>To find the image we will demonstrate two methods:</p><ul><li>Optimization to find the MAP (fast but often a poor estimator)</li><li>Sampling to find the posterior (slow but provides a substantially better estimator)</li></ul><p>For optimization we will use the <code>Optimization.jl</code> package and the LBFGS optimizer. To use this we use the <a href="../../api/#Comrade.comrade_opt"><code>comrade_opt</code></a> function</p><pre><code class="language-julia hljs">using Optimization
using OptimizationOptimJL
using Zygote
xopt, sol = comrade_opt(post, LBFGS(), Optimization.AutoZygote(); initial_params=prior_sample(rng, post), maxiters=1000, g_tol=1e0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">((sky = (c = [-0.09675761120294217 -0.07667565963537941 … -0.17317873534808 -0.04667509704315911; -0.1094313986479224 -0.1014912717313783 … -0.30817496630418123 -0.16205869003719764; … ; 0.10570104931105952 0.11681241980124311 … 0.06830809548161039 0.00020081498203082914; 0.1282693925010045 0.11692905812685064 … 0.16358952754178072 0.07619194904574546], σimg = 2.846776251189203, f = 0.7109265442506806, r = 1.0199090359067985e-10, σ = 1.3607619499246577e-11, τ = 0.08761244713745943, ξτ = 0.007089234147967239, ma = (0.2551442975260665, 0.1003468488940498), mp = (2.53271529800982, 2.1748372062294754), fg = 0.1114436361210507), instrument = (lg = [-0.0015257314943844802, -0.002525626967881393, 0.03104163502871717, 0.04000393370782979, -0.23190238891819423, 0.07461436219189191, 0.01994131568235906, 0.045896010625037995, -0.001722881133606136, 0.05812966645189334  …  0.06356800533234827, 0.030912370722565852, -0.48560166827065465, 0.03029872248859674, 0.03718370466737517, 0.03817807232420468, 0.027302256061859837, 0.0375287134205558, -0.5417844112315241, 0.02827805412767294], gp = [0.0, 0.19844367916086267, 0.0, -2.1911549882826753, 1.4680712001144292, 0.045992189002646996, 0.0, -2.2411158159727504, 1.52046665031338, -0.14792676143899441  …  -1.6582757199998674, -0.01412849139273644, -2.8907895649644697, -3.1359431497048664, 0.0, -1.8299079762138188, -1.7395072512522096, -0.04676960806110297, -3.0244673343562476, 3.11182658559361])), retcode: Failure
u: [-0.09675761120294217, -0.1094313986479224, 0.047080601786554384, 0.24994550095538745, 0.22915013759717962, 0.007308738142342173, -0.17771814947260736, -0.19847374008355123, -0.10706355575434803, -0.0035264240468653022  …  -0.9245708274063649, -0.24507649710503876, -0.930922539381472, -0.15856408779385991, -0.043920682474971585, 0.9384011464918826, -0.11032329449978272, -0.9376140792291747, 0.02795885658770503, -0.9390087648104783]
Final objective value:     -1526.3146829276754
)</code></pre><p>First we will evaluate our fit by plotting the residuals</p><pre><code class="language-julia hljs">using Plots
fig = residual(post, xopt);</code></pre><img src="fcba6326.png" alt="Example block output"/><p>These residuals suggest that we are substantially overfitting the data. This is a common side effect of MAP imaging. As a result if we plot the image we see that there is substantial high-frequency structure in the image that isn&#39;t supported by the data.</p><pre><code class="language-julia hljs">imageviz(intensitymap(skymodel(post, xopt), gpl), figure=(;resolution=(500, 400),))</code></pre><img src="266a5696.png" alt="Example block output"/><p>To improve our results we will now move to Posterior sampling. This is the main method we recommend for all inference problems in <code>Comrade</code>. While it is slower the results are often substantially better. To sample we will use the <code>AdvancedHMC</code> package.</p><pre><code class="language-julia hljs">using AdvancedHMC
chain = sample(rng, post, NUTS(0.8), 700; n_adapts=500, progress=false, initial_params=xopt);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[ Info: Found initial step size 0.0015625</code></pre><p>We then remove the adaptation/warmup phase from our chain</p><pre><code class="language-julia hljs">chain = chain[501:end]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PosteriorSamples
  Samples size: (200,)
  sampler used: AHMC
<span class="sgr1">Mean
┌───────────────────────────────────────────────────────────────────────────────
│ sky                                                                          ⋯
│<span class="sgr90"> @NamedTuple{c::Matrix{Float64}, σimg::Float64, f::Float64, r::Float64, σ::Fl ⋯
├───────────────────────────────────────────────────────────────────────────────
│ (c = [-0.186916 -0.234328 … -0.324639 -0.253928; -0.28135 -0.461076 … -0.524 ⋯
└───────────────────────────────────────────────────────────────────────────────
</span><span class="sgr36">                                                               2 columns omitted
Std. Dev.
┌───────────────────────────────────────────────────────────────────────────────
│ sky                                                                          ⋯
│</span><span class="sgr90"> @NamedTuple{c::Matrix{Float64}, σimg::Float64, f::Float64, r::Float64, σ::Fl ⋯
├───────────────────────────────────────────────────────────────────────────────
│ (c = [0.645366 0.781108 … 0.682433 0.585507; 0.692316 0.788015 … 0.751314 0. ⋯
└───────────────────────────────────────────────────────────────────────────────
</span><span class="sgr36">                                                               2 columns omitted
</span></span></code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This should be run for 4-5x more steps to properly estimate expectations of the posterior</p></div></div><p>Now lets plot the mean image and standard deviation images. To do this we first clip the first 250 MCMC steps since that is during tuning and so the posterior is not sampling from the correct sitesary distribution.</p><pre><code class="language-julia hljs">using StatsBase
msamples = skymodel.(Ref(post), chain[begin:2:end]);</code></pre><p>The mean image is then given by</p><pre><code class="language-julia hljs">imgs = intensitymap.(msamples, Ref(gpl))
fig = imageviz(mean(imgs), colormap=:afmhot, size=(400, 300));</code></pre><img src="dc61af5f.png" alt="Example block output"/><pre><code class="language-julia hljs">fig = imageviz(std(imgs), colormap=:batlow, size=(400, 300));</code></pre><img src="0f04a3d5.png" alt="Example block output"/><p>We can also split up the model into its components and analyze each separately</p><pre><code class="language-julia hljs">comp = Comrade.components.(msamples)
ring_samples = getindex.(comp, 2)
rast_samples = first.(comp)
ring_imgs = intensitymap.(ring_samples, Ref(gpl));
rast_imgs = intensitymap.(rast_samples, Ref(gpl));

ring_mean, ring_std = mean_and_std(ring_imgs);
rast_mean, rast_std = mean_and_std(rast_imgs);

fig = CM.Figure(; resolution=(400, 400));
axes = [CM.Axis(fig[i, j], xreversed=true, aspect=CM.DataAspect()) for i in 1:2, j in 1:2]
CM.image!(axes[1,1], ring_mean, colormap=:afmhot); axes[1,1].title = &quot;Ring Mean&quot;
CM.image!(axes[1,2], ring_std, colormap=:afmhot); axes[1,2].title = &quot;Ring Std. Dev.&quot;
CM.image!(axes[2,1], rast_mean, colormap=:afmhot); axes[2,1].title = &quot;Rast Mean&quot;
CM.image!(axes[2,2], rast_mean./rast_std, colormap=:afmhot, colorrange=(1.5, 3)); axes[2,2].title = &quot;Rast SNR&quot;
CM.hidedecorations!.(axes)</code></pre><img src="64e80705.png" alt="Example block output"/><p>Finally, let&#39;s take a look at some of the ring parameters</p><pre><code class="language-julia hljs">figd = CM.Figure(;resolution=(650, 400));
p1 = CM.density(figd[1,1], rad2μas(chain.sky.r)*2, axis=(xlabel=&quot;Ring Diameter (μas)&quot;,))
p2 = CM.density(figd[1,2], rad2μas(chain.sky.σ)*2*sqrt(2*log(2)), axis=(xlabel=&quot;Ring FWHM (μas)&quot;,))
p3 = CM.density(figd[1,3], -rad2deg.(chain.sky.mp.:1) .+ 360.0, axis=(xlabel = &quot;Ring PA (deg) E of N&quot;,))
p4 = CM.density(figd[2,1], 2*chain.sky.ma.:2, axis=(xlabel=&quot;Brightness asymmetry&quot;,))
p5 = CM.density(figd[2,2], 1 .- chain.sky.f, axis=(xlabel=&quot;Ring flux fraction&quot;,))</code></pre><img src="b5c97afc.png" alt="Example block output"/><p>Now let&#39;s check the residuals using draws from the posterior</p><pre><code class="language-julia hljs">p = Plots.plot();
for s in sample(chain, 10)
    residual!(p, post, s, legend=false)
end</code></pre><img src="0cff656f.png" alt="Example block output"/><p>And everything looks pretty good! Now comes the hard part: interpreting the results...</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../GeometricModeling/">« Geometric Modeling of EHT Data</a><a class="docs-footer-nextpage" href="../LoadingData/">Loading Data into Comrade »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Thursday 16 May 2024 00:11">Thursday 16 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
