<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Imaging a Black Hole using only Closure Quantities · Comrade.jl</title><meta name="title" content="Imaging a Black Hole using only Closure Quantities · Comrade.jl"/><meta property="og:title" content="Imaging a Black Hole using only Closure Quantities · Comrade.jl"/><meta property="twitter:title" content="Imaging a Black Hole using only Closure Quantities · Comrade.jl"/><meta name="description" content="Documentation for Comrade.jl."/><meta property="og:description" content="Documentation for Comrade.jl."/><meta property="twitter:description" content="Documentation for Comrade.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Comrade.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../benchmarks/">Benchmarks</a></li><li><a class="tocitem" href="../../vlbi_imaging_problem/">Introduction to the VLBI Imaging Problem</a></li><li><a class="tocitem" href="../../conventions/">Conventions</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Imaging a Black Hole using only Closure Quantities</a><ul class="internal"><li><a class="tocitem" href="#Introduction-to-Closure-Imaging"><span>Introduction to Closure Imaging</span></a></li><li><a class="tocitem" href="#Load-the-Data"><span>Load the Data</span></a></li><li><a class="tocitem" href="#Build-the-Model/Posterior"><span>Build the Model/Posterior</span></a></li><li><a class="tocitem" href="#Reconstructing-the-Image"><span>Reconstructing the Image</span></a></li></ul></li><li><a class="tocitem" href="../GeometricModeling/">Geometric Modeling of EHT Data</a></li><li><a class="tocitem" href="../HybridImaging/">Hybrid Imaging of a Black Hole</a></li><li><a class="tocitem" href="../LoadingData/">Loading Data into Comrade</a></li><li><a class="tocitem" href="../PolarizedImaging/">Polarized Image and Instrumental Modeling</a></li><li><a class="tocitem" href="../StokesIImaging/">Stokes I Simultaneous Image and Instrument Modeling</a></li></ul></li><li><span class="tocitem">Extensions</span><ul><li><a class="tocitem" href="../../ext/optimization/">Optimization Extension</a></li><li><a class="tocitem" href="../../ext/ahmc/">AdvancedHMC Extension</a></li><li><a class="tocitem" href="../../ext/nested/">NestedSamples Extension</a></li><li><a class="tocitem" href="../../ext/dynesty/">Dynesty Extension</a></li></ul></li><li><a class="tocitem" href="../../base_api/">Base API</a></li><li><a class="tocitem" href="../../api/">Comrade API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Imaging a Black Hole using only Closure Quantities</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Imaging a Black Hole using only Closure Quantities</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ptiede/Comrade.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ptiede/Comrade.jl/blob/main/examples/ClosureImaging/main.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Imaging-a-Black-Hole-using-only-Closure-Quantities"><a class="docs-heading-anchor" href="#Imaging-a-Black-Hole-using-only-Closure-Quantities">Imaging a Black Hole using only Closure Quantities</a><a id="Imaging-a-Black-Hole-using-only-Closure-Quantities-1"></a><a class="docs-heading-anchor-permalink" href="#Imaging-a-Black-Hole-using-only-Closure-Quantities" title="Permalink"></a></h1><p>In this tutorial, we will create a preliminary reconstruction of the 2017 M87 data on April 6 using closure-only imaging. This tutorial is a general introduction to closure-only imaging in Comrade. For an introduction to simultaneous image and instrument modeling, see <a href="../StokesIImaging/#Stokes-I-Simultaneous-Image-and-Instrument-Modeling">Stokes I Simultaneous Image and Instrument Modeling</a></p><h2 id="Introduction-to-Closure-Imaging"><a class="docs-heading-anchor" href="#Introduction-to-Closure-Imaging">Introduction to Closure Imaging</a><a id="Introduction-to-Closure-Imaging-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction-to-Closure-Imaging" title="Permalink"></a></h2><p>The EHT is one of the highest-resolution telescope ever created. Its resolution is equivalent to roughly tracking a hockey puck on the moon when viewing it from the earth. However, the EHT is also a unique interferometer. First, EHT data is incredibly sparse, the array is formed from only eight geographic locations around the planet. Second, the obseving frequency is much higher than traditional VLBI. Lastly, each site in the array is unique. They have different dishes, recievers, feeds, and electronics. Putting this all together implies that many of the common imaging techniques struggle to fit the EHT data and explore the uncertainty in both the image and instrument. One way to deal with some of these uncertainties is to not directly fit the data but instead fit closure quantities, which are independent of many of the instrumental effects that plague the data. The types of closure quantities are briefly described in <a href="../../vlbi_imaging_problem/#Introduction-to-the-VLBI-Imaging-Problem">Introduction to the VLBI Imaging Problem</a>.</p><p>In this tutorial, we will do closure-only modeling of M87 to produce a posterior of images of M87.</p><p>To get started, we will load Comrade</p><pre><code class="language-julia hljs">using Comrade</code></pre><p>Pyehtim loads eht-imaging using PythonCall this is necessary to load uvfits files currently.</p><pre><code class="language-julia hljs">using Pyehtim</code></pre><p>For reproducibility we use a stable random number genreator</p><pre><code class="language-julia hljs">using StableRNGs
rng = StableRNG(123)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">StableRNGs.LehmerRNG(state=0x000000000000000000000000000000f7)</code></pre><h2 id="Load-the-Data"><a class="docs-heading-anchor" href="#Load-the-Data">Load the Data</a><a id="Load-the-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Load-the-Data" title="Permalink"></a></h2><p>To download the data visit https://doi.org/10.25739/g85n-f134 To load the eht-imaging obsdata object we do:</p><pre><code class="language-julia hljs">obs = ehtim.obsdata.load_uvfits(joinpath(__DIR, &quot;../Data/SR1_M87_2017_096_lo_hops_netcal_StokesI.uvfits&quot;))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Python: &lt;ehtim.obsdata.Obsdata object at 0x7f0860d5ba60&gt;</code></pre><p>Now we do some minor preprocessing:</p><ul><li>Scan average the data since the data have been preprocessed so that the gain phases  are coherent.</li><li>Add 2% systematic noise to deal with calibration issues such as leakage.</li></ul><pre><code class="language-julia hljs">obs = scan_average(obs).add_fractional_noise(0.02)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Python: &lt;ehtim.obsdata.Obsdata object at 0x7f07deca9330&gt;</code></pre><p>Now, we extract our closure quantities from the EHT data set. We flag now SNR points since the closure likelihood we use is only applicable to high SNR data.</p><pre><code class="language-julia hljs">dlcamp, dcphase  = extract_table(obs, LogClosureAmplitudes(;snrcut=3), ClosurePhases(;snrcut=3))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(EHTObservationTable{Comrade.EHTLogClosureAmplitudeDatum{:I}}
  source:      M87
  mjd:         57849
  bandwidth:   1.856e9
  sites:       [:AA, :AP, :AZ, :JC, :LM, :PV, :SM]
  nsamples:    128, EHTObservationTable{Comrade.EHTClosurePhaseDatum{:I}}
  source:      M87
  mjd:         57849
  bandwidth:   1.856e9
  sites:       [:AA, :AP, :AZ, :JC, :LM, :PV, :SM]
  nsamples:    152)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Fitting low SNR closure data is complicated and requires a more sophisticated likelihood. If low-SNR data is very important we recommend fitting visibilties with a instrumental model.</p></div></div><h2 id="Build-the-Model/Posterior"><a class="docs-heading-anchor" href="#Build-the-Model/Posterior">Build the Model/Posterior</a><a id="Build-the-Model/Posterior-1"></a><a class="docs-heading-anchor-permalink" href="#Build-the-Model/Posterior" title="Permalink"></a></h2><p>For our model, we will be using an image model that consists of a raster of point sources, convolved with some pulse or kernel to make a <code>ContinuousImage</code>. To define this model we define the standard two argument function <code>sky</code> that defines the sky model we want to fit. The first argument are the model parameters, and are typically a NamedTuple. The second argument defines the metadata for the model that is typically constant. For our model the constant <code>metdata</code> will just by the mean or prior image.</p><pre><code class="language-julia hljs">function sky(θ, metadata)
    (;fg, c, σimg) = θ
    (;mimg) = metadata
    # Apply the GMRF fluctuations to the image
    rast = apply_fluctuations(CenteredLR(), mimg, σimg.*c.params)
    m = ContinuousImage(((1-fg)).*rast, BSplinePulse{3}())
    # Force the image centroid to be at the origin
    x0, y0 = centroid(m)
    # Add a large-scale gaussian to deal with the over-resolved mas flux
    g = modify(Gaussian(), Stretch(μas2rad(250.0), μas2rad(250.0)), Renormalize(fg))
    return shifted(m, -x0, -y0) + g
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">sky (generic function with 1 method)</code></pre><p>Now, let&#39;s set up our image model. The EHT&#39;s nominal resolution is 20-25 μas. Additionally, the EHT is not very sensitive to a larger field of views; typically, 60-80 μas is enough to describe the compact flux of M87. Given this, we only need to use a small number of pixels to describe our image.</p><pre><code class="language-julia hljs">npix = 32
fovxy = μas2rad(150.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">7.27220521664304e-10</code></pre><p>To define the image model we need to specify both the grid we will be using and the FT algorithm we will use, in this case the NFFT which is the most efficient.</p><pre><code class="language-julia hljs">grid = imagepixels(fovxy, fovxy, npix, npix)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">RectiGrid(
executor: Serial()
Dimensions: 
<span class="sgr38_5" style="color:#ff875f">↓ X</span> Sampled{Float64} <span class="sgr38_5" style="color:#ff875f">LinRange{Float64}(-3.5224744018114725e-10, 3.5224744018114725e-10, 32)</span> <span class="sgr38_5" style="color:#808080">ForwardOrdered</span> <span class="sgr38_5" style="color:#808080">Regular</span> <span class="sgr38_5" style="color:#808080">Points</span>,
<span class="sgr38_5" style="color:#0087d7">→ Y</span> Sampled{Float64} <span class="sgr38_5" style="color:#0087d7">LinRange{Float64}(-3.5224744018114725e-10, 3.5224744018114725e-10, 32)</span> <span class="sgr38_5" style="color:#808080">ForwardOrdered</span> <span class="sgr38_5" style="color:#808080">Regular</span> <span class="sgr38_5" style="color:#808080">Points</span>
)</code></pre><p>Now we need to specify our image prior. For this work we will use a Gaussian Markov Random field prior</p><pre><code class="language-julia hljs">using VLBIImagePriors, Distributions, DistributionsAD</code></pre><p>Since we are using a Gaussian Markov random field prior we need to first specify our <code>mean</code> image. For this work we will use a symmetric Gaussian with a FWHM of 50 μas</p><pre><code class="language-julia hljs">fwhmfac = 2*sqrt(2*log(2))
mpr = modify(Gaussian(), Stretch(μas2rad(50.0)./fwhmfac))
imgpr = intensitymap(mpr, grid)
skymeta = (;mimg = imgpr./flux(imgpr));</code></pre><p>In addition we want a reasonable guess for what the resolution of our image should be. For radio astronomy this is given by roughly the longest baseline in the image. To put this into pixel space we then divide by the pixel size.</p><pre><code class="language-julia hljs">beam = beamsize(dlcamp)
rat = (beam/(step(grid.X)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5.326336637737519</code></pre><p>To make the Gaussian Markov random field efficient we first precompute a bunch of quantities that allow us to scale things linearly with the number of image pixels. This drastically improves the usual N^3 scaling you get from usual Gaussian Processes.</p><pre><code class="language-julia hljs">crcache = ConditionalMarkov(GMRF, grid; order=1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConditionalMarkov(
Random Field: GaussMarkovRandomField
Graph: MarkovRandomFieldGraph{1}(
dims: (32, 32)
)
)</code></pre><p>Now we can finally form our image prior. For this we use a heirarchical prior where the correlation length is given by a inverse gamma prior to prevent overfitting. Gaussian Markov random fields are extremly flexible models. To prevent overfitting it is common to use priors that penalize complexity. Therefore, we want to use priors that enforce similarity to our mean image, and prefer smoothness.</p><pre><code class="language-julia hljs">cprior = HierarchicalPrior(crcache, truncated(InverseGamma(1.0, -log(0.1)*rat); upper=2*npix))
prior = (c = cprior, σimg = Exponential(0.5), fg=Uniform(0.0, 1.0))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(c = HierarchicalPrior(
	map: 
	ConditionalMarkov(
Random Field: GaussMarkovRandomField
Graph: MarkovRandomFieldGraph{1}(
dims: (32, 32)
)
)	hyper prior: 
	Truncated(Distributions.InverseGamma{Float64}(
invd: Distributions.Gamma{Float64}(α=1.0, θ=0.0815371823902832)
θ: 12.264343342322437
)
; upper=64.0)

)
, σimg = Distributions.Exponential{Float64}(θ=0.5), fg = Distributions.Uniform{Float64}(a=0.0, b=1.0))</code></pre><p>Putting this all together we can define our sky model.</p><pre><code class="language-julia hljs">skym = SkyModel(sky, prior, grid; metadata=skymeta)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr34"><span class="sgr1"> SkyModel</span></span>
  with map: sky
   on grid: RectiGrid</code></pre><p>Since we are fitting closures we do not need to include an instrument model, since the closure likelihood is approximately independent of gains in the high SNR limit.</p><pre><code class="language-julia hljs">post = VLBIPosterior(skym, dlcamp, dcphase)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr95"><span class="sgr1">VLBIPosterior</span></span>
<span class="sgr34"><span class="sgr1">ObservedSkyModel</span></span>
  with map: sky
   on grid: FourierDualDomain<span class="sgr96"><span class="sgr1">IdealInstrumentModel</span></span><span class="sgr92">Data Products: </span>Comrade.EHTLogClosureAmplitudeDatumComrade.EHTClosurePhaseDatum
</code></pre><h2 id="Reconstructing-the-Image"><a class="docs-heading-anchor" href="#Reconstructing-the-Image">Reconstructing the Image</a><a id="Reconstructing-the-Image-1"></a><a class="docs-heading-anchor-permalink" href="#Reconstructing-the-Image" title="Permalink"></a></h2><p>To reconstruct the image we will first use the MAP estimate. This is approach is basically a re-implentation of regularized maximum likelihood (RML) imaging. However, unlike traditional RML imaging we also fit the regularizer hyperparameters, thanks to our interpretation of as our imaging prior as a hierarchical model.</p><p>To optimize our posterior <code>Comrade</code> provides the <code>comrade_opt</code> function. To use this functionality a user first needs to import <code>Optimization.jl</code> and the optimizer of choice. In this tutorial we will use Optim.jl&#39;s L-BFGS optimizer, which is defined in the sub-package OptimizationOptimJL. We also need to import Zygote to allow for automatic differentiation.</p><pre><code class="language-julia hljs">using Optimization
using OptimizationOptimJL
using Zygote
xopt, sol = comrade_opt(post, LBFGS(), Optimization.AutoZygote(); maxiters=1000)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">((sky = (c = (params = [4.0325793726743134e-7 -2.670992497100339e-6 … 3.814616864291783e-6 1.6711510479878672e-6; -3.4754925337650934e-6 -1.925040538007019e-6 … 2.8558640443064367e-6 2.632604766098715e-6; … ; -3.2320545966617127e-6 -4.6446454507065905e-6 … 3.2171909022581232e-6 -3.548597696516967e-7; -2.2465366133663275e-6 -2.3274188784128557e-6 … 2.845984748801865e-6 -8.642541785775902e-7], hyperparams = 0.013581218638165209), σimg = 49.53479443595636, fg = 0.20993305660024567),), retcode: Failure
u: [4.0325793726743134e-7, -3.4754925337650934e-6, -2.2343304517216225e-6, -5.632421184836578e-6, 4.7447693936494003e-7, 1.165674721326907e-8, -4.7349960960204e-6, -1.970153170381798e-5, -4.4834682357456276e-5, -5.990919414521695e-5  …  -3.7607089095792865e-5, -1.91229954502797e-5, -2.3760440194124113e-6, 4.253301388198418e-6, 5.275068341764152e-7, -3.548597696516967e-7, -8.642541785775902e-7, -8.457738277462562, 3.902675340541675, -1.3253289785488034]
Final objective value:     -2628.7585159629934
)</code></pre><p>First we will evaluate our fit by plotting the residuals</p><pre><code class="language-julia hljs">using Plots
p = residual(post, xopt)</code></pre><img src="ba34a05b.png" alt="Example block output"/><p>Now let&#39;s plot the MAP estimate.</p><pre><code class="language-julia hljs">import CairoMakie as CM
g = imagepixels(μas2rad(150.0), μas2rad(150.0), 100, 100)
img = intensitymap(skymodel(post, xopt), g)
fig = imageviz(img, size=(600, 500));</code></pre><img src="e21a2cd5.png" alt="Example block output"/><p>That doesn&#39;t look great. This is pretty common for the sparse EHT data. In this case the MAP often drastically overfits the data, producing a image filled with artifacts. In addition, we note that the MAP itself is not invariant to the model parameterization. Namely, if we changed our prior to use a fully centered parameterization we would get a very different image. Fortunately, these issues go away when we sample from the posterior, and construct expectations of the posterior, like the mean image.</p><p>To sample from the posterior we will use HMC and more specifically the NUTS algorithm. For information about NUTS see Michael Betancourt&#39;s <a href="https://arxiv.org/abs/1701.02434">notes</a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For our <code>metric</code> we use a diagonal matrix due to easier tuning.</p></div></div><pre><code class="language-julia hljs">using AdvancedHMC
using Zygote
chain = sample(post, NUTS(0.8), 700; n_adapts=500, progress=false, initial_params=xopt);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[ Info: Found initial step size 0.0001953125</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This should be run for longer!</p></div></div><p>Now that we have our posterior, we can assess which parts of the image are strongly inferred by the data. This is rather unique to <code>Comrade</code> where more traditional imaging algorithms like CLEAN and RML are inherently unable to assess uncertainty in their reconstructions.</p><p>To explore our posterior let&#39;s first create images from a bunch of draws from the posterior</p><pre><code class="language-julia hljs">msamples = skymodel.(Ref(post), chain[501:2:end]);</code></pre><p>The mean image is then given by</p><pre><code class="language-julia hljs">using StatsBase
imgs = intensitymap.(msamples, Ref(g))
mimg = mean(imgs)
simg = std(imgs)
fig = CM.Figure(;resolution=(700, 700));
CM.image(fig[1,1], mimg,
                   axis=(xreversed=true, aspect=1, title=&quot;Mean Image&quot;),
                   colormap=:afmhot);
CM.image(fig[1,2], simg./(max.(mimg, 1e-8)),
                   axis=(xreversed=true, aspect=1, title=&quot;1/SNR&quot;,), colorrange=(0.0, 2.0),
                   colormap=:afmhot);
CM.image(fig[2,1], imgs[1],
                   axis=(xreversed=true, aspect=1,title=&quot;Draw 1&quot;),
                   colormap=:afmhot);
CM.image(fig[2,2], imgs[end],
                   axis=(xreversed=true, aspect=1,title=&quot;Draw 2&quot;),
                   colormap=:afmhot);
CM.hidedecorations!.(fig.content)</code></pre><img src="02453a1e.png" alt="Example block output"/><p>Now let&#39;s see whether our residuals look better.</p><pre><code class="language-julia hljs">p = Plots.plot(layout=(2,1));
for s in sample(chain[501:end], 10)
    residual!(post, s)
end
p</code></pre><img src="8020006b.svg" alt="Example block output"/><p>And viola, you have a quick and preliminary image of M87 fitting only closure products. For a publication-level version we would recommend</p><ol><li>Running the chain longer and multiple times to properly assess things like ESS and R̂ (see <a href="../GeometricModeling/#Geometric-Modeling-of-EHT-Data">Geometric Modeling of EHT Data</a>)</li><li>Fitting gains. Typically gain amplitudes are good to 10-20% for the EHT not the infinite uncertainty closures implicitly assume</li></ol><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../conventions/">« Conventions</a><a class="docs-footer-nextpage" href="../GeometricModeling/">Geometric Modeling of EHT Data »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Thursday 16 May 2024 13:15">Thursday 16 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
