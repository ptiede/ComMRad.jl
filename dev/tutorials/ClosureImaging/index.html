<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Imaging a Black Hole using only Closure Quantities · Comrade.jl</title><meta name="title" content="Imaging a Black Hole using only Closure Quantities · Comrade.jl"/><meta property="og:title" content="Imaging a Black Hole using only Closure Quantities · Comrade.jl"/><meta property="twitter:title" content="Imaging a Black Hole using only Closure Quantities · Comrade.jl"/><meta name="description" content="Documentation for Comrade.jl."/><meta property="og:description" content="Documentation for Comrade.jl."/><meta property="twitter:description" content="Documentation for Comrade.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Comrade.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../benchmarks/">Benchmarks</a></li><li><a class="tocitem" href="../../vlbi_imaging_problem/">Introduction to the VLBI Imaging Problem</a></li><li><a class="tocitem" href="../../conventions/">Conventions</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Imaging a Black Hole using only Closure Quantities</a><ul class="internal"><li><a class="tocitem" href="#Introduction-to-Closure-Imaging"><span>Introduction to Closure Imaging</span></a></li><li><a class="tocitem" href="#Load-the-Data"><span>Load the Data</span></a></li><li><a class="tocitem" href="#Build-the-Model/Posterior"><span>Build the Model/Posterior</span></a></li><li><a class="tocitem" href="#Reconstructing-the-Image"><span>Reconstructing the Image</span></a></li></ul></li><li><a class="tocitem" href="../GeometricModeling/">Geometric Modeling of EHT Data</a></li><li><a class="tocitem" href="../HybridImaging/">Hybrid Imaging of a Black Hole</a></li><li><a class="tocitem" href="../LoadingData/">Loading Data into Comrade</a></li><li><a class="tocitem" href="../PolarizedImaging/">Polarized Image and Instrumental Modeling</a></li><li><a class="tocitem" href="../StokesIImaging/">Stokes I Simultaneous Image and Instrument Modeling</a></li></ul></li><li><span class="tocitem">Libraries</span><ul><li><a class="tocitem" href="../../libs/optimization/">ComradeOptimization</a></li><li><a class="tocitem" href="../../libs/ahmc/">ComradeAHMC</a></li><li><a class="tocitem" href="../../libs/nested/">ComradeNested</a></li><li><a class="tocitem" href="../../libs/dynesty/">ComradeDynesty</a></li><li><a class="tocitem" href="../../libs/adaptmcmc/">ComradeAdaptMCMC</a></li></ul></li><li><a class="tocitem" href="../../base_api/">ComradeBase API</a></li><li><a class="tocitem" href="../../api/">Comrade API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Imaging a Black Hole using only Closure Quantities</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Imaging a Black Hole using only Closure Quantities</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ptiede/Comrade.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ptiede/Comrade.jl/blob/main/examples/ClosureImaging/main.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Imaging-a-Black-Hole-using-only-Closure-Quantities"><a class="docs-heading-anchor" href="#Imaging-a-Black-Hole-using-only-Closure-Quantities">Imaging a Black Hole using only Closure Quantities</a><a id="Imaging-a-Black-Hole-using-only-Closure-Quantities-1"></a><a class="docs-heading-anchor-permalink" href="#Imaging-a-Black-Hole-using-only-Closure-Quantities" title="Permalink"></a></h1><p>In this tutorial, we will create a preliminary reconstruction of the 2017 M87 data on April 6 using closure-only imaging. This tutorial is a general introduction to closure-only imaging in Comrade. For an introduction to simultaneous image and instrument modeling, see <a href="../StokesIImaging/#Stokes-I-Simultaneous-Image-and-Instrument-Modeling">Stokes I Simultaneous Image and Instrument Modeling</a></p><h2 id="Introduction-to-Closure-Imaging"><a class="docs-heading-anchor" href="#Introduction-to-Closure-Imaging">Introduction to Closure Imaging</a><a id="Introduction-to-Closure-Imaging-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction-to-Closure-Imaging" title="Permalink"></a></h2><p>The EHT is the highest-resolution telescope ever created. Its resolution is equivalent to roughly tracking a hockey puck on the moon when viewing it from the earth. However, the EHT is also a unique interferometer. For one, the data it produces is incredibly sparse. The array is formed from only eight geographic locations around the planet, each with its unique telescope. Additionally, the EHT observes at a much higher frequency than typical interferometers. As a result, it is often difficult to directly provide calibrated data since the source model can be complicated. This implies there can be large instrumental effects often called <em>gains</em> that can corrupt our signal. One way to deal with this is to fit quantities that are independent of gains. These are often called <strong>closure quantities</strong>. The types of closure quantities are briefly described in <a href="../../vlbi_imaging_problem/#Introduction-to-the-VLBI-Imaging-Problem">Introduction to the VLBI Imaging Problem</a>.</p><p>In this tutorial, we will do closure-only modeling of M87 to produce preliminary images of M87.</p><p>To get started, we will load Comrade</p><pre><code class="language-julia hljs">using Comrade</code></pre><p>Pyehtim loads eht-imaging using PythonCall this is necessary to load uvfits files currently.</p><pre><code class="language-julia hljs">using Pyehtim</code></pre><p>For reproducibility we use a stable random number genreator</p><pre><code class="language-julia hljs">using StableRNGs
rng = StableRNG(123)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">StableRNGs.LehmerRNG(state=0x000000000000000000000000000000f7)</code></pre><h2 id="Load-the-Data"><a class="docs-heading-anchor" href="#Load-the-Data">Load the Data</a><a id="Load-the-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Load-the-Data" title="Permalink"></a></h2><p>To download the data visit https://doi.org/10.25739/g85n-f134 To load the eht-imaging obsdata object we do:</p><pre><code class="language-julia hljs">obs = ehtim.obsdata.load_uvfits(joinpath(__DIR, &quot;../Data/SR1_M87_2017_096_lo_hops_netcal_StokesI.uvfits&quot;))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Python: &lt;ehtim.obsdata.Obsdata object at 0x7feb8680dab0&gt;</code></pre><p>Now we do some minor preprocessing:</p><ul><li>Scan average the data since the data have been preprocessed so that the gain phases  are coherent.</li><li>Add 2% systematic noise to deal with calibration issues such as leakage.</li></ul><pre><code class="language-julia hljs">obs = scan_average(obs).add_fractional_noise(0.02)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Python: &lt;ehtim.obsdata.Obsdata object at 0x7feb868fb7f0&gt;</code></pre><p>Now, we extract our closure quantities from the EHT data set.</p><pre><code class="language-julia hljs">dlcamp, dcphase  = extract_table(obs, LogClosureAmplitudes(;snrcut=3), ClosurePhases(;snrcut=3))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(EHTObservation{Float64,Comrade.EHTLogClosureAmplitudeDatum{Float64}, ...}
  source: M87
  mjd: 57849
  frequency: 2.27070703125e11
  bandwidth: 1.856e9
  stations: [:AA, :AP, :AZ, :JC, :LM, :PV, :SM]
  nsamples: 128
, EHTObservation{Float64,Comrade.EHTClosurePhaseDatum{Float64}, ...}
  source: M87
  mjd: 57849
  frequency: 2.27070703125e11
  bandwidth: 1.856e9
  stations: [:AA, :AP, :AZ, :JC, :LM, :PV, :SM]
  nsamples: 152
)</code></pre><h2 id="Build-the-Model/Posterior"><a class="docs-heading-anchor" href="#Build-the-Model/Posterior">Build the Model/Posterior</a><a id="Build-the-Model/Posterior-1"></a><a class="docs-heading-anchor-permalink" href="#Build-the-Model/Posterior" title="Permalink"></a></h2><p>For our model, we will be using an image model that consists of a raster of point sources, convolved with some pulse or kernel to make a <code>ContinuousImage</code> object with it <code>Comrade&#39;s.</code> generic image model. For this we will define a two argument function. The first argument is typically a named tuple with the model parameters. The second argument defines the metadata for the model that is typically constant. This allows us to explicitly pass arguments that are constant to the model, such as the image <code>cache</code> object that we will define below.</p><pre><code class="language-julia hljs">function sky(θ, metadata)
    (;fg, c, σimg) = θ
    (;meanpr, cache) = metadata
    # Construct the image model we fix the flux to 0.6 Jy in this case
    cp = meanpr .+ σimg.*c.params
    rast = ((1-fg))*to_simplex(AdditiveLR(), cp)
    m = ContinuousImage(rast, cache)
    # Add a large-scale gaussian to deal with the over-resolved mas flux
    g = modify(Gaussian(), Stretch(μas2rad(250.0), μas2rad(250.0)), Renormalize(fg))
    return m + g
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">sky (generic function with 1 method)</code></pre><p>Now, let&#39;s set up our image model. The EHT&#39;s nominal resolution is 20-25 μas. Additionally, the EHT is not very sensitive to a larger field of views; typically, 60-80 μas is enough to describe the compact flux of M87. Given this, we only need to use a small number of pixels to describe our image.</p><pre><code class="language-julia hljs">npix = 32
fovxy = μas2rad(150.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">7.27220521664304e-10</code></pre><p>To define the image model we need to specify both the grid we will be using and the FT algorithm we will use, in this case the NFFT which is the most efficient.</p><pre><code class="language-julia hljs">grid = imagepixels(fovxy, fovxy, npix, npix)
cache = create_cache(NFFTAlg(dlcamp), grid, BSplinePulse{3}())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">VLBISkyModels.NUFTCache: 
	FT algorithm: VLBISkyModels.ObservedNUFT
	pulse: BSplinePulse{3}
	domain: RectiGrid(:X, :Y)</code></pre><p>Now we need to specify our image prior. For this work we will use a Gaussian Markov Random field prior</p><pre><code class="language-julia hljs">using VLBIImagePriors, Distributions, DistributionsAD</code></pre><p>Since we are using a Gaussian Markov random field prior we need to first specify our <code>mean</code> image. For this work we will use a symmetric Gaussian with a FWHM of 50 μas</p><pre><code class="language-julia hljs">fwhmfac = 2*sqrt(2*log(2))
mpr = modify(Gaussian(), Stretch(μas2rad(50.0)./fwhmfac))
imgpr = intensitymap(mpr, grid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">32×32 IntensityMap{Float64,2}<span class="sgr90"> with dimensions: </span>
  <span class="sgr31">X</span> Sampled{Float64} <span class="sgr36">LinRange{Float64}(-3.52247e-10, 3.52247e-10, 32)</span> ForwardOrdered Regular Points,
  <span class="sgr31">Y</span> Sampled{Float64} <span class="sgr36">LinRange{Float64}(-3.52247e-10, 3.52247e-10, 32)</span> ForwardOrdered Regular Points
               <span class="sgr90">-3.52247e-10</span>  <span class="sgr90">-3.29522e-10</span>  …  <span class="sgr90">3.29522e-10</span>  <span class="sgr90">3.52247e-10</span>
 <span class="sgr90">-3.52247e-10</span>   6.37537e-8    1.32434e-7      1.32434e-7   6.37537e-8
 <span class="sgr90">-3.29522e-10</span>   1.32434e-7    2.751e-7        2.751e-7     1.32434e-7
 <span class="sgr90">-3.06796e-10</span>   2.62014e-7    5.44273e-7      5.44273e-7   2.62014e-7
 <span class="sgr90">-2.84071e-10</span>   4.93724e-7    1.0256e-6       1.0256e-6    4.93724e-7
 <span class="sgr90">-2.61345e-10</span>   8.86092e-7    1.84065e-6   …  1.84065e-6   8.86092e-7
  ⋮                                        ⋱  ⋮            
  <span class="sgr90">2.38619e-10</span>   1.51463e-6    3.14629e-6      3.14629e-6   1.51463e-6
  <span class="sgr90">2.61345e-10</span>   8.86092e-7    1.84065e-6      1.84065e-6   8.86092e-7
  <span class="sgr90">2.84071e-10</span>   4.93724e-7    1.0256e-6       1.0256e-6    4.93724e-7
  <span class="sgr90">3.06796e-10</span>   2.62014e-7    5.44273e-7   …  5.44273e-7   2.62014e-7
  <span class="sgr90">3.29522e-10</span>   1.32434e-7    2.751e-7        2.751e-7     1.32434e-7
  <span class="sgr90">3.52247e-10</span>   6.37537e-8    1.32434e-7      1.32434e-7   6.37537e-8</code></pre><p>Now since we are actually modeling our image on the simplex we need to ensure that our mean image has unit flux before we transform</p><pre><code class="language-julia hljs">imgpr ./= flux(imgpr)
meanpr = to_real(AdditiveLR(), baseimage(imgpr));</code></pre><pre><code class="language-julia hljs">skymeta = (;meanpr, cache);</code></pre><p>In addition we want a reasonable guess for what the resolution of our image should be. For radio astronomy this is given by roughly the longest baseline in the image. To put this into pixel space we then divide by the pixel size.</p><pre><code class="language-julia hljs">beam = beamsize(dlcamp)
rat = (beam/(step(grid.X)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5.326336637737519</code></pre><p>To make the Gaussian Markov random field efficient we first precompute a bunch of quantities that allow us to scale things linearly with the number of image pixels. This drastically improves the usual N^3 scaling you get from usual Gaussian Processes.</p><pre><code class="language-julia hljs">crcache = ConditionalMarkov(GMRF, grid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConditionalMarkov(
Random Field: VLBIImagePriors.GaussMarkovRandomField
Graph: MarkovRandomFieldGraph{1}(
dims: (32, 32)
)
)</code></pre><p>Now we can finally form our image prior. For this we use a heirarchical prior where the correlation length is given by a inverse gamma prior to prevent overfitting. Gaussian Markov random fields are extremly flexible models. To prevent overfitting it is common to use priors that penalize complexity. Therefore, we want to use priors that enforce similarity to our mean image, and prefer smoothness.</p><pre><code class="language-julia hljs">cprior = HierarchicalPrior(crcache, truncated(InverseGamma(2.0, -log(0.1*rat)); upper=npix))

prior = NamedDist(c = cprior, σimg = truncated(Normal(0.0, 0.1); lower = 0.0), fg=Uniform(0.0, 1.0))

lklhd = RadioLikelihood(sky, dlcamp, dcphase;
                        skymeta = skymeta)
post = Posterior(lklhd, prior)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Posterior(
RadioLikelihood
	Number of data products: 2

Prior:
(c = HierarchicalPrior(
	map: 
	ConditionalMarkov(
Random Field: VLBIImagePriors.GaussMarkovRandomField
Graph: MarkovRandomFieldGraph{1}(
dims: (32, 32)
)
)	hyper prior: 
	Truncated(Distributions.InverseGamma{Float64}(
invd: Distributions.Gamma{Float64}(α=2.0, θ=1.587499643971231)
θ: 0.6299214011150495
)
; upper=32.0)

)
, σimg = Truncated(Distributions.Normal{Float64}(μ=0.0, σ=0.1); lower=0.0), fg = Distributions.Uniform{Float64}(a=0.0, b=1.0))
)</code></pre><h2 id="Reconstructing-the-Image"><a class="docs-heading-anchor" href="#Reconstructing-the-Image">Reconstructing the Image</a><a id="Reconstructing-the-Image-1"></a><a class="docs-heading-anchor-permalink" href="#Reconstructing-the-Image" title="Permalink"></a></h2><p>To sample from this posterior, it is convenient to first move from our constrained parameter space to an unconstrained one (i.e., the support of the transformed posterior is (-∞, ∞)). This is done using the <code>asflat</code> function.</p><pre><code class="language-julia hljs">tpost = asflat(post)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">TransformedPosterior(
Posterior(
RadioLikelihood
	Number of data products: 2

Prior:
(c = HierarchicalPrior(
	map: 
	ConditionalMarkov(
Random Field: VLBIImagePriors.GaussMarkovRandomField
Graph: MarkovRandomFieldGraph{1}(
dims: (32, 32)
)
)	hyper prior: 
	Truncated(Distributions.InverseGamma{Float64}(
invd: Distributions.Gamma{Float64}(α=2.0, θ=1.587499643971231)
θ: 0.6299214011150495
)
; upper=32.0)

)
, σimg = Truncated(Distributions.Normal{Float64}(μ=0.0, σ=0.1); lower=0.0), fg = Distributions.Uniform{Float64}(a=0.0, b=1.0))
)
Transform: Params to ℝ^1027
)</code></pre><p>We can now also find the dimension of our posterior or the number of parameters we will sample.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This can often be different from what you would expect. This is especially true when using angular variables, where we often artificially increase the dimension of the parameter space to make sampling easier.</p></div></div><pre><code class="language-julia hljs">ndim = dimension(tpost)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1027</code></pre><p>Now we optimize using LBFGS</p><pre><code class="language-julia hljs">using ComradeOptimization
using OptimizationOptimJL
using Zygote
f = OptimizationFunction(tpost, Optimization.AutoZygote())
prob = Optimization.OptimizationProblem(f, prior_sample(rng, tpost), nothing)
sol = solve(prob, LBFGS(); maxiters=500);</code></pre><p>Before we analyze our solution we first need to transform back to parameter space.</p><pre><code class="language-julia hljs">xopt = transform(tpost, sol)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(c = (params = [9.761263083041981e-7 4.221185729158731e-6 … -4.8073373263384e-6 -2.1057141484247486e-6; 2.6020549384202527e-6 5.708710777301589e-6 … -1.864668512717162e-5 -5.2588657885536535e-6; … ; 2.6197086258670364e-6 -6.123474487065041e-6 … 1.3476586449850432e-5 2.585268049247257e-6; 8.571648712613899e-7 -5.174559422611086e-7 … 6.9943680091979565e-6 1.912259555467427e-8], hyperparams = 0.044839260786255844), σimg = 3.1737558964160493, fg = 0.0021043873541184573)</code></pre><p>First we will evaluate our fit by plotting the residuals</p><pre><code class="language-julia hljs">using Plots
p = residual(skymodel(post, xopt), dlcamp, ylabel=&quot;Log Closure Amplitude Res.&quot;)</code></pre><img src="139da8ae.png" alt="Example block output"/><p>and now closure phases</p><pre><code class="language-julia hljs">p = residual(skymodel(post, xopt), dcphase, ylabel=&quot;|Closure Phase Res.|&quot;)
DisplayAs.Text(DisplayAs.PNG(p))</code></pre><img src="2be49574.png" alt="Example block output"/><p>Now let&#39;s plot the MAP estimate.</p><pre><code class="language-julia hljs">import CairoMakie as CM
img = intensitymap(skymodel(post, xopt), μas2rad(150.0), μas2rad(150.0), 100, 100)
fig = imageviz(img);</code></pre><img src="8fcf82a4.png" alt="Example block output"/><p>That doesn&#39;t look great. The reason for this is that the MAP, from a Bayesian standpoint, is not representative of the posterior. In fact, the MAP often overfits the data and depends on the choice of parameterization of the posterior. Given this we will turn to sampling from the posterior instead.</p><p>To sample from the posterior we will use HMC and more specifically the NUTS algorithm. For information about NUTS see Michael Betancourt&#39;s <a href="https://arxiv.org/abs/1701.02434">notes</a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For our <code>metric</code> we use a diagonal matrix due to easier tuning.</p></div></div><pre><code class="language-julia hljs">using ComradeAHMC
using Zygote
metric = DiagEuclideanMetric(ndim)
chain = sample(post, AHMC(;metric, autodiff=Val(:Zygote)), 700; n_adapts=500, progress=false);</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This should be run for longer!</p></div></div><p>Now that we have our posterior, we can assess which parts of the image are strongly inferred by the data. This is rather unique to <code>Comrade</code> where more traditional imaging algorithms like CLEAN and RML are inherently unable to assess uncertainty in their reconstructions.</p><p>To explore our posterior let&#39;s first create images from a bunch of draws from the posterior</p><pre><code class="language-julia hljs">msamples = skymodel.(Ref(post), chain[501:2:end]);</code></pre><p>The mean image is then given by</p><pre><code class="language-julia hljs">using StatsBase
imgs = intensitymap.(msamples, μas2rad(150.0), μas2rad(150.0), 128, 128)
mimg = mean(imgs)
simg = std(imgs)
fig = CM.Figure(;resolution=(700, 700));
CM.image(fig[1,1], mimg,
                   axis=(xreversed=true, aspect=1, title=&quot;Mean Image&quot;),
                   colormap=:afmhot);
CM.image(fig[1,2], simg./(max.(mimg, 1e-5)),
                   axis=(xreversed=true, aspect=1, title=&quot;1/SNR&quot;,), colorrange=(0.0, 2.0),
                   colormap=:afmhot);
CM.image(fig[2,1], imgs[1],
                   axis=(xreversed=true, aspect=1,title=&quot;Draw 1&quot;),
                   colormap=:afmhot);
CM.image(fig[2,2], imgs[end],
                   axis=(xreversed=true, aspect=1,title=&quot;Draw 2&quot;),
                   colormap=:afmhot);
CM.hidedecorations!.(fig.content)</code></pre><img src="d517ed7a.png" alt="Example block output"/><p>Now let&#39;s see whether our residuals look better.</p><pre><code class="language-julia hljs">p = Plots.plot();
for s in sample(chain[501:end], 10)
    residual!(p, vlbimodel(post, s), dlcamp)
end
Plots.ylabel!(&quot;Log-Closure Amplitude Res.&quot;);
DisplayAs.Text(DisplayAs.PNG(p))</code></pre><img src="fbf2f9b9.png" alt="Example block output"/><pre><code class="language-julia hljs">p = Plots.plot();
for s in sample(chain[501:end], 10)
    residual!(p, vlbimodel(post, s), dcphase)
end
Plots.ylabel!(&quot;|Closure Phase Res.|&quot;);
DisplayAs.Text(DisplayAs.PNG(p))</code></pre><img src="ca5caa25.png" alt="Example block output"/><p>And viola, you have a quick and preliminary image of M87 fitting only closure products. For a publication-level version we would recommend</p><ol><li>Running the chain longer and multiple times to properly assess things like ESS and R̂ (see <a href="../GeometricModeling/#Geometric-Modeling-of-EHT-Data">Geometric Modeling of EHT Data</a>)</li><li>Fitting gains. Typically gain amplitudes are good to 10-20% for the EHT not the infinite uncertainty closures implicitly assume</li></ol><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../conventions/">« Conventions</a><a class="docs-footer-nextpage" href="../GeometricModeling/">Geometric Modeling of EHT Data »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Thursday 22 February 2024 15:03">Thursday 22 February 2024</span>. Using Julia version 1.10.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
