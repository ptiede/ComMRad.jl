<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ComradeBase API · Comrade.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Comrade.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../benchmarks/">Benchmarks</a></li><li><a class="tocitem" href="../vlbi_imaging_problem/">Introduction to the VLBI Imaging Problem</a></li><li><a class="tocitem" href="../conventions/">Conventions</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../examples/data/">Loading Data into Comrade</a></li><li><a class="tocitem" href="../examples/geometric_modeling/">Geometric Modeling of EHT Data</a></li><li><a class="tocitem" href="../examples/imaging_closures/">Imaging a Black Hole using only Closure Quantities</a></li><li><a class="tocitem" href="../examples/imaging_vis/">Stokes I Simultaneous Image and Instrument Modeling</a></li><li><a class="tocitem" href="../examples/imaging_pol/">Polarized Image and Instrumental Modeling</a></li><li><a class="tocitem" href="../examples/hybrid_imaging/">Hybrid Imaging of a Black Hole</a></li></ul></li><li><span class="tocitem">Libraries</span><ul><li><a class="tocitem" href="../libs/optimization/">ComradeOptimization</a></li><li><a class="tocitem" href="../libs/ahmc/">ComradeAHMC</a></li><li><a class="tocitem" href="../libs/nested/">ComradeNested</a></li><li><a class="tocitem" href="../libs/dynesty/">ComradeDynesty</a></li><li><a class="tocitem" href="../libs/adaptmcmc/">ComradeAdaptMCMC</a></li></ul></li><li class="is-active"><a class="tocitem" href>ComradeBase API</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Model-API"><span>Model API</span></a></li><li><a class="tocitem" href="#Polarization"><span>Polarization</span></a></li></ul></li><li><a class="tocitem" href="../api/">Comrade API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>ComradeBase API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>ComradeBase API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ptiede/Comrade.jl/blob/main/docs/src/base_api.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ComradeBase-API"><a class="docs-heading-anchor" href="#ComradeBase-API">ComradeBase API</a><a id="ComradeBase-API-1"></a><a class="docs-heading-anchor-permalink" href="#ComradeBase-API" title="Permalink"></a></h1><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#ComradeBase-API">ComradeBase API</a></li><li class="no-marker"><ul><li><a href="#Contents">Contents</a></li><li><a href="#Index">Index</a></li><li><a href="#Model-API">Model API</a></li><li><a href="#Polarization">Polarization</a></li></ul></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#ComradeBase.AbstractModel"><code>ComradeBase.AbstractModel</code></a></li><li><a href="#ComradeBase.AbstractPolarizedModel"><code>ComradeBase.AbstractPolarizedModel</code></a></li><li><a href="#ComradeBase.DensityAnalytic"><code>ComradeBase.DensityAnalytic</code></a></li><li><a href="#ComradeBase.GriddedKeys"><code>ComradeBase.GriddedKeys</code></a></li><li><a href="#ComradeBase.IntensityMap-Tuple{AbstractArray, ComradeBase.AbstractDims}"><code>ComradeBase.IntensityMap</code></a></li><li><a href="#ComradeBase.IntensityMap"><code>ComradeBase.IntensityMap</code></a></li><li><a href="#ComradeBase.IsAnalytic"><code>ComradeBase.IsAnalytic</code></a></li><li><a href="#ComradeBase.IsPrimitive"><code>ComradeBase.IsPrimitive</code></a></li><li><a href="#ComradeBase.MinimalHeader"><code>ComradeBase.MinimalHeader</code></a></li><li><a href="#ComradeBase.NoHeader"><code>ComradeBase.NoHeader</code></a></li><li><a href="#ComradeBase.NotAnalytic"><code>ComradeBase.NotAnalytic</code></a></li><li><a href="#ComradeBase.NotPrimitive"><code>ComradeBase.NotPrimitive</code></a></li><li><a href="#ComradeBase.PrimitiveTrait"><code>ComradeBase.PrimitiveTrait</code></a></li><li><a href="#ComradeBase.StokesIntensityMap"><code>ComradeBase.StokesIntensityMap</code></a></li><li><a href="#PolarizedTypes.CirBasis"><code>PolarizedTypes.CirBasis</code></a></li><li><a href="#PolarizedTypes.CoherencyMatrix"><code>PolarizedTypes.CoherencyMatrix</code></a></li><li><a href="#PolarizedTypes.ElectricFieldBasis"><code>PolarizedTypes.ElectricFieldBasis</code></a></li><li><a href="#PolarizedTypes.LPol"><code>PolarizedTypes.LPol</code></a></li><li><a href="#PolarizedTypes.LinBasis"><code>PolarizedTypes.LinBasis</code></a></li><li><a href="#PolarizedTypes.PolBasis"><code>PolarizedTypes.PolBasis</code></a></li><li><a href="#PolarizedTypes.RPol"><code>PolarizedTypes.RPol</code></a></li><li><a href="#PolarizedTypes.StokesParams"><code>PolarizedTypes.StokesParams</code></a></li><li><a href="#PolarizedTypes.XPol"><code>PolarizedTypes.XPol</code></a></li><li><a href="#PolarizedTypes.YPol"><code>PolarizedTypes.YPol</code></a></li><li><a href="#ComradeBase.amplitude-Tuple{Any, Any}"><code>ComradeBase.amplitude</code></a></li><li><a href="#ComradeBase.amplitudes"><code>ComradeBase.amplitudes</code></a></li><li><a href="#ComradeBase.axisdims"><code>ComradeBase.axisdims</code></a></li><li><a href="#ComradeBase.bispectra"><code>ComradeBase.bispectra</code></a></li><li><a href="#ComradeBase.bispectrum"><code>ComradeBase.bispectrum</code></a></li><li><a href="#ComradeBase.centroid"><code>ComradeBase.centroid</code></a></li><li><a href="#ComradeBase.closure_phase"><code>ComradeBase.closure_phase</code></a></li><li><a href="#ComradeBase.closure_phases"><code>ComradeBase.closure_phases</code></a></li><li><a href="#ComradeBase.dims"><code>ComradeBase.dims</code></a></li><li><a href="#ComradeBase.fieldofview"><code>ComradeBase.fieldofview</code></a></li><li><a href="#ComradeBase.flux"><code>ComradeBase.flux</code></a></li><li><a href="#ComradeBase.header"><code>ComradeBase.header</code></a></li><li><a href="#ComradeBase.imagegrid"><code>ComradeBase.imagegrid</code></a></li><li><a href="#ComradeBase.imagepixels"><code>ComradeBase.imagepixels</code></a></li><li><a href="#ComradeBase.imanalytic"><code>ComradeBase.imanalytic</code></a></li><li><a href="#ComradeBase.intensity_point"><code>ComradeBase.intensity_point</code></a></li><li><a href="#ComradeBase.intensitymap"><code>ComradeBase.intensitymap</code></a></li><li><a href="#ComradeBase.intensitymap!"><code>ComradeBase.intensitymap!</code></a></li><li><a href="#ComradeBase.intensitymap_analytic"><code>ComradeBase.intensitymap_analytic</code></a></li><li><a href="#ComradeBase.intensitymap_analytic!"><code>ComradeBase.intensitymap_analytic!</code></a></li><li><a href="#ComradeBase.intensitymap_numeric"><code>ComradeBase.intensitymap_numeric</code></a></li><li><a href="#ComradeBase.intensitymap_numeric!"><code>ComradeBase.intensitymap_numeric!</code></a></li><li><a href="#ComradeBase.ispolarized"><code>ComradeBase.ispolarized</code></a></li><li><a href="#ComradeBase.isprimitive"><code>ComradeBase.isprimitive</code></a></li><li><a href="#ComradeBase.load"><code>ComradeBase.load</code></a></li><li><a href="#ComradeBase.logclosure_amplitude"><code>ComradeBase.logclosure_amplitude</code></a></li><li><a href="#ComradeBase.logclosure_amplitudes"><code>ComradeBase.logclosure_amplitudes</code></a></li><li><a href="#ComradeBase.named_dims"><code>ComradeBase.named_dims</code></a></li><li><a href="#ComradeBase.phasecenter"><code>ComradeBase.phasecenter</code></a></li><li><a href="#ComradeBase.pixelsizes"><code>ComradeBase.pixelsizes</code></a></li><li><a href="#ComradeBase.radialextent"><code>ComradeBase.radialextent</code></a></li><li><a href="#ComradeBase.save"><code>ComradeBase.save</code></a></li><li><a href="#ComradeBase.second_moment"><code>ComradeBase.second_moment</code></a></li><li><a href="#ComradeBase.stokes"><code>ComradeBase.stokes</code></a></li><li><a href="#ComradeBase.visanalytic"><code>ComradeBase.visanalytic</code></a></li><li><a href="#ComradeBase.visibilities"><code>ComradeBase.visibilities</code></a></li><li><a href="#ComradeBase.visibilities!"><code>ComradeBase.visibilities!</code></a></li><li><a href="#ComradeBase.visibilities_analytic"><code>ComradeBase.visibilities_analytic</code></a></li><li><a href="#ComradeBase.visibilities_analytic!"><code>ComradeBase.visibilities_analytic!</code></a></li><li><a href="#ComradeBase.visibilities_numeric"><code>ComradeBase.visibilities_numeric</code></a></li><li><a href="#ComradeBase.visibilities_numeric!"><code>ComradeBase.visibilities_numeric!</code></a></li><li><a href="#ComradeBase.visibility"><code>ComradeBase.visibility</code></a></li><li><a href="#ComradeBase.visibility_point"><code>ComradeBase.visibility_point</code></a></li><li><a href="#PolarizedTypes.basis_components"><code>PolarizedTypes.basis_components</code></a></li><li><a href="#PolarizedTypes.basis_transform"><code>PolarizedTypes.basis_transform</code></a></li><li><a href="#PolarizedTypes.innerprod"><code>PolarizedTypes.innerprod</code></a></li></ul><h2 id="Model-API"><a class="docs-heading-anchor" href="#Model-API">Model API</a><a id="Model-API-1"></a><a class="docs-heading-anchor-permalink" href="#Model-API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.flux" href="#ComradeBase.flux"><code>ComradeBase.flux</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">flux(im::IntensityMap)
flux(img::StokesIntensityMap)</code></pre><p>Computes the flux of a intensity map</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/images/methods.jl#L82-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.visibility" href="#ComradeBase.visibility"><code>ComradeBase.visibility</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">visibility(mimg, p)</code></pre><p>Computes the complex visibility of model <code>m</code> at coordinates <code>p</code>. <code>p</code> corresponds to the coordinates of the model. These need to have the properties <code>U</code>, <code>V</code> and sometimes <code>Ti</code> for time and <code>Fr</code> for frequency.</p><p><strong>Notes</strong></p><p>If you want to compute the visibilities at a large number of positions consider using the <a href="#ComradeBase.visibilities"><code>visibilities</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/visibilities.jl#L53-L63">source</a></section><section><div><pre><code class="nohighlight hljs">visibility(d::EHTVisibilityDatum)</code></pre><p>Return the complex visibility of the visibility datum</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/21c90571b68b236cff42ab5173f1391100ec6949/src/observations/observations.jl#L524-L528">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.visibilities" href="#ComradeBase.visibilities"><code>ComradeBase.visibilities</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">visibilities(model::AbstractModel, args...)</code></pre><p>Computes the complex visibilities at the locations given by <code>args...</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/interface.jl#L263-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.visibilities!" href="#ComradeBase.visibilities!"><code>ComradeBase.visibilities!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">visibilities!(vis::AbstractArray, model::AbstractModel, args...)</code></pre><p>Computes the complex visibilities <code>vis</code> in place at the locations given by <code>args...</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/interface.jl#L271-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.intensitymap" href="#ComradeBase.intensitymap"><code>ComradeBase.intensitymap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">intensitymap(model::AbstractModel, p::AbstractDims)</code></pre><p>Computes the intensity map of model. For the inplace version see <a href="#ComradeBase.intensitymap!"><code>intensitymap!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/interface.jl#L207-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.intensitymap!" href="#ComradeBase.intensitymap!"><code>ComradeBase.intensitymap!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">intensitymap!(buffer::AbstractDimArray, model::AbstractModel)</code></pre><p>Computes the intensity map of <code>model</code> by modifying the <code>buffer</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/interface.jl#L199-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.IntensityMap" href="#ComradeBase.IntensityMap"><code>ComradeBase.IntensityMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IntensityMap(data::AbstractArray, dims::NamedTuple)
IntensityMap(data::AbstractArray, grid::AbstractDims)</code></pre><p>Constructs an intensitymap using the image dimensions given by <code>dims</code>. This returns a <code>KeyedArray</code> with keys given by an <code>ImageDimensions</code> object.</p><pre><code class="language-julia hljs">dims = (X=range(-10.0, 10.0, length=100), Y = range(-10.0, 10.0, length=100),
        T = [0.1, 0.2, 0.5, 0.9, 1.0], F = [230e9, 345e9]
        )
imgk = IntensityMap(rand(100,100,5,1), dims)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/images/keyed_image.jl#L274-L287">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.amplitude-Tuple{Any, Any}" href="#ComradeBase.amplitude-Tuple{Any, Any}"><code>ComradeBase.amplitude</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">amplitude(model, p)</code></pre><p>Computes the visibility amplitude of model <code>m</code> at the coordinate <code>p</code>. The coordinate <code>p</code> is expected to have the properties <code>U</code>, <code>V</code>, and sometimes <code>Ti</code> and <code>Fr</code>.</p><p>If you want to compute the amplitudes at a large number of positions consider using the <code>amplitudes</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/visibilities.jl#L71-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.amplitudes" href="#ComradeBase.amplitudes"><code>ComradeBase.amplitudes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">amplitudes(m::AbstractModel, u::AbstractArray, v::AbstractArray)</code></pre><p>Computes the visibility amplitudes of the model <code>m</code> at the coordinates <code>p</code>. The coordinates <code>p</code> are expected to have the properties <code>U</code>, <code>V</code>, and sometimes <code>Ti</code> and <code>Fr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/visibilities.jl#L154-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.bispectrum" href="#ComradeBase.bispectrum"><code>ComradeBase.bispectrum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bispectrum(model, p1, p2, p3)</code></pre><p>Computes the complex bispectrum of model <code>m</code> at the uv-triangle p1 -&gt; p2 -&gt; p3</p><p>If you want to compute the bispectrum over a number of triangles consider using the <code>bispectra</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/visibilities.jl#L85-L93">source</a></section><section><div><pre><code class="nohighlight hljs">bispectrum(d1::T, d2::T, d3::T) where {T&lt;:EHTVisibilityDatum}</code></pre><p>Finds the bispectrum of three visibilities. We will assume these form closed triangles, i.e. the phase of the bispectrum is a closure phase.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/21c90571b68b236cff42ab5173f1391100ec6949/src/observations/observations.jl#L612-L617">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.bispectra" href="#ComradeBase.bispectra"><code>ComradeBase.bispectra</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bispectra(m, p1, p2, p3)</code></pre><p>Computes the closure phases of the model <code>m</code> at the triangles p1, p2, p3, where <code>pi</code> are coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/visibilities.jl#L185-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.closure_phase" href="#ComradeBase.closure_phase"><code>ComradeBase.closure_phase</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">closure_phase(model, p1, p2, p3, p4)</code></pre><p>Computes the closure phase of model <code>m</code> at the uv-triangle u1,v1 -&gt; u2,v2 -&gt; u3,v3</p><p>If you want to compute closure phases over a number of triangles consider using the <code>closure_phases</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/visibilities.jl#L98-L106">source</a></section><section><div><pre><code class="language-julia hljs">closure_phase(D1::EHTVisibilityDatum,
              D2::EHTVisibilityDatum,
              D3::EHTVisibilityDatum
              )</code></pre><p>Computes the closure phase of the three visibility datums.</p><p><strong>Notes</strong></p><p>We currently use the high SNR Gaussian error approximation for the closure phase. In the future we may use the moment matching from Monte Carlo sampling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/21c90571b68b236cff42ab5173f1391100ec6949/src/observations/observations.jl#L735-L746">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.closure_phases" href="#ComradeBase.closure_phases"><code>ComradeBase.closure_phases</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">closure_phases(m,
               p1::AbstractArray
               p2::AbstractArray
               p3::AbstractArray
               )</code></pre><p>Computes the closure phases of the model <code>m</code> at the triangles p1, p2, p3, where <code>pi</code> are coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/visibilities.jl#L228-L237">source</a></section><section><div><pre><code class="nohighlight hljs">closure_phases(m::AbstractModel, ac::ClosureConfig)</code></pre><p>Computes the closure phases of the model <code>m</code> using the array configuration <code>ac</code>.</p><p><strong>Notes</strong></p><p>This is faster than the <code>closure_phases(m, u1, v1, ...)</code> method since it only computes as many visibilities as required thanks to the closure design matrix formalism from Blackburn et al.<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/21c90571b68b236cff42ab5173f1391100ec6949/src/models/methods.jl#L10-L21">source</a></section><section><div><pre><code class="nohighlight hljs">closure_phases(vis::AbstractArray, ac::ArrayConfiguration)</code></pre><p>Compute the closure phases for a set of visibilities and an array configuration</p><p><strong>Notes</strong></p><p>This uses a closure design matrix for the computation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/21c90571b68b236cff42ab5173f1391100ec6949/src/distributions/radiolikelihood.jl#L236-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.logclosure_amplitude" href="#ComradeBase.logclosure_amplitude"><code>ComradeBase.logclosure_amplitude</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">logclosure_amplitude(model, p1, p2, p3, p4)</code></pre><p>Computes the log-closure amplitude of model <code>m</code> at the uv-quadrangle u1,v1 -&gt; u2,v2 -&gt; u3,v3 -&gt; u4,v4 using the formula</p><p class="math-container">\[C = \log\left|\frac{V(u1,v1)V(u2,v2)}{V(u3,v3)V(u4,v4)}\right|\]</p><p>If you want to compute log closure amplitudes over a number of triangles consider using the <code>logclosure_amplitudes</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/visibilities.jl#L111-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.logclosure_amplitudes" href="#ComradeBase.logclosure_amplitudes"><code>ComradeBase.logclosure_amplitudes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">logclosure_amplitudes(m::AbstractModel,
                      p1,
                      p2,
                      p3,
                      p4
                     )</code></pre><p>Computes the log closure amplitudes of the model <code>m</code> at the quadrangles p1, p2, p3, p4.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/visibilities.jl#L263-L273">source</a></section><section><div><pre><code class="nohighlight hljs">logclosure_amplitudes(m::AbstractModel, ac::ClosureConfig)</code></pre><p>Computes the log closure amplitudes of the model <code>m</code> using the array configuration <code>ac</code>.</p><p><strong>Notes</strong></p><p>This is faster than the <code>logclosure_amplitudes(m, u1, v1, ...)</code> method since it only computes as many visibilities as required thanks to the closure design matrix formalism from Blackburn et al.<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/21c90571b68b236cff42ab5173f1391100ec6949/src/models/methods.jl#L27-L38">source</a></section><section><div><pre><code class="nohighlight hljs">logclosure_amplitudes(vis::AbstractArray, ac::ArrayConfiguration)</code></pre><p>Compute the log-closure amplitudes for a set of visibilities and an array configuration</p><p><strong>Notes</strong></p><p>This uses a closure design matrix for the computation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/21c90571b68b236cff42ab5173f1391100ec6949/src/distributions/radiolikelihood.jl#L223-L230">source</a></section></article><h3 id="Model-Interface"><a class="docs-heading-anchor" href="#Model-Interface">Model Interface</a><a id="Model-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Interface" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.AbstractModel" href="#ComradeBase.AbstractModel"><code>ComradeBase.AbstractModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractModel</code></pre><p>The Comrade abstract model type. To instantiate your own model type you should subtybe from this model. Additionally you need to implement the following methods to satify the interface:</p><p><strong>Mandatory Methods</strong></p><ul><li><a href="#ComradeBase.isprimitive"><code>isprimitive</code></a>: defines whether a model is standalone or is defined in terms of other models.  is the model is primitive then this should return <code>IsPrimitive()</code> otherwise it returns  <code>NotPrimitive()</code></li><li><a href="#ComradeBase.visanalytic"><code>visanalytic</code></a>: defines whether the model visibilities can be computed analytically. If yes  then this should return <code>IsAnalytic()</code> and the user <em>must</em> to define <code>visibility_point</code>.  If not analytic then <code>visanalytic</code> should return <code>NotAnalytic()</code>.</li><li><a href="#ComradeBase.imanalytic"><code>imanalytic</code></a>: defines whether the model intensities can be computed pointwise. If yes   then this should return <code>IsAnalytic()</code> and the user <em>must</em> to define <code>intensity_point</code>.   If not analytic then <code>imanalytic</code> should return <code>NotAnalytic()</code>.</li><li><a href="#ComradeBase.radialextent"><code>radialextent</code></a>: Provides a estimate of the radial extent of the model in the image domain.  This is used for estimating the size of the image, and for plotting.</li><li><a href="#ComradeBase.flux"><code>flux</code></a>: Returns the total flux of the model.</li><li><a href="#ComradeBase.intensity_point"><code>intensity_point</code></a>: Defines how to compute model intensities pointwise. Note this is must be defined if <code>imanalytic(::Type{YourModel})==IsAnalytic()</code>.</li><li><a href="#ComradeBase.visibility_point"><code>visibility_point</code></a>: Defines how to compute model visibilties pointwise. Note this is   must be defined if <code>visanalytic(::Type{YourModel})==IsAnalytic()</code>.</li></ul><p><strong>Optional Methods:</strong></p><ul><li><a href="#ComradeBase.ispolarized"><code>ispolarized</code></a>: Specified whether a model is intrinsically polarized (returns <code>IsPolarized()</code>) or is not (returns <code>NotPolarized()</code>), by default a model is <code>NotPolarized()</code></li><li><a href="#ComradeBase.visibilities_analytic"><code>visibilities_analytic</code></a>: Vectorized version of <code>visibility_point</code> for models where <code>visanalytic</code> returns <code>IsAnalytic()</code></li><li><a href="#ComradeBase.visibilities_numeric"><code>visibilities_numeric</code></a>: Vectorized version of <code>visibility_point</code> for models where <code>visanalytic</code> returns <code>NotAnalytic()</code> typically these are numerical FT&#39;s</li><li><a href="#ComradeBase.intensitymap_analytic"><code>intensitymap_analytic</code></a>: Computes the entire image for models where <code>imanalytic</code> returns <code>IsAnalytic()</code></li><li><a href="#ComradeBase.intensitymap_numeric"><code>intensitymap_numeric</code></a>: Computes the entire image for models where <code>imanalytic</code> returns <code>NotAnalytic()</code></li><li><a href="#ComradeBase.intensitymap_analytic!"><code>intensitymap_analytic!</code></a>: Inplace version of <code>intensitymap</code></li><li><a href="#ComradeBase.intensitymap_numeric!"><code>intensitymap_numeric!</code></a>: Inplace version of <code>intensitymap</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/interface.jl#L2-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.isprimitive" href="#ComradeBase.isprimitive"><code>ComradeBase.isprimitive</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isprimitive(::Type)</code></pre><p>Dispatch function that specifies whether a type is a primitive Comrade model. This function is used for dispatch purposes when composing models.</p><p><strong>Notes</strong></p><p>If a user is specifying their own model primitive model outside of Comrade they need to specify if it is primitive</p><pre><code class="language-julia hljs">struct MyPrimitiveModel end
ComradeBase.isprimitive(::Type{MyModel}) = ComradeBase.IsPrimitive()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/interface.jl#L92-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.visanalytic" href="#ComradeBase.visanalytic"><code>ComradeBase.visanalytic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">visanalytic(::Type{&lt;:AbstractModel})</code></pre><p>Determines whether the model is pointwise analytic in Fourier domain, i.e. we can evaluate its fourier transform at an arbritrary point.</p><p>If <code>IsAnalytic()</code> then it will try to call <code>visibility_point</code> to calculate the complex visibilities. Otherwise it fallback to using the FFT that works for all models that can compute an image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/interface.jl#L146-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.imanalytic" href="#ComradeBase.imanalytic"><code>ComradeBase.imanalytic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">imanalytic(::Type{&lt;:AbstractModel})</code></pre><p>Determines whether the model is pointwise analytic in the image domain, i.e. we can evaluate its intensity at an arbritrary point.</p><p>If <code>IsAnalytic()</code> then it will try to call <code>intensity_point</code> to calculate the intensity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/interface.jl#L158-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.ispolarized" href="#ComradeBase.ispolarized"><code>ComradeBase.ispolarized</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ispolarized(::Type)</code></pre><p>Trait function that defines whether a model is polarized or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/interface.jl#L60-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.radialextent" href="#ComradeBase.radialextent"><code>ComradeBase.radialextent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">radialextent(model::AbstractModel)</code></pre><p>Provides an estimate of the radial size/extent of the <code>model</code>. This is used internally to estimate image size when plotting and using <code>modelimage</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/interface.jl#L255-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.PrimitiveTrait" href="#ComradeBase.PrimitiveTrait"><code>ComradeBase.PrimitiveTrait</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type PrimitiveTrait</code></pre><p>This trait specifies whether the model is a <em>primitive</em></p><p><strong>Notes</strong></p><p>This will likely turn into a trait in the future so people can inject their models into Comrade more easily.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/interface.jl#L70-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.IsPrimitive" href="#ComradeBase.IsPrimitive"><code>ComradeBase.IsPrimitive</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct IsPrimitive</code></pre><p>Trait for primitive model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/interface.jl#L81-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.NotPrimitive" href="#ComradeBase.NotPrimitive"><code>ComradeBase.NotPrimitive</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NotPrimitive</code></pre><p>Trait for not-primitive model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/interface.jl#L86-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.DensityAnalytic" href="#ComradeBase.DensityAnalytic"><code>ComradeBase.DensityAnalytic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DensityAnalytic</code></pre><p>Internal type for specifying the nature of the model functions. Whether they can be easily evaluated pointwise analytic. This is an internal type that may change.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/interface.jl#L117-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.IsAnalytic" href="#ComradeBase.IsAnalytic"><code>ComradeBase.IsAnalytic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct IsAnalytic &lt;: ComradeBase.DensityAnalytic</code></pre><p>Defines a trait that a states that a model is analytic. This is usually used with an abstract model where we use it to specify whether a model has a analytic fourier transform and/or image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/interface.jl#L126-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.NotAnalytic" href="#ComradeBase.NotAnalytic"><code>ComradeBase.NotAnalytic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NotAnalytic &lt;: ComradeBase.DensityAnalytic</code></pre><p>Defines a trait that a states that a model is analytic. This is usually used with an abstract model where we use it to specify whether a model has does not have a easy analytic fourier transform and/or intensity function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/interface.jl#L136-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.visibility_point" href="#ComradeBase.visibility_point"><code>ComradeBase.visibility_point</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">visibility_point(model::AbstractModel, p)</code></pre><p>Function that computes the pointwise visibility. This must be implemented in the model interface if <code>visanalytic(::Type{MyModel}) == IsAnalytic()</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/interface.jl#L181-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.visibilities_analytic" href="#ComradeBase.visibilities_analytic"><code>ComradeBase.visibilities_analytic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">visibilties_analytic(model, u, v, time, freq)</code></pre><p>Computes the visibilties of a <code>model</code> using using the analytic visibility expression given by <code>visibility_point</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/interface.jl#L307-L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.visibilities_analytic!" href="#ComradeBase.visibilities_analytic!"><code>ComradeBase.visibilities_analytic!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">visibilties_analytic!(vis, model, u, v, time, freq)</code></pre><p>Computes the visibilties of a <code>model</code> in-place, using using the analytic visibility expression given by <code>visibility_point</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/interface.jl#L323-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.visibilities_numeric" href="#ComradeBase.visibilities_numeric"><code>ComradeBase.visibilities_numeric</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">visibilties_numeric(model, u, v, time, freq)</code></pre><p>Computes the visibilties of a <code>model</code> using a numerical fourier transform. Note that none of these are implemented in <code>ComradeBase</code>. For implementations please see <code>Comrade</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/interface.jl#L299-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.visibilities_numeric!" href="#ComradeBase.visibilities_numeric!"><code>ComradeBase.visibilities_numeric!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">visibilties_numeric!(vis, model, u, v, time, freq)</code></pre><p>Computes the visibilties of a <code>model</code> in-place using a numerical fourier transform. Note that none of these are implemented in <code>ComradeBase</code>. For implementations please see <code>Comrade</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/interface.jl#L315-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.intensity_point" href="#ComradeBase.intensity_point"><code>ComradeBase.intensity_point</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">intensity_point(model::AbstractModel, p)</code></pre><p>Function that computes the pointwise intensity if the model has the trait in the image domain <code>IsAnalytic()</code>. Otherwise it will use construct the image in visibility space and invert it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/interface.jl#L189-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.intensitymap_analytic" href="#ComradeBase.intensitymap_analytic"><code>ComradeBase.intensitymap_analytic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">intensitymap_analytic(m::AbstractModel, p::AbstractDims)</code></pre><p>Computes the <code>IntensityMap</code> of a model <code>m</code> using the image dimensions <code>p</code> by broadcasting over the analytic <a href="#ComradeBase.intensity_point"><code>intensity_point</code></a> method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/interface.jl#L223-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.intensitymap_analytic!" href="#ComradeBase.intensitymap_analytic!"><code>ComradeBase.intensitymap_analytic!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">intensitymap_analytic!(img::IntensityMap, m::AbstractModel)
intensitymap_analytic!(img::StokesIntensityMap, m::AbstractModel)</code></pre><p>Updates the <code>img</code> using the model <code>m</code>  by broadcasting over the analytic <a href="#ComradeBase.intensity_point"><code>intensity_point</code></a> method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/interface.jl#L241-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.intensitymap_numeric" href="#ComradeBase.intensitymap_numeric"><code>ComradeBase.intensitymap_numeric</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">intensitymap_numeric(m::AbstractModel, p::AbstractDims)</code></pre><p>Computes the <code>IntensityMap</code> of a model <code>m</code> at the image positions <code>p</code> using a numerical method. This has to be specified uniquely for every model <code>m</code> if <code>imanalytic(typeof(m)) === NotAnalytic()</code>. See <code>Comrade.jl</code> for example implementations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/interface.jl#L214-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.intensitymap_numeric!" href="#ComradeBase.intensitymap_numeric!"><code>ComradeBase.intensitymap_numeric!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">intensitymap_numeric!(img::IntensityMap, m::AbstractModel)
intensitymap_numeric!(img::StokesIntensityMap, m::AbstractModel)</code></pre><p>Updates the <code>img</code> using the model <code>m</code>  using a numerical method. This has to be specified uniquely for every model <code>m</code> if <code>imanalytic(typeof(m)) === NotAnalytic()</code>. See <code>Comrade.jl</code> for example implementations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/interface.jl#L231-L238">source</a></section></article><h3 id="Image-Types"><a class="docs-heading-anchor" href="#Image-Types">Image Types</a><a id="Image-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Image-Types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.IntensityMap-Tuple{AbstractArray, ComradeBase.AbstractDims}" href="#ComradeBase.IntensityMap-Tuple{AbstractArray, ComradeBase.AbstractDims}"><code>ComradeBase.IntensityMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">IntensityMap(data::AbstractArray, dims::NamedTuple)
IntensityMap(data::AbstractArray, grid::AbstractDims)</code></pre><p>Constructs an intensitymap using the image dimensions given by <code>dims</code>. This returns a <code>KeyedArray</code> with keys given by an <code>ImageDimensions</code> object.</p><pre><code class="language-julia hljs">dims = (X=range(-10.0, 10.0, length=100), Y = range(-10.0, 10.0, length=100),
        T = [0.1, 0.2, 0.5, 0.9, 1.0], F = [230e9, 345e9]
        )
imgk = IntensityMap(rand(100,100,5,1), dims)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/images/keyed_image.jl#L274-L287">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.StokesIntensityMap" href="#ComradeBase.StokesIntensityMap"><code>ComradeBase.StokesIntensityMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct StokesIntensityMap{T, N, SI, SQ, SU, SV}</code></pre><p>General struct that holds intensity maps for each stokes parameter. Each image <code>I, Q, U, V</code> must share the same axis dimensions. This type also obeys much of the usual array interface in Julia. The following methods have been implemented:</p><ul><li>size</li><li>eltype (returns StokesParams)</li><li>ndims</li><li>getindex</li><li>setindex!</li><li>pixelsizes</li><li>fieldofview</li><li>imagepixels</li><li>imagegrid</li><li>stokes</li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This may eventually be phased out for <code>IntensityMaps</code> whose base types are <code>StokesParams</code>, but currently we use this for speed reasons with Zygote.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/images/stokes_image.jl#L4-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.imagepixels" href="#ComradeBase.imagepixels"><code>ComradeBase.imagepixels</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">imagepixels(img::IntensityMap)
imagepixels(img::IntensityMapTypes)</code></pre><p>Returns a abstract spatial dimension with the image pixels locations <code>X</code> and <code>Y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/images/methods.jl#L25-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.GriddedKeys" href="#ComradeBase.GriddedKeys"><code>ComradeBase.GriddedKeys</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GriddedKeys{N, G, Hd, T} &lt;: ComradeBase.AbstractDims{N, T}</code></pre><p>This struct holds the dimensions that the EHT expect. The first type parameter <code>N</code> defines the names of each dimension. These names are usually one of     - (:X, :Y, :T, :F)     - (:X, :Y, :F, :T)     - (:X, :Y) # spatial only where <code>:X,:Y</code> are the RA and DEC spatial dimensions respectively, <code>:T</code> is the the time direction and <code>:F</code> is the frequency direction.</p><p><strong>Fieldnames</strong></p><ul><li><p><code>dims</code></p></li><li><p><code>header</code></p></li></ul><p><strong>Notes</strong></p><p>Warning it is rare you need to access this constructor directly. Instead use the direct <a href="#ComradeBase.IntensityMap"><code>IntensityMap</code></a> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/images/keyed_image.jl#L50-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.dims" href="#ComradeBase.dims"><code>ComradeBase.dims</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dims(g::AbstractDims)</code></pre><p>Returns a tuple containing the dimensions of <code>g</code>. For a named version see <a href="#ComradeBase.named_dims"><code>ComradeBase.named_dims</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/images/keyed_image.jl#L72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.named_dims" href="#ComradeBase.named_dims"><code>ComradeBase.named_dims</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">named_dims(g::AbstractDims)</code></pre><p>Returns a named tuple containing the dimensions of <code>g</code>. For a unnamed version see <a href="#ComradeBase.dims"><code>dims</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/images/keyed_image.jl#L79-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.axisdims" href="#ComradeBase.axisdims"><code>ComradeBase.axisdims</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">axisdims(img::IntensityMap)</code></pre><p>Returns the keys of the <code>IntensityMap</code> as the actual internal <code>AbstractDims</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/images/keyed_image.jl#L214-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.stokes" href="#ComradeBase.stokes"><code>ComradeBase.stokes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stokes(m::AbstractPolarizedModel, p::Symbol)</code></pre><p>Extract the specific stokes component <code>p</code> from the polarized model <code>m</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/interface.jl#L49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.imagegrid" href="#ComradeBase.imagegrid"><code>ComradeBase.imagegrid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">imagegrid(k::IntensityMap)</code></pre><p>Returns the grid the <code>IntensityMap</code> is defined as. Note that this is unallocating since it lazily computes the grid. The grid is an example of a KeyedArray and works similarly. This is useful for broadcasting a model across an abritrary grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/images/methods.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.fieldofview" href="#ComradeBase.fieldofview"><code>ComradeBase.fieldofview</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fieldofview(img::IntensityMap)
fieldofview(img::IntensityMapTypes)</code></pre><p>Returns a named tuple with the field of view of the image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/images/methods.jl#L49-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.pixelsizes" href="#ComradeBase.pixelsizes"><code>ComradeBase.pixelsizes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pixelsizes(img::IntensityMap)
pixelsizes(img::IntensityMapTypes)</code></pre><p>Returns a named tuple with the spatial pixel sizes of the image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/images/methods.jl#L67-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.phasecenter" href="#ComradeBase.phasecenter"><code>ComradeBase.phasecenter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">phasecenter(img::IntensityMap)
phasecenter(img::StokesIntensitymap)</code></pre><p>Computes the phase center of an intensity map. Note this is the pixels that is in the middle of the image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/images/methods.jl#L12-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.centroid" href="#ComradeBase.centroid"><code>ComradeBase.centroid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">centroid(im::AbstractIntensityMap)</code></pre><p>Computes the image centroid aka the center of light of the image.</p><p>For polarized maps we return the centroid for Stokes I only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/images/methods.jl#L104-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.second_moment" href="#ComradeBase.second_moment"><code>ComradeBase.second_moment</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">second_moment(im::AbstractIntensityMap; center=true)</code></pre><p>Computes the image second moment tensor of the image. By default we really return the second <strong>cumulant</strong> or centered second moment, which is specified by the <code>center</code> argument.</p><p>For polarized maps we return the second moment for Stokes I only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/images/methods.jl#L128-L136">source</a></section><section><div><pre><code class="nohighlight hljs">second_moment(im::AbstractIntensityMap; center=true)</code></pre><p>Computes the image second moment tensor of the image. By default we really return the second <strong>cumulant</strong> or centered second moment, which is specified by the <code>center</code> argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/images/methods.jl#L146-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.header" href="#ComradeBase.header"><code>ComradeBase.header</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">header(g::AbstractDims)</code></pre><p>Returns the headerinformation of the dimensions <code>g</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/images/keyed_image.jl#L86-L90">source</a></section><section><div><pre><code class="nohighlight hljs">header(img::IntensityMap)</code></pre><p>Retrieves the header of an IntensityMap</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/images/keyed_image.jl#L223-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.NoHeader" href="#ComradeBase.NoHeader"><code>ComradeBase.NoHeader</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoHeader</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/images/keyed_image.jl#L42-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.MinimalHeader" href="#ComradeBase.MinimalHeader"><code>ComradeBase.MinimalHeader</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MinimalHeader{T}</code></pre><p>A minimal header type for ancillary image information.</p><p><strong>Fields</strong></p><ul><li><code>source</code>: Common source name</li></ul><ul><li><code>ra</code>: Right ascension of the image in degrees (J2000)</li></ul><ul><li><code>dec</code>: Declination of the image in degrees (J2000)</li></ul><ul><li><code>mjd</code>: Modified Julian Date in days</li></ul><ul><li><code>frequency</code>: Frequency of the image in Hz</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/images/keyed_image.jl#L11-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.load" href="#ComradeBase.load"><code>ComradeBase.load</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ComradeBase.load(fitsfile::String, IntensityMap)</code></pre><p>This loads in a fits file that is more robust to the various imaging algorithms in the EHT, i.e. is works with clean, smili, eht-imaging. The function returns an tuple with an intensitymap and a second named tuple with ancillary information about the image, like the source name, location, mjd, and radio frequency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/images/io.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.save" href="#ComradeBase.save"><code>ComradeBase.save</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ComradeBase.save(file::String, img::IntensityMap, obs)</code></pre><p>Saves an image to a fits file. You can optionally pass an EHTObservation so that ancillary information will be added.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/images/io.jl#L110-L115">source</a></section></article><h2 id="Polarization"><a class="docs-heading-anchor" href="#Polarization">Polarization</a><a id="Polarization-1"></a><a class="docs-heading-anchor-permalink" href="#Polarization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ComradeBase.AbstractPolarizedModel" href="#ComradeBase.AbstractPolarizedModel"><code>ComradeBase.AbstractPolarizedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractPolarizedModel &lt;: ComradeBase.AbstractModel</code></pre><p>Type the classifies a model as being intrinsically polarized. This means that any call to visibility must return a <code>StokesParams</code> to denote the full stokes polarization of the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/Comrade.jl/blob/ece28d0fe93eeeb1f20f08bbd7970a9506f05606/src/interface.jl#L39-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.StokesParams" href="#PolarizedTypes.StokesParams"><code>PolarizedTypes.StokesParams</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct StokesParams{T} &lt;: StaticArraysCore.FieldVector{4, T}</code></pre><p>Static vector that holds the stokes parameters of a polarized complex visibility</p><p>To convert between a <code>StokesParams</code> and <code>CoherencyMatrix</code> use the <code>convert</code> function</p><pre><code class="language-julia hljs">convert(::CoherencyMatrix, StokesVector(1.0, 0.1, 0.1, 0.4))</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.ElectricFieldBasis" href="#PolarizedTypes.ElectricFieldBasis"><code>PolarizedTypes.ElectricFieldBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type ElectricFieldBasis</code></pre><p>An abstract type whose subtypes denote a specific electric field basis.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.RPol" href="#PolarizedTypes.RPol"><code>PolarizedTypes.RPol</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RPol &lt;: PolarizedTypes.ElectricFieldBasis</code></pre><p>The right circular electric field basis, i.e. a right-handed circular feed.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.LPol" href="#PolarizedTypes.LPol"><code>PolarizedTypes.LPol</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LPol &lt;: PolarizedTypes.ElectricFieldBasis</code></pre><p>The left circular electric field basis, i.e. a left-handed circular feed.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.XPol" href="#PolarizedTypes.XPol"><code>PolarizedTypes.XPol</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct XPol &lt;: PolarizedTypes.ElectricFieldBasis</code></pre><p>The horizontal or X electric feed basis, i.e. the horizontal linear feed.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.YPol" href="#PolarizedTypes.YPol"><code>PolarizedTypes.YPol</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct YPol &lt;: PolarizedTypes.ElectricFieldBasis</code></pre><p>The vertical or Y electric feed basis, i.e. the vertical linear feed.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.PolBasis" href="#PolarizedTypes.PolBasis"><code>PolarizedTypes.PolBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct PolBasis{B1&lt;:Union{Missing, PolarizedTypes.ElectricFieldBasis}, B2&lt;:Union{Missing, PolarizedTypes.ElectricFieldBasis}}</code></pre><p>Denotes a general polarization basis, with basis vectors (B1,B2) which are typically <code>&lt;: Union{ElectricFieldBasis, Missing}</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.CirBasis" href="#PolarizedTypes.CirBasis"><code>PolarizedTypes.CirBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CirBasis &lt;: PolBasis</code></pre><p>Measurement uses the circular polarization basis, which is typically used for circular feed interferometers.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.LinBasis" href="#PolarizedTypes.LinBasis"><code>PolarizedTypes.LinBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinBasis &lt;: PolBasis</code></pre><p>Measurement uses the linear polarization basis, which is typically used for linear feed interferometers.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.CoherencyMatrix" href="#PolarizedTypes.CoherencyMatrix"><code>PolarizedTypes.CoherencyMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CoherencyMatrix{B1, B2, T} &lt;: StaticArraysCore.FieldMatrix{2, 2, T}</code></pre><p>Coherency matrix for a single baseline with bases <code>B1</code> and <code>B2</code>. The two bases correspond to the type of feeds used for each telescope and should be subtypes of <code>PolBasis</code>. To see which bases are implemented type <code>subtypes(Rimes.PolBasis)</code> in the REPL.</p><p>For a circular basis the layout of the coherency matrix is</p><pre><code class="nohighlight hljs">RR* RL*
LR* RR*</code></pre><p>which can be constructed using</p><pre><code class="language-julia-repl hljs">c = CoherencyMatrix(RR, LR, RL, LL, CirBasis())</code></pre><p>For a linear basis the layout of the coherency matrix is</p><pre><code class="nohighlight hljs">XX* XY*
YX* YY*</code></pre><p>which can be constructed using</p><pre><code class="language-julia-repl hljs">c = CoherencyMatrix(XX, YX, XY, YY, CirBasis())</code></pre><p>For a mixed (e.g., circular and linear basis) the layout of the coherency matrix is</p><pre><code class="nohighlight hljs">RX* RY*
LX* LY*</code></pre><p>or e.g., linear and circular the layout of the coherency matrix is</p><pre><code class="nohighlight hljs">XR* XL*
YR* YL*</code></pre><p>These coherency matrices can be constructed using:</p><pre><code class="language-julia-repl hljs"># Circular and linear feeds i.e., |R&gt;&lt;X|
c = CoherencyMatrix(RX, LX, RY, LY, LinBasis(), CirBasis())
# Linear and circular feeds i.e., |X&gt;&lt;R|
c = CoherencyMatrix(XR, YR, XL, YL, LinBasis(), CirBasis())</code></pre></div></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>PolarizedTypes.evpa</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>PolarizedTypes.m̆</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>PolarizedTypes.linearpol</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.innerprod" href="#PolarizedTypes.innerprod"><code>PolarizedTypes.innerprod</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">innerprod(::Type{T}, XPol(), YPol())</code></pre><p>Computes the complex inner product of two elements of a complex Hilbert space <code>X</code> and <code>Y</code> where base element of the output is T.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.basis_components" href="#PolarizedTypes.basis_components"><code>PolarizedTypes.basis_components</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basis_components([T=Float64,], e::ElectricFieldBasis, b::PolBasis)</code></pre><p>Returns a static vector that contains the components of the electric field basis vector <code>e</code> in terms of the polarization basis <code>b</code>. The first argument is optionally the eltype of the static vector.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; basis_components(Float64, R(), PolBasis{XPol,Y}())
2-element StaticArraysCore.SVector{2, ComplexF64} with indices SOneTo(2):
 0.7071067811865475 + 0.0im
                0.0 - 0.7071067811865475im

julia&gt; basis_components(R(), PolBasis{XPol,Y}())
2-element StaticArraysCore.SVector{2, ComplexF64} with indices SOneTo(2):
 0.7071067811865475 + 0.0im
                0.0 - 0.7071067811865475im


julia&gt; basis_components(Float64, X(), PolBasis{XPol,Y}())
2-element StaticArraysCore.SVector{2, ComplexF64} with indices SOneTo(2):
 1.0 + 0.0im
 0.0 + 0.0im</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PolarizedTypes.basis_transform" href="#PolarizedTypes.basis_transform"><code>PolarizedTypes.basis_transform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basis_transform([T=Float64,], b1::PolBasis, b2::PolBasis)
basis_transform([T=Float64,], b1::PolBasis=&gt;b2::PolBasis)</code></pre><p>Produces the transformation matrix that transforms the vector components from basis <code>b1</code> to basis <code>b2</code>. This means that if for example <code>E</code> is the circular basis then <code>basis_transform(CirBasis=&gt;LinBasis)E</code> is in the linear basis. In other words the <strong>columns</strong> of the transformation matrix are the coordinate vectors of the new basis vectors in the old basis.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; basis_transform(CirBasis()=&gt;LinBasis())
2×2 StaticArraysCore.SMatrix{2, 2, ComplexF64, 4} with indices SOneTo(2)×SOneTo(2):
 0.707107-0.0im       0.707107-0.0im
      0.0-0.707107im       0.0+0.707107im</code></pre></div></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Blackburn L., et al &quot;Closure Statistics in Interferometric Data&quot; ApJ 2020</li><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Blackburn L., et al &quot;Closure Statistics in Interferometric Data&quot; ApJ 2020</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../libs/adaptmcmc/">« ComradeAdaptMCMC</a><a class="docs-footer-nextpage" href="../api/">Comrade API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Saturday 19 August 2023 19:11">Saturday 19 August 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
