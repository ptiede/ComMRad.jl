<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Polarized Image and Instrumental Modeling · Comrade.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Comrade.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../benchmarks/">Benchmarks</a></li><li><a class="tocitem" href="../../vlbi_imaging_problem/">Introduction to the VLBI Imaging Problem</a></li><li><a class="tocitem" href="../../conventions/">Conventions</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../data/">Loading Data into Comrade</a></li><li><a class="tocitem" href="../geometric_modeling/">Geometric Modeling of EHT Data</a></li><li><a class="tocitem" href="../imaging_closures/">Imaging a Black Hole using only Closure Quantities</a></li></ul></li><li><span class="tocitem">Libraries</span><ul><li><a class="tocitem" href="../../libs/optimization/">ComradeOptimization</a></li><li><a class="tocitem" href="../../libs/ahmc/">ComradeAHMC</a></li><li><a class="tocitem" href="../../libs/nested/">ComradeNested</a></li><li><a class="tocitem" href="../../libs/dynesty/">ComradeDynesty</a></li><li><a class="tocitem" href="../../libs/adaptmcmc/">ComradeAdaptMCMC</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Polarized Image and Instrumental Modeling</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Polarized Image and Instrumental Modeling</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ptiede/Comrade.jl/blob/main/examples/imaging_pol.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Polarized-Image-and-Instrumental-Modeling"><a class="docs-heading-anchor" href="#Polarized-Image-and-Instrumental-Modeling">Polarized Image and Instrumental Modeling</a><a id="Polarized-Image-and-Instrumental-Modeling-1"></a><a class="docs-heading-anchor-permalink" href="#Polarized-Image-and-Instrumental-Modeling" title="Permalink"></a></h1><p>In this tutorial, we will analyze a simulated simple polarized dataset to demonstrate Comrade&#39;s polarized imaging capabilities.</p><h2 id="Introduction-to-Polarized-Imaging"><a class="docs-heading-anchor" href="#Introduction-to-Polarized-Imaging">Introduction to Polarized Imaging</a><a id="Introduction-to-Polarized-Imaging-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction-to-Polarized-Imaging" title="Permalink"></a></h2><p>The EHT is a polarized interferometer. However, like all VLBI interferometers, it does not directly measure the Stokes parameters (I, Q, U, V). Instead, it measures components related to the electric field at the telescope along two <em>directions</em> using feeds. There are two types of feeds at telescopes: circular, which measure <span>$R/L$</span> components of the electric field, and linear feeds, which measure <span>$X/Y$</span> components of the electric field. Most sites in the EHT use circular feeds, meaning they measure the right (R) and left electric field (L) at each telescope. These circular electric field measurements are then correlated, producing <strong>coherency matrices</strong>,</p><p class="math-container">\[ C_{ij} = \begin{pmatrix}
       RR^* &amp;  RL^*\\
       LR^* &amp;  LL^*
     \end{pmatrix}.\]</p><p>These coherency matrices are the fundamental object in interferometry and what the telescope observes. For a perfect interferometer, these coherency matrices are related to the usual Fourier transform of the stokes parameters by</p><p class="math-container">\[  \begin{pmatrix}
      \tilde{I}\\ \tilde{Q} \\ \tilde{U} \\ \tilde{V}
  \end{pmatrix}
  =\frac{1}{2}
  \begin{pmatrix}
     RR^* + LL^* \\
     RL^* + LR^* \\
     i(LR^* - RL^*)\\
     RR^* - LL^*
  \end{pmatrix},\]</p><p>for circularly polarized measurements.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In this tutorial, we stick to circular feeds but Comrade has the capabilities to model linear (XX,XY, ...) and mixed basis coherencies (e.g., RX, RY, ...).</p></div></div><p>In reality, the measure coherencies are corrupted by both the atmosphere and the telescope itself. In <code>Comrade</code> we use the RIME formalism <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> to represent these corruptions, namely our measured coherency matrices <span>$V_{ij}$</span> are given by</p><p class="math-container">\[   V_{ij} = J_iC_{ij}J_j^\dagger\]</p><p>where <span>$J$</span> is known as a <em>Jones matrix</em> and <span>$ij$</span> denotes the baseline <span>$ij$</span> with sites <span>$i$</span> and <span>$j$</span>.</p><p><code>Comrade</code> is highly flexible with how the Jones matrices are formed and provides several convenience functions that parameterize standard Jones matrices. These matrices include:</p><ul><li><a href="../../api/#Comrade.jonesG"><code>jonesG</code></a> which builds the set of complex gain Jones matrices</li></ul><p class="math-container">\[  G = \begin{pmatrix}
          g_a   &amp;0\\
          0     &amp;g_b\\
      \end{pmatrix}\]</p><ul><li><a href="../../api/#Comrade.jonesD"><code>jonesD</code></a> which builds the set of complex d-terms Jones matrices</li></ul><p class="math-container">\[  D = \begin{pmatrix}
          1   &amp; d_a\\
          d_b     &amp;1\\
      \end{pmatrix}\]</p><ul><li><a href="../../api/#Comrade.jonesT"><code>jonesT</code></a> is the basis transform matrix <span>$T$</span>. This transformation is special and  combines two things using the decomposition <span>$T=FB$</span>. The first, <span>$B$</span>, is the transformation from  some reference basis to the observed coherency basis (this allows for mixed basis measurements).  The second is the feed rotation, <span>$F$</span>, that transforms from some reference axis to the axis of the  telescope as the source moves in the sky. The feed rotation matrix <code>F</code> in terms of  the per station feed rotation angle <span>$\varphi$</span> is</li></ul><p class="math-container">\[  F = \begin{pmatrix}
          e^{-i\varphi}   &amp; 0\\
          0     &amp; e^{i\varphi}\\
      \end{pmatrix}\]</p><p>In the rest of the tutorial, we are going to solve for all of these instrument model terms on  in addition to our image structure to reconstruct a polarized image of a synthetic dataset.</p><pre><code class="language-julia hljs">using Comrade</code></pre><h2 id="Load-the-Data"><a class="docs-heading-anchor" href="#Load-the-Data">Load the Data</a><a id="Load-the-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Load-the-Data" title="Permalink"></a></h2><pre class="documenter-example-output"><code class="nohighlight hljs ansi">  Activating project at `~/work/Comrade.jl/Comrade.jl/examples`</code></pre><p>For reproducibility we use a stable random number genreator</p><pre><code class="language-julia hljs">using StableRNGs
rng = StableRNG(123)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">StableRNGs.LehmerRNG(state=0x000000000000000000000000000000f7)</code></pre><p>Now we will load some synthetic polarized data.</p><pre><code class="language-julia hljs">obs = load_ehtim_uvfits(joinpath(dirname(pathof(Comrade)), &quot;..&quot;, &quot;examples&quot;, &quot;PolarizedExamples/polarized_gaussian_nogains_withdterms_withfr.uvfits&quot;),
                        joinpath(dirname(pathof(Comrade)), &quot;..&quot;, &quot;examples&quot;, &quot;PolarizedExamples/array.txt&quot;))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Python Obsdata: &lt;ehtim.obsdata.Obsdata object at 0x7f719efdf940&gt;</code></pre><p>Notice that, unlike other non-polarized tutorials, we need to include a second argument. This is the <strong>array file</strong> of the observation and is required to determine the feed rotation of the array.</p><p>Now we scan average the data since the data to boost the SNR and reduce the total data volume.</p><pre><code class="language-julia hljs">obs = scan_average(obs)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Python Obsdata: &lt;ehtim.obsdata.Obsdata object at 0x7f719df968c0&gt;</code></pre><p>Now we extract our observed/corrupted coherency matrices.</p><pre><code class="language-julia hljs">dvis = extract_coherency(obs)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EHTObservation{Float64,Comrade.EHTCoherencyDatum{Float64, CirBasis, CirBasis, StaticArraysCore.SMatrix{2, 2, ComplexF64, 4}, StaticArraysCore.SMatrix{2, 2, Float64, 4}}, ...}
  source: 17.761122472222223:-28.992189444444445
  mjd: 51544
  frequency: 2.3e11
  bandwidth: 1.0e9
  stations: [:AA, :AP, :AZ, :JC, :LM, :PV, :SM]
  nsamples: 315
</code></pre><p>##Building the Model/Posterior</p><p>To build the model, we first break it down into two parts:</p><ol><li><strong>The image model</strong>. In Comrade, all polarized image models are written in terms of the Stokes parameters. The reason for using Stokes parameters is that it is usually what physical models consider and is the often easiest to reason about since they are additive. In this tutorial, we will use a polarized image model based on Pesce (2021)<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>. This model parameterizes the polarized image in terms of the <a href="https://en.wikipedia.org/wiki/Unpolarized_light#Poincar%C3%A9_sphere"><code>Poincare sphere</code></a>, and allows us to easily incorporate physical restrictions such as <span>$I^2 ≥ Q^2 + U^2 + V^2$</span>.</li><li><strong>The instrument model</strong>. The instrument model specifies the model that describes the impact of instrumental and atmospheric effects. We will be using the <span>$J = GDT$</span> decomposition we described above. However, to parameterize the R/L complex gains, we will be using a gain product and ratio decomposition. The reason for this decomposition is that in realistic measurements, the gain ratios and products have different temporal characteristics. Namely, many of the EHT observations tend to demonstrate constant R/L gain ratios across an nights observations, compared to the gain products, which vary every scan. Additionally, the gain ratios tend to be smaller (i.e., closer to unity) than the gain products. Using this apriori knowledge, we can build this into our model and reduce the total number of parameters we need to model.</li></ol><pre><code class="language-julia hljs">function model(θ, metadata)
    (;c, f, p, angparams, dRx, dRy, dLx, dLy, lgp, gpp, lgr, gpr) = θ
    (; grid, cache, tcache, scancache, trackcache, phasecache) = metadata
    # Construct the image model
    # produce Stokes images from parameters
    imgI = f*c
    # Converts from poincare sphere parameterization of polzarization to Stokes Parameters
    pimg = PoincareSphere2Map(imgI, p, angparams, grid)
    m = ContinuousImage(pimg, cache)

    # Now construct the basis transformation cache
    jT = jonesT(tcache)

    # Gain product parameters
    gPa = exp.(lgp/2 .+ 0im)
    gPp = exp.(1im.*gpp/2)
    Gpa = jonesG(gPa, gPa, scancache)
    Gpp = jonesG(gPp, gPp, phasecache)
    # Gain ratio
    gR = exp.(lgr/2 .+ 1im.*gpr/2)
    Gr = jonesG(gR, inv.(gR), trackcache)
    ##D-terms
    D = jonesD(complex.(dRx, dRy), complex.(dLx, dLy), trackcache)
    # sandwich all the jones matrices together
    J = Gpa*Gpp*Gr*D*jT
    # form the complete Jones or RIME model. We use tcache here
    # to set the reference basis of the model.
    return JonesModel(J, m, tcache)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">model (generic function with 1 method)</code></pre><p>Now, we define the model metadata required to build the model. We specify our image grid and cache model needed to define the polarimetric image model.</p><pre><code class="language-julia hljs">fovx = μas2rad(50.0)
fovy = μas2rad(50.0)
nx = 5
ny = floor(Int, fovy/fovx*nx)
grid = imagepixels(fovx, fovy, nx, ny) # image grid
buffer = IntensityMap(zeros(nx, ny), grid) # buffer to store temporary image
pulse = BSplinePulse{3}() # pulse we will be using
cache = create_cache(NFFTAlg(dvis), buffer, pulse) # cache to define the NFFT transform</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Comrade.NUFTCache{Comrade.ObservedNUFT{NFFTAlg{Float64, AbstractNFFTs.PrecomputeFlags, UInt32}, Matrix{Float64}}, NFFT.NFFTPlan{Float64, 2, 1}, Vector{ComplexF64}, BSplinePulse{3}, AxisKeys.KeyedArray{Float64, 2, NamedDims.NamedDimsArray{(:X, :Y), Float64, 2, Matrix{Float64}}, GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, Nothing, Float64}}}(Comrade.ObservedNUFT{NFFTAlg{Float64, AbstractNFFTs.PrecomputeFlags, UInt32}, Matrix{Float64}}(NFFTAlg{Float64, AbstractNFFTs.PrecomputeFlags, UInt32}(1, 4, 2.0, :kaiser_bessel, AbstractNFFTs.TENSOR, true, false, true, 0x00000000), [59827.55078125 60351.01953125 … 57731.1796875 59075.01171875; -91918.53125 -94468.7265625 … -87413.2578125 -89891.890625]), NFFTPlan with 315 sampling points for an input array of size(5, 5) and an output array of size(315,) with dims 1:2, ComplexF64[0.9999999998020331 - 4.887735833479455e-6im, 0.9999999997921527 - 5.19642394141582e-6im, 0.9999999997823958 - 5.5773420751775874e-6im, 0.9999999997727597 - 6.027576735731718e-6im, 0.9999999997632122 - 6.5436807486049795e-6im, 0.9999999997537009 - 7.121707771326001e-6im, 0.999999953413493 - 9.554058415347402e-5im, 0.11487523368044451 - 0.4903009530935098im, 0.1149455498763295 - 0.4903903182256715im, 0.9999999510581715 - 9.694678355603363e-5im  …  0.9650387541615585 - 0.03031697513720594im, 0.7236825150581802 + 0.29468465832942775im, 0.7236779064194327 + 0.29467875197068955im, 0.8074548475519499 - 0.358747961757572im, 0.9999999998586939 - 4.60780075438823e-6im, 0.9999999998495279 - 4.4690475196511684e-6im, 0.9999999998399299 - 4.4080913130850975e-6im, 0.9999999998300636 - 4.425399770024229e-6im, 0.9999999998200652 - 4.5208390253898465e-6im, 0.9999999998100452 - 4.693679068293542e-6im], BSplinePulse{3}(), [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0])</code></pre><p>To define the instrument models, <span>$T$</span>, <span>$G$</span>, <span>$D$</span>, we need to build some Jones caches (see <a href="../../api/#Comrade.JonesCache"><code>JonesCache</code></a>) that map from a flat vector of gain/dterms to the specific sites for each baseline.</p><p>First, we will define our deterministic transform cache. Note that this dataset has need been pre-corrected for feed rotation, so we need to add those into the <code>tcache</code>.</p><pre><code class="language-julia hljs">tcache = TransformCache(dvis; add_fr=true, ehtim_fr_convention=false)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">TransformCache{StructArrays.StructVector{StaticArraysCore.SMatrix{2, 2, ComplexF64, 4}, NTuple{4, Vector{ComplexF64}}, Int64}, CirBasis}(StaticArraysCore.SMatrix{2, 2, ComplexF64, 4}[[0.7478621428837151 - 0.6638540617043611im 0.0 + 0.0im; 0.0 + 0.0im 0.7478621428837151 + 0.6638540617043611im], [0.6986903594406451 - 0.7154241969801568im 0.0 + 0.0im; 0.0 + 0.0im 0.6986903594406451 + 0.7154241969801568im], [0.6501178594775278 - 0.7598333822545292im 0.0 + 0.0im; 0.0 + 0.0im 0.6501178594775278 + 0.7598333822545292im], [0.6026809337927997 - 0.7979822629874921im 0.0 + 0.0im; 0.0 + 0.0im 0.6026809337927997 + 0.7979822629874921im], [0.5566871604612363 - 0.8307222191428406im 0.0 + 0.0im; 0.0 + 0.0im 0.5566871604612363 + 0.8307222191428406im], [0.5122745107404276 - 0.8588217659361316im 0.0 + 0.0im; 0.0 + 0.0im 0.5122745107404276 + 0.8588217659361316im], [-0.33813106657687086 + 0.9410990286976114im 0.0 + 0.0im; 0.0 + 0.0im -0.33813106657687086 - 0.9410990286976114im], [-0.33813106657687086 + 0.9410990286976114im 0.0 + 0.0im; 0.0 + 0.0im -0.33813106657687086 - 0.9410990286976114im], [-0.13759196460196443 + 0.9904889960403254im 0.0 + 0.0im; 0.0 + 0.0im -0.13759196460196443 - 0.9904889960403254im], [-0.30371621954304256 + 0.9527625401885206im 0.0 + 0.0im; 0.0 + 0.0im -0.30371621954304256 - 0.9527625401885206im]  …  [0.6951608782942372 - 0.7188541947357507im 0.0 + 0.0im; 0.0 + 0.0im 0.6951608782942372 + 0.7188541947357507im], [0.6951608782942372 - 0.7188541947357507im 0.0 + 0.0im; 0.0 + 0.0im 0.6951608782942372 + 0.7188541947357507im], [0.6951608782942372 - 0.7188541947357507im 0.0 + 0.0im; 0.0 + 0.0im 0.6951608782942372 + 0.7188541947357507im], [0.9882178966179475 - 0.15305354881217104im 0.0 + 0.0im; 0.0 + 0.0im 0.9882178966179475 + 0.15305354881217104im], [0.9811288247310107 - 0.19335518943629537im 0.0 + 0.0im; 0.0 + 0.0im 0.9811288247310107 + 0.19335518943629537im], [0.9555317179808939 - 0.2948883448569669im 0.0 + 0.0im; 0.0 + 0.0im 0.9555317179808939 + 0.2948883448569669im], [0.9212728168576649 - 0.3889169537563814im 0.0 + 0.0im; 0.0 + 0.0im 0.9212728168576649 + 0.3889169537563814im], [0.8804577114119955 - 0.47412468657005324im 0.0 + 0.0im; 0.0 + 0.0im 0.8804577114119955 + 0.47412468657005324im], [0.8351706660440119 - 0.5499908713602449im 0.0 + 0.0im; 0.0 + 0.0im 0.8351706660440119 + 0.5499908713602449im], [0.7872511131353739 - 0.6166325363351457im 0.0 + 0.0im; 0.0 + 0.0im 0.7872511131353739 + 0.6166325363351457im]], StaticArraysCore.SMatrix{2, 2, ComplexF64, 4}[[0.5359655821341627 - 0.8442398324928694im 0.0 + 0.0im; 0.0 + 0.0im 0.5359655821341627 + 0.8442398324928694im], [0.42734019640203735 - 0.9040909005952157im 0.0 + 0.0im; 0.0 + 0.0im 0.42734019640203735 + 0.9040909005952157im], [0.3138295986168128 - 0.9494793220665788im 0.0 + 0.0im; 0.0 + 0.0im 0.3138295986168128 + 0.9494793220665788im], [0.19738269607652517 - 0.9803265125913724im 0.0 + 0.0im; 0.0 + 0.0im 0.19738269607652517 + 0.9803265125913724im], [0.07977738574774802 - 0.9968127049367173im 0.0 + 0.0im; 0.0 + 0.0im 0.07977738574774802 + 0.9968127049367173im], [-0.03737545468756512 - 0.9993012935981309im 0.0 + 0.0im; -0.0 + 0.0im -0.03737545468756512 + 0.9993012935981309im], [-0.13759196460196443 + 0.9904889960403254im 0.0 + 0.0im; 0.0 + 0.0im -0.13759196460196443 - 0.9904889960403254im], [0.755819776015662 + 0.6547797081336857im 0.0 + 0.0im; 0.0 + 0.0im 0.755819776015662 - 0.6547797081336857im], [0.755819776015662 + 0.6547797081336857im 0.0 + 0.0im; 0.0 + 0.0im 0.755819776015662 - 0.6547797081336857im], [-0.02917693859059436 + 0.9995742625010313im 0.0 + 0.0im; 0.0 + 0.0im -0.02917693859059436 - 0.9995742625010313im]  …  [0.5922345552510417 - 0.8057656182579402im 0.0 + 0.0im; 0.0 + 0.0im 0.5922345552510417 + 0.8057656182579402im], [0.996254476298424 - 0.08646975456975105im 0.0 + 0.0im; 0.0 + 0.0im 0.996254476298424 + 0.08646975456975105im], [0.9882178966179475 - 0.15305354881217104im 0.0 + 0.0im; 0.0 + 0.0im 0.9882178966179475 + 0.15305354881217104im], [0.5922345552510417 - 0.8057656182579402im 0.0 + 0.0im; 0.0 + 0.0im 0.5922345552510417 + 0.8057656182579402im], [0.963130413957882 - 0.26903495257924925im 0.0 + 0.0im; 0.0 + 0.0im 0.963130413957882 + 0.26903495257924925im], [0.9226606528537035 - 0.38561291430082795im 0.0 + 0.0im; 0.0 + 0.0im 0.9226606528537035 + 0.38561291430082795im], [0.8667200848715123 - 0.4987948420746936im 0.0 + 0.0im; 0.0 + 0.0im 0.8667200848715123 + 0.4987948420746936im], [0.7962012296816233 - 0.6050319015171605im 0.0 + 0.0im; 0.0 + 0.0im 0.7962012296816233 + 0.6050319015171605im], [0.7127118237241107 - 0.7014569525807356im 0.0 + 0.0im; 0.0 + 0.0im 0.7127118237241107 + 0.7014569525807356im], [0.6182782054875793 - 0.7859593250410982im 0.0 + 0.0im; 0.0 + 0.0im 0.6182782054875793 + 0.7859593250410982im]], CirBasis())</code></pre><p>Next we define our cache that maps quantities e.g., gain products, that change from scan-to-scan.</p><pre><code class="language-julia hljs">scancache = jonescache(dvis, ScanSeg())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, ScanSeg{false}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}(sparse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  306, 307, 308, 309, 310, 311, 312, 313, 314, 315], [1, 3, 5, 7, 9, 11, 13, 13, 14, 16  …  173, 173, 173, 174, 175, 177, 179, 181, 183, 185], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 186), sparse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  309, 307, 305, 308, 310, 311, 312, 313, 314, 315], [2, 4, 6, 8, 10, 12, 14, 15, 15, 17  …  171, 172, 174, 174, 176, 178, 180, 182, 184, 186], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 186), (AA = ScanSeg{false}(), AP = ScanSeg{false}(), AZ = ScanSeg{false}(), JC = ScanSeg{false}(), LM = ScanSeg{false}(), PV = ScanSeg{false}(), SM = ScanSeg{false}()), Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}([:JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM  …  :JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM], [0.0, 0.0, 0.3333333358168602, 0.3333333358168602, 0.6666666716337204, 0.6666666716337204, 1.0000000298023224, 1.0000000298023224, 1.3333333432674408, 1.3333333432674408  …  22.33333396911621, 22.33333396911621, 22.66666603088379, 22.66666603088379, 22.999999523162842, 22.999999523162842, 23.333333015441895, 23.333333015441895, 23.666666507720947, 23.666666507720947], [(0.0, :JC), (0.0, :SM), (0.3333333358168602, :JC), (0.3333333358168602, :SM), (0.6666666716337204, :JC), (0.6666666716337204, :SM), (1.0000000298023224, :JC), (1.0000000298023224, :SM), (1.3333333432674408, :JC), (1.3333333432674408, :SM)  …  (22.33333396911621, :JC), (22.33333396911621, :SM), (22.66666603088379, :JC), (22.66666603088379, :SM), (22.999999523162842, :JC), (22.999999523162842, :SM), (23.333333015441895, :JC), (23.333333015441895, :SM), (23.666666507720947, :JC), (23.666666507720947, :SM)]))</code></pre><p>In addition we will assign a reference station. This is necessary for gain phases due to a trivial degeneracy being present. To do this we will select ALMA <code>AA</code> as the reference station as is standard in EHT analyses.</p><pre><code class="language-julia hljs">phase_segs = station_tuple(dvis, ScanSeg(); AA=FixedSeg(1.0 + 0.0im))
phasecache = jonescache(dvis, phase_segs)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">JonesCache{Comrade.AffineDesignMatrix{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseVector{ComplexF64, Int64}}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), Tuple{FixedSeg{ComplexF64}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}(Comrade.AffineDesignMatrix{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseVector{ComplexF64, Int64}}(sparse([1, 2, 3, 4, 5, 6, 9, 12, 15, 18  …  306, 307, 308, 309, 310, 311, 312, 313, 314, 315], [1, 3, 5, 7, 9, 11, 13, 15, 17, 19  …  137, 137, 137, 138, 139, 141, 143, 145, 147, 149], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 150),   [7  ]  =  1.0+0.0im
  [8  ]  =  1.0+0.0im
  [10 ]  =  1.0+0.0im
  [11 ]  =  1.0+0.0im
  [13 ]  =  1.0+0.0im
  [14 ]  =  1.0+0.0im
  [16 ]  =  1.0+0.0im
         ⋮
  [276]  =  1.0+0.0im
  [277]  =  1.0+0.0im
  [278]  =  1.0+0.0im
  [289]  =  1.0+0.0im
  [290]  =  1.0+0.0im
  [291]  =  1.0+0.0im
  [292]  =  1.0+0.0im
  [293]  =  1.0+0.0im), sparse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  309, 307, 305, 308, 310, 311, 312, 313, 314, 315], [2, 4, 6, 8, 10, 12, 13, 14, 14, 15  …  135, 136, 138, 138, 140, 142, 144, 146, 148, 150], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 150), (AA = FixedSeg{ComplexF64}(1.0 + 0.0im), AP = ScanSeg{false}(), AZ = ScanSeg{false}(), JC = ScanSeg{false}(), LM = ScanSeg{false}(), PV = ScanSeg{false}(), SM = ScanSeg{false}()), Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}([:JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM  …  :JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM], [0.0, 0.0, 0.3333333358168602, 0.3333333358168602, 0.6666666716337204, 0.6666666716337204, 1.0000000298023224, 1.0000000298023224, 1.3333333432674408, 1.3333333432674408  …  22.33333396911621, 22.33333396911621, 22.66666603088379, 22.66666603088379, 22.999999523162842, 22.999999523162842, 23.333333015441895, 23.333333015441895, 23.666666507720947, 23.666666507720947], [(0.0, :JC), (0.0, :SM), (0.3333333358168602, :JC), (0.3333333358168602, :SM), (0.6666666716337204, :JC), (0.6666666716337204, :SM), (1.0000000298023224, :JC), (1.0000000298023224, :SM), (1.3333333432674408, :JC), (1.3333333432674408, :SM)  …  (22.33333396911621, :JC), (22.33333396911621, :SM), (22.66666603088379, :JC), (22.66666603088379, :SM), (22.999999523162842, :JC), (22.999999523162842, :SM), (23.333333015441895, :JC), (23.333333015441895, :SM), (23.666666507720947, :JC), (23.666666507720947, :SM)]))</code></pre><p>Finally, we define our cache that maps quantities, e.g., gain ratios and d-terms, that are constant across a observation night, and we collect everything together.</p><pre><code class="language-julia hljs">trackcache = jonescache(dvis, TrackSeg())
metadata = (;cache, grid, tcache, scancache, trackcache, phasecache)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(cache = Comrade.NUFTCache{Comrade.ObservedNUFT{NFFTAlg{Float64, AbstractNFFTs.PrecomputeFlags, UInt32}, Matrix{Float64}}, NFFT.NFFTPlan{Float64, 2, 1}, Vector{ComplexF64}, BSplinePulse{3}, AxisKeys.KeyedArray{Float64, 2, NamedDims.NamedDimsArray{(:X, :Y), Float64, 2, Matrix{Float64}}, GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, Nothing, Float64}}}(Comrade.ObservedNUFT{NFFTAlg{Float64, AbstractNFFTs.PrecomputeFlags, UInt32}, Matrix{Float64}}(NFFTAlg{Float64, AbstractNFFTs.PrecomputeFlags, UInt32}(1, 4, 2.0, :kaiser_bessel, AbstractNFFTs.TENSOR, true, false, true, 0x00000000), [59827.55078125 60351.01953125 … 57731.1796875 59075.01171875; -91918.53125 -94468.7265625 … -87413.2578125 -89891.890625]), NFFTPlan with 315 sampling points for an input array of size(5, 5) and an output array of size(315,) with dims 1:2, ComplexF64[0.9999999998020331 - 4.887735833479455e-6im, 0.9999999997921527 - 5.19642394141582e-6im, 0.9999999997823958 - 5.5773420751775874e-6im, 0.9999999997727597 - 6.027576735731718e-6im, 0.9999999997632122 - 6.5436807486049795e-6im, 0.9999999997537009 - 7.121707771326001e-6im, 0.999999953413493 - 9.554058415347402e-5im, 0.11487523368044451 - 0.4903009530935098im, 0.1149455498763295 - 0.4903903182256715im, 0.9999999510581715 - 9.694678355603363e-5im  …  0.9650387541615585 - 0.03031697513720594im, 0.7236825150581802 + 0.29468465832942775im, 0.7236779064194327 + 0.29467875197068955im, 0.8074548475519499 - 0.358747961757572im, 0.9999999998586939 - 4.60780075438823e-6im, 0.9999999998495279 - 4.4690475196511684e-6im, 0.9999999998399299 - 4.4080913130850975e-6im, 0.9999999998300636 - 4.425399770024229e-6im, 0.9999999998200652 - 4.5208390253898465e-6im, 0.9999999998100452 - 4.693679068293542e-6im], BSplinePulse{3}(), [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]), grid = GriddedKeys{(:X, :Y)}
	X: LinRange{Float64}(-9.69627362219072e-11, 9.69627362219072e-11, 5)
	Y: LinRange{Float64}(-9.69627362219072e-11, 9.69627362219072e-11, 5)
, tcache = TransformCache{StructArrays.StructVector{StaticArraysCore.SMatrix{2, 2, ComplexF64, 4}, NTuple{4, Vector{ComplexF64}}, Int64}, CirBasis}(StaticArraysCore.SMatrix{2, 2, ComplexF64, 4}[[0.7478621428837151 - 0.6638540617043611im 0.0 + 0.0im; 0.0 + 0.0im 0.7478621428837151 + 0.6638540617043611im], [0.6986903594406451 - 0.7154241969801568im 0.0 + 0.0im; 0.0 + 0.0im 0.6986903594406451 + 0.7154241969801568im], [0.6501178594775278 - 0.7598333822545292im 0.0 + 0.0im; 0.0 + 0.0im 0.6501178594775278 + 0.7598333822545292im], [0.6026809337927997 - 0.7979822629874921im 0.0 + 0.0im; 0.0 + 0.0im 0.6026809337927997 + 0.7979822629874921im], [0.5566871604612363 - 0.8307222191428406im 0.0 + 0.0im; 0.0 + 0.0im 0.5566871604612363 + 0.8307222191428406im], [0.5122745107404276 - 0.8588217659361316im 0.0 + 0.0im; 0.0 + 0.0im 0.5122745107404276 + 0.8588217659361316im], [-0.33813106657687086 + 0.9410990286976114im 0.0 + 0.0im; 0.0 + 0.0im -0.33813106657687086 - 0.9410990286976114im], [-0.33813106657687086 + 0.9410990286976114im 0.0 + 0.0im; 0.0 + 0.0im -0.33813106657687086 - 0.9410990286976114im], [-0.13759196460196443 + 0.9904889960403254im 0.0 + 0.0im; 0.0 + 0.0im -0.13759196460196443 - 0.9904889960403254im], [-0.30371621954304256 + 0.9527625401885206im 0.0 + 0.0im; 0.0 + 0.0im -0.30371621954304256 - 0.9527625401885206im]  …  [0.6951608782942372 - 0.7188541947357507im 0.0 + 0.0im; 0.0 + 0.0im 0.6951608782942372 + 0.7188541947357507im], [0.6951608782942372 - 0.7188541947357507im 0.0 + 0.0im; 0.0 + 0.0im 0.6951608782942372 + 0.7188541947357507im], [0.6951608782942372 - 0.7188541947357507im 0.0 + 0.0im; 0.0 + 0.0im 0.6951608782942372 + 0.7188541947357507im], [0.9882178966179475 - 0.15305354881217104im 0.0 + 0.0im; 0.0 + 0.0im 0.9882178966179475 + 0.15305354881217104im], [0.9811288247310107 - 0.19335518943629537im 0.0 + 0.0im; 0.0 + 0.0im 0.9811288247310107 + 0.19335518943629537im], [0.9555317179808939 - 0.2948883448569669im 0.0 + 0.0im; 0.0 + 0.0im 0.9555317179808939 + 0.2948883448569669im], [0.9212728168576649 - 0.3889169537563814im 0.0 + 0.0im; 0.0 + 0.0im 0.9212728168576649 + 0.3889169537563814im], [0.8804577114119955 - 0.47412468657005324im 0.0 + 0.0im; 0.0 + 0.0im 0.8804577114119955 + 0.47412468657005324im], [0.8351706660440119 - 0.5499908713602449im 0.0 + 0.0im; 0.0 + 0.0im 0.8351706660440119 + 0.5499908713602449im], [0.7872511131353739 - 0.6166325363351457im 0.0 + 0.0im; 0.0 + 0.0im 0.7872511131353739 + 0.6166325363351457im]], StaticArraysCore.SMatrix{2, 2, ComplexF64, 4}[[0.5359655821341627 - 0.8442398324928694im 0.0 + 0.0im; 0.0 + 0.0im 0.5359655821341627 + 0.8442398324928694im], [0.42734019640203735 - 0.9040909005952157im 0.0 + 0.0im; 0.0 + 0.0im 0.42734019640203735 + 0.9040909005952157im], [0.3138295986168128 - 0.9494793220665788im 0.0 + 0.0im; 0.0 + 0.0im 0.3138295986168128 + 0.9494793220665788im], [0.19738269607652517 - 0.9803265125913724im 0.0 + 0.0im; 0.0 + 0.0im 0.19738269607652517 + 0.9803265125913724im], [0.07977738574774802 - 0.9968127049367173im 0.0 + 0.0im; 0.0 + 0.0im 0.07977738574774802 + 0.9968127049367173im], [-0.03737545468756512 - 0.9993012935981309im 0.0 + 0.0im; -0.0 + 0.0im -0.03737545468756512 + 0.9993012935981309im], [-0.13759196460196443 + 0.9904889960403254im 0.0 + 0.0im; 0.0 + 0.0im -0.13759196460196443 - 0.9904889960403254im], [0.755819776015662 + 0.6547797081336857im 0.0 + 0.0im; 0.0 + 0.0im 0.755819776015662 - 0.6547797081336857im], [0.755819776015662 + 0.6547797081336857im 0.0 + 0.0im; 0.0 + 0.0im 0.755819776015662 - 0.6547797081336857im], [-0.02917693859059436 + 0.9995742625010313im 0.0 + 0.0im; 0.0 + 0.0im -0.02917693859059436 - 0.9995742625010313im]  …  [0.5922345552510417 - 0.8057656182579402im 0.0 + 0.0im; 0.0 + 0.0im 0.5922345552510417 + 0.8057656182579402im], [0.996254476298424 - 0.08646975456975105im 0.0 + 0.0im; 0.0 + 0.0im 0.996254476298424 + 0.08646975456975105im], [0.9882178966179475 - 0.15305354881217104im 0.0 + 0.0im; 0.0 + 0.0im 0.9882178966179475 + 0.15305354881217104im], [0.5922345552510417 - 0.8057656182579402im 0.0 + 0.0im; 0.0 + 0.0im 0.5922345552510417 + 0.8057656182579402im], [0.963130413957882 - 0.26903495257924925im 0.0 + 0.0im; 0.0 + 0.0im 0.963130413957882 + 0.26903495257924925im], [0.9226606528537035 - 0.38561291430082795im 0.0 + 0.0im; 0.0 + 0.0im 0.9226606528537035 + 0.38561291430082795im], [0.8667200848715123 - 0.4987948420746936im 0.0 + 0.0im; 0.0 + 0.0im 0.8667200848715123 + 0.4987948420746936im], [0.7962012296816233 - 0.6050319015171605im 0.0 + 0.0im; 0.0 + 0.0im 0.7962012296816233 + 0.6050319015171605im], [0.7127118237241107 - 0.7014569525807356im 0.0 + 0.0im; 0.0 + 0.0im 0.7127118237241107 + 0.7014569525807356im], [0.6182782054875793 - 0.7859593250410982im 0.0 + 0.0im; 0.0 + 0.0im 0.6182782054875793 + 0.7859593250410982im]], CirBasis()), scancache = JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, ScanSeg{false}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}(sparse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  306, 307, 308, 309, 310, 311, 312, 313, 314, 315], [1, 3, 5, 7, 9, 11, 13, 13, 14, 16  …  173, 173, 173, 174, 175, 177, 179, 181, 183, 185], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 186), sparse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  309, 307, 305, 308, 310, 311, 312, 313, 314, 315], [2, 4, 6, 8, 10, 12, 14, 15, 15, 17  …  171, 172, 174, 174, 176, 178, 180, 182, 184, 186], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 186), (AA = ScanSeg{false}(), AP = ScanSeg{false}(), AZ = ScanSeg{false}(), JC = ScanSeg{false}(), LM = ScanSeg{false}(), PV = ScanSeg{false}(), SM = ScanSeg{false}()), Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}([:JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM  …  :JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM], [0.0, 0.0, 0.3333333358168602, 0.3333333358168602, 0.6666666716337204, 0.6666666716337204, 1.0000000298023224, 1.0000000298023224, 1.3333333432674408, 1.3333333432674408  …  22.33333396911621, 22.33333396911621, 22.66666603088379, 22.66666603088379, 22.999999523162842, 22.999999523162842, 23.333333015441895, 23.333333015441895, 23.666666507720947, 23.666666507720947], [(0.0, :JC), (0.0, :SM), (0.3333333358168602, :JC), (0.3333333358168602, :SM), (0.6666666716337204, :JC), (0.6666666716337204, :SM), (1.0000000298023224, :JC), (1.0000000298023224, :SM), (1.3333333432674408, :JC), (1.3333333432674408, :SM)  …  (22.33333396911621, :JC), (22.33333396911621, :SM), (22.66666603088379, :JC), (22.66666603088379, :SM), (22.999999523162842, :JC), (22.999999523162842, :SM), (23.333333015441895, :JC), (23.333333015441895, :SM), (23.666666507720947, :JC), (23.666666507720947, :SM)])), trackcache = JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}(sparse([1, 2, 3, 4, 5, 6, 115, 116, 117, 130  …  284, 285, 286, 298, 299, 300, 301, 306, 307, 308], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), sparse([111, 120, 126, 135, 141, 150, 156, 165, 171, 180  …  284, 288, 290, 294, 296, 299, 303, 304, 306, 309], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), (AA = TrackSeg(), AP = TrackSeg(), AZ = TrackSeg(), JC = TrackSeg(), LM = TrackSeg(), PV = TrackSeg(), SM = TrackSeg()), Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}([:JC, :SM, :AA, :AP, :PV, :LM, :AZ], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [(0.0, :JC), (0.0, :SM), (0.0, :AA), (0.0, :AP), (0.0, :PV), (0.0, :LM), (0.0, :AZ)])), phasecache = JonesCache{Comrade.AffineDesignMatrix{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseVector{ComplexF64, Int64}}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), Tuple{FixedSeg{ComplexF64}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}(Comrade.AffineDesignMatrix{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseVector{ComplexF64, Int64}}(sparse([1, 2, 3, 4, 5, 6, 9, 12, 15, 18  …  306, 307, 308, 309, 310, 311, 312, 313, 314, 315], [1, 3, 5, 7, 9, 11, 13, 15, 17, 19  …  137, 137, 137, 138, 139, 141, 143, 145, 147, 149], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 150),   [7  ]  =  1.0+0.0im
  [8  ]  =  1.0+0.0im
  [10 ]  =  1.0+0.0im
  [11 ]  =  1.0+0.0im
  [13 ]  =  1.0+0.0im
  [14 ]  =  1.0+0.0im
  [16 ]  =  1.0+0.0im
         ⋮
  [276]  =  1.0+0.0im
  [277]  =  1.0+0.0im
  [278]  =  1.0+0.0im
  [289]  =  1.0+0.0im
  [290]  =  1.0+0.0im
  [291]  =  1.0+0.0im
  [292]  =  1.0+0.0im
  [293]  =  1.0+0.0im), sparse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  309, 307, 305, 308, 310, 311, 312, 313, 314, 315], [2, 4, 6, 8, 10, 12, 13, 14, 14, 15  …  135, 136, 138, 138, 140, 142, 144, 146, 148, 150], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 150), (AA = FixedSeg{ComplexF64}(1.0 + 0.0im), AP = ScanSeg{false}(), AZ = ScanSeg{false}(), JC = ScanSeg{false}(), LM = ScanSeg{false}(), PV = ScanSeg{false}(), SM = ScanSeg{false}()), Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}([:JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM  …  :JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM], [0.0, 0.0, 0.3333333358168602, 0.3333333358168602, 0.6666666716337204, 0.6666666716337204, 1.0000000298023224, 1.0000000298023224, 1.3333333432674408, 1.3333333432674408  …  22.33333396911621, 22.33333396911621, 22.66666603088379, 22.66666603088379, 22.999999523162842, 22.999999523162842, 23.333333015441895, 23.333333015441895, 23.666666507720947, 23.666666507720947], [(0.0, :JC), (0.0, :SM), (0.3333333358168602, :JC), (0.3333333358168602, :SM), (0.6666666716337204, :JC), (0.6666666716337204, :SM), (1.0000000298023224, :JC), (1.0000000298023224, :SM), (1.3333333432674408, :JC), (1.3333333432674408, :SM)  …  (22.33333396911621, :JC), (22.33333396911621, :SM), (22.66666603088379, :JC), (22.66666603088379, :SM), (22.999999523162842, :JC), (22.999999523162842, :SM), (23.333333015441895, :JC), (23.333333015441895, :SM), (23.666666507720947, :JC), (23.666666507720947, :SM)])))</code></pre><p>Moving onto our prior, we first focus on the instrument model priors. Each station gain requires its own prior on both the amplitudes and phases. For the amplitudes, we assume that the gains are apriori well calibrated around unit gains (or 0 log gain amplitudes) which corresponds to no instrument corruption. The gain dispersion is then set to 10% for all stations except LMT, representing that we expect 10% deviations from scan-to-scan. For LMT, we let the prior expand to 100% due to the known pointing issues LMT had in 2017.</p><pre><code class="language-julia hljs">using Distributions
using DistributionsAD
distamp = (AA = Normal(0.0, 0.1),
           AP = Normal(0.0, 0.1),
           LM = Normal(0.0, 0.1),
           AZ = Normal(0.0, 0.1),
           JC = Normal(0.0, 0.1),
           PV = Normal(0.0, 0.1),
           SM = Normal(0.0, 0.1),
           )</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(AA = Distributions.Normal{Float64}(μ=0.0, σ=0.1), AP = Distributions.Normal{Float64}(μ=0.0, σ=0.1), LM = Distributions.Normal{Float64}(μ=0.0, σ=0.1), AZ = Distributions.Normal{Float64}(μ=0.0, σ=0.1), JC = Distributions.Normal{Float64}(μ=0.0, σ=0.1), PV = Distributions.Normal{Float64}(μ=0.0, σ=0.1), SM = Distributions.Normal{Float64}(μ=0.0, σ=0.1))</code></pre><p>For the phases, we assume that the atmosphere effectively scrambles the gains. Since the gain phases are periodic, we also use broad von Mises priors for all stations. Notice that we don&#39;t assign a prior for AA since we have already fixed it.</p><pre><code class="language-julia hljs">using VLBIImagePriors
distphase = (
             AP = DiagonalVonMises(0.0, inv(π^2)),
             LM = DiagonalVonMises(0.0, inv(π^2)),
             AZ = DiagonalVonMises(0.0, inv(π^2)),
             JC = DiagonalVonMises(0.0, inv(π^2)),
             PV = DiagonalVonMises(0.0, inv(π^2)),
             SM = DiagonalVonMises(0.0, inv(π^2)),
           )</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(AP = VLBIImagePriors.DiagonalVonMises{Float64, Float64, Float64}(μ=0.0, κ=0.10132118364233778, lnorm=-1.739120733481688), LM = VLBIImagePriors.DiagonalVonMises{Float64, Float64, Float64}(μ=0.0, κ=0.10132118364233778, lnorm=-1.739120733481688), AZ = VLBIImagePriors.DiagonalVonMises{Float64, Float64, Float64}(μ=0.0, κ=0.10132118364233778, lnorm=-1.739120733481688), JC = VLBIImagePriors.DiagonalVonMises{Float64, Float64, Float64}(μ=0.0, κ=0.10132118364233778, lnorm=-1.739120733481688), PV = VLBIImagePriors.DiagonalVonMises{Float64, Float64, Float64}(μ=0.0, κ=0.10132118364233778, lnorm=-1.739120733481688), SM = VLBIImagePriors.DiagonalVonMises{Float64, Float64, Float64}(μ=0.0, κ=0.10132118364233778, lnorm=-1.739120733481688))</code></pre><p>However, we can now also use a little additional information about the phase offsets where in most cases, they are much better behaved than the products</p><pre><code class="language-julia hljs">distphase_ratio = (
             AA = DiagonalVonMises(0.0, inv(0.01)),
             AP = DiagonalVonMises(0.0, inv(0.1^2)),
             LM = DiagonalVonMises(0.0, inv(0.1^2)),
             AZ = DiagonalVonMises(0.0, inv(0.1^2)),
             JC = DiagonalVonMises(0.0, inv(0.1^2)),
             PV = DiagonalVonMises(0.0, inv(0.1^2)),
             SM = DiagonalVonMises(0.0, inv(0.1^2)),
           )</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(AA = VLBIImagePriors.DiagonalVonMises{Float64, Float64, Float64}(μ=0.0, κ=100.0, lnorm=1.3823902436480708), AP = VLBIImagePriors.DiagonalVonMises{Float64, Float64, Float64}(μ=0.0, κ=99.99999999999999, lnorm=1.3823902436480708), LM = VLBIImagePriors.DiagonalVonMises{Float64, Float64, Float64}(μ=0.0, κ=99.99999999999999, lnorm=1.3823902436480708), AZ = VLBIImagePriors.DiagonalVonMises{Float64, Float64, Float64}(μ=0.0, κ=99.99999999999999, lnorm=1.3823902436480708), JC = VLBIImagePriors.DiagonalVonMises{Float64, Float64, Float64}(μ=0.0, κ=99.99999999999999, lnorm=1.3823902436480708), PV = VLBIImagePriors.DiagonalVonMises{Float64, Float64, Float64}(μ=0.0, κ=99.99999999999999, lnorm=1.3823902436480708), SM = VLBIImagePriors.DiagonalVonMises{Float64, Float64, Float64}(μ=0.0, κ=99.99999999999999, lnorm=1.3823902436480708))</code></pre><p>Moving onto the d-terms, here we directly parameterize the real and complex components of the d-terms since they are expected to be complex numbers near the origin. To help enforce this smallness, a weakly informative Normal prior is used.</p><pre><code class="language-julia hljs">distD = ( AA = Normal(0.0, 0.1),
          AP = Normal(0.0, 0.1),
          LM = Normal(0.0, 0.1),
          AZ = Normal(0.0, 0.1),
          JC = Normal(0.0, 0.1),
          PV = Normal(0.0, 0.1),
          SM = Normal(0.0, 0.1),
        )</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(AA = Distributions.Normal{Float64}(μ=0.0, σ=0.1), AP = Distributions.Normal{Float64}(μ=0.0, σ=0.1), LM = Distributions.Normal{Float64}(μ=0.0, σ=0.1), AZ = Distributions.Normal{Float64}(μ=0.0, σ=0.1), JC = Distributions.Normal{Float64}(μ=0.0, σ=0.1), PV = Distributions.Normal{Float64}(μ=0.0, σ=0.1), SM = Distributions.Normal{Float64}(μ=0.0, σ=0.1))</code></pre><p>Our image priors are:</p><ul><li>We use a Dirichlet prior, <code>ImageDirichlet</code>, with unit concentration for our stokes I image pixels, <code>c</code>.</li><li>For the total polarization fraction, <code>p</code>, we assume an uncorrelated uniform prior <code>ImageUniform</code> for each pixel.</li><li>To specify the orientation of the polarization, <code>angparams</code>, on the Poincare sphere, we use a uniform spherical distribution, <code>ImageSphericalUniform</code>.</li></ul><p>For all the calibration parameters, we use a helper function <code>CalPrior</code> which builds the prior given the named tuple of station priors and a <code>JonesCache</code> that specifies the segmentation scheme. For the gain products, we use the <code>scancache</code>, while for every other quantity, we use the <code>trackcache</code>.</p><pre><code class="language-julia hljs">prior = (
          c = ImageDirichlet(1.0, nx, ny),
          f = Uniform(0.7, 1.2),
          p = ImageUniform(nx, ny),
          angparams = ImageSphericalUniform(nx, ny),
          dRx = CalPrior(distD, trackcache),
          dRy = CalPrior(distD, trackcache),
          dLx = CalPrior(distD, trackcache),
          dLy = CalPrior(distD, trackcache),
          lgp = CalPrior(distamp, scancache),
          gpp = CalPrior(distphase, phasecache),
          lgr = CalPrior(distamp, trackcache),
          gpr = CalPrior(distphase_ratio,trackcache),
          )</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(c = VLBIImagePriors.ImageDirichlet{Float64, FillArrays.Fill{Float64, 2, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}}, Float64}(
α: Fill(1.0, 5, 5)
α0: 25.0
lmnB: -54.78472939811231
)
, f = Distributions.Uniform{Float64}(a=0.7, b=1.2), p = VLBIImagePriors.ImageUniform{Float64}(a=0.0, b=1.0, nx=5, ny=5), angparams = VLBIImagePriors.ImageSphericalUniform{Float64}(nx=5, ny=5), dRx = CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}(
dists: DiagNormal(
dim: 7
μ: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
Σ: [0.010000000000000002 0.0 … 0.0 0.0; 0.0 0.010000000000000002 … 0.0 0.0; … ; 0.0 0.0 … 0.010000000000000002 0.0; 0.0 0.0 … 0.0 0.010000000000000002]
)

jcache: JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}(sparse([1, 2, 3, 4, 5, 6, 115, 116, 117, 130  …  284, 285, 286, 298, 299, 300, 301, 306, 307, 308], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), sparse([111, 120, 126, 135, 141, 150, 156, 165, 171, 180  …  284, 288, 290, 294, 296, 299, 303, 304, 306, 309], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), (AA = TrackSeg(), AP = TrackSeg(), AZ = TrackSeg(), JC = TrackSeg(), LM = TrackSeg(), PV = TrackSeg(), SM = TrackSeg()), Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}([:JC, :SM, :AA, :AP, :PV, :LM, :AZ], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [(0.0, :JC), (0.0, :SM), (0.0, :AA), (0.0, :AP), (0.0, :PV), (0.0, :LM), (0.0, :AZ)]))
)
, dRy = CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}(
dists: DiagNormal(
dim: 7
μ: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
Σ: [0.010000000000000002 0.0 … 0.0 0.0; 0.0 0.010000000000000002 … 0.0 0.0; … ; 0.0 0.0 … 0.010000000000000002 0.0; 0.0 0.0 … 0.0 0.010000000000000002]
)

jcache: JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}(sparse([1, 2, 3, 4, 5, 6, 115, 116, 117, 130  …  284, 285, 286, 298, 299, 300, 301, 306, 307, 308], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), sparse([111, 120, 126, 135, 141, 150, 156, 165, 171, 180  …  284, 288, 290, 294, 296, 299, 303, 304, 306, 309], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), (AA = TrackSeg(), AP = TrackSeg(), AZ = TrackSeg(), JC = TrackSeg(), LM = TrackSeg(), PV = TrackSeg(), SM = TrackSeg()), Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}([:JC, :SM, :AA, :AP, :PV, :LM, :AZ], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [(0.0, :JC), (0.0, :SM), (0.0, :AA), (0.0, :AP), (0.0, :PV), (0.0, :LM), (0.0, :AZ)]))
)
, dLx = CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}(
dists: DiagNormal(
dim: 7
μ: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
Σ: [0.010000000000000002 0.0 … 0.0 0.0; 0.0 0.010000000000000002 … 0.0 0.0; … ; 0.0 0.0 … 0.010000000000000002 0.0; 0.0 0.0 … 0.0 0.010000000000000002]
)

jcache: JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}(sparse([1, 2, 3, 4, 5, 6, 115, 116, 117, 130  …  284, 285, 286, 298, 299, 300, 301, 306, 307, 308], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), sparse([111, 120, 126, 135, 141, 150, 156, 165, 171, 180  …  284, 288, 290, 294, 296, 299, 303, 304, 306, 309], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), (AA = TrackSeg(), AP = TrackSeg(), AZ = TrackSeg(), JC = TrackSeg(), LM = TrackSeg(), PV = TrackSeg(), SM = TrackSeg()), Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}([:JC, :SM, :AA, :AP, :PV, :LM, :AZ], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [(0.0, :JC), (0.0, :SM), (0.0, :AA), (0.0, :AP), (0.0, :PV), (0.0, :LM), (0.0, :AZ)]))
)
, dLy = CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}(
dists: DiagNormal(
dim: 7
μ: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
Σ: [0.010000000000000002 0.0 … 0.0 0.0; 0.0 0.010000000000000002 … 0.0 0.0; … ; 0.0 0.0 … 0.010000000000000002 0.0; 0.0 0.0 … 0.0 0.010000000000000002]
)

jcache: JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}(sparse([1, 2, 3, 4, 5, 6, 115, 116, 117, 130  …  284, 285, 286, 298, 299, 300, 301, 306, 307, 308], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), sparse([111, 120, 126, 135, 141, 150, 156, 165, 171, 180  …  284, 288, 290, 294, 296, 299, 303, 304, 306, 309], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), (AA = TrackSeg(), AP = TrackSeg(), AZ = TrackSeg(), JC = TrackSeg(), LM = TrackSeg(), PV = TrackSeg(), SM = TrackSeg()), Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}([:JC, :SM, :AA, :AP, :PV, :LM, :AZ], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [(0.0, :JC), (0.0, :SM), (0.0, :AA), (0.0, :AP), (0.0, :PV), (0.0, :LM), (0.0, :AZ)]))
)
, lgp = CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, ScanSeg{false}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}(
dists: DiagNormal(
dim: 186
μ: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
Σ: [0.010000000000000002 0.0 … 0.0 0.0; 0.0 0.010000000000000002 … 0.0 0.0; … ; 0.0 0.0 … 0.010000000000000002 0.0; 0.0 0.0 … 0.0 0.010000000000000002]
)

jcache: JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, ScanSeg{false}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}(sparse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  306, 307, 308, 309, 310, 311, 312, 313, 314, 315], [1, 3, 5, 7, 9, 11, 13, 13, 14, 16  …  173, 173, 173, 174, 175, 177, 179, 181, 183, 185], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 186), sparse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  309, 307, 305, 308, 310, 311, 312, 313, 314, 315], [2, 4, 6, 8, 10, 12, 14, 15, 15, 17  …  171, 172, 174, 174, 176, 178, 180, 182, 184, 186], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 186), (AA = ScanSeg{false}(), AP = ScanSeg{false}(), AZ = ScanSeg{false}(), JC = ScanSeg{false}(), LM = ScanSeg{false}(), PV = ScanSeg{false}(), SM = ScanSeg{false}()), Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}([:JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM  …  :JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM], [0.0, 0.0, 0.3333333358168602, 0.3333333358168602, 0.6666666716337204, 0.6666666716337204, 1.0000000298023224, 1.0000000298023224, 1.3333333432674408, 1.3333333432674408  …  22.33333396911621, 22.33333396911621, 22.66666603088379, 22.66666603088379, 22.999999523162842, 22.999999523162842, 23.333333015441895, 23.333333015441895, 23.666666507720947, 23.666666507720947], [(0.0, :JC), (0.0, :SM), (0.3333333358168602, :JC), (0.3333333358168602, :SM), (0.6666666716337204, :JC), (0.6666666716337204, :SM), (1.0000000298023224, :JC), (1.0000000298023224, :SM), (1.3333333432674408, :JC), (1.3333333432674408, :SM)  …  (22.33333396911621, :JC), (22.33333396911621, :SM), (22.66666603088379, :JC), (22.66666603088379, :SM), (22.999999523162842, :JC), (22.999999523162842, :SM), (23.333333015441895, :JC), (23.333333015441895, :SM), (23.666666507720947, :JC), (23.666666507720947, :SM)]))
)
, gpp = CalPrior{VLBIImagePriors.DiagonalVonMises{Vector{Float64}, Vector{Float64}, Float64}, JonesCache{Comrade.AffineDesignMatrix{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseVector{ComplexF64, Int64}}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), Tuple{FixedSeg{ComplexF64}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}(
dists: VLBIImagePriors.DiagonalVonMises{Vector{Float64}, Vector{Float64}, Float64}(
μ: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
κ: [0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778  …  0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778]
lnorm: -260.8681100222532
)

jcache: JonesCache{Comrade.AffineDesignMatrix{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseVector{ComplexF64, Int64}}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), Tuple{FixedSeg{ComplexF64}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}(Comrade.AffineDesignMatrix{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseVector{ComplexF64, Int64}}(sparse([1, 2, 3, 4, 5, 6, 9, 12, 15, 18  …  306, 307, 308, 309, 310, 311, 312, 313, 314, 315], [1, 3, 5, 7, 9, 11, 13, 15, 17, 19  …  137, 137, 137, 138, 139, 141, 143, 145, 147, 149], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 150),   [7  ]  =  1.0+0.0im
  [8  ]  =  1.0+0.0im
  [10 ]  =  1.0+0.0im
  [11 ]  =  1.0+0.0im
  [13 ]  =  1.0+0.0im
  [14 ]  =  1.0+0.0im
  [16 ]  =  1.0+0.0im
         ⋮
  [276]  =  1.0+0.0im
  [277]  =  1.0+0.0im
  [278]  =  1.0+0.0im
  [289]  =  1.0+0.0im
  [290]  =  1.0+0.0im
  [291]  =  1.0+0.0im
  [292]  =  1.0+0.0im
  [293]  =  1.0+0.0im), sparse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  309, 307, 305, 308, 310, 311, 312, 313, 314, 315], [2, 4, 6, 8, 10, 12, 13, 14, 14, 15  …  135, 136, 138, 138, 140, 142, 144, 146, 148, 150], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 150), (AA = FixedSeg{ComplexF64}(1.0 + 0.0im), AP = ScanSeg{false}(), AZ = ScanSeg{false}(), JC = ScanSeg{false}(), LM = ScanSeg{false}(), PV = ScanSeg{false}(), SM = ScanSeg{false}()), Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}([:JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM  …  :JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM], [0.0, 0.0, 0.3333333358168602, 0.3333333358168602, 0.6666666716337204, 0.6666666716337204, 1.0000000298023224, 1.0000000298023224, 1.3333333432674408, 1.3333333432674408  …  22.33333396911621, 22.33333396911621, 22.66666603088379, 22.66666603088379, 22.999999523162842, 22.999999523162842, 23.333333015441895, 23.333333015441895, 23.666666507720947, 23.666666507720947], [(0.0, :JC), (0.0, :SM), (0.3333333358168602, :JC), (0.3333333358168602, :SM), (0.6666666716337204, :JC), (0.6666666716337204, :SM), (1.0000000298023224, :JC), (1.0000000298023224, :SM), (1.3333333432674408, :JC), (1.3333333432674408, :SM)  …  (22.33333396911621, :JC), (22.33333396911621, :SM), (22.66666603088379, :JC), (22.66666603088379, :SM), (22.999999523162842, :JC), (22.999999523162842, :SM), (23.333333015441895, :JC), (23.333333015441895, :SM), (23.666666507720947, :JC), (23.666666507720947, :SM)]))
)
, lgr = CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}(
dists: DiagNormal(
dim: 7
μ: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
Σ: [0.010000000000000002 0.0 … 0.0 0.0; 0.0 0.010000000000000002 … 0.0 0.0; … ; 0.0 0.0 … 0.010000000000000002 0.0; 0.0 0.0 … 0.0 0.010000000000000002]
)

jcache: JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}(sparse([1, 2, 3, 4, 5, 6, 115, 116, 117, 130  …  284, 285, 286, 298, 299, 300, 301, 306, 307, 308], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), sparse([111, 120, 126, 135, 141, 150, 156, 165, 171, 180  …  284, 288, 290, 294, 296, 299, 303, 304, 306, 309], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), (AA = TrackSeg(), AP = TrackSeg(), AZ = TrackSeg(), JC = TrackSeg(), LM = TrackSeg(), PV = TrackSeg(), SM = TrackSeg()), Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}([:JC, :SM, :AA, :AP, :PV, :LM, :AZ], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [(0.0, :JC), (0.0, :SM), (0.0, :AA), (0.0, :AP), (0.0, :PV), (0.0, :LM), (0.0, :AZ)]))
)
, gpr = CalPrior{VLBIImagePriors.DiagonalVonMises{Vector{Float64}, Vector{Float64}, Float64}, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}(
dists: VLBIImagePriors.DiagonalVonMises{Vector{Float64}, Vector{Float64}, Float64}(
μ: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
κ: [99.99999999999999, 99.99999999999999, 100.0, 99.99999999999999, 99.99999999999999, 99.99999999999999, 99.99999999999999]
lnorm: 9.676731705536497
)

jcache: JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}(sparse([1, 2, 3, 4, 5, 6, 115, 116, 117, 130  …  284, 285, 286, 298, 299, 300, 301, 306, 307, 308], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), sparse([111, 120, 126, 135, 141, 150, 156, 165, 171, 180  …  284, 288, 290, 294, 296, 299, 303, 304, 306, 309], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), (AA = TrackSeg(), AP = TrackSeg(), AZ = TrackSeg(), JC = TrackSeg(), LM = TrackSeg(), PV = TrackSeg(), SM = TrackSeg()), Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}([:JC, :SM, :AA, :AP, :PV, :LM, :AZ], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [(0.0, :JC), (0.0, :SM), (0.0, :AA), (0.0, :AP), (0.0, :PV), (0.0, :LM), (0.0, :AZ)]))
)
)</code></pre><p>Putting it all together, we form our likelihood and posterior objects for optimization and sampling.</p><pre><code class="language-julia hljs">lklhd = RadioLikelihood(model, metadata, dvis)
post = Posterior(lklhd, prior)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Posterior{RadioLikelihood{Comrade.ModelMetadata{typeof(Main.model), NamedTuple{(:cache, :grid, :tcache, :scancache, :trackcache, :phasecache), Tuple{Comrade.NUFTCache{Comrade.ObservedNUFT{NFFTAlg{Float64, AbstractNFFTs.PrecomputeFlags, UInt32}, Matrix{Float64}}, NFFT.NFFTPlan{Float64, 2, 1}, Vector{ComplexF64}, BSplinePulse{3}, AxisKeys.KeyedArray{Float64, 2, NamedDims.NamedDimsArray{(:X, :Y), Float64, 2, Matrix{Float64}}, GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, Nothing, Float64}}}, GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, Nothing, Float64}, TransformCache{StructArrays.StructVector{StaticArraysCore.SMatrix{2, 2, ComplexF64, 4}, NTuple{4, Vector{ComplexF64}}, Int64}, CirBasis}, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, ScanSeg{false}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}, JonesCache{Comrade.AffineDesignMatrix{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseVector{ComplexF64, Int64}}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), Tuple{FixedSeg{ComplexF64}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}}}, Tuple{Comrade.ConditionedLikelihood{Comrade.var&quot;#68#70&quot;{StructArrays.StructVector{StaticArraysCore.SMatrix{2, 2, Float64, 4}, NTuple{4, Vector{Float64}}, Int64}}, StructArrays.StructVector{StaticArraysCore.SMatrix{2, 2, ComplexF64, 4}, NTuple{4, Vector{ComplexF64}}, Int64}}}, Comrade.EHTArrayConfiguration{Float64, TypedTables.Table{NamedTuple{(:sites, :X, :Y, :Z, :SEFD1, :SEFD2, :fr_parallactic, :fr_elevation, :fr_offset), Tuple{Symbol, Float64, Float64, Float64, Float64, Float64, Float64, Float64, Float64}}, 1, NamedTuple{(:sites, :X, :Y, :Z, :SEFD1, :SEFD2, :fr_parallactic, :fr_elevation, :fr_offset), Tuple{Vector{Symbol}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}}}}, TypedTables.Table{NamedTuple{(:start, :stop), Tuple{Float64, Float64}}, 1, NamedTuple{(:start, :stop), Tuple{Vector{Float64}, Vector{Float64}}}}, StructArrays.StructVector{Comrade.ArrayBaselineDatum, NamedTuple{(:U, :V, :T, :F, :baseline, :error, :elevation, :parallactic), Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Tuple{Symbol, Symbol}}, StructArrays.StructVector{StaticArraysCore.SMatrix{2, 2, Float64, 4}, NTuple{4, Vector{Float64}}, Int64}, StructArrays.StructVector{Tuple{Float64, Float64}, Tuple{Vector{Float64}, Vector{Float64}}, Int64}, StructArrays.StructVector{Tuple{Float64, Float64}, Tuple{Vector{Float64}, Vector{Float64}}, Int64}}}, Int64}}, NamedTuple{(:U, :V, :T, :F), NTuple{4, Vector{Float64}}}}, Comrade.NamedDist{(:c, :f, :p, :angparams, :dRx, :dRy, :dLx, :dLy, :lgp, :gpp, :lgr, :gpr), Tuple{VLBIImagePriors.ImageDirichlet{Float64, FillArrays.Fill{Float64, 2, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}}, Float64}, Distributions.Uniform{Float64}, VLBIImagePriors.ImageUniform{Float64}, VLBIImagePriors.ImageSphericalUniform{Float64}, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, ScanSeg{false}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}, CalPrior{VLBIImagePriors.DiagonalVonMises{Vector{Float64}, Vector{Float64}, Float64}, JonesCache{Comrade.AffineDesignMatrix{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseVector{ComplexF64, Int64}}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), Tuple{FixedSeg{ComplexF64}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}, CalPrior{VLBIImagePriors.DiagonalVonMises{Vector{Float64}, Vector{Float64}, Float64}, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}}}}(RadioLikelihood
	Number of data products: 1
, Comrade.NamedDist{(:c, :f, :p, :angparams, :dRx, :dRy, :dLx, :dLy, :lgp, :gpp, :lgr, :gpr), Tuple{VLBIImagePriors.ImageDirichlet{Float64, FillArrays.Fill{Float64, 2, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}}, Float64}, Distributions.Uniform{Float64}, VLBIImagePriors.ImageUniform{Float64}, VLBIImagePriors.ImageSphericalUniform{Float64}, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, ScanSeg{false}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}, CalPrior{VLBIImagePriors.DiagonalVonMises{Vector{Float64}, Vector{Float64}, Float64}, JonesCache{Comrade.AffineDesignMatrix{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseVector{ComplexF64, Int64}}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), Tuple{FixedSeg{ComplexF64}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}, CalPrior{VLBIImagePriors.DiagonalVonMises{Vector{Float64}, Vector{Float64}, Float64}, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}}}((VLBIImagePriors.ImageDirichlet{Float64, FillArrays.Fill{Float64, 2, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}}, Float64}(
α: Fill(1.0, 5, 5)
α0: 25.0
lmnB: -54.78472939811231
)
, Distributions.Uniform{Float64}(a=0.7, b=1.2), VLBIImagePriors.ImageUniform{Float64}(a=0.0, b=1.0, nx=5, ny=5), VLBIImagePriors.ImageSphericalUniform{Float64}(nx=5, ny=5), CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}(
dists: DiagNormal(
dim: 7
μ: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
Σ: [0.010000000000000002 0.0 … 0.0 0.0; 0.0 0.010000000000000002 … 0.0 0.0; … ; 0.0 0.0 … 0.010000000000000002 0.0; 0.0 0.0 … 0.0 0.010000000000000002]
)

jcache: JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}(sparse([1, 2, 3, 4, 5, 6, 115, 116, 117, 130  …  284, 285, 286, 298, 299, 300, 301, 306, 307, 308], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), sparse([111, 120, 126, 135, 141, 150, 156, 165, 171, 180  …  284, 288, 290, 294, 296, 299, 303, 304, 306, 309], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), (AA = TrackSeg(), AP = TrackSeg(), AZ = TrackSeg(), JC = TrackSeg(), LM = TrackSeg(), PV = TrackSeg(), SM = TrackSeg()), Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}([:JC, :SM, :AA, :AP, :PV, :LM, :AZ], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [(0.0, :JC), (0.0, :SM), (0.0, :AA), (0.0, :AP), (0.0, :PV), (0.0, :LM), (0.0, :AZ)]))
)
, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}(
dists: DiagNormal(
dim: 7
μ: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
Σ: [0.010000000000000002 0.0 … 0.0 0.0; 0.0 0.010000000000000002 … 0.0 0.0; … ; 0.0 0.0 … 0.010000000000000002 0.0; 0.0 0.0 … 0.0 0.010000000000000002]
)

jcache: JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}(sparse([1, 2, 3, 4, 5, 6, 115, 116, 117, 130  …  284, 285, 286, 298, 299, 300, 301, 306, 307, 308], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), sparse([111, 120, 126, 135, 141, 150, 156, 165, 171, 180  …  284, 288, 290, 294, 296, 299, 303, 304, 306, 309], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), (AA = TrackSeg(), AP = TrackSeg(), AZ = TrackSeg(), JC = TrackSeg(), LM = TrackSeg(), PV = TrackSeg(), SM = TrackSeg()), Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}([:JC, :SM, :AA, :AP, :PV, :LM, :AZ], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [(0.0, :JC), (0.0, :SM), (0.0, :AA), (0.0, :AP), (0.0, :PV), (0.0, :LM), (0.0, :AZ)]))
)
, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}(
dists: DiagNormal(
dim: 7
μ: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
Σ: [0.010000000000000002 0.0 … 0.0 0.0; 0.0 0.010000000000000002 … 0.0 0.0; … ; 0.0 0.0 … 0.010000000000000002 0.0; 0.0 0.0 … 0.0 0.010000000000000002]
)

jcache: JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}(sparse([1, 2, 3, 4, 5, 6, 115, 116, 117, 130  …  284, 285, 286, 298, 299, 300, 301, 306, 307, 308], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), sparse([111, 120, 126, 135, 141, 150, 156, 165, 171, 180  …  284, 288, 290, 294, 296, 299, 303, 304, 306, 309], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), (AA = TrackSeg(), AP = TrackSeg(), AZ = TrackSeg(), JC = TrackSeg(), LM = TrackSeg(), PV = TrackSeg(), SM = TrackSeg()), Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}([:JC, :SM, :AA, :AP, :PV, :LM, :AZ], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [(0.0, :JC), (0.0, :SM), (0.0, :AA), (0.0, :AP), (0.0, :PV), (0.0, :LM), (0.0, :AZ)]))
)
, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}(
dists: DiagNormal(
dim: 7
μ: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
Σ: [0.010000000000000002 0.0 … 0.0 0.0; 0.0 0.010000000000000002 … 0.0 0.0; … ; 0.0 0.0 … 0.010000000000000002 0.0; 0.0 0.0 … 0.0 0.010000000000000002]
)

jcache: JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}(sparse([1, 2, 3, 4, 5, 6, 115, 116, 117, 130  …  284, 285, 286, 298, 299, 300, 301, 306, 307, 308], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), sparse([111, 120, 126, 135, 141, 150, 156, 165, 171, 180  …  284, 288, 290, 294, 296, 299, 303, 304, 306, 309], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), (AA = TrackSeg(), AP = TrackSeg(), AZ = TrackSeg(), JC = TrackSeg(), LM = TrackSeg(), PV = TrackSeg(), SM = TrackSeg()), Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}([:JC, :SM, :AA, :AP, :PV, :LM, :AZ], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [(0.0, :JC), (0.0, :SM), (0.0, :AA), (0.0, :AP), (0.0, :PV), (0.0, :LM), (0.0, :AZ)]))
)
, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, ScanSeg{false}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}(
dists: DiagNormal(
dim: 186
μ: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
Σ: [0.010000000000000002 0.0 … 0.0 0.0; 0.0 0.010000000000000002 … 0.0 0.0; … ; 0.0 0.0 … 0.010000000000000002 0.0; 0.0 0.0 … 0.0 0.010000000000000002]
)

jcache: JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, ScanSeg{false}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}(sparse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  306, 307, 308, 309, 310, 311, 312, 313, 314, 315], [1, 3, 5, 7, 9, 11, 13, 13, 14, 16  …  173, 173, 173, 174, 175, 177, 179, 181, 183, 185], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 186), sparse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  309, 307, 305, 308, 310, 311, 312, 313, 314, 315], [2, 4, 6, 8, 10, 12, 14, 15, 15, 17  …  171, 172, 174, 174, 176, 178, 180, 182, 184, 186], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 186), (AA = ScanSeg{false}(), AP = ScanSeg{false}(), AZ = ScanSeg{false}(), JC = ScanSeg{false}(), LM = ScanSeg{false}(), PV = ScanSeg{false}(), SM = ScanSeg{false}()), Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}([:JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM  …  :JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM], [0.0, 0.0, 0.3333333358168602, 0.3333333358168602, 0.6666666716337204, 0.6666666716337204, 1.0000000298023224, 1.0000000298023224, 1.3333333432674408, 1.3333333432674408  …  22.33333396911621, 22.33333396911621, 22.66666603088379, 22.66666603088379, 22.999999523162842, 22.999999523162842, 23.333333015441895, 23.333333015441895, 23.666666507720947, 23.666666507720947], [(0.0, :JC), (0.0, :SM), (0.3333333358168602, :JC), (0.3333333358168602, :SM), (0.6666666716337204, :JC), (0.6666666716337204, :SM), (1.0000000298023224, :JC), (1.0000000298023224, :SM), (1.3333333432674408, :JC), (1.3333333432674408, :SM)  …  (22.33333396911621, :JC), (22.33333396911621, :SM), (22.66666603088379, :JC), (22.66666603088379, :SM), (22.999999523162842, :JC), (22.999999523162842, :SM), (23.333333015441895, :JC), (23.333333015441895, :SM), (23.666666507720947, :JC), (23.666666507720947, :SM)]))
)
, CalPrior{VLBIImagePriors.DiagonalVonMises{Vector{Float64}, Vector{Float64}, Float64}, JonesCache{Comrade.AffineDesignMatrix{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseVector{ComplexF64, Int64}}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), Tuple{FixedSeg{ComplexF64}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}(
dists: VLBIImagePriors.DiagonalVonMises{Vector{Float64}, Vector{Float64}, Float64}(
μ: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
κ: [0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778  …  0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778]
lnorm: -260.8681100222532
)

jcache: JonesCache{Comrade.AffineDesignMatrix{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseVector{ComplexF64, Int64}}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), Tuple{FixedSeg{ComplexF64}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}(Comrade.AffineDesignMatrix{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseVector{ComplexF64, Int64}}(sparse([1, 2, 3, 4, 5, 6, 9, 12, 15, 18  …  306, 307, 308, 309, 310, 311, 312, 313, 314, 315], [1, 3, 5, 7, 9, 11, 13, 15, 17, 19  …  137, 137, 137, 138, 139, 141, 143, 145, 147, 149], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 150),   [7  ]  =  1.0+0.0im
  [8  ]  =  1.0+0.0im
  [10 ]  =  1.0+0.0im
  [11 ]  =  1.0+0.0im
  [13 ]  =  1.0+0.0im
  [14 ]  =  1.0+0.0im
  [16 ]  =  1.0+0.0im
         ⋮
  [276]  =  1.0+0.0im
  [277]  =  1.0+0.0im
  [278]  =  1.0+0.0im
  [289]  =  1.0+0.0im
  [290]  =  1.0+0.0im
  [291]  =  1.0+0.0im
  [292]  =  1.0+0.0im
  [293]  =  1.0+0.0im), sparse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  309, 307, 305, 308, 310, 311, 312, 313, 314, 315], [2, 4, 6, 8, 10, 12, 13, 14, 14, 15  …  135, 136, 138, 138, 140, 142, 144, 146, 148, 150], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 150), (AA = FixedSeg{ComplexF64}(1.0 + 0.0im), AP = ScanSeg{false}(), AZ = ScanSeg{false}(), JC = ScanSeg{false}(), LM = ScanSeg{false}(), PV = ScanSeg{false}(), SM = ScanSeg{false}()), Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}([:JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM  …  :JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM], [0.0, 0.0, 0.3333333358168602, 0.3333333358168602, 0.6666666716337204, 0.6666666716337204, 1.0000000298023224, 1.0000000298023224, 1.3333333432674408, 1.3333333432674408  …  22.33333396911621, 22.33333396911621, 22.66666603088379, 22.66666603088379, 22.999999523162842, 22.999999523162842, 23.333333015441895, 23.333333015441895, 23.666666507720947, 23.666666507720947], [(0.0, :JC), (0.0, :SM), (0.3333333358168602, :JC), (0.3333333358168602, :SM), (0.6666666716337204, :JC), (0.6666666716337204, :SM), (1.0000000298023224, :JC), (1.0000000298023224, :SM), (1.3333333432674408, :JC), (1.3333333432674408, :SM)  …  (22.33333396911621, :JC), (22.33333396911621, :SM), (22.66666603088379, :JC), (22.66666603088379, :SM), (22.999999523162842, :JC), (22.999999523162842, :SM), (23.333333015441895, :JC), (23.333333015441895, :SM), (23.666666507720947, :JC), (23.666666507720947, :SM)]))
)
, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}(
dists: DiagNormal(
dim: 7
μ: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
Σ: [0.010000000000000002 0.0 … 0.0 0.0; 0.0 0.010000000000000002 … 0.0 0.0; … ; 0.0 0.0 … 0.010000000000000002 0.0; 0.0 0.0 … 0.0 0.010000000000000002]
)

jcache: JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}(sparse([1, 2, 3, 4, 5, 6, 115, 116, 117, 130  …  284, 285, 286, 298, 299, 300, 301, 306, 307, 308], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), sparse([111, 120, 126, 135, 141, 150, 156, 165, 171, 180  …  284, 288, 290, 294, 296, 299, 303, 304, 306, 309], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), (AA = TrackSeg(), AP = TrackSeg(), AZ = TrackSeg(), JC = TrackSeg(), LM = TrackSeg(), PV = TrackSeg(), SM = TrackSeg()), Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}([:JC, :SM, :AA, :AP, :PV, :LM, :AZ], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [(0.0, :JC), (0.0, :SM), (0.0, :AA), (0.0, :AP), (0.0, :PV), (0.0, :LM), (0.0, :AZ)]))
)
, CalPrior{VLBIImagePriors.DiagonalVonMises{Vector{Float64}, Vector{Float64}, Float64}, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}(
dists: VLBIImagePriors.DiagonalVonMises{Vector{Float64}, Vector{Float64}, Float64}(
μ: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
κ: [99.99999999999999, 99.99999999999999, 100.0, 99.99999999999999, 99.99999999999999, 99.99999999999999, 99.99999999999999]
lnorm: 9.676731705536497
)

jcache: JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}(sparse([1, 2, 3, 4, 5, 6, 115, 116, 117, 130  …  284, 285, 286, 298, 299, 300, 301, 306, 307, 308], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), sparse([111, 120, 126, 135, 141, 150, 156, 165, 171, 180  …  284, 288, 290, 294, 296, 299, 303, 304, 306, 309], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), (AA = TrackSeg(), AP = TrackSeg(), AZ = TrackSeg(), JC = TrackSeg(), LM = TrackSeg(), PV = TrackSeg(), SM = TrackSeg()), Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}([:JC, :SM, :AA, :AP, :PV, :LM, :AZ], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [(0.0, :JC), (0.0, :SM), (0.0, :AA), (0.0, :AP), (0.0, :PV), (0.0, :LM), (0.0, :AZ)]))
)
)))</code></pre><h2 id="Reconstructing-the-Image-and-Instrument-Effects"><a class="docs-heading-anchor" href="#Reconstructing-the-Image-and-Instrument-Effects">Reconstructing the Image and Instrument Effects</a><a id="Reconstructing-the-Image-and-Instrument-Effects-1"></a><a class="docs-heading-anchor-permalink" href="#Reconstructing-the-Image-and-Instrument-Effects" title="Permalink"></a></h2><p>To sample from this posterior, it is convenient to move from our constrained parameter space to an unconstrained one (i.e., the support of the transformed posterior is (-∞, ∞)). This transformation is done using the <code>asflat</code> function.</p><pre><code class="language-julia hljs">tpost = asflat(post)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Comrade.TransformedPosterior{Posterior{RadioLikelihood{Comrade.ModelMetadata{typeof(Main.model), NamedTuple{(:cache, :grid, :tcache, :scancache, :trackcache, :phasecache), Tuple{Comrade.NUFTCache{Comrade.ObservedNUFT{NFFTAlg{Float64, AbstractNFFTs.PrecomputeFlags, UInt32}, Matrix{Float64}}, NFFT.NFFTPlan{Float64, 2, 1}, Vector{ComplexF64}, BSplinePulse{3}, AxisKeys.KeyedArray{Float64, 2, NamedDims.NamedDimsArray{(:X, :Y), Float64, 2, Matrix{Float64}}, GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, Nothing, Float64}}}, GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, Nothing, Float64}, TransformCache{StructArrays.StructVector{StaticArraysCore.SMatrix{2, 2, ComplexF64, 4}, NTuple{4, Vector{ComplexF64}}, Int64}, CirBasis}, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, ScanSeg{false}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}, JonesCache{Comrade.AffineDesignMatrix{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseVector{ComplexF64, Int64}}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), Tuple{FixedSeg{ComplexF64}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}}}, Tuple{Comrade.ConditionedLikelihood{Comrade.var&quot;#68#70&quot;{StructArrays.StructVector{StaticArraysCore.SMatrix{2, 2, Float64, 4}, NTuple{4, Vector{Float64}}, Int64}}, StructArrays.StructVector{StaticArraysCore.SMatrix{2, 2, ComplexF64, 4}, NTuple{4, Vector{ComplexF64}}, Int64}}}, Comrade.EHTArrayConfiguration{Float64, TypedTables.Table{NamedTuple{(:sites, :X, :Y, :Z, :SEFD1, :SEFD2, :fr_parallactic, :fr_elevation, :fr_offset), Tuple{Symbol, Float64, Float64, Float64, Float64, Float64, Float64, Float64, Float64}}, 1, NamedTuple{(:sites, :X, :Y, :Z, :SEFD1, :SEFD2, :fr_parallactic, :fr_elevation, :fr_offset), Tuple{Vector{Symbol}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}}}}, TypedTables.Table{NamedTuple{(:start, :stop), Tuple{Float64, Float64}}, 1, NamedTuple{(:start, :stop), Tuple{Vector{Float64}, Vector{Float64}}}}, StructArrays.StructVector{Comrade.ArrayBaselineDatum, NamedTuple{(:U, :V, :T, :F, :baseline, :error, :elevation, :parallactic), Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Tuple{Symbol, Symbol}}, StructArrays.StructVector{StaticArraysCore.SMatrix{2, 2, Float64, 4}, NTuple{4, Vector{Float64}}, Int64}, StructArrays.StructVector{Tuple{Float64, Float64}, Tuple{Vector{Float64}, Vector{Float64}}, Int64}, StructArrays.StructVector{Tuple{Float64, Float64}, Tuple{Vector{Float64}, Vector{Float64}}, Int64}}}, Int64}}, NamedTuple{(:U, :V, :T, :F), NTuple{4, Vector{Float64}}}}, Comrade.NamedDist{(:c, :f, :p, :angparams, :dRx, :dRy, :dLx, :dLy, :lgp, :gpp, :lgr, :gpr), Tuple{VLBIImagePriors.ImageDirichlet{Float64, FillArrays.Fill{Float64, 2, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}}, Float64}, Distributions.Uniform{Float64}, VLBIImagePriors.ImageUniform{Float64}, VLBIImagePriors.ImageSphericalUniform{Float64}, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, ScanSeg{false}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}, CalPrior{VLBIImagePriors.DiagonalVonMises{Vector{Float64}, Vector{Float64}, Float64}, JonesCache{Comrade.AffineDesignMatrix{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseVector{ComplexF64, Int64}}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), Tuple{FixedSeg{ComplexF64}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}, CalPrior{VLBIImagePriors.DiagonalVonMises{Vector{Float64}, Vector{Float64}, Float64}, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}}}}, TransformVariables.TransformTuple{NamedTuple{(:c, :f, :p, :angparams, :dRx, :dRy, :dLx, :dLy, :lgp, :gpp, :lgr, :gpr), Tuple{VLBIImagePriors.ImageSimplex, TransformVariables.ScaledShiftedLogistic{Float64}, TransformVariables.ArrayTransform{TransformVariables.ScaledShiftedLogistic{Float64}, 2}, TransformVariables.ArrayTransform{VLBIImagePriors.SphericalUnitVector{2}, 2}, TransformVariables.ArrayTransform{TransformVariables.Identity, 1}, TransformVariables.ArrayTransform{TransformVariables.Identity, 1}, TransformVariables.ArrayTransform{TransformVariables.Identity, 1}, TransformVariables.ArrayTransform{TransformVariables.Identity, 1}, TransformVariables.ArrayTransform{TransformVariables.Identity, 1}, TransformVariables.ArrayTransform{VLBIImagePriors.AngleTransform, 1}, TransformVariables.ArrayTransform{TransformVariables.Identity, 1}, TransformVariables.ArrayTransform{VLBIImagePriors.AngleTransform, 1}}}}}(Posterior{RadioLikelihood{Comrade.ModelMetadata{typeof(Main.model), NamedTuple{(:cache, :grid, :tcache, :scancache, :trackcache, :phasecache), Tuple{Comrade.NUFTCache{Comrade.ObservedNUFT{NFFTAlg{Float64, AbstractNFFTs.PrecomputeFlags, UInt32}, Matrix{Float64}}, NFFT.NFFTPlan{Float64, 2, 1}, Vector{ComplexF64}, BSplinePulse{3}, AxisKeys.KeyedArray{Float64, 2, NamedDims.NamedDimsArray{(:X, :Y), Float64, 2, Matrix{Float64}}, GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, Nothing, Float64}}}, GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, Nothing, Float64}, TransformCache{StructArrays.StructVector{StaticArraysCore.SMatrix{2, 2, ComplexF64, 4}, NTuple{4, Vector{ComplexF64}}, Int64}, CirBasis}, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, ScanSeg{false}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}, JonesCache{Comrade.AffineDesignMatrix{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseVector{ComplexF64, Int64}}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), Tuple{FixedSeg{ComplexF64}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}}}, Tuple{Comrade.ConditionedLikelihood{Comrade.var&quot;#68#70&quot;{StructArrays.StructVector{StaticArraysCore.SMatrix{2, 2, Float64, 4}, NTuple{4, Vector{Float64}}, Int64}}, StructArrays.StructVector{StaticArraysCore.SMatrix{2, 2, ComplexF64, 4}, NTuple{4, Vector{ComplexF64}}, Int64}}}, Comrade.EHTArrayConfiguration{Float64, TypedTables.Table{NamedTuple{(:sites, :X, :Y, :Z, :SEFD1, :SEFD2, :fr_parallactic, :fr_elevation, :fr_offset), Tuple{Symbol, Float64, Float64, Float64, Float64, Float64, Float64, Float64, Float64}}, 1, NamedTuple{(:sites, :X, :Y, :Z, :SEFD1, :SEFD2, :fr_parallactic, :fr_elevation, :fr_offset), Tuple{Vector{Symbol}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}}}}, TypedTables.Table{NamedTuple{(:start, :stop), Tuple{Float64, Float64}}, 1, NamedTuple{(:start, :stop), Tuple{Vector{Float64}, Vector{Float64}}}}, StructArrays.StructVector{Comrade.ArrayBaselineDatum, NamedTuple{(:U, :V, :T, :F, :baseline, :error, :elevation, :parallactic), Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Tuple{Symbol, Symbol}}, StructArrays.StructVector{StaticArraysCore.SMatrix{2, 2, Float64, 4}, NTuple{4, Vector{Float64}}, Int64}, StructArrays.StructVector{Tuple{Float64, Float64}, Tuple{Vector{Float64}, Vector{Float64}}, Int64}, StructArrays.StructVector{Tuple{Float64, Float64}, Tuple{Vector{Float64}, Vector{Float64}}, Int64}}}, Int64}}, NamedTuple{(:U, :V, :T, :F), NTuple{4, Vector{Float64}}}}, Comrade.NamedDist{(:c, :f, :p, :angparams, :dRx, :dRy, :dLx, :dLy, :lgp, :gpp, :lgr, :gpr), Tuple{VLBIImagePriors.ImageDirichlet{Float64, FillArrays.Fill{Float64, 2, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}}, Float64}, Distributions.Uniform{Float64}, VLBIImagePriors.ImageUniform{Float64}, VLBIImagePriors.ImageSphericalUniform{Float64}, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, ScanSeg{false}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}, CalPrior{VLBIImagePriors.DiagonalVonMises{Vector{Float64}, Vector{Float64}, Float64}, JonesCache{Comrade.AffineDesignMatrix{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseVector{ComplexF64, Int64}}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), Tuple{FixedSeg{ComplexF64}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}, CalPrior{VLBIImagePriors.DiagonalVonMises{Vector{Float64}, Vector{Float64}, Float64}, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}}}}(RadioLikelihood
	Number of data products: 1
, Comrade.NamedDist{(:c, :f, :p, :angparams, :dRx, :dRy, :dLx, :dLy, :lgp, :gpp, :lgr, :gpr), Tuple{VLBIImagePriors.ImageDirichlet{Float64, FillArrays.Fill{Float64, 2, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}}, Float64}, Distributions.Uniform{Float64}, VLBIImagePriors.ImageUniform{Float64}, VLBIImagePriors.ImageSphericalUniform{Float64}, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, ScanSeg{false}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}, CalPrior{VLBIImagePriors.DiagonalVonMises{Vector{Float64}, Vector{Float64}, Float64}, JonesCache{Comrade.AffineDesignMatrix{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseVector{ComplexF64, Int64}}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), Tuple{FixedSeg{ComplexF64}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}, CalPrior{VLBIImagePriors.DiagonalVonMises{Vector{Float64}, Vector{Float64}, Float64}, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}}}((VLBIImagePriors.ImageDirichlet{Float64, FillArrays.Fill{Float64, 2, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}}, Float64}(
α: Fill(1.0, 5, 5)
α0: 25.0
lmnB: -54.78472939811231
)
, Distributions.Uniform{Float64}(a=0.7, b=1.2), VLBIImagePriors.ImageUniform{Float64}(a=0.0, b=1.0, nx=5, ny=5), VLBIImagePriors.ImageSphericalUniform{Float64}(nx=5, ny=5), CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}(
dists: DiagNormal(
dim: 7
μ: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
Σ: [0.010000000000000002 0.0 … 0.0 0.0; 0.0 0.010000000000000002 … 0.0 0.0; … ; 0.0 0.0 … 0.010000000000000002 0.0; 0.0 0.0 … 0.0 0.010000000000000002]
)

jcache: JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}(sparse([1, 2, 3, 4, 5, 6, 115, 116, 117, 130  …  284, 285, 286, 298, 299, 300, 301, 306, 307, 308], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), sparse([111, 120, 126, 135, 141, 150, 156, 165, 171, 180  …  284, 288, 290, 294, 296, 299, 303, 304, 306, 309], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), (AA = TrackSeg(), AP = TrackSeg(), AZ = TrackSeg(), JC = TrackSeg(), LM = TrackSeg(), PV = TrackSeg(), SM = TrackSeg()), Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}([:JC, :SM, :AA, :AP, :PV, :LM, :AZ], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [(0.0, :JC), (0.0, :SM), (0.0, :AA), (0.0, :AP), (0.0, :PV), (0.0, :LM), (0.0, :AZ)]))
)
, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}(
dists: DiagNormal(
dim: 7
μ: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
Σ: [0.010000000000000002 0.0 … 0.0 0.0; 0.0 0.010000000000000002 … 0.0 0.0; … ; 0.0 0.0 … 0.010000000000000002 0.0; 0.0 0.0 … 0.0 0.010000000000000002]
)

jcache: JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}(sparse([1, 2, 3, 4, 5, 6, 115, 116, 117, 130  …  284, 285, 286, 298, 299, 300, 301, 306, 307, 308], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), sparse([111, 120, 126, 135, 141, 150, 156, 165, 171, 180  …  284, 288, 290, 294, 296, 299, 303, 304, 306, 309], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), (AA = TrackSeg(), AP = TrackSeg(), AZ = TrackSeg(), JC = TrackSeg(), LM = TrackSeg(), PV = TrackSeg(), SM = TrackSeg()), Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}([:JC, :SM, :AA, :AP, :PV, :LM, :AZ], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [(0.0, :JC), (0.0, :SM), (0.0, :AA), (0.0, :AP), (0.0, :PV), (0.0, :LM), (0.0, :AZ)]))
)
, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}(
dists: DiagNormal(
dim: 7
μ: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
Σ: [0.010000000000000002 0.0 … 0.0 0.0; 0.0 0.010000000000000002 … 0.0 0.0; … ; 0.0 0.0 … 0.010000000000000002 0.0; 0.0 0.0 … 0.0 0.010000000000000002]
)

jcache: JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}(sparse([1, 2, 3, 4, 5, 6, 115, 116, 117, 130  …  284, 285, 286, 298, 299, 300, 301, 306, 307, 308], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), sparse([111, 120, 126, 135, 141, 150, 156, 165, 171, 180  …  284, 288, 290, 294, 296, 299, 303, 304, 306, 309], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), (AA = TrackSeg(), AP = TrackSeg(), AZ = TrackSeg(), JC = TrackSeg(), LM = TrackSeg(), PV = TrackSeg(), SM = TrackSeg()), Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}([:JC, :SM, :AA, :AP, :PV, :LM, :AZ], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [(0.0, :JC), (0.0, :SM), (0.0, :AA), (0.0, :AP), (0.0, :PV), (0.0, :LM), (0.0, :AZ)]))
)
, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}(
dists: DiagNormal(
dim: 7
μ: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
Σ: [0.010000000000000002 0.0 … 0.0 0.0; 0.0 0.010000000000000002 … 0.0 0.0; … ; 0.0 0.0 … 0.010000000000000002 0.0; 0.0 0.0 … 0.0 0.010000000000000002]
)

jcache: JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}(sparse([1, 2, 3, 4, 5, 6, 115, 116, 117, 130  …  284, 285, 286, 298, 299, 300, 301, 306, 307, 308], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), sparse([111, 120, 126, 135, 141, 150, 156, 165, 171, 180  …  284, 288, 290, 294, 296, 299, 303, 304, 306, 309], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), (AA = TrackSeg(), AP = TrackSeg(), AZ = TrackSeg(), JC = TrackSeg(), LM = TrackSeg(), PV = TrackSeg(), SM = TrackSeg()), Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}([:JC, :SM, :AA, :AP, :PV, :LM, :AZ], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [(0.0, :JC), (0.0, :SM), (0.0, :AA), (0.0, :AP), (0.0, :PV), (0.0, :LM), (0.0, :AZ)]))
)
, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, ScanSeg{false}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}(
dists: DiagNormal(
dim: 186
μ: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
Σ: [0.010000000000000002 0.0 … 0.0 0.0; 0.0 0.010000000000000002 … 0.0 0.0; … ; 0.0 0.0 … 0.010000000000000002 0.0; 0.0 0.0 … 0.0 0.010000000000000002]
)

jcache: JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, ScanSeg{false}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}(sparse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  306, 307, 308, 309, 310, 311, 312, 313, 314, 315], [1, 3, 5, 7, 9, 11, 13, 13, 14, 16  …  173, 173, 173, 174, 175, 177, 179, 181, 183, 185], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 186), sparse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  309, 307, 305, 308, 310, 311, 312, 313, 314, 315], [2, 4, 6, 8, 10, 12, 14, 15, 15, 17  …  171, 172, 174, 174, 176, 178, 180, 182, 184, 186], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 186), (AA = ScanSeg{false}(), AP = ScanSeg{false}(), AZ = ScanSeg{false}(), JC = ScanSeg{false}(), LM = ScanSeg{false}(), PV = ScanSeg{false}(), SM = ScanSeg{false}()), Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}([:JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM  …  :JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM], [0.0, 0.0, 0.3333333358168602, 0.3333333358168602, 0.6666666716337204, 0.6666666716337204, 1.0000000298023224, 1.0000000298023224, 1.3333333432674408, 1.3333333432674408  …  22.33333396911621, 22.33333396911621, 22.66666603088379, 22.66666603088379, 22.999999523162842, 22.999999523162842, 23.333333015441895, 23.333333015441895, 23.666666507720947, 23.666666507720947], [(0.0, :JC), (0.0, :SM), (0.3333333358168602, :JC), (0.3333333358168602, :SM), (0.6666666716337204, :JC), (0.6666666716337204, :SM), (1.0000000298023224, :JC), (1.0000000298023224, :SM), (1.3333333432674408, :JC), (1.3333333432674408, :SM)  …  (22.33333396911621, :JC), (22.33333396911621, :SM), (22.66666603088379, :JC), (22.66666603088379, :SM), (22.999999523162842, :JC), (22.999999523162842, :SM), (23.333333015441895, :JC), (23.333333015441895, :SM), (23.666666507720947, :JC), (23.666666507720947, :SM)]))
)
, CalPrior{VLBIImagePriors.DiagonalVonMises{Vector{Float64}, Vector{Float64}, Float64}, JonesCache{Comrade.AffineDesignMatrix{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseVector{ComplexF64, Int64}}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), Tuple{FixedSeg{ComplexF64}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}(
dists: VLBIImagePriors.DiagonalVonMises{Vector{Float64}, Vector{Float64}, Float64}(
μ: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
κ: [0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778  …  0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778]
lnorm: -260.8681100222532
)

jcache: JonesCache{Comrade.AffineDesignMatrix{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseVector{ComplexF64, Int64}}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), Tuple{FixedSeg{ComplexF64}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}, ScanSeg{false}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}(Comrade.AffineDesignMatrix{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseVector{ComplexF64, Int64}}(sparse([1, 2, 3, 4, 5, 6, 9, 12, 15, 18  …  306, 307, 308, 309, 310, 311, 312, 313, 314, 315], [1, 3, 5, 7, 9, 11, 13, 15, 17, 19  …  137, 137, 137, 138, 139, 141, 143, 145, 147, 149], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 150),   [7  ]  =  1.0+0.0im
  [8  ]  =  1.0+0.0im
  [10 ]  =  1.0+0.0im
  [11 ]  =  1.0+0.0im
  [13 ]  =  1.0+0.0im
  [14 ]  =  1.0+0.0im
  [16 ]  =  1.0+0.0im
         ⋮
  [276]  =  1.0+0.0im
  [277]  =  1.0+0.0im
  [278]  =  1.0+0.0im
  [289]  =  1.0+0.0im
  [290]  =  1.0+0.0im
  [291]  =  1.0+0.0im
  [292]  =  1.0+0.0im
  [293]  =  1.0+0.0im), sparse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  309, 307, 305, 308, 310, 311, 312, 313, 314, 315], [2, 4, 6, 8, 10, 12, 13, 14, 14, 15  …  135, 136, 138, 138, 140, 142, 144, 146, 148, 150], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 150), (AA = FixedSeg{ComplexF64}(1.0 + 0.0im), AP = ScanSeg{false}(), AZ = ScanSeg{false}(), JC = ScanSeg{false}(), LM = ScanSeg{false}(), PV = ScanSeg{false}(), SM = ScanSeg{false}()), Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}([:JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM  …  :JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM, :JC, :SM], [0.0, 0.0, 0.3333333358168602, 0.3333333358168602, 0.6666666716337204, 0.6666666716337204, 1.0000000298023224, 1.0000000298023224, 1.3333333432674408, 1.3333333432674408  …  22.33333396911621, 22.33333396911621, 22.66666603088379, 22.66666603088379, 22.999999523162842, 22.999999523162842, 23.333333015441895, 23.333333015441895, 23.666666507720947, 23.666666507720947], [(0.0, :JC), (0.0, :SM), (0.3333333358168602, :JC), (0.3333333358168602, :SM), (0.6666666716337204, :JC), (0.6666666716337204, :SM), (1.0000000298023224, :JC), (1.0000000298023224, :SM), (1.3333333432674408, :JC), (1.3333333432674408, :SM)  …  (22.33333396911621, :JC), (22.33333396911621, :SM), (22.66666603088379, :JC), (22.66666603088379, :SM), (22.999999523162842, :JC), (22.999999523162842, :SM), (23.333333015441895, :JC), (23.333333015441895, :SM), (23.666666507720947, :JC), (23.666666507720947, :SM)]))
)
, CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}(
dists: DiagNormal(
dim: 7
μ: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
Σ: [0.010000000000000002 0.0 … 0.0 0.0; 0.0 0.010000000000000002 … 0.0 0.0; … ; 0.0 0.0 … 0.010000000000000002 0.0; 0.0 0.0 … 0.0 0.010000000000000002]
)

jcache: JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}(sparse([1, 2, 3, 4, 5, 6, 115, 116, 117, 130  …  284, 285, 286, 298, 299, 300, 301, 306, 307, 308], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), sparse([111, 120, 126, 135, 141, 150, 156, 165, 171, 180  …  284, 288, 290, 294, 296, 299, 303, 304, 306, 309], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), (AA = TrackSeg(), AP = TrackSeg(), AZ = TrackSeg(), JC = TrackSeg(), LM = TrackSeg(), PV = TrackSeg(), SM = TrackSeg()), Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}([:JC, :SM, :AA, :AP, :PV, :LM, :AZ], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [(0.0, :JC), (0.0, :SM), (0.0, :AA), (0.0, :AP), (0.0, :PV), (0.0, :LM), (0.0, :AZ)]))
)
, CalPrior{VLBIImagePriors.DiagonalVonMises{Vector{Float64}, Vector{Float64}, Float64}, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}(
dists: VLBIImagePriors.DiagonalVonMises{Vector{Float64}, Vector{Float64}, Float64}(
μ: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
κ: [99.99999999999999, 99.99999999999999, 100.0, 99.99999999999999, 99.99999999999999, 99.99999999999999, 99.99999999999999]
lnorm: 9.676731705536497
)

jcache: JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, TrackSeg}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}(sparse([1, 2, 3, 4, 5, 6, 115, 116, 117, 130  …  284, 285, 286, 298, 299, 300, 301, 306, 307, 308], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), sparse([111, 120, 126, 135, 141, 150, 156, 165, 171, 180  …  284, 288, 290, 294, 296, 299, 303, 304, 306, 309], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 315, 7), (AA = TrackSeg(), AP = TrackSeg(), AZ = TrackSeg(), JC = TrackSeg(), LM = TrackSeg(), PV = TrackSeg(), SM = TrackSeg()), Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}([:JC, :SM, :AA, :AP, :PV, :LM, :AZ], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [(0.0, :JC), (0.0, :SM), (0.0, :AA), (0.0, :AP), (0.0, :PV), (0.0, :LM), (0.0, :AZ)]))
)
))), TransformVariables.TransformTuple{NamedTuple{(:c, :f, :p, :angparams, :dRx, :dRy, :dLx, :dLy, :lgp, :gpp, :lgr, :gpr), Tuple{VLBIImagePriors.ImageSimplex, TransformVariables.ScaledShiftedLogistic{Float64}, TransformVariables.ArrayTransform{TransformVariables.ScaledShiftedLogistic{Float64}, 2}, TransformVariables.ArrayTransform{VLBIImagePriors.SphericalUnitVector{2}, 2}, TransformVariables.ArrayTransform{TransformVariables.Identity, 1}, TransformVariables.ArrayTransform{TransformVariables.Identity, 1}, TransformVariables.ArrayTransform{TransformVariables.Identity, 1}, TransformVariables.ArrayTransform{TransformVariables.Identity, 1}, TransformVariables.ArrayTransform{TransformVariables.Identity, 1}, TransformVariables.ArrayTransform{VLBIImagePriors.AngleTransform, 1}, TransformVariables.ArrayTransform{TransformVariables.Identity, 1}, TransformVariables.ArrayTransform{VLBIImagePriors.AngleTransform, 1}}}}((c = VLBIImagePriors.ImageSimplex(25, (5, 5)), f = as(Real, 0.7, 1.2), p = TransformVariables.ArrayTransform{TransformVariables.ScaledShiftedLogistic{Float64}, 2}(as(Real, 0.0, 1.0), (5, 5)), angparams = TransformVariables.ArrayTransform{VLBIImagePriors.SphericalUnitVector{2}, 2}(VLBIImagePriors.SphericalUnitVector{2}(), (5, 5)), dRx = TransformVariables.ArrayTransform{TransformVariables.Identity, 1}(asℝ, (7,)), dRy = TransformVariables.ArrayTransform{TransformVariables.Identity, 1}(asℝ, (7,)), dLx = TransformVariables.ArrayTransform{TransformVariables.Identity, 1}(asℝ, (7,)), dLy = TransformVariables.ArrayTransform{TransformVariables.Identity, 1}(asℝ, (7,)), lgp = TransformVariables.ArrayTransform{TransformVariables.Identity, 1}(asℝ, (186,)), gpp = TransformVariables.ArrayTransform{VLBIImagePriors.AngleTransform, 1}(VLBIImagePriors.AngleTransform(), (150,)), lgr = TransformVariables.ArrayTransform{TransformVariables.Identity, 1}(asℝ, (7,)), gpr = TransformVariables.ArrayTransform{VLBIImagePriors.AngleTransform, 1}(VLBIImagePriors.AngleTransform(), (7,))), 660))</code></pre><p>We can now also find the dimension of our posterior or the number of parameters we will sample.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This can often be different from what you would expect. This difference is especially true when using angular variables, where we often artificially increase the dimension of the parameter space to make sampling easier.</p></div></div><pre><code class="language-julia hljs">ndim = dimension(tpost)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">660</code></pre><p>Now we optimize. Unlike other imaging examples, we move straight to gradient optimizers due to the higher dimension of the space.</p><pre><code class="language-julia hljs">using ComradeOptimization
using OptimizationOptimJL
using Zygote
f = OptimizationFunction(tpost, Optimization.AutoZygote())
ℓ = logdensityof(tpost)
prob = Optimization.OptimizationProblem(f, prior_sample(rng, tpost), nothing)
sol = solve(prob, LBFGS(), maxiters=15_000, callback=((x,p)-&gt;(@info ℓ(x);false)), g_tol=1e-1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">u: 660-element Vector{Float64}:
 -2.3468206894270383
  0.523201482690142
  0.08538718530574574
 -4.997181705744715
 -8.829960698106389
 -0.08191130601053799
  2.415612555034227
  2.6460949215656115
 -4.024245774795597
 -1.1301377894822429
  ⋮
  0.815754778176392
  0.024222244966977145
  0.7576551539361641
  0.019526056597763713
  0.9100071326853891
  0.023175678673184298
  0.7640161878537441
  0.028294626186056035
  0.9277801214302599</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Fitting polarized images is generally much harder than Stokes I imaging. This difficulty means that optimization can take a long time, and starting from a good starting location is often required.</p></div></div><p>Before we analyze our solution, we need to transform it back to parameter space.</p><pre><code class="language-julia hljs">xopt = transform(tpost, sol)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(c = [0.003970540830839374 0.04087933982381163 … 0.00017141552603502986 0.00041600010344703715; 0.06808006670561932 0.3232850541255178 … 0.0007860208138589796 0.00038407018059026803; … ; 0.00028440143899911927 0.0003170753664132667 … 0.00021795654851163596 0.00014603128026791976; 6.4649198545344625e-6 0.0059818308887780395 … 0.000392167823335181 0.0001007869146751875], f = 1.0048651698859588, p = [0.23761298765083624 0.163119343815719 … 0.7031238767050714 0.3989182794484337; 0.16397752582464245 0.14908181993746347 … 0.3608114988395365 0.4976897071335432; … ; 0.18617950479497195 0.21398729507686795 … 0.5222824927766436 0.7409780478229129; 0.8443404273279876 0.09044920727081121 … 0.4883906156203845 0.5838819408564384], angparams = ([0.3238084275814442 0.1380992781362934 … -0.7119265948862136 -0.9443188462897973; 0.052643690453927715 0.0043244311945638365 … 0.08509986902408896 0.03800711460383577; … ; 0.02572569114851552 -0.7100459599829383 … 0.5769185558804186 0.35985962825313406; -0.8024366694564686 -0.19135159088807974 … 0.14935969873778862 0.3098659645155294], [0.8966395446064988 0.978767432261431 … -0.1931394309917538 0.31812394053652115; 0.9890474512658921 0.9981639742375986 … 0.9644205347778726 0.9599868476442891; … ; 0.9106927767542938 0.45759170654615444 … -0.7835469908100774 0.9186834167214082; 0.33288089590529607 0.9774944057964224 … 0.9554201651708669 -0.36649256511093864], [0.30196958336078006 -0.15146914841841494 … 0.6751723362889677 0.08401830157425136; -0.13789046740015762 -0.06041506293173941 … -0.25030190648663675 0.2774539810301366; … ; 0.41228249439248016 -0.5352051614213803 … -0.23069263766606188 -0.16285523569905752; -0.49526326398482 0.08882147995445606 … -0.25468409525887215 0.8773062656525742]), dRx = [-0.0361409133865758, 0.07843804987599053, 0.009270925766044847, -0.07595359449770912, -0.00992533952807359, 0.02918541344338396, 0.08577708801458642], dRy = [0.05255224654479352, -0.07005069904286525, -0.019794283478005093, 0.07029775154571426, 0.019344820139758086, -0.0195272152312191, -0.10071106999557265], dLx = [-0.06140800929601989, 0.06269984786897723, 0.03204180081312726, -0.06325160828975232, -0.031929619451152545, 0.010638027167647548, 0.0938369406845666], dLy = [0.07177951733543332, -0.046214564686930346, -0.0399456842324574, 0.0489258740778381, 0.04192675601555852, 0.0009452971639718716, -0.07873332929353884], lgp = [-0.014196097253199286, -0.014528407929178054, -0.008563294679026855, -0.009745497092238948, -0.010436536957101455, -0.009102740327090589, -0.0018793464964139703, -0.0042378271042247005, -0.004908380399682971, -0.005415313488823468  …  -0.015429104780477772, -0.014587240335685921, 0.006836876489924465, 0.0020549169141833965, -0.021228694535438904, -0.022512485260053918, -0.011902741461434024, -0.010580619153378813, -0.007271594429697235, -0.008302184990061714], gpp = [0.07113443158977528, 0.08524305494904867, -1.0479012111932642, -1.04895681446878, -2.1664942926411936, -2.1599847347548957, -0.5126519533424589, -0.5080021526501098, 1.7769820526499973, 1.780238245220253  …  -0.8167710386498976, -0.8090560558260055, 2.7010570210234284, 2.694661425162979, -0.902538570231357, -0.9105411230632765, -0.5194420042151336, -0.5076868211193081, -0.6518749280454965, -0.6545600272118695], lgr = [0.02462002861865938, 0.023366900932993626, 0.024444147229835667, 0.02433768999140033, 0.013438705563182145, 0.024509985620584134, 0.023937746083893433], gpr = [0.027737464565031986, 0.028809058617584135, 0.03178701565038215, 0.0319591274829927, 0.021453744807489183, 0.030324716383438453, 0.030487675244064635])</code></pre><p>Now let&#39;s evaluate our fits by plotting the residuals</p><pre><code class="language-julia hljs">using Plots
residual(model(xopt, metadata), dvis)</code></pre><p>These look reasonable, although there may be some minor overfitting. Let&#39;s compare our results to the ground truth values we know in this example. First, we will load the polarized truth</p><pre><code class="language-julia hljs">using AxisKeys
imgtrue = Comrade.load(joinpath(dirname(pathof(Comrade)), &quot;..&quot;, &quot;examples&quot;, &quot;PolarizedExamples/polarized_gaussian.fits&quot;), StokesIntensityMap)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   X ∈ 1024-element LinRange{Float64,...}
→   Y ∈ 1024-element LinRange{Float64,...}
And data, 1024×1024 NamedDimsArray(StructArray(::Matrix{Float64}, ::Matrix{Float64}, ::Matrix{Float64}, ::Matrix{Float64}), (:X, :Y)):
                 …  (4.8434e-10)
 (-4.8434e-10)         [6.86545e-65, 4.08459e-78, 1.02982e-65, 1.02982e-66]
 (-4.83393e-10)        [8.99558e-65, 5.35191e-78, 1.34934e-65, 1.34934e-66]
 (-4.82446e-10)        [1.17804e-64, 7.00873e-78, 1.76706e-65, 1.76706e-66]
 (-4.815e-10)          [1.54192e-64, 9.17361e-78, 2.31287e-65, 2.31287e-66]
 (-4.80553e-10)  …     [2.01712e-64, 1.20008e-77, 3.02568e-65, 3.02568e-66]
 (-4.79606e-10)        [2.63738e-64, 1.56911e-77, 3.95607e-65, 3.95607e-66]
    ⋮            ⋱  
  (4.78659e-10)        [3.44655e-64, 2.05052e-77, 5.16983e-65, 5.16983e-66]
  (4.79606e-10)        [2.63738e-64, 1.56911e-77, 3.95607e-65, 3.95607e-66]
  (4.80553e-10)  …     [2.01712e-64, 1.20008e-77, 3.02568e-65, 3.02568e-66]
  (4.815e-10)          [1.54192e-64, 9.17361e-78, 2.31287e-65, 2.31287e-66]
  (4.82446e-10)        [1.17804e-64, 7.00873e-78, 1.76706e-65, 1.76706e-66]
  (4.83393e-10)        [8.99558e-65, 5.35191e-78, 1.34934e-65, 1.34934e-66]
  (4.8434e-10)         [6.86545e-65, 4.08459e-78, 1.02982e-65, 1.02982e-66]</code></pre><p>Select a reasonable zoom in of the image.</p><pre><code class="language-julia hljs">imgtruesub = imgtrue(Interval(-fovx/2, fovx/2), Interval(-fovy/2, fovy/2))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   X ∈ 256-element LinRange{Float64,...}
→   Y ∈ 256-element LinRange{Float64,...}
And data, 256×256 NamedDimsArray(StructArray(view(::Matrix{Float64}, 385:640, 385:640), view(::Matrix{Float64}, 385:640, 385:640), view(::Matrix{Float64}, 385:640, 385:640), view(::Matrix{Float64}, 385:640, 385:640)), (:X, :Y)):
                 …  (1.2073e-10)
 (-1.2073e-10)         [1.55454e-8, 9.2487e-22, 2.3318e-9, 2.3318e-10]
 (-1.19783e-10)        [1.66253e-8, 9.89119e-22, 2.49379e-9, 2.49379e-10]
 (-1.18836e-10)        [1.77708e-8, 1.05727e-21, 2.66562e-9, 2.66562e-10]
 (-1.17889e-10)        [1.89852e-8, 1.12952e-21, 2.84778e-9, 2.84778e-10]
 (-1.16942e-10)  …     [2.02719e-8, 1.20607e-21, 3.04078e-9, 3.04078e-10]
 (-1.15995e-10)        [2.16343e-8, 1.28713e-21, 3.24515e-9, 3.24515e-10]
    ⋮            ⋱  
  (1.15049e-10)        [2.30761e-8, 1.37291e-21, 3.46142e-9, 3.46142e-10]
  (1.15995e-10)        [2.16343e-8, 1.28713e-21, 3.24515e-9, 3.24515e-10]
  (1.16942e-10)  …     [2.02719e-8, 1.20607e-21, 3.04078e-9, 3.04078e-10]
  (1.17889e-10)        [1.89852e-8, 1.12952e-21, 2.84778e-9, 2.84778e-10]
  (1.18836e-10)        [1.77708e-8, 1.05727e-21, 2.66562e-9, 2.66562e-10]
  (1.19783e-10)        [1.66253e-8, 9.89119e-22, 2.49379e-9, 2.49379e-10]
  (1.2073e-10)         [1.55454e-8, 9.2487e-22, 2.3318e-9, 2.3318e-10]</code></pre><p>plot(imgtruesub, title=&quot;True Image&quot;, xlims=(-25.0,25.0), ylims=(-25.0,25.0))</p><pre><code class="language-julia hljs">img = intensitymap!(copy(imgtruesub), model(xopt, metadata))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   X ∈ 256-element LinRange{Float64,...}
→   Y ∈ 256-element LinRange{Float64,...}
And data, 256×256 NamedDimsArray(StructArray(::Matrix{Float64}, ::Matrix{Float64}, ::Matrix{Float64}, ::Matrix{Float64}), (:X, :Y)):
                 …  (1.2073e-10)
 (-1.2073e-10)         [3.99759e-8, -1.44625e-8, 5.47411e-9, 1.79719e-9]
 (-1.19783e-10)        [4.11281e-8, -1.48171e-8, 5.6857e-9, 1.86101e-9]
 (-1.18836e-10)        [4.22783e-8, -1.51646e-8, 5.9025e-9, 1.92596e-9]
 (-1.17889e-10)        [4.34254e-8, -1.55044e-8, 6.12455e-9, 1.99205e-9]
 (-1.16942e-10)  …     [4.45683e-8, -1.58358e-8, 6.35192e-9, 2.05926e-9]
 (-1.15995e-10)        [4.57058e-8, -1.61582e-8, 6.58466e-9, 2.1276e-9]
    ⋮            ⋱  
  (1.15049e-10)        [1.34041e-8, 2.33155e-9, -6.34712e-10, 4.94268e-9]
  (1.15995e-10)        [1.3061e-8, 2.2638e-9, -6.74439e-10, 4.85773e-9]
  (1.16942e-10)  …     [1.27176e-8, 2.19672e-9, -7.09283e-10, 4.7691e-9]
  (1.17889e-10)        [1.23744e-8, 2.13033e-9, -7.39433e-10, 4.677e-9]
  (1.18836e-10)        [1.20315e-8, 2.06465e-9, -7.65075e-10, 4.58167e-9]
  (1.19783e-10)        [1.16892e-8, 1.99971e-9, -7.86396e-10, 4.48335e-9]
  (1.2073e-10)         [1.13479e-8, 1.93553e-9, -8.03584e-10, 4.38225e-9]</code></pre><p>plot(img, title=&quot;Reconstructed Image&quot;, xlims=(-25.0,25.0), ylims=(-25.0,25.0))</p><p>Let&#39;s compare some image statics, like the total linear polarization fraction</p><pre><code class="language-julia hljs">using Comrade.ComradeBase: linearpol
ftrue = flux(imgtruesub);
@info &quot;Linear polarization true image: $(abs(linearpol(ftrue))/ftrue.I)&quot;
frecon = flux(img);
@info &quot;Linear polarization recon image: $(abs(linearpol(frecon))/frecon.I)&quot;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[ Info: Linear polarization true image: 0.15000000000000088
[ Info: Linear polarization recon image: 0.14967033680609462</code></pre><p>And the Circular polarization fraction</p><pre><code class="language-julia hljs">@info &quot;Circular polarization true image: $(ftrue.V/ftrue.I)&quot;
@info &quot;Circular polarization recon image: $(frecon.V/frecon.I)&quot;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[ Info: Circular polarization true image: 0.015000000000000024
[ Info: Circular polarization recon image: -0.009019673795505698</code></pre><p>Because we also fit the instrument model, we can inspect their parameters. To do this, <code>Comrade</code> provides a <code>caltable</code> function that converts the flattened gain parameters to a tabular format based on the time and its segmentation.</p><pre><code class="language-julia hljs">dR = caltable(trackcache, complex.(xopt.dRx, xopt.dRy))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">───────────┬────────────────────────────────────────────────────────────────────
      time │           AA             AP             AZ              JC        ⋯
───────────┼────────────────────────────────────────────────────────────────────
 0.0+0.0im │ 0.009-0.02im  -0.076+0.07im  0.086-0.101im  -0.036+0.053im  0.029 ⋯
───────────┴────────────────────────────────────────────────────────────────────
                                                               3 columns omitted
</code></pre><p>We can compare this to the ground truth d-terms</p><table><tr><th style="text-align: right">time</th><th style="text-align: right">AA</th><th style="text-align: right">AP</th><th style="text-align: right">AZ</th><th style="text-align: right">JC</th><th style="text-align: right">LM</th><th style="text-align: right">PV</th><th style="text-align: right">SM</th></tr><tr><td style="text-align: right">0.0</td><td style="text-align: right">0.01-0.02im</td><td style="text-align: right">-0.08+0.07im</td><td style="text-align: right">0.09-0.10im</td><td style="text-align: right">-0.04+0.05im</td><td style="text-align: right">0.03-0.02im</td><td style="text-align: right">-0.01+0.02im</td><td style="text-align: right">0.08-0.07im</td></tr></table><p>And same for the left-handed dterms</p><pre><code class="language-julia hljs">dL = caltable(trackcache, complex.(xopt.dLx, xopt.dLy))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">───────────┬────────────────────────────────────────────────────────────────────
      time │           AA              AP             AZ              JC       ⋯
───────────┼────────────────────────────────────────────────────────────────────
 0.0+0.0im │ 0.032-0.04im  -0.063+0.049im  0.094-0.079im  -0.061+0.072im  0.01 ⋯
───────────┴────────────────────────────────────────────────────────────────────
                                                               3 columns omitted
</code></pre><table><tr><th style="text-align: right">time</th><th style="text-align: right">AA</th><th style="text-align: right">AP</th><th style="text-align: right">AZ</th><th style="text-align: right">JC</th><th style="text-align: right">LM</th><th style="text-align: right">PV</th><th style="text-align: right">SM</th></tr><tr><td style="text-align: right">0.0</td><td style="text-align: right">0.03-0.04im</td><td style="text-align: right">-0.06+0.05im</td><td style="text-align: right">0.09-0.08im</td><td style="text-align: right">-0.06+0.07im</td><td style="text-align: right">0.01-0.00im</td><td style="text-align: right">-0.03+0.04im</td><td style="text-align: right">0.06-0.05im</td></tr></table><p>Looking at the gain phase ratio</p><pre><code class="language-julia hljs">gphase_ratio = caltable(trackcache, xopt.gpr)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">──────┬───────────────────────────────────────────────
 time │    AA     AP    AZ     JC    LM     PV     SM
──────┼───────────────────────────────────────────────
  0.0 │ 0.032  0.032  0.03  0.028  0.03  0.021  0.029
──────┴───────────────────────────────────────────────
</code></pre><p>we see that they are all very small. Which should be the case since this data doesn&#39;t have gain corruptions! Similarly our gain ratio amplitudes are also very close to unity as expected.</p><pre><code class="language-julia hljs">gamp_ratio   = caltable(trackcache, exp.(xopt.lgr))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">──────┬─────────────────────────────────────────────────
 time │    AA     AP     AZ     JC     LM     PV     SM
──────┼─────────────────────────────────────────────────
  0.0 │ 1.025  1.025  1.024  1.025  1.025  1.014  1.024
──────┴─────────────────────────────────────────────────
</code></pre><p>Plotting the gain phases, we see some offsets from zero. This is because the prior on the gain product phases is very broad, so we can&#39;t phase center the image. For realistic data this is always the case since the atmosphere effectively scrambles the phases.</p><pre><code class="language-julia hljs">gphase_prod = caltable(phasecache, xopt.gpp)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">────────┬──────────────────────────────────────────────────────
   time │      AP       AZ       JC       LM       PV       SM
────────┼──────────────────────────────────────────────────────
    0.0 │ missing  missing    0.071  missing  missing    0.085
  0.333 │ missing  missing   -1.048  missing  missing   -1.049
  0.667 │ missing  missing   -2.166  missing  missing    -2.16
    1.0 │ missing  missing   -0.513  missing  missing   -0.508
  1.333 │ missing  missing    1.777  missing  missing     1.78
  1.667 │ missing  missing    0.694  missing  missing    0.698
  9.667 │   0.001  missing  missing  missing    1.513  missing
   10.0 │    -0.0  missing  missing  missing    1.513  missing
 10.333 │   0.002  missing  missing  missing    1.512  missing
 10.667 │    -0.0  missing  missing  missing      1.5  missing
   11.0 │    -0.0  missing  missing  missing    1.487  missing
 11.333 │  -0.001  missing  missing  missing    1.476  missing
 11.667 │   0.001  missing  missing  missing    1.454  missing
   12.0 │   0.001  missing  missing  missing    1.426  missing
 12.333 │     0.0  missing  missing  missing    1.398  missing
 12.667 │   0.002  missing  missing  missing    1.359  missing
   ⋮    │    ⋮        ⋮        ⋮        ⋮        ⋮        ⋮
────────┴──────────────────────────────────────────────────────
                                                33 rows omitted
</code></pre><p>plot(gphase_prod, layout=(3,3), size=(650,500))</p><p>Finally, the product gain amplitudes are all very close to unity as well, as expected since gain corruptions have not been added to the data.</p><pre><code class="language-julia hljs">gamp_prod = caltable(scancache, exp.(xopt.lgp))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">────────┬───────────────────────────────────────────────────────────────
   time │      AA       AP       AZ       JC       LM       PV       SM
────────┼───────────────────────────────────────────────────────────────
    0.0 │ missing  missing  missing    0.986  missing  missing    0.986
  0.333 │ missing  missing  missing    0.991  missing  missing     0.99
  0.667 │ missing  missing  missing     0.99  missing  missing    0.991
    1.0 │ missing  missing  missing    0.998  missing  missing    0.996
  1.333 │ missing  missing  missing    0.995  missing  missing    0.995
  1.667 │ missing  missing  missing    0.994  missing  missing    0.991
  9.667 │   0.989    0.999  missing  missing  missing    1.048  missing
   10.0 │   0.979    1.013  missing  missing  missing    1.064  missing
 10.333 │   1.001    0.988  missing  missing  missing    1.033  missing
 10.667 │   0.997    0.993  missing  missing  missing    1.038  missing
   11.0 │   0.995    0.995  missing  missing  missing    1.042  missing
 11.333 │   0.999    0.991  missing  missing  missing    1.033  missing
 11.667 │   0.998    0.993  missing  missing  missing    1.026  missing
   12.0 │   0.992    0.998  missing  missing  missing    1.036  missing
 12.333 │   0.999    0.992  missing  missing  missing    1.023  missing
 12.667 │   1.004    0.987  missing  missing  missing    1.012  missing
   ⋮    │    ⋮        ⋮        ⋮        ⋮        ⋮        ⋮        ⋮
────────┴───────────────────────────────────────────────────────────────
                                                         33 rows omitted
</code></pre><p>plot(gamp_prod, layout=(3,3), size=(650,500))</p><p>At this point, you should run the sampler to recover an uncertainty estimate, which is identical to every other imaging example (see, e.g., <a href="../imaging_vis/#Stokes-I-Simultaneous-Image-and-Instrument-Modeling">Stokes I Simultaneous Image and Instrument Modeling</a>. However, due to the time it takes to sample, we will skip that for this tutorial. Note that on the computer environment listed below, 20_000 MCMC steps take 4 hours.</p><h2 id="Computing-information"><a class="docs-heading-anchor" href="#Computing-information">Computing information</a><a id="Computing-information-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-information" title="Permalink"></a></h2><pre><code class="nohighlight hljs">Julia Version 1.8.5
Commit 17cfb8e65ea (2023-01-08 06:45 UTC)
Platform Info:
  OS: Linux (x86_64-linux-gnu)
  CPU: 32 × AMD Ryzen 9 7950X 16-Core Processor
  WORD_SIZE: 64
  LIBM: libopenlibm
  LLVM: libLLVM-13.0.1 (ORCJIT, znver3)
  Threads: 1 on 32 virtual cores
Environment:
  JULIA_EDITOR = code
  JULIA_NUM_THREADS = 1</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Hamaker J.P, Bregman J.D., Sault R.J. (1996) [https://articles.adsabs.harvard.edu/pdf/1996A%26AS..117..137H]</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>Pesce D. (2021) [https://ui.adsabs.harvard.edu/abs/2021AJ....161..178P/abstract]</li></ul></section></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Monday 17 April 2023 15:50">Monday 17 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
