<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Imaging a Black Hole using only Closure Quantities · Comrade.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Comrade.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../benchmarks/">Benchmarks</a></li><li><a class="tocitem" href="../../vlbi_imaging_problem/">Introduction to the VLBI Imaging Problem</a></li><li><a class="tocitem" href="../../conventions/">Conventions</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../data/">Loading Data into Comrade</a></li></ul></li><li><span class="tocitem">Libraries</span><ul><li><a class="tocitem" href="../../libs/optimization/">ComradeOptimization</a></li><li><a class="tocitem" href="../../libs/ahmc/">ComradeAHMC</a></li><li><a class="tocitem" href="../../libs/nested/">ComradeNested</a></li><li><a class="tocitem" href="../../libs/dynesty/">ComradeDynesty</a></li><li><a class="tocitem" href="../../libs/adaptmcmc/">ComradeAdaptMCMC</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Imaging a Black Hole using only Closure Quantities</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Imaging a Black Hole using only Closure Quantities</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ptiede/Comrade.jl/blob/main/examples/imaging_closures.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Imaging-a-Black-Hole-using-only-Closure-Quantities"><a class="docs-heading-anchor" href="#Imaging-a-Black-Hole-using-only-Closure-Quantities">Imaging a Black Hole using only Closure Quantities</a><a id="Imaging-a-Black-Hole-using-only-Closure-Quantities-1"></a><a class="docs-heading-anchor-permalink" href="#Imaging-a-Black-Hole-using-only-Closure-Quantities" title="Permalink"></a></h1><p>In this tutorial, we will create a preliminary reconstruction of the 2017 M87 data on April 6 using closure-only imaging. This tutorial is a general introduction to closure-only imaging in Comrade. For an introduction to simultaneous image and instrument modeling, see <a href="../imaging_vis/#Stokes-I-Simultaneous-Image-and-Instrument-Modeling">Stokes I Simultaneous Image and Instrument Modeling</a></p><h2 id="Introduction-to-Closure-Imaging"><a class="docs-heading-anchor" href="#Introduction-to-Closure-Imaging">Introduction to Closure Imaging</a><a id="Introduction-to-Closure-Imaging-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction-to-Closure-Imaging" title="Permalink"></a></h2><p>The EHT is the highest-resolution telescope ever created. Its resolution is equivalent to roughly tracking a hockey puck on the moon when viewing it from the earth. However, the EHT is also a unique interferometer. For one, the data it produces is incredibly sparse. The array is formed from only eight geographic locations around the planet, each with its unique telescope. Additionally, the EHT observes at a much higher frequency than typical interferometers. As a result, it is often difficult to directly provide calibrated data since the source model can be complicated. This implies there can be large instrumental effects often called <em>gains</em> that can corrupt our signal. One way to deal with this is to fit quantities that are independent of gains. These are often called <strong>closure quantities</strong>. The types of closure quantities are briefly described in <a href="../../vlbi_imaging_problem/#Introduction-to-the-VLBI-Imaging-Problem">Introduction to the VLBI Imaging Problem</a>.</p><p>In this tutorial, we will do closure-only modeling of M87 to produce preliminary images of M87.</p><p>To get started, we will load Comrade</p><pre><code class="language-julia hljs">using Comrade</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">  Activating project at `~/work/Comrade.jl/Comrade.jl/examples`</code></pre><p>For reproducibility we use a stable random number genreator</p><pre><code class="language-julia hljs">using StableRNGs
rng = StableRNG(123)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">StableRNGs.LehmerRNG(state=0x000000000000000000000000000000f7)</code></pre><h2 id="Load-the-Data"><a class="docs-heading-anchor" href="#Load-the-Data">Load the Data</a><a id="Load-the-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Load-the-Data" title="Permalink"></a></h2><p>To download the data visit https://doi.org/10.25739/g85n-f134 To load the eht-imaging obsdata object we do:</p><pre><code class="language-julia hljs">obs = load_ehtim_uvfits(joinpath(dirname(pathof(Comrade)), &quot;..&quot;, &quot;examples&quot;, &quot;SR1_M87_2017_096_lo_hops_netcal_StokesI.uvfits&quot;))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Python Obsdata: &lt;ehtim.obsdata.Obsdata object at 0x7f5d5bf9b250&gt;</code></pre><p>Now we do some minor preprocessing:</p><ul><li>Scan average the data since the data have been preprocessed so that the gain phases  are coherent.</li><li>Add 2% systematic noise to deal with calibration issues that cause 1% non-closing errors.</li></ul><pre><code class="language-julia hljs">obs = scan_average(obs).add_fractional_noise(0.02)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Python Obsdata: &lt;ehtim.obsdata.Obsdata object at 0x7f5d5cfde710&gt;</code></pre><p>Now, we extract our closure quantities from the EHT data set.</p><pre><code class="language-julia hljs">dlcamp = extract_lcamp(obs; snrcut=3.0)
dcphase = extract_cphase(obs; snrcut=3.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EHTObservation{Float64,Comrade.EHTClosurePhaseDatum{Float64}, ...}
  source: M87
  mjd: 57849
  frequency: 2.27070703125e11
  bandwidth: 1.856e9
  stations: [:AA, :AP, :AZ, :JC, :LM, :PV, :SM]
  nsamples: 152
</code></pre><h2 id="Build-the-Model/Posterior"><a class="docs-heading-anchor" href="#Build-the-Model/Posterior">Build the Model/Posterior</a><a id="Build-the-Model/Posterior-1"></a><a class="docs-heading-anchor-permalink" href="#Build-the-Model/Posterior" title="Permalink"></a></h2><p>For our model, we will be using an image model that consists of a raster of point sources, convolved with some pulse or kernel to make a <code>ContinuousImage</code> object with it <code>Comrade&#39;s.</code> generic image model. Note that <code>ContinuousImage(img, cache)</code> actually creates a <a href="../../api/#Comrade.ModelImage"><code>Comrade.ModelImage</code></a> object that allows <code>Comrade</code> to numerically compute the Fourier transform of the image.</p><pre><code class="language-julia hljs">function model(θ, metadata)
    (;c) = θ
    (; grid, cache) = metadata
    # Construct the image model
    img = IntensityMap(c, grid)
    return  ContinuousImage(img, cache)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">model (generic function with 1 method)</code></pre><p>Now, let&#39;s set up our image model. The EHT&#39;s nominal resolution is 20-25 μas. Additionally, the EHT is not very sensitive to a larger field of views; typically, 60-80 μas is enough to describe the compact flux of M87. Given this, we only need to use a small number of pixels to describe our image.</p><pre><code class="language-julia hljs">npix = 7
fovxy = μas2rad(77.5)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3.7573060285989036e-10</code></pre><p>Now, we can feed in the array information to form the cache. We will be using a DFT since it is efficient for so few pixels We will use a Dirichlet prior, enforcing that the flux sums to unity since closures are degenerate to total flux.</p><pre><code class="language-julia hljs">grid = imagepixels(fovxy, fovxy, npix, npix)
buffer = IntensityMap(zeros(npix,npix), grid)
cache = create_cache(DFTAlg(dlcamp), buffer, BSplinePulse{3}())
metadata = (;grid, cache)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(grid = GriddedKeys{(:X, :Y)}
	X: LinRange{Float64}(-1.610274012256673e-10, 1.610274012256673e-10, 7)
	Y: LinRange{Float64}(-1.610274012256673e-10, 1.610274012256673e-10, 7)
, cache = Comrade.NUFTCache{Comrade.ObservedNUFT{DFTAlg, Matrix{Float64}}, Matrix{ComplexF64}, Vector{ComplexF64}, BSplinePulse{3}, AxisKeys.KeyedArray{Float64, 2, NamedDims.NamedDimsArray{(:X, :Y), Float64, 2, Matrix{Float64}}, GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, Nothing, Float64}}}(Comrade.ObservedNUFT{DFTAlg, Matrix{Float64}}(DFTAlg(), [-4.405690154666661e9 787577.6145833326 … -5.999801315555549e9 -15551.297851562484; -4.523017159111106e9 -1.6838098888888871e6 … 3.059254300444441e9 118294.64453124987]), ComplexF64[-0.9245191124215104 - 0.3811356855075926im 0.30131276219012987 - 0.953525363764045im … 0.30131276219012987 + 0.953525363764045im -0.9245191124215104 + 0.3811356855075926im; 0.9999995888782646 - 0.000906776324033165im 0.999999312749824 - 0.001172390668505908im … 0.999999312749824 + 0.001172390668505908im 0.9999995888782646 + 0.000906776324033165im; … ; -0.9861791362368345 - 0.1656825616990844im 0.5803160899959727 - 0.8143913283500667im … 0.5803160899959722 + 0.8143913283500671im -0.9861791362368345 + 0.1656825616990844im; 0.9999999945969782 + 0.000103952122113533im 0.9999999940380212 + 0.00010919687504810613im … 0.9999999940380212 - 0.00010919687504810613im 0.9999999945969782 - 0.000103952122113533im], ComplexF64[0.4627381083445155 + 0.0im, 0.9999999344948112 + 0.0im, 0.4534816630693232 + 0.0im, 0.7360821375215807 + 0.0im, 0.7362934239815856 + 0.0im, 0.45355745260008706 + 0.0im, 0.5126624251071039 + 0.0im, 0.9999999362048164 + 0.0im, 0.7329860227727403 + 0.0im, 0.4464017959011386 + 0.0im  …  0.4121685902933072 + 0.0im, 0.6412897325606622 + 0.0im, 0.7905852239619925 + 0.0im, 0.7905870556427168 + 0.0im, 0.6838961493776081 + 0.0im, 0.8037977245225527 + 0.0im, 0.6838982004390146 + 0.0im, 0.9592197914429591 + 0.0im, 0.4121605108439113 + 0.0im, 0.9999999997301408 + 0.0im], BSplinePulse{3}(), [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]))</code></pre><p>Now we need to specify our image prior. For this work we use a very simple Dirichlet prior</p><pre><code class="language-julia hljs">using VLBIImagePriors
(;X, Y) = grid
prior = (c = ImageDirichlet(1.0, npix, npix), )

lklhd = RadioLikelihood(model, metadata, dlcamp, dcphase)
post = Posterior(lklhd, prior)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Posterior{RadioLikelihood{Comrade.ModelMetadata{typeof(Main.model), NamedTuple{(:grid, :cache), Tuple{GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, Nothing, Float64}, Comrade.NUFTCache{Comrade.ObservedNUFT{DFTAlg, Matrix{Float64}}, Matrix{ComplexF64}, Vector{ComplexF64}, BSplinePulse{3}, AxisKeys.KeyedArray{Float64, 2, NamedDims.NamedDimsArray{(:X, :Y), Float64, 2, Matrix{Float64}}, GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, Nothing, Float64}}}}}}, Tuple{Comrade.ConditionedLikelihood{Comrade.var&quot;#73#74&quot;{Base.Fix2{typeof(logclosure_amplitudes), Comrade.ClosureConfig{Comrade.EHTObservation{Float64, Comrade.EHTVisibilityDatum{Float64}, StructArrays.StructVector{Comrade.EHTVisibilityDatum{Float64}, NamedTuple{(:measurement, :error, :U, :V, :T, :F, :baseline), Tuple{Vector{ComplexF64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Tuple{Symbol, Symbol}}}}, Int64}, Comrade.EHTArrayConfiguration{Float64, TypedTables.Table{NamedTuple{(:sites, :X, :Y, :Z, :SEFD1, :SEFD2, :fr_parallactic, :fr_elevation, :fr_offset), Tuple{Symbol, Float64, Float64, Float64, Float64, Float64, Float64, Float64, Float64}}, 1, NamedTuple{(:sites, :X, :Y, :Z, :SEFD1, :SEFD2, :fr_parallactic, :fr_elevation, :fr_offset), Tuple{Vector{Symbol}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}}}}, TypedTables.Table{NamedTuple{(:start, :stop), Tuple{Float64, Float64}}, 1, NamedTuple{(:start, :stop), Tuple{Vector{Float64}, Vector{Float64}}}}, StructArrays.StructVector{Comrade.ArrayBaselineDatum, NamedTuple{(:U, :V, :T, :F, :baseline, :error, :elevation, :parallactic), Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Tuple{Symbol, Symbol}}, Vector{Float64}, StructArrays.StructVector{Tuple{Float64, Float64}, Tuple{Vector{Float64}, Vector{Float64}}, Int64}, StructArrays.StructVector{Tuple{Float64, Float64}, Tuple{Vector{Float64}, Vector{Float64}}, Int64}}}, Int64}}, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}}}, Vector{Float64}}, Vector{Float64}}, Comrade.ConditionedLikelihood{Comrade.var&quot;#75#76&quot;{Base.Fix2{typeof(closure_phases), Comrade.ClosureConfig{Comrade.EHTObservation{Float64, Comrade.EHTVisibilityDatum{Float64}, StructArrays.StructVector{Comrade.EHTVisibilityDatum{Float64}, NamedTuple{(:measurement, :error, :U, :V, :T, :F, :baseline), Tuple{Vector{ComplexF64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Tuple{Symbol, Symbol}}}}, Int64}, Comrade.EHTArrayConfiguration{Float64, TypedTables.Table{NamedTuple{(:sites, :X, :Y, :Z, :SEFD1, :SEFD2, :fr_parallactic, :fr_elevation, :fr_offset), Tuple{Symbol, Float64, Float64, Float64, Float64, Float64, Float64, Float64, Float64}}, 1, NamedTuple{(:sites, :X, :Y, :Z, :SEFD1, :SEFD2, :fr_parallactic, :fr_elevation, :fr_offset), Tuple{Vector{Symbol}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}}}}, TypedTables.Table{NamedTuple{(:start, :stop), Tuple{Float64, Float64}}, 1, NamedTuple{(:start, :stop), Tuple{Vector{Float64}, Vector{Float64}}}}, StructArrays.StructVector{Comrade.ArrayBaselineDatum, NamedTuple{(:U, :V, :T, :F, :baseline, :error, :elevation, :parallactic), Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Tuple{Symbol, Symbol}}, Vector{Float64}, StructArrays.StructVector{Tuple{Float64, Float64}, Tuple{Vector{Float64}, Vector{Float64}}, Int64}, StructArrays.StructVector{Tuple{Float64, Float64}, Tuple{Vector{Float64}, Vector{Float64}}, Int64}}}, Int64}}, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}}}, Vector{Float64}}, Vector{Float64}}}, Comrade.ClosureConfig{Comrade.EHTObservation{Float64, Comrade.EHTVisibilityDatum{Float64}, StructArrays.StructVector{Comrade.EHTVisibilityDatum{Float64}, NamedTuple{(:measurement, :error, :U, :V, :T, :F, :baseline), Tuple{Vector{ComplexF64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Tuple{Symbol, Symbol}}}}, Int64}, Comrade.EHTArrayConfiguration{Float64, TypedTables.Table{NamedTuple{(:sites, :X, :Y, :Z, :SEFD1, :SEFD2, :fr_parallactic, :fr_elevation, :fr_offset), Tuple{Symbol, Float64, Float64, Float64, Float64, Float64, Float64, Float64, Float64}}, 1, NamedTuple{(:sites, :X, :Y, :Z, :SEFD1, :SEFD2, :fr_parallactic, :fr_elevation, :fr_offset), Tuple{Vector{Symbol}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}}}}, TypedTables.Table{NamedTuple{(:start, :stop), Tuple{Float64, Float64}}, 1, NamedTuple{(:start, :stop), Tuple{Vector{Float64}, Vector{Float64}}}}, StructArrays.StructVector{Comrade.ArrayBaselineDatum, NamedTuple{(:U, :V, :T, :F, :baseline, :error, :elevation, :parallactic), Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Tuple{Symbol, Symbol}}, Vector{Float64}, StructArrays.StructVector{Tuple{Float64, Float64}, Tuple{Vector{Float64}, Vector{Float64}}, Int64}, StructArrays.StructVector{Tuple{Float64, Float64}, Tuple{Vector{Float64}, Vector{Float64}}, Int64}}}, Int64}}, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}}, NamedTuple{(:U, :V, :T, :F), NTuple{4, Vector{Float64}}}}, Comrade.NamedDist{(:c,), Tuple{VLBIImagePriors.ImageDirichlet{Float64, FillArrays.Fill{Float64, 2, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}}, Float64}}}}(RadioLikelihood
	Number of data products: 2
, Comrade.NamedDist{(:c,), Tuple{VLBIImagePriors.ImageDirichlet{Float64, FillArrays.Fill{Float64, 2, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}}, Float64}}}((VLBIImagePriors.ImageDirichlet{Float64, FillArrays.Fill{Float64, 2, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}}, Float64}(
α: Fill(1.0, 7, 7)
α0: 49.0
lmnB: -140.67392364823425
)
,)))</code></pre><h2 id="Reconstructing-the-Image"><a class="docs-heading-anchor" href="#Reconstructing-the-Image">Reconstructing the Image</a><a id="Reconstructing-the-Image-1"></a><a class="docs-heading-anchor-permalink" href="#Reconstructing-the-Image" title="Permalink"></a></h2><p>To sample from this posterior, it is convenient to first move from our constrained parameter space to an unconstrained one (i.e., the support of the transformed posterior is (-∞, ∞)). This is done using the <code>asflat</code> function.</p><pre><code class="language-julia hljs">tpost = asflat(post)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Comrade.TransformedPosterior{Posterior{RadioLikelihood{Comrade.ModelMetadata{typeof(Main.model), NamedTuple{(:grid, :cache), Tuple{GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, Nothing, Float64}, Comrade.NUFTCache{Comrade.ObservedNUFT{DFTAlg, Matrix{Float64}}, Matrix{ComplexF64}, Vector{ComplexF64}, BSplinePulse{3}, AxisKeys.KeyedArray{Float64, 2, NamedDims.NamedDimsArray{(:X, :Y), Float64, 2, Matrix{Float64}}, GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, Nothing, Float64}}}}}}, Tuple{Comrade.ConditionedLikelihood{Comrade.var&quot;#73#74&quot;{Base.Fix2{typeof(logclosure_amplitudes), Comrade.ClosureConfig{Comrade.EHTObservation{Float64, Comrade.EHTVisibilityDatum{Float64}, StructArrays.StructVector{Comrade.EHTVisibilityDatum{Float64}, NamedTuple{(:measurement, :error, :U, :V, :T, :F, :baseline), Tuple{Vector{ComplexF64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Tuple{Symbol, Symbol}}}}, Int64}, Comrade.EHTArrayConfiguration{Float64, TypedTables.Table{NamedTuple{(:sites, :X, :Y, :Z, :SEFD1, :SEFD2, :fr_parallactic, :fr_elevation, :fr_offset), Tuple{Symbol, Float64, Float64, Float64, Float64, Float64, Float64, Float64, Float64}}, 1, NamedTuple{(:sites, :X, :Y, :Z, :SEFD1, :SEFD2, :fr_parallactic, :fr_elevation, :fr_offset), Tuple{Vector{Symbol}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}}}}, TypedTables.Table{NamedTuple{(:start, :stop), Tuple{Float64, Float64}}, 1, NamedTuple{(:start, :stop), Tuple{Vector{Float64}, Vector{Float64}}}}, StructArrays.StructVector{Comrade.ArrayBaselineDatum, NamedTuple{(:U, :V, :T, :F, :baseline, :error, :elevation, :parallactic), Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Tuple{Symbol, Symbol}}, Vector{Float64}, StructArrays.StructVector{Tuple{Float64, Float64}, Tuple{Vector{Float64}, Vector{Float64}}, Int64}, StructArrays.StructVector{Tuple{Float64, Float64}, Tuple{Vector{Float64}, Vector{Float64}}, Int64}}}, Int64}}, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}}}, Vector{Float64}}, Vector{Float64}}, Comrade.ConditionedLikelihood{Comrade.var&quot;#75#76&quot;{Base.Fix2{typeof(closure_phases), Comrade.ClosureConfig{Comrade.EHTObservation{Float64, Comrade.EHTVisibilityDatum{Float64}, StructArrays.StructVector{Comrade.EHTVisibilityDatum{Float64}, NamedTuple{(:measurement, :error, :U, :V, :T, :F, :baseline), Tuple{Vector{ComplexF64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Tuple{Symbol, Symbol}}}}, Int64}, Comrade.EHTArrayConfiguration{Float64, TypedTables.Table{NamedTuple{(:sites, :X, :Y, :Z, :SEFD1, :SEFD2, :fr_parallactic, :fr_elevation, :fr_offset), Tuple{Symbol, Float64, Float64, Float64, Float64, Float64, Float64, Float64, Float64}}, 1, NamedTuple{(:sites, :X, :Y, :Z, :SEFD1, :SEFD2, :fr_parallactic, :fr_elevation, :fr_offset), Tuple{Vector{Symbol}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}}}}, TypedTables.Table{NamedTuple{(:start, :stop), Tuple{Float64, Float64}}, 1, NamedTuple{(:start, :stop), Tuple{Vector{Float64}, Vector{Float64}}}}, StructArrays.StructVector{Comrade.ArrayBaselineDatum, NamedTuple{(:U, :V, :T, :F, :baseline, :error, :elevation, :parallactic), Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Tuple{Symbol, Symbol}}, Vector{Float64}, StructArrays.StructVector{Tuple{Float64, Float64}, Tuple{Vector{Float64}, Vector{Float64}}, Int64}, StructArrays.StructVector{Tuple{Float64, Float64}, Tuple{Vector{Float64}, Vector{Float64}}, Int64}}}, Int64}}, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}}}, Vector{Float64}}, Vector{Float64}}}, Comrade.ClosureConfig{Comrade.EHTObservation{Float64, Comrade.EHTVisibilityDatum{Float64}, StructArrays.StructVector{Comrade.EHTVisibilityDatum{Float64}, NamedTuple{(:measurement, :error, :U, :V, :T, :F, :baseline), Tuple{Vector{ComplexF64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Tuple{Symbol, Symbol}}}}, Int64}, Comrade.EHTArrayConfiguration{Float64, TypedTables.Table{NamedTuple{(:sites, :X, :Y, :Z, :SEFD1, :SEFD2, :fr_parallactic, :fr_elevation, :fr_offset), Tuple{Symbol, Float64, Float64, Float64, Float64, Float64, Float64, Float64, Float64}}, 1, NamedTuple{(:sites, :X, :Y, :Z, :SEFD1, :SEFD2, :fr_parallactic, :fr_elevation, :fr_offset), Tuple{Vector{Symbol}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}}}}, TypedTables.Table{NamedTuple{(:start, :stop), Tuple{Float64, Float64}}, 1, NamedTuple{(:start, :stop), Tuple{Vector{Float64}, Vector{Float64}}}}, StructArrays.StructVector{Comrade.ArrayBaselineDatum, NamedTuple{(:U, :V, :T, :F, :baseline, :error, :elevation, :parallactic), Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Tuple{Symbol, Symbol}}, Vector{Float64}, StructArrays.StructVector{Tuple{Float64, Float64}, Tuple{Vector{Float64}, Vector{Float64}}, Int64}, StructArrays.StructVector{Tuple{Float64, Float64}, Tuple{Vector{Float64}, Vector{Float64}}, Int64}}}, Int64}}, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}}, NamedTuple{(:U, :V, :T, :F), NTuple{4, Vector{Float64}}}}, Comrade.NamedDist{(:c,), Tuple{VLBIImagePriors.ImageDirichlet{Float64, FillArrays.Fill{Float64, 2, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}}, Float64}}}}, TransformVariables.TransformTuple{NamedTuple{(:c,), Tuple{VLBIImagePriors.ImageSimplex}}}}(Posterior{RadioLikelihood{Comrade.ModelMetadata{typeof(Main.model), NamedTuple{(:grid, :cache), Tuple{GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, Nothing, Float64}, Comrade.NUFTCache{Comrade.ObservedNUFT{DFTAlg, Matrix{Float64}}, Matrix{ComplexF64}, Vector{ComplexF64}, BSplinePulse{3}, AxisKeys.KeyedArray{Float64, 2, NamedDims.NamedDimsArray{(:X, :Y), Float64, 2, Matrix{Float64}}, GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, Nothing, Float64}}}}}}, Tuple{Comrade.ConditionedLikelihood{Comrade.var&quot;#73#74&quot;{Base.Fix2{typeof(logclosure_amplitudes), Comrade.ClosureConfig{Comrade.EHTObservation{Float64, Comrade.EHTVisibilityDatum{Float64}, StructArrays.StructVector{Comrade.EHTVisibilityDatum{Float64}, NamedTuple{(:measurement, :error, :U, :V, :T, :F, :baseline), Tuple{Vector{ComplexF64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Tuple{Symbol, Symbol}}}}, Int64}, Comrade.EHTArrayConfiguration{Float64, TypedTables.Table{NamedTuple{(:sites, :X, :Y, :Z, :SEFD1, :SEFD2, :fr_parallactic, :fr_elevation, :fr_offset), Tuple{Symbol, Float64, Float64, Float64, Float64, Float64, Float64, Float64, Float64}}, 1, NamedTuple{(:sites, :X, :Y, :Z, :SEFD1, :SEFD2, :fr_parallactic, :fr_elevation, :fr_offset), Tuple{Vector{Symbol}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}}}}, TypedTables.Table{NamedTuple{(:start, :stop), Tuple{Float64, Float64}}, 1, NamedTuple{(:start, :stop), Tuple{Vector{Float64}, Vector{Float64}}}}, StructArrays.StructVector{Comrade.ArrayBaselineDatum, NamedTuple{(:U, :V, :T, :F, :baseline, :error, :elevation, :parallactic), Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Tuple{Symbol, Symbol}}, Vector{Float64}, StructArrays.StructVector{Tuple{Float64, Float64}, Tuple{Vector{Float64}, Vector{Float64}}, Int64}, StructArrays.StructVector{Tuple{Float64, Float64}, Tuple{Vector{Float64}, Vector{Float64}}, Int64}}}, Int64}}, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}}}, Vector{Float64}}, Vector{Float64}}, Comrade.ConditionedLikelihood{Comrade.var&quot;#75#76&quot;{Base.Fix2{typeof(closure_phases), Comrade.ClosureConfig{Comrade.EHTObservation{Float64, Comrade.EHTVisibilityDatum{Float64}, StructArrays.StructVector{Comrade.EHTVisibilityDatum{Float64}, NamedTuple{(:measurement, :error, :U, :V, :T, :F, :baseline), Tuple{Vector{ComplexF64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Tuple{Symbol, Symbol}}}}, Int64}, Comrade.EHTArrayConfiguration{Float64, TypedTables.Table{NamedTuple{(:sites, :X, :Y, :Z, :SEFD1, :SEFD2, :fr_parallactic, :fr_elevation, :fr_offset), Tuple{Symbol, Float64, Float64, Float64, Float64, Float64, Float64, Float64, Float64}}, 1, NamedTuple{(:sites, :X, :Y, :Z, :SEFD1, :SEFD2, :fr_parallactic, :fr_elevation, :fr_offset), Tuple{Vector{Symbol}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}}}}, TypedTables.Table{NamedTuple{(:start, :stop), Tuple{Float64, Float64}}, 1, NamedTuple{(:start, :stop), Tuple{Vector{Float64}, Vector{Float64}}}}, StructArrays.StructVector{Comrade.ArrayBaselineDatum, NamedTuple{(:U, :V, :T, :F, :baseline, :error, :elevation, :parallactic), Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Tuple{Symbol, Symbol}}, Vector{Float64}, StructArrays.StructVector{Tuple{Float64, Float64}, Tuple{Vector{Float64}, Vector{Float64}}, Int64}, StructArrays.StructVector{Tuple{Float64, Float64}, Tuple{Vector{Float64}, Vector{Float64}}, Int64}}}, Int64}}, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}}}, Vector{Float64}}, Vector{Float64}}}, Comrade.ClosureConfig{Comrade.EHTObservation{Float64, Comrade.EHTVisibilityDatum{Float64}, StructArrays.StructVector{Comrade.EHTVisibilityDatum{Float64}, NamedTuple{(:measurement, :error, :U, :V, :T, :F, :baseline), Tuple{Vector{ComplexF64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Tuple{Symbol, Symbol}}}}, Int64}, Comrade.EHTArrayConfiguration{Float64, TypedTables.Table{NamedTuple{(:sites, :X, :Y, :Z, :SEFD1, :SEFD2, :fr_parallactic, :fr_elevation, :fr_offset), Tuple{Symbol, Float64, Float64, Float64, Float64, Float64, Float64, Float64, Float64}}, 1, NamedTuple{(:sites, :X, :Y, :Z, :SEFD1, :SEFD2, :fr_parallactic, :fr_elevation, :fr_offset), Tuple{Vector{Symbol}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}}}}, TypedTables.Table{NamedTuple{(:start, :stop), Tuple{Float64, Float64}}, 1, NamedTuple{(:start, :stop), Tuple{Vector{Float64}, Vector{Float64}}}}, StructArrays.StructVector{Comrade.ArrayBaselineDatum, NamedTuple{(:U, :V, :T, :F, :baseline, :error, :elevation, :parallactic), Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Tuple{Symbol, Symbol}}, Vector{Float64}, StructArrays.StructVector{Tuple{Float64, Float64}, Tuple{Vector{Float64}, Vector{Float64}}, Int64}, StructArrays.StructVector{Tuple{Float64, Float64}, Tuple{Vector{Float64}, Vector{Float64}}, Int64}}}, Int64}}, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}}, NamedTuple{(:U, :V, :T, :F), NTuple{4, Vector{Float64}}}}, Comrade.NamedDist{(:c,), Tuple{VLBIImagePriors.ImageDirichlet{Float64, FillArrays.Fill{Float64, 2, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}}, Float64}}}}(RadioLikelihood
	Number of data products: 2
, Comrade.NamedDist{(:c,), Tuple{VLBIImagePriors.ImageDirichlet{Float64, FillArrays.Fill{Float64, 2, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}}, Float64}}}((VLBIImagePriors.ImageDirichlet{Float64, FillArrays.Fill{Float64, 2, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}}, Float64}(
α: Fill(1.0, 7, 7)
α0: 49.0
lmnB: -140.67392364823425
)
,))), TransformVariables.TransformTuple{NamedTuple{(:c,), Tuple{VLBIImagePriors.ImageSimplex}}}((c = VLBIImagePriors.ImageSimplex(49, (7, 7)),), 48))</code></pre><p>We can now also find the dimension of our posterior or the number of parameters we will sample. !!! Warning    This can often be different from what you would expect. This is especially true when using    angular variables, where we often artificially increase the dimension    of the parameter space to make sampling easier.</p><pre><code class="language-julia hljs">ndim = dimension(tpost)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">48</code></pre><p>Now we optimize. First we will use BlackBoxOptim which is a genetic algorithm to get us in the region of the best fit model.</p><pre><code class="language-julia hljs">using ComradeOptimization
using OptimizationBBO
f = OptimizationFunction(tpost, Optimization.AutoForwardDiff())
prob = Optimization.OptimizationProblem(f, prior_sample(tpost), nothing, lb=fill(-5.0, ndim), ub=fill(5.0,ndim))
sol = solve(prob, BBO_adaptive_de_rand_1_bin_radiuslimited(); maxiters=100_000)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">u: 48-element Vector{Float64}:
 -1.1585639389228914
  0.9400072810958364
  0.4976974453104019
  0.7441646050786739
  2.1677037872099962
  1.1564029704637115
  0.7482141142585904
 -1.6996236348599836
 -1.3280767322215525
 -0.9662199324828094
  ⋮
  0.211476543479327
 -0.09463024638656606
  1.1670435063644276
 -1.4385944241195958
  0.3572762937652326
 -1.2100724691856986
 -2.0667233430211396
 -0.544066580090051
 -1.1965122331270401</code></pre><p>Alright now let&#39;s zoom to the peak</p><pre><code class="language-julia hljs">using OptimizationOptimJL
prob = Optimization.OptimizationProblem(f, sol.u, nothing)
ℓ = logdensityof(tpost)
sol = solve(prob, LBFGS(), maxiters=1_000, callback=((x,p)-&gt;(@info ℓ(x);false)), g_tol=1e-1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">u: 48-element Vector{Float64}:
 -0.4710307731171538
 -0.15637746784814482
  0.4695756286424951
 -0.5474096099303926
 -0.6180280316933767
 -1.489104688364224
 -0.3532985607099067
 -0.19825824270874284
 -1.604562818918376
 -1.4742468488142852
  ⋮
  1.2301644663170757
 -0.06154000344890478
 -0.7531314031468013
 -0.9157815888718688
 -0.37968108000032463
  0.9025251339140933
 -2.318601199780869
 -2.2589905103991406
 -0.10809440036853409</code></pre><p>Before we analyze our solution we first need to transform back to parameter space.</p><pre><code class="language-julia hljs">xopt = transform(tpost, sol)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(c = [0.012840444288853062 0.01753536906348084 … 0.011595362790060583 0.009097512684855468; 0.017641845621904826 0.0043823982156754576 … 0.002711811103821727 0.01641493873900771; … ; 0.0047689997480537 0.05287457048772518 … 0.018251273410826517 0.03230538432275506; 0.014952648884390478 0.03665303935036868 … 0.009787155873421306 0.0359931381737468],)</code></pre><p>First we will evaluate our fit by plotting the residuals</p><pre><code class="language-julia hljs">using Plots</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">WARNING: using Plots.grid in module Main conflicts with an existing identifier.</code></pre><p>residual(model(xopt, metadata), dlcamp) residual(model(xopt, metadata), dcphase)</p><p>These look pretty reasonable, although maybe they are a bit high. This could probably be improved in a few ways, but that is beyond the goal of this quick tutorial. Plotting the image, we have recovered a ring-like image reproducing the first EHT results.</p><pre><code class="language-julia hljs">img = intensitymap(model(xopt, metadata), μas2rad(120.0), μas2rad(120.0), 128, 128)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   X ∈ 128-element LinRange{Float64,...}
→   Y ∈ 128-element LinRange{Float64,...}
And data, 128×128 NamedDimsArray(::Matrix{Float64}, (:X, :Y)):
                 (-2.88616e-10)  …  (2.84071e-10)  (2.88616e-10)
 (-2.88616e-10)     0.0               0.0            0.0
 (-2.84071e-10)     0.0               0.0            0.0
 (-2.79525e-10)     0.0               0.0            0.0
 (-2.7498e-10)      0.0               0.0            0.0
 (-2.70435e-10)     0.0          …    0.0            0.0
 (-2.6589e-10)      0.0               0.0            0.0
    ⋮                            ⋱    ⋮            
  (2.61345e-10)     0.0               0.0            0.0
  (2.6589e-10)      0.0               0.0            0.0
  (2.70435e-10)     0.0          …    0.0            0.0
  (2.7498e-10)      0.0               0.0            0.0
  (2.79525e-10)     0.0               0.0            0.0
  (2.84071e-10)     0.0               0.0            0.0
  (2.88616e-10)     0.0               0.0            0.0</code></pre><p>plot(img, title=&quot;MAP Image&quot;)</p><p>To sample from the posterior we will use HMC and more specifically the NUTS algorithm. For information about NUTS see Michael Betancourt&#39;s <a href="https://arxiv.org/abs/1701.02434">notes</a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For our <code>metric</code> we use a diagonal matrix due to easier tuning.</p></div></div><pre><code class="language-julia hljs">using ComradeAHMC
using Zygote
metric = DiagEuclideanMetric(ndim)
chain, stats = sample(post, AHMC(;metric, autodiff=Val(:Zygote)), 500; nadapts=250, init_params=xopt)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(NamedTuple{(:c,), Tuple{Base.ReshapedArray{Float64, 2, SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{Int64}}, true}, Tuple{}}}}[(c = [0.012521596094009376 0.016500649712861592 … 0.011252451506829516 0.008915921655779362; 0.01688499372537104 0.004400547422298605 … 0.0027303066828839053 0.016984607934215544; … ; 0.004730630257624752 0.05305080090124118 … 0.01846978883380245 0.03194484245097334; 0.014964602062110683 0.03649542493855583 … 0.009645385414057017 0.035233983404428376],), (c = [0.01874968585979207 0.01563268062399462 … 0.013723157849614748 0.0010243038045712033; 0.019037728448033517 0.0074959850203191345 … 0.0013188948612308678 0.016411222076454436; … ; 0.0030550449514874047 0.05408822688012638 … 0.02477535457253064 0.024264886676569127; 0.0150383132104095 0.030897493071382603 … 0.0015338958626534831 0.029532258430139922],), (c = [0.013067376866020483 0.015610714385235275 … 0.013251406242129875 0.0019482874802885769; 0.015889028820817542 0.008933068555282938 … 0.002853631190234515 0.015580386323268636; … ; 0.004198919430894809 0.0542522510378417 … 0.021408169657570357 0.017776993657013507; 0.018635233086340297 0.03213521954177265 … 0.0033763110430930225 0.03325591206623635],), (c = [0.014825106194498885 0.015252204003546417 … 0.012653259855159986 0.0021002215566577474; 0.02233697280111972 0.008540004712469688 … 0.002385933607898549 0.016531683062376495; … ; 0.005242542070212203 0.05524070047165515 … 0.01767944512765791 0.019564784522624383; 0.014578086983641733 0.03380845078481635 … 0.003485101580326172 0.030225027884577337],), (c = [0.018472136294848885 0.008667202390983305 … 0.009844171310177303 0.004745503491702885; 0.022034542318377898 0.003225220987084573 … 0.0011352537724834825 0.0257895571555738; … ; 0.011617411987953397 0.04200697417558426 … 0.014600640386447919 0.03481657307941412; 0.0036177192308348037 0.06332907338021318 … 0.021347527325668247 0.03941093211425924],), (c = [0.012177087148455583 0.014236651281634942 … 0.010569887360051598 0.008266988661200205; 0.013372555836552967 0.004652164038913437 … 0.0008893369498702832 0.018055389287243335; … ; 0.0020346933100715034 0.04057393543730286 … 0.020286438305472592 0.03528937713110562; 0.007635436252902846 0.06388133804881245 … 0.027006394746919692 0.03869259801019348],), (c = [0.01239953909718788 0.007102812369087538 … 0.013228636896818665 0.00521171530623607; 0.020407050478241522 0.007713709447058043 … 0.0006241502378685652 0.016184491101061814; … ; 0.005289146908340037 0.060469277435523855 … 0.008864917019288286 0.04000350615204072; 0.008171947932747269 0.043005686372711904 … 0.01252216888765387 0.0271833382647604],), (c = [0.03476817046684986 0.0018062575128103512 … 0.011009250761939858 0.012438070685789908; 0.010454151638428706 6.777823828548581e-5 … 0.0006142130066751588 0.008929593197548309; … ; 0.0022688500885533515 0.0488078977377838 … 0.004588479220558103 0.03515520288224565; 0.01205481838073719 0.04204151411571539 … 0.004990981848568049 0.03181202474294352],), (c = [0.017955204653647187 0.014211288487049917 … 0.00833206483495425 0.0025370431061332585; 0.02486619707904004 0.002747293301389514 … 9.368264774620806e-5 0.01880225058697393; … ; 0.0026982425692214825 0.051130706711236394 … 0.01657508046473495 0.03283488634982555; 0.006192935799049569 0.04900096533004668 … 0.013658489369007622 0.030167515774417352],), (c = [0.01705066926931238 0.012363666686360155 … 0.006238828144454312 0.00894646294999934; 0.020272141855343484 0.004157024238666581 … 0.00013436787376216064 0.012733144453509418; … ; 0.00606654212211171 0.03678654424042027 … 0.005717781642026168 0.022612313389533033; 0.016298684905253828 0.02026977712926857 … 0.0007442819420724566 0.04054321241104237],)  …  (c = [0.0029021675500101604 0.026998568082352004 … 0.0014888872333040856 0.0073490385562183375; 0.025928517021766566 0.0048640023299473594 … 2.5911640068060026e-5 0.013341356799026293; … ; 0.00038856170403364605 0.0009476266969695926 … 0.0012159027530761228 0.029381097581418738; 0.027176607577731264 0.0005791487282166059 … 0.018847238999893556 0.033291923422892396],), (c = [0.003468665349319755 0.025756270246147243 … 0.0009501625244680085 0.017752353854523818; 0.02855719985237488 0.006221724500638712 … 6.25289810588929e-5 0.010649722334517815; … ; 0.0018407752165528056 0.001893994129131155 … 0.0001066679279914557 0.03077805664826236; 0.024459323705922905 0.0003092142308250498 … 0.014996816543909974 0.026827373107383465],), (c = [0.004313140723874124 0.017959672449901487 … 0.005131525776761937 0.009231432613706533; 0.01676810698244437 0.0053886221398518645 … 0.0036892979553136774 0.011933866116455095; … ; 0.0028314054450170973 0.0007481696125406023 … 0.008625603466119913 0.024302911077142695; 0.022788401749331395 0.011255529374961368 … 0.018623235998955656 0.030653450956026736],), (c = [0.008737679911799775 0.01964204778111652 … 0.0010114493047343326 0.007742329155528198; 0.01878981214970498 0.004286925959850269 … 0.0036521325216697627 0.010397866640794427; … ; 0.001282176033144512 0.0027024888554162975 … 0.00027579063779407383 0.03203086861270769; 0.024339860074319247 0.0007695508698667052 … 0.049185738587229286 0.02075357723644719],), (c = [0.005277362025833247 0.017157727889085064 … 0.00457462199775638 0.010583196281032761; 0.026730020996424082 0.0008312849613911925 … 0.0018180390876618106 0.007834597037224349; … ; 0.005209335545376173 0.0010974880101358065 … 0.0035039434663702474 0.03083987933204411; 0.022479063259869536 0.008230074274543257 … 0.011433719198701448 0.03130277730249492],), (c = [0.013657895105061693 0.0019307491000630588 … 0.002800357965292068 0.0033685367750139906; 0.02073961110480731 0.01438362303340512 … 0.001652519737516018 0.011083136811762937; … ; 0.00026775021531058016 0.009099681719973059 … 0.0016352786997208804 0.026523994918583774; 0.021178672362306215 0.00131758064405311 … 0.006392681168364444 0.04659245134403808],), (c = [0.009507361503398976 0.0020100879210885616 … 0.0016296986759997867 0.007299017747324622; 0.020931859092553146 0.015386015198336784 … 0.002154562651541727 0.013391918282522066; … ; 0.003468663439580547 0.0016899479076993768 … 0.004022511868397331 0.036102569595266705; 0.020621722936260387 0.0021680334657544075 … 0.02415637422155707 0.029027423901003557],), (c = [0.006642483594450473 0.025062240394323455 … 0.006201117632562992 0.011361253729346174; 0.018374172511150328 0.0002901772969411509 … 0.007532940271789883 0.008328905108531211; … ; 0.0011142333813551353 0.0001581837126449151 … 0.00235058673637645 0.030980195914875917; 0.022091281588602723 0.003636541899406653 … 0.04884773682296254 0.018494316903925976],), (c = [0.007065321819156252 0.013655281956847506 … 0.0035084544442833205 0.013262773504151438; 0.019375443615599553 0.0007679624432531148 … 0.0016308116880729324 0.0059995623935482495; … ; 0.0024287804391387893 0.00018873368187786435 … 0.007270123260339127 0.026137947080420977; 0.03343904514971894 0.0044825178850964 … 0.031346639421834833 0.022440488119511992],), (c = [0.011214994434387664 0.016042843443112874 … 0.0031379504268856406 0.009116905306917495; 0.018129596382068038 0.000561971661792586 … 0.00414058005605676 0.015860187245931395; … ; 0.0018361896079140128 8.505047240720025e-5 … 0.002761241805055087 0.035799827833215905; 0.02462067625895664 0.0020671922042719516 … 0.025378381101158594 0.0313107225531262],)], NamedTuple{(:n_steps, :is_accept, :acceptance_rate, :log_density, :hamiltonian_energy, :hamiltonian_energy_error, :max_hamiltonian_energy_error, :tree_depth, :numerical_error, :step_size, :nom_step_size, :is_adapt), Tuple{Int64, Bool, Float64, Float64, Float64, Float64, Float64, Int64, Bool, Float64, Float64, Bool}}[(n_steps = 1023, is_accept = 1, acceptance_rate = 0.9999833792890683, log_density = -245.8003456367913, hamiltonian_energy = 259.93836154490987, hamiltonian_energy_error = 1.9334591002007073e-5, max_hamiltonian_energy_error = 2.339748317581325e-5, tree_depth = 10, numerical_error = 0, step_size = 0.0001, nom_step_size = 0.0001, is_adapt = 1), (n_steps = 1023, is_accept = 1, acceptance_rate = 0.9965128582274404, log_density = -257.37688509834925, hamiltonian_energy = 270.7261727940998, hamiltonian_energy_error = 0.002248600941015866, max_hamiltonian_energy_error = 0.009594237303076625, tree_depth = 10, numerical_error = 0, step_size = 0.0014385075379790887, nom_step_size = 0.0014385075379790887, is_adapt = 1), (n_steps = 1023, is_accept = 1, acceptance_rate = 0.9847943834691262, log_density = -263.4413297593561, hamiltonian_energy = 280.0248828273289, hamiltonian_energy_error = 0.003592776596008207, max_hamiltonian_energy_error = 0.03579038035309168, tree_depth = 10, numerical_error = 0, step_size = 0.0025460689824478495, nom_step_size = 0.0025460689824478495, is_adapt = 1), (n_steps = 1023, is_accept = 1, acceptance_rate = 0.9948956577741581, log_density = -262.5483065986043, hamiltonian_energy = 285.26961948216757, hamiltonian_energy_error = 0.003599625656192984, max_hamiltonian_energy_error = -0.03637046813304323, tree_depth = 9, numerical_error = 0, step_size = 0.004706579241524301, nom_step_size = 0.004706579241524301, is_adapt = 1), (n_steps = 511, is_accept = 1, acceptance_rate = 0.9442267983084337, log_density = -264.6733629863959, hamiltonian_energy = 281.6574239865966, hamiltonian_energy_error = 0.19041881754247925, max_hamiltonian_energy_error = 0.25062734379315543, tree_depth = 9, numerical_error = 0, step_size = 0.009185949442849953, nom_step_size = 0.009185949442849953, is_adapt = 1), (n_steps = 255, is_accept = 1, acceptance_rate = 0.18857516325072166, log_density = -260.8718928959154, hamiltonian_energy = 290.6016200016707, hamiltonian_energy_error = -1.006795443503563, max_hamiltonian_energy_error = 18.11140198778179, tree_depth = 8, numerical_error = 0, step_size = 0.015551259160090898, nom_step_size = 0.015551259160090898, is_adapt = 1), (n_steps = 1023, is_accept = 1, acceptance_rate = 0.9990126475763473, log_density = -260.7321306123223, hamiltonian_energy = 278.348390617577, hamiltonian_energy_error = 0.0005962919842090741, max_hamiltonian_energy_error = -0.013263445942698127, tree_depth = 10, numerical_error = 0, step_size = 0.002575591989756002, nom_step_size = 0.002575591989756002, is_adapt = 1), (n_steps = 1023, is_accept = 1, acceptance_rate = 0.9971818939447834, log_density = -265.95647897806253, hamiltonian_energy = 288.2035075470295, hamiltonian_energy_error = -0.013978535950741389, max_hamiltonian_energy_error = -0.05656805184099767, tree_depth = 10, numerical_error = 0, step_size = 0.004860922589575307, nom_step_size = 0.004860922589575307, is_adapt = 1), (n_steps = 511, is_accept = 1, acceptance_rate = 0.9827364206747549, log_density = -275.7732487655544, hamiltonian_energy = 295.55392591280366, hamiltonian_energy_error = -0.015858358213733936, max_hamiltonian_energy_error = -0.22145473132195548, tree_depth = 9, numerical_error = 0, step_size = 0.009172186290963311, nom_step_size = 0.009172186290963311, is_adapt = 1), (n_steps = 255, is_accept = 1, acceptance_rate = 0.7818671497925304, log_density = -268.5383918314345, hamiltonian_energy = 296.9120935783214, hamiltonian_energy_error = 0.6288281727406115, max_hamiltonian_energy_error = 1.7599143841776481, tree_depth = 8, numerical_error = 0, step_size = 0.01650982034626659, nom_step_size = 0.01650982034626659, is_adapt = 1)  …  (n_steps = 255, is_accept = 1, acceptance_rate = 0.997076013266559, log_density = -260.9385728549668, hamiltonian_energy = 287.7683972322623, hamiltonian_energy_error = -0.25376853565364854, max_hamiltonian_energy_error = -0.4000565347827205, tree_depth = 7, numerical_error = 0, step_size = 0.021807483975488377, nom_step_size = 0.021807483975488377, is_adapt = 0), (n_steps = 255, is_accept = 1, acceptance_rate = 0.7682449021467354, log_density = -268.82867512876487, hamiltonian_energy = 289.362956222118, hamiltonian_energy_error = 0.563345034930876, max_hamiltonian_energy_error = 0.730599739911554, tree_depth = 8, numerical_error = 0, step_size = 0.021807483975488377, nom_step_size = 0.021807483975488377, is_adapt = 0), (n_steps = 255, is_accept = 1, acceptance_rate = 0.9946002196057288, log_density = -262.46837849440715, hamiltonian_energy = 288.15822996691077, hamiltonian_energy_error = -0.4653924189551617, max_hamiltonian_energy_error = -0.837922897002386, tree_depth = 8, numerical_error = 0, step_size = 0.021807483975488377, nom_step_size = 0.021807483975488377, is_adapt = 0), (n_steps = 255, is_accept = 1, acceptance_rate = 0.7479361622677553, log_density = -265.21599094182335, hamiltonian_energy = 288.0600405418462, hamiltonian_energy_error = 0.2404740929374043, max_hamiltonian_energy_error = 0.807404165521632, tree_depth = 8, numerical_error = 0, step_size = 0.021807483975488377, nom_step_size = 0.021807483975488377, is_adapt = 0), (n_steps = 255, is_accept = 1, acceptance_rate = 0.9995979419180594, log_density = -259.64444085307207, hamiltonian_energy = 284.69764776477734, hamiltonian_energy_error = -0.11813594411148642, max_hamiltonian_energy_error = -0.5707077559903837, tree_depth = 8, numerical_error = 0, step_size = 0.021807483975488377, nom_step_size = 0.021807483975488377, is_adapt = 0), (n_steps = 255, is_accept = 1, acceptance_rate = 0.9191890406418389, log_density = -259.16858716795326, hamiltonian_energy = 280.26415804917104, hamiltonian_energy_error = -0.2542008536055391, max_hamiltonian_energy_error = -0.49427958147424533, tree_depth = 8, numerical_error = 0, step_size = 0.021807483975488377, nom_step_size = 0.021807483975488377, is_adapt = 0), (n_steps = 127, is_accept = 1, acceptance_rate = 0.9254748470060422, log_density = -255.59302990228466, hamiltonian_energy = 276.8621628245722, hamiltonian_energy_error = -0.1038275414950931, max_hamiltonian_energy_error = 0.2881123957773184, tree_depth = 7, numerical_error = 0, step_size = 0.021807483975488377, nom_step_size = 0.021807483975488377, is_adapt = 0), (n_steps = 255, is_accept = 1, acceptance_rate = 0.936209669966024, log_density = -256.3452660670589, hamiltonian_energy = 272.71029863511865, hamiltonian_energy_error = -0.01469785937541701, max_hamiltonian_energy_error = 0.2674288855873783, tree_depth = 8, numerical_error = 0, step_size = 0.021807483975488377, nom_step_size = 0.021807483975488377, is_adapt = 0), (n_steps = 255, is_accept = 1, acceptance_rate = 0.926038506340549, log_density = -256.7334515975948, hamiltonian_energy = 275.3810396761718, hamiltonian_energy_error = -0.14748014810732002, max_hamiltonian_energy_error = 0.3037486768448048, tree_depth = 8, numerical_error = 0, step_size = 0.021807483975488377, nom_step_size = 0.021807483975488377, is_adapt = 0), (n_steps = 255, is_accept = 1, acceptance_rate = 0.967328061424881, log_density = -256.43866728642445, hamiltonian_energy = 273.4990302471956, hamiltonian_energy_error = 0.10004242176495381, max_hamiltonian_energy_error = 0.15783783168552645, tree_depth = 7, numerical_error = 0, step_size = 0.021807483975488377, nom_step_size = 0.021807483975488377, is_adapt = 0)])</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This should be run for likely an order of magnitude more steps to estimate expectations of the posterior properly</p></div></div><p>Now that we have our posterior, we can assess which parts of the image are strongly inferred by the data. This is rather unique to <code>Comrade</code> where more traditional imaging algorithms like CLEAN and RML are inherently unable to assess uncertainty in their reconstructions.</p><p>To explore our posterior let&#39;s first create images from a bunch of draws from the posterior</p><pre><code class="language-julia hljs">msamples = model.(chain[251:2:end], Ref(metadata))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">125-element Vector{Comrade.ModelImage{ContinuousImage{AxisKeys.KeyedArray{Float64, 2, NamedDims.NamedDimsArray{(:X, :Y), Float64, 2, Base.ReshapedArray{Float64, 2, SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{Int64}}, true}, Tuple{}}}, GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, Nothing, Float64}}, BSplinePulse{3}}, AxisKeys.KeyedArray{Float64, 2, NamedDims.NamedDimsArray{(:X, :Y), Float64, 2, Base.ReshapedArray{Float64, 2, SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{Int64}}, true}, Tuple{}}}, GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, Nothing, Float64}}, Comrade.NUFTCache{Comrade.ObservedNUFT{DFTAlg, Matrix{Float64}}, Matrix{ComplexF64}, Vector{ComplexF64}, BSplinePulse{3}, AxisKeys.KeyedArray{Float64, 2, NamedDims.NamedDimsArray{(:X, :Y), Float64, 2, Base.ReshapedArray{Float64, 2, SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{Int64}}, true}, Tuple{}}}, GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, Nothing, Float64}}}}}:
 ModelImage
	model: ContinuousImage{AxisKeys.KeyedArray{Float64, 2, NamedDims.NamedDimsArray{(:X, :Y), Float64, 2, Base.ReshapedArray{Float64, 2, SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{Int64}}, true}, Tuple{}}}, GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, Nothing, Float64}}, BSplinePulse{3}}
	image: 2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   X ∈ 7-element LinRange{Float64,...}
→   Y ∈ 7-element LinRange{Float64,...}
And data, 7×7 NamedDimsArray(reshape(view(::Vector{Float64}, 1:49), 7, 7), (:X, :Y))
	cache: Comrade.NUFTCache

 ModelImage
	model: ContinuousImage{AxisKeys.KeyedArray{Float64, 2, NamedDims.NamedDimsArray{(:X, :Y), Float64, 2, Base.ReshapedArray{Float64, 2, SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{Int64}}, true}, Tuple{}}}, GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, Nothing, Float64}}, BSplinePulse{3}}
	image: 2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   X ∈ 7-element LinRange{Float64,...}
→   Y ∈ 7-element LinRange{Float64,...}
And data, 7×7 NamedDimsArray(reshape(view(::Vector{Float64}, 1:49), 7, 7), (:X, :Y))
	cache: Comrade.NUFTCache

 ModelImage
	model: ContinuousImage{AxisKeys.KeyedArray{Float64, 2, NamedDims.NamedDimsArray{(:X, :Y), Float64, 2, Base.ReshapedArray{Float64, 2, SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{Int64}}, true}, Tuple{}}}, GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, Nothing, Float64}}, BSplinePulse{3}}
	image: 2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   X ∈ 7-element LinRange{Float64,...}
→   Y ∈ 7-element LinRange{Float64,...}
And data, 7×7 NamedDimsArray(reshape(view(::Vector{Float64}, 1:49), 7, 7), (:X, :Y))
	cache: Comrade.NUFTCache

 ModelImage
	model: ContinuousImage{AxisKeys.KeyedArray{Float64, 2, NamedDims.NamedDimsArray{(:X, :Y), Float64, 2, Base.ReshapedArray{Float64, 2, SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{Int64}}, true}, Tuple{}}}, GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, Nothing, Float64}}, BSplinePulse{3}}
	image: 2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   X ∈ 7-element LinRange{Float64,...}
→   Y ∈ 7-element LinRange{Float64,...}
And data, 7×7 NamedDimsArray(reshape(view(::Vector{Float64}, 1:49), 7, 7), (:X, :Y))
	cache: Comrade.NUFTCache

 ModelImage
	model: ContinuousImage{AxisKeys.KeyedArray{Float64, 2, NamedDims.NamedDimsArray{(:X, :Y), Float64, 2, Base.ReshapedArray{Float64, 2, SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{Int64}}, true}, Tuple{}}}, GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, Nothing, Float64}}, BSplinePulse{3}}
	image: 2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   X ∈ 7-element LinRange{Float64,...}
→   Y ∈ 7-element LinRange{Float64,...}
And data, 7×7 NamedDimsArray(reshape(view(::Vector{Float64}, 1:49), 7, 7), (:X, :Y))
	cache: Comrade.NUFTCache

 ModelImage
	model: ContinuousImage{AxisKeys.KeyedArray{Float64, 2, NamedDims.NamedDimsArray{(:X, :Y), Float64, 2, Base.ReshapedArray{Float64, 2, SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{Int64}}, true}, Tuple{}}}, GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, Nothing, Float64}}, BSplinePulse{3}}
	image: 2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   X ∈ 7-element LinRange{Float64,...}
→   Y ∈ 7-element LinRange{Float64,...}
And data, 7×7 NamedDimsArray(reshape(view(::Vector{Float64}, 1:49), 7, 7), (:X, :Y))
	cache: Comrade.NUFTCache

 ModelImage
	model: ContinuousImage{AxisKeys.KeyedArray{Float64, 2, NamedDims.NamedDimsArray{(:X, :Y), Float64, 2, Base.ReshapedArray{Float64, 2, SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{Int64}}, true}, Tuple{}}}, GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, Nothing, Float64}}, BSplinePulse{3}}
	image: 2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   X ∈ 7-element LinRange{Float64,...}
→   Y ∈ 7-element LinRange{Float64,...}
And data, 7×7 NamedDimsArray(reshape(view(::Vector{Float64}, 1:49), 7, 7), (:X, :Y))
	cache: Comrade.NUFTCache

 ModelImage
	model: ContinuousImage{AxisKeys.KeyedArray{Float64, 2, NamedDims.NamedDimsArray{(:X, :Y), Float64, 2, Base.ReshapedArray{Float64, 2, SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{Int64}}, true}, Tuple{}}}, GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, Nothing, Float64}}, BSplinePulse{3}}
	image: 2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   X ∈ 7-element LinRange{Float64,...}
→   Y ∈ 7-element LinRange{Float64,...}
And data, 7×7 NamedDimsArray(reshape(view(::Vector{Float64}, 1:49), 7, 7), (:X, :Y))
	cache: Comrade.NUFTCache

 ModelImage
	model: ContinuousImage{AxisKeys.KeyedArray{Float64, 2, NamedDims.NamedDimsArray{(:X, :Y), Float64, 2, Base.ReshapedArray{Float64, 2, SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{Int64}}, true}, Tuple{}}}, GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, Nothing, Float64}}, BSplinePulse{3}}
	image: 2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   X ∈ 7-element LinRange{Float64,...}
→   Y ∈ 7-element LinRange{Float64,...}
And data, 7×7 NamedDimsArray(reshape(view(::Vector{Float64}, 1:49), 7, 7), (:X, :Y))
	cache: Comrade.NUFTCache

 ModelImage
	model: ContinuousImage{AxisKeys.KeyedArray{Float64, 2, NamedDims.NamedDimsArray{(:X, :Y), Float64, 2, Base.ReshapedArray{Float64, 2, SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{Int64}}, true}, Tuple{}}}, GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, Nothing, Float64}}, BSplinePulse{3}}
	image: 2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   X ∈ 7-element LinRange{Float64,...}
→   Y ∈ 7-element LinRange{Float64,...}
And data, 7×7 NamedDimsArray(reshape(view(::Vector{Float64}, 1:49), 7, 7), (:X, :Y))
	cache: Comrade.NUFTCache

 ⋮
 ModelImage
	model: ContinuousImage{AxisKeys.KeyedArray{Float64, 2, NamedDims.NamedDimsArray{(:X, :Y), Float64, 2, Base.ReshapedArray{Float64, 2, SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{Int64}}, true}, Tuple{}}}, GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, Nothing, Float64}}, BSplinePulse{3}}
	image: 2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   X ∈ 7-element LinRange{Float64,...}
→   Y ∈ 7-element LinRange{Float64,...}
And data, 7×7 NamedDimsArray(reshape(view(::Vector{Float64}, 1:49), 7, 7), (:X, :Y))
	cache: Comrade.NUFTCache

 ModelImage
	model: ContinuousImage{AxisKeys.KeyedArray{Float64, 2, NamedDims.NamedDimsArray{(:X, :Y), Float64, 2, Base.ReshapedArray{Float64, 2, SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{Int64}}, true}, Tuple{}}}, GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, Nothing, Float64}}, BSplinePulse{3}}
	image: 2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   X ∈ 7-element LinRange{Float64,...}
→   Y ∈ 7-element LinRange{Float64,...}
And data, 7×7 NamedDimsArray(reshape(view(::Vector{Float64}, 1:49), 7, 7), (:X, :Y))
	cache: Comrade.NUFTCache

 ModelImage
	model: ContinuousImage{AxisKeys.KeyedArray{Float64, 2, NamedDims.NamedDimsArray{(:X, :Y), Float64, 2, Base.ReshapedArray{Float64, 2, SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{Int64}}, true}, Tuple{}}}, GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, Nothing, Float64}}, BSplinePulse{3}}
	image: 2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   X ∈ 7-element LinRange{Float64,...}
→   Y ∈ 7-element LinRange{Float64,...}
And data, 7×7 NamedDimsArray(reshape(view(::Vector{Float64}, 1:49), 7, 7), (:X, :Y))
	cache: Comrade.NUFTCache

 ModelImage
	model: ContinuousImage{AxisKeys.KeyedArray{Float64, 2, NamedDims.NamedDimsArray{(:X, :Y), Float64, 2, Base.ReshapedArray{Float64, 2, SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{Int64}}, true}, Tuple{}}}, GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, Nothing, Float64}}, BSplinePulse{3}}
	image: 2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   X ∈ 7-element LinRange{Float64,...}
→   Y ∈ 7-element LinRange{Float64,...}
And data, 7×7 NamedDimsArray(reshape(view(::Vector{Float64}, 1:49), 7, 7), (:X, :Y))
	cache: Comrade.NUFTCache

 ModelImage
	model: ContinuousImage{AxisKeys.KeyedArray{Float64, 2, NamedDims.NamedDimsArray{(:X, :Y), Float64, 2, Base.ReshapedArray{Float64, 2, SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{Int64}}, true}, Tuple{}}}, GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, Nothing, Float64}}, BSplinePulse{3}}
	image: 2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   X ∈ 7-element LinRange{Float64,...}
→   Y ∈ 7-element LinRange{Float64,...}
And data, 7×7 NamedDimsArray(reshape(view(::Vector{Float64}, 1:49), 7, 7), (:X, :Y))
	cache: Comrade.NUFTCache

 ModelImage
	model: ContinuousImage{AxisKeys.KeyedArray{Float64, 2, NamedDims.NamedDimsArray{(:X, :Y), Float64, 2, Base.ReshapedArray{Float64, 2, SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{Int64}}, true}, Tuple{}}}, GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, Nothing, Float64}}, BSplinePulse{3}}
	image: 2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   X ∈ 7-element LinRange{Float64,...}
→   Y ∈ 7-element LinRange{Float64,...}
And data, 7×7 NamedDimsArray(reshape(view(::Vector{Float64}, 1:49), 7, 7), (:X, :Y))
	cache: Comrade.NUFTCache

 ModelImage
	model: ContinuousImage{AxisKeys.KeyedArray{Float64, 2, NamedDims.NamedDimsArray{(:X, :Y), Float64, 2, Base.ReshapedArray{Float64, 2, SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{Int64}}, true}, Tuple{}}}, GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, Nothing, Float64}}, BSplinePulse{3}}
	image: 2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   X ∈ 7-element LinRange{Float64,...}
→   Y ∈ 7-element LinRange{Float64,...}
And data, 7×7 NamedDimsArray(reshape(view(::Vector{Float64}, 1:49), 7, 7), (:X, :Y))
	cache: Comrade.NUFTCache

 ModelImage
	model: ContinuousImage{AxisKeys.KeyedArray{Float64, 2, NamedDims.NamedDimsArray{(:X, :Y), Float64, 2, Base.ReshapedArray{Float64, 2, SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{Int64}}, true}, Tuple{}}}, GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, Nothing, Float64}}, BSplinePulse{3}}
	image: 2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   X ∈ 7-element LinRange{Float64,...}
→   Y ∈ 7-element LinRange{Float64,...}
And data, 7×7 NamedDimsArray(reshape(view(::Vector{Float64}, 1:49), 7, 7), (:X, :Y))
	cache: Comrade.NUFTCache

 ModelImage
	model: ContinuousImage{AxisKeys.KeyedArray{Float64, 2, NamedDims.NamedDimsArray{(:X, :Y), Float64, 2, Base.ReshapedArray{Float64, 2, SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{Int64}}, true}, Tuple{}}}, GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, Nothing, Float64}}, BSplinePulse{3}}
	image: 2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   X ∈ 7-element LinRange{Float64,...}
→   Y ∈ 7-element LinRange{Float64,...}
And data, 7×7 NamedDimsArray(reshape(view(::Vector{Float64}, 1:49), 7, 7), (:X, :Y))
	cache: Comrade.NUFTCache
</code></pre><p>The mean image is then given by</p><pre><code class="language-julia hljs">using StatsBase
imgs = intensitymap.(msamples, μas2rad(120.0), μas2rad(120.0), 128, 128)
mimg = mean(imgs)
simg = std(imgs)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   X ∈ 128-element LinRange{Float64,...}
→   Y ∈ 128-element LinRange{Float64,...}
And data, 128×128 NamedDimsArray(::Matrix{Float64}, (:X, :Y)):
                 (-2.88616e-10)  …  (2.84071e-10)  (2.88616e-10)
 (-2.88616e-10)     0.0               0.0            0.0
 (-2.84071e-10)     0.0               0.0            0.0
 (-2.79525e-10)     0.0               0.0            0.0
 (-2.7498e-10)      0.0               0.0            0.0
 (-2.70435e-10)     0.0          …    0.0            0.0
 (-2.6589e-10)      0.0               0.0            0.0
    ⋮                            ⋱    ⋮            
  (2.61345e-10)     0.0               0.0            0.0
  (2.6589e-10)      0.0               0.0            0.0
  (2.70435e-10)     0.0          …    0.0            0.0
  (2.7498e-10)      0.0               0.0            0.0
  (2.79525e-10)     0.0               0.0            0.0
  (2.84071e-10)     0.0               0.0            0.0
  (2.88616e-10)     0.0               0.0            0.0</code></pre><p>p1 = plot(mimg, title=&quot;Mean Image&quot;) p2 = plot(simg./mimg, title=&quot;1/SNR&quot;) p3 = plot(imgs[1], title=&quot;Draw 1&quot;) p4 = plot(imgs[end], title=&quot;Draw 2&quot;) plot(p1, p2, p3, p4, size=(800,800), colorbar=:none)</p><p>And viola, you have a quick and preliminary image of M87 fitting only closure products. For a publication-level version we would recommend</p><ol><li>Running the chain longer and multiple times to properly assess things like ESS and R̂ (see <a href="../geometric_modeling/#Geometric-Modeling-of-EHT-Data">Geometric Modeling of EHT Data</a>)</li><li>Fitting gains. Typically gain amplitudes are good to 10-20% for the EHT not the infinite uncertainty closures implicitly assume</li><li>Making sure the posterior is unimodal (hint for this example it isn&#39;t!). The EHT image posteriors can be pretty complicated, so typically you want to use a sampler that can deal with multi-modal posteriors. Check out the package <a href="https://github.com/Julia-Tempering/Pigeons.jl"><code>Pigeons.jl</code></a> for an <strong>in-development</strong> package that should easily enable this type of sampling.</li></ol><h2 id="Computing-information"><a class="docs-heading-anchor" href="#Computing-information">Computing information</a><a id="Computing-information-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-information" title="Permalink"></a></h2><pre><code class="nohighlight hljs">Julia Version 1.8.5
Commit 17cfb8e65ea (2023-01-08 06:45 UTC)
Platform Info:
  OS: Linux (x86_64-linux-gnu)
  CPU: 32 × AMD Ryzen 9 7950X 16-Core Processor
  WORD_SIZE: 64
  LIBM: libopenlibm
  LLVM: libLLVM-13.0.1 (ORCJIT, znver3)
  Threads: 1 on 32 virtual cores
Environment:
  JULIA_EDITOR = code
  JULIA_NUM_THREADS = 1</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Sunday 16 April 2023 22:49">Sunday 16 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
