<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Hybrid Imaging of a Black Hole · Comrade.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Comrade.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../benchmarks/">Benchmarks</a></li><li><a class="tocitem" href="../../vlbi_imaging_problem/">Introduction to the VLBI Imaging Problem</a></li><li><a class="tocitem" href="../../conventions/">Conventions</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../data/">Loading Data into Comrade</a></li><li><a class="tocitem" href="../nonanalytic/">Modeling with non-analytic Fourier transforms</a></li><li><a class="tocitem" href="../geometric_modeling/">Geometric Modeling of EHT Data</a></li><li><a class="tocitem" href="../imaging_closures/">Imaging a Black Hole using only Closure Quantities</a></li><li><a class="tocitem" href="../imaging_vis/">Stokes I Simultaneous Image and Instrument Modeling</a></li><li><a class="tocitem" href="../imaging_pol/">Polarized Image and Instrumental Modeling</a></li><li class="is-active"><a class="tocitem" href>Hybrid Imaging of a Black Hole</a><ul class="internal"><li><a class="tocitem" href="#Introduction-to-Hybrid-modeling-and-imaging"><span>Introduction to Hybrid modeling and imaging</span></a></li><li><a class="tocitem" href="#Loading-the-Data"><span>Loading the Data</span></a></li><li><a class="tocitem" href="#Load-the-Data"><span>Load the Data</span></a></li><li><a class="tocitem" href="#Building-the-Model/Posterior"><span>Building the Model/Posterior</span></a></li><li><a class="tocitem" href="#Reconstructing-the-Image"><span>Reconstructing the Image</span></a></li><li><a class="tocitem" href="#Computing-information"><span>Computing information</span></a></li></ul></li></ul></li><li><span class="tocitem">Libraries</span><ul><li><a class="tocitem" href="../../libs/optimization/">ComradeOptimization</a></li><li><a class="tocitem" href="../../libs/ahmc/">ComradeAHMC</a></li><li><a class="tocitem" href="../../libs/nested/">ComradeNested</a></li><li><a class="tocitem" href="../../libs/dynesty/">ComradeDynesty</a></li><li><a class="tocitem" href="../../libs/adaptmcmc/">ComradeAdaptMCMC</a></li></ul></li><li><a class="tocitem" href="../../interface/">Model Interface</a></li><li><a class="tocitem" href="../../base_api/">ComradeBase API</a></li><li><a class="tocitem" href="../../api/">Comrade API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Hybrid Imaging of a Black Hole</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Hybrid Imaging of a Black Hole</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ptiede/Comrade.jl/blob/main/examples/hybrid_imaging.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Hybrid-Imaging-of-a-Black-Hole"><a class="docs-heading-anchor" href="#Hybrid-Imaging-of-a-Black-Hole">Hybrid Imaging of a Black Hole</a><a id="Hybrid-Imaging-of-a-Black-Hole-1"></a><a class="docs-heading-anchor-permalink" href="#Hybrid-Imaging-of-a-Black-Hole" title="Permalink"></a></h1><p>In this tutorial, we will use <strong>hybrid imaging</strong> to analyze the 2017 EHT data. By hybrid imaging, we mean decomposing the model into simple geometric models, e.g., rings and such, plus a rasterized image model to soak up the additional structure. This approach was first developed in <a href="https://iopscience.iop.org/article/10.3847/1538-4357/ab9c1f"><code>BB20</code></a> and applied to EHT 2017 data. We will use a similar model in this tutorial.</p><h2 id="Introduction-to-Hybrid-modeling-and-imaging"><a class="docs-heading-anchor" href="#Introduction-to-Hybrid-modeling-and-imaging">Introduction to Hybrid modeling and imaging</a><a id="Introduction-to-Hybrid-modeling-and-imaging-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction-to-Hybrid-modeling-and-imaging" title="Permalink"></a></h2><p>The benefit of using a hybrid-based modeling approach is the effective compression of information/parameters when fitting the data. Hybrid modeling requires the user to incorporate specific knowledge of how you expect the source to look like. For instance for M87, we expect the image to be dominated by a ring-like structure. Therefore, instead of using a high-dimensional raster to recover the ring, we can use a ring model plus a raster to soak up the additional degrees of freedom. This is the approach we will take in this tutorial to analyze the April 6 2017 EHT data of M87.</p><h2 id="Loading-the-Data"><a class="docs-heading-anchor" href="#Loading-the-Data">Loading the Data</a><a id="Loading-the-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-the-Data" title="Permalink"></a></h2><p>To get started we will load Comrade</p><pre><code class="language-julia hljs">using Comrade</code></pre><h2 id="Load-the-Data"><a class="docs-heading-anchor" href="#Load-the-Data">Load the Data</a><a id="Load-the-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Load-the-Data" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Pyehtim</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">  Activating project at `~/work/Comrade.jl/Comrade.jl/examples`</code></pre><p>For reproducibility we use a stable random number genreator</p><pre><code class="language-julia hljs">using StableRNGs
rng = StableRNG(42)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">StableRNGs.LehmerRNG(state=0x00000000000000000000000000000055)</code></pre><p>To download the data visit https://doi.org/10.25739/g85n-f134 To load the eht-imaging obsdata object we do:</p><pre><code class="language-julia hljs">obs = ehtim.obsdata.load_uvfits(joinpath(dirname(pathof(Comrade)), &quot;..&quot;, &quot;examples&quot;, &quot;SR1_M87_2017_096_lo_hops_netcal_StokesI.uvfits&quot;))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Python: &lt;ehtim.obsdata.Obsdata object at 0x7f9463deb940&gt;</code></pre><p>Now we do some minor preprocessing:</p><ul><li>Scan average the data since the data have been preprocessed so that the gain phases  coherent.</li></ul><pre><code class="language-julia hljs">obs = scan_average(obs).add_fractional_noise(0.01)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Python: &lt;ehtim.obsdata.Obsdata object at 0x7f94645accd0&gt;</code></pre><p>For this tutorial we will once again fit complex visibilities since they provide the most information once the telescope/instrument model are taken into account.</p><pre><code class="language-julia hljs">dvis  = extract_table(obs, ComplexVisibilities())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EHTObservation{Float64,Comrade.EHTVisibilityDatum{Float64}, ...}
  source: M87
  mjd: 57849
  frequency: 2.27070703125e11
  bandwidth: 1.856e9
  stations: [:AA, :AP, :AZ, :JC, :LM, :PV, :SM]
  nsamples: 274
</code></pre><h2 id="Building-the-Model/Posterior"><a class="docs-heading-anchor" href="#Building-the-Model/Posterior">Building the Model/Posterior</a><a id="Building-the-Model/Posterior-1"></a><a class="docs-heading-anchor-permalink" href="#Building-the-Model/Posterior" title="Permalink"></a></h2><p>Now we build our intensity/visibility model. That is, the model that takes in a named tuple of parameters and perhaps some metadata required to construct the model. For our model, we will use a raster or <code>ContinuousImage</code> model, an <code>m-ring</code> model, and a large asymmetric Gaussian component to model the unresolved short-baseline flux.</p><pre><code class="language-julia hljs">function sky(θ, metadata)
    (;c, f, r, σ, ma, mp, fg) = θ
    (; grid, cache) = metadata
    # Form the image model
    # First transform to simplex space
    rast = to_simplex(CenteredLR(), c.params)
    img = IntensityMap((f*(1-fg))*rast, grid)
    mimg = ContinuousImage(img, cache)
    # Form the ring model
    s,c = sincos(mp)
    α = ma*c
    β = ma*s
    ring = ((1-f)*(1-fg))*smoothed(stretched(MRing(α, β), r, r),σ)
    gauss = fg*stretched(Gaussian(), μas2rad(200.0), μas2rad(200.0))
    return mimg + (ring + gauss)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">sky (generic function with 1 method)</code></pre><p>Unlike other imaging examples (e.g., <a href="../imaging_closures/#Imaging-a-Black-Hole-using-only-Closure-Quantities">Imaging a Black Hole using only Closure Quantities</a>) we also need to include a model for the instrument, i.e., gains as well. The gains will be broken into two components</p><ul><li>Gain amplitudes which are typically known to 10-20%, except for LMT, which has amplitudes closer to 50-100%.</li><li>Gain phases which are more difficult to constrain and can shift rapidly.</li></ul><pre><code class="language-julia hljs">function instrument(θ, metadata)
    (; lgamp, gphase) = θ
    (; gcache, gcachep) = metadata
    # Now form our instrument model
    gvis = exp.(lgamp)
    gphase = exp.(1im.*gphase)
    jgamp = jonesStokes(gvis, gcache)
    jgphase = jonesStokes(gphase, gcachep)
    return CorruptionModel(jgamp*jgphase)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">instrument (generic function with 1 method)</code></pre><p>Before we move on, let&#39;s go into the <code>model</code> function a bit. This function takes two arguments <code>θ</code> and <code>metadata</code>. The <code>θ</code> argument is a named tuple of parameters that are fit to the data. The <code>metadata</code> argument is all the ancillary information we need to construct the model. For our hybrid model, we will need two variables for the metadata, a <code>grid</code> that specifies the locations of the image pixels and a <code>cache</code> that defines the algorithm used to calculate the visibilities given the image model. This is required since <code>ContinuousImage</code> is most easily computed using number Fourier transforms like the <a href="https://github.com/JuliaMath/NFFT.jl"><code>NFFT</code></a> or <a href="https://github.com/JuliaMath/FFTW.jl">FFT</a>. To combine the models, we use <code>Comrade</code>&#39;s overloaded <code>+</code> operators, which will combine the images such that their intensities and visibilities are added pointwise.</p><p>Now let&#39;s define our metadata. First we will define the cache for the image. This is required to compute the numerical Fourier transform.</p><pre><code class="language-julia hljs">fovxy  = μas2rad(150.0)
npix   = 32
grid   = imagepixels(fovxy, fovxy, npix, npix)
buffer = IntensityMap(zeros(npix,npix), grid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   X ∈ 32-element LinRange{Float64,...}
→   Y ∈ 32-element LinRange{Float64,...}
And data, 32×32 NamedDimsArray(::Matrix{Float64}, (:X, :Y)):
                 (-3.52247e-10)  …  (3.29522e-10)  (3.52247e-10)
 (-3.52247e-10)     0.0               0.0            0.0
 (-3.29522e-10)     0.0               0.0            0.0
 (-3.06796e-10)     0.0               0.0            0.0
 (-2.84071e-10)     0.0               0.0            0.0
 (-2.61345e-10)     0.0          …    0.0            0.0
 (-2.38619e-10)     0.0               0.0            0.0
    ⋮                            ⋱    ⋮            
  (2.15894e-10)     0.0               0.0            0.0
  (2.38619e-10)     0.0               0.0            0.0
  (2.61345e-10)     0.0          …    0.0            0.0
  (2.84071e-10)     0.0               0.0            0.0
  (3.06796e-10)     0.0               0.0            0.0
  (3.29522e-10)     0.0               0.0            0.0
  (3.52247e-10)     0.0               0.0            0.0</code></pre><p>For our image, we will use the non-uniform Fourier transform (<code>NFFTAlg</code>) to compute the numerical FT. The last argument to the <code>create_cache</code> call is the image <em>kernel</em> or <em>pulse</em> defines the continuous function we convolve our image with to produce a continuous on-sky image.</p><pre><code class="language-julia hljs">cache  = create_cache(NFFTAlg(dvis), buffer, BSplinePulse{3}())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Comrade.NUFTCache{Comrade.ObservedNUFT{NFFTAlg{Float64, AbstractNFFTs.PrecomputeFlags, UInt32}, Matrix{Float64}}, NFFT.NFFTPlan{Float64, 2, 1}, Vector{ComplexF64}, BSplinePulse{3}, AxisKeys.KeyedArray{Float64, 2, NamedDims.NamedDimsArray{(:X, :Y), Float64, 2, Matrix{Float64}}, GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, ComradeBase.NoHeader, Float64}}}(Comrade.ObservedNUFT{NFFTAlg{Float64, AbstractNFFTs.PrecomputeFlags, UInt32}, Matrix{Float64}}(NFFTAlg{Float64, AbstractNFFTs.PrecomputeFlags, UInt32}(1, 4, 2.0, :kaiser_bessel, AbstractNFFTs.POLYNOMIAL, true, false, true, 0x00000000), [-4.405690154666661e9 787577.6145833326 … -5.999801315555549e9 -15551.297851562484; -4.523017159111106e9 -1.6838098888888871e6 … 3.059254300444441e9 118294.64453124987]), NFFTPlan with 274 sampling points for an input array of size(32, 32) and an output array of size(274,) with dims 1:2, ComplexF64[0.7014670924816703 - 0.519511453845776im, 0.9999999862106403 - 6.398624051637031e-5im, 0.6947985314160843 - 0.5233374146500747im, 0.9328845732113544 - 0.16336912604935844im, 0.9329421134238738 + 0.16331744240563614im, 0.6948519110447875 + 0.5233083088067162im, 0.7925669922789302 + 0.40478845348863063im, 0.9999999864389528 - 6.519719206334107e-5im, 0.9340555032742773 - 0.1520910238460368im, 0.6896791530194316 - 0.5261728587493705im  …  0.8376666586657548 + 0.1784956664688869im, 0.9196690775195503 + 0.09173305645579018im, 0.9135584686897926 + 0.29199716871629755im, 0.9135610039654034 + 0.2919905620278203im, 0.8899638273254515 + 0.28719490128071723im, 0.9568100109264257 + 0.09814170760184636im, 0.8899622135777404 + 0.287201492222944im, 0.9925668796456906 + 0.0027765725149323534im, 0.8376650833595861 - 0.17848899851834446im, 0.9999999999247222 + 7.335331210317892e-6im], BSplinePulse{3}(), [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0])</code></pre><p>Now we form the metadata</p><pre><code class="language-julia hljs">skymetadata = (;grid, cache)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(grid = GriddedKeys{(:X, :Y)}
	X: LinRange{Float64}(-3.5224744018114725e-10, 3.5224744018114725e-10, 32)
	Y: LinRange{Float64}(-3.5224744018114725e-10, 3.5224744018114725e-10, 32)
, cache = Comrade.NUFTCache{Comrade.ObservedNUFT{NFFTAlg{Float64, AbstractNFFTs.PrecomputeFlags, UInt32}, Matrix{Float64}}, NFFT.NFFTPlan{Float64, 2, 1}, Vector{ComplexF64}, BSplinePulse{3}, AxisKeys.KeyedArray{Float64, 2, NamedDims.NamedDimsArray{(:X, :Y), Float64, 2, Matrix{Float64}}, GriddedKeys{(:X, :Y), Tuple{LinRange{Float64, Int64}, LinRange{Float64, Int64}}, ComradeBase.NoHeader, Float64}}}(Comrade.ObservedNUFT{NFFTAlg{Float64, AbstractNFFTs.PrecomputeFlags, UInt32}, Matrix{Float64}}(NFFTAlg{Float64, AbstractNFFTs.PrecomputeFlags, UInt32}(1, 4, 2.0, :kaiser_bessel, AbstractNFFTs.POLYNOMIAL, true, false, true, 0x00000000), [-4.405690154666661e9 787577.6145833326 … -5.999801315555549e9 -15551.297851562484; -4.523017159111106e9 -1.6838098888888871e6 … 3.059254300444441e9 118294.64453124987]), NFFTPlan with 274 sampling points for an input array of size(32, 32) and an output array of size(274,) with dims 1:2, ComplexF64[0.7014670924816703 - 0.519511453845776im, 0.9999999862106403 - 6.398624051637031e-5im, 0.6947985314160843 - 0.5233374146500747im, 0.9328845732113544 - 0.16336912604935844im, 0.9329421134238738 + 0.16331744240563614im, 0.6948519110447875 + 0.5233083088067162im, 0.7925669922789302 + 0.40478845348863063im, 0.9999999864389528 - 6.519719206334107e-5im, 0.9340555032742773 - 0.1520910238460368im, 0.6896791530194316 - 0.5261728587493705im  …  0.8376666586657548 + 0.1784956664688869im, 0.9196690775195503 + 0.09173305645579018im, 0.9135584686897926 + 0.29199716871629755im, 0.9135610039654034 + 0.2919905620278203im, 0.8899638273254515 + 0.28719490128071723im, 0.9568100109264257 + 0.09814170760184636im, 0.8899622135777404 + 0.287201492222944im, 0.9925668796456906 + 0.0027765725149323534im, 0.8376650833595861 - 0.17848899851834446im, 0.9999999999247222 + 7.335331210317892e-6im], BSplinePulse{3}(), [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]))</code></pre><p>Second, we now construct our instrument model cache. This tells us how to map from the gains to the model visibilities. However, to construct this map, we also need to specify the observation segmentation over which we expect the gains to change. This is specified in the second argument to <code>jonescache</code>, and currently, there are two options</p><ul><li><code>FixedSeg(val)</code>: Fixes the corruption to the value <code>val</code> for all time. This is usefule for reference stations</li><li><code>ScanSeg()</code>: which forces the corruptions to only change from scan-to-scan</li><li><code>TrackSeg()</code>: which forces the corruptions to be constant over a night&#39;s observation</li></ul><p>For this work, we use the scan segmentation for the gain amplitudes since that is roughly the timescale we expect them to vary. For the phases we use a station specific scheme where we set AA to be fixed to unit gain because it will function as a reference station.</p><pre><code class="language-julia hljs">gcache = jonescache(dvis, ScanSeg())
segs = station_tuple(dvis, ScanSeg(); AA = FixedSeg(complex(1.0)))
gcachep = jonescache(dvis, segs)

intmetadata = (;gcache, gcachep)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(gcache = JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, ScanSeg{false}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}(sparse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  265, 266, 267, 268, 269, 270, 271, 272, 273, 274], [1, 3, 3, 3, 5, 6, 6, 7, 7, 7, 9, 10, 10, 11, 11, 11, 13, 14, 14, 15, 15, 15, 17, 18, 18, 20, 21, 21, 22, 22, 22, 24, 25, 25, 26, 26, 26, 28, 29, 29, 30, 30, 30, 32, 33, 33, 34, 34, 34, 34, 36, 37, 37, 38, 38, 38, 39, 39, 39, 39, 41, 42, 42, 43, 43, 43, 44, 44, 44, 44, 46, 47, 47, 48, 48, 48, 49, 49, 49, 49, 49, 50, 51, 51, 53, 53, 53, 54, 54, 54, 54, 55, 55, 55, 55, 55, 55, 56, 57, 57, 57, 59, 59, 59, 59, 60, 60, 60, 60, 60, 61, 61, 62, 62, 62, 62, 62, 62, 63, 64, 64, 64, 66, 66, 66, 66, 67, 67, 67, 67, 67, 68, 68, 69, 69, 69, 69, 69, 69, 70, 71, 71, 71, 73, 73, 73, 73, 74, 74, 74, 74, 74, 75, 75, 76, 76, 76, 76, 77, 77, 79, 79, 79, 80, 81, 81, 81, 81, 82, 83, 83, 85, 85, 85, 86, 86, 86, 86, 86, 87, 88, 88, 88, 90, 90, 90, 90, 91, 91, 92, 92, 92, 92, 93, 93, 95, 95, 95, 96, 97, 97, 97, 97, 97, 98, 99, 99, 99, 101, 101, 101, 101, 102, 102, 103, 103, 103, 103, 103, 104, 105, 105, 105, 107, 107, 107, 107, 108, 108, 109, 109, 109, 109, 109, 110, 111, 111, 111, 113, 113, 113, 113, 114, 114, 115, 115, 115, 115, 115, 116, 117, 117, 117, 119, 119, 119, 119, 120, 120, 121, 121, 121, 121, 121, 122, 123, 123, 123, 125, 125, 125, 125, 126, 126], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 274, 126), sparse([1, 2, 5, 6, 4, 7, 3, 8, 11, 12  …  272, 261, 265, 267, 271, 274, 264, 263, 268, 269], [2, 4, 4, 4, 5, 5, 6, 8, 8, 8, 9, 9, 10, 12, 12, 12, 13, 13, 14, 16, 16, 16, 17, 17, 18, 19, 19, 20, 23, 23, 23, 24, 24, 25, 27, 27, 27, 28, 28, 29, 31, 31, 31, 32, 32, 33, 35, 35, 35, 35, 36, 36, 36, 37, 37, 38, 40, 40, 40, 40, 41, 41, 41, 42, 42, 43, 45, 45, 45, 45, 46, 46, 46, 47, 47, 48, 50, 50, 50, 50, 51, 51, 51, 52, 52, 52, 52, 52, 53, 53, 54, 56, 56, 56, 56, 56, 57, 57, 57, 58, 58, 58, 58, 58, 58, 59, 59, 60, 61, 61, 61, 61, 63, 63, 63, 63, 63, 64, 64, 64, 65, 65, 65, 65, 65, 65, 66, 66, 67, 68, 68, 68, 68, 70, 70, 70, 70, 70, 71, 71, 71, 72, 72, 72, 72, 72, 72, 73, 73, 74, 75, 75, 75, 75, 77, 77, 78, 78, 78, 78, 79, 80, 80, 80, 82, 82, 82, 83, 83, 84, 84, 84, 84, 85, 87, 87, 87, 87, 88, 88, 89, 89, 89, 89, 89, 90, 91, 91, 91, 93, 93, 94, 94, 94, 94, 95, 96, 96, 96, 98, 98, 98, 98, 99, 99, 100, 100, 100, 100, 100, 101, 102, 102, 102, 104, 104, 104, 104, 105, 105, 106, 106, 106, 106, 106, 107, 108, 108, 108, 110, 110, 110, 110, 111, 111, 112, 112, 112, 112, 112, 113, 114, 114, 114, 116, 116, 116, 116, 117, 117, 118, 118, 118, 118, 118, 119, 120, 120, 120, 122, 122, 122, 122, 123, 123, 124, 124, 124, 124, 124, 125, 126, 126, 126], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 274, 126), (AA = ScanSeg{false}(), AP = ScanSeg{false}(), AZ = ScanSeg{false}(), JC = ScanSeg{false}(), LM = ScanSeg{false}(), PV = ScanSeg{false}(), SM = ScanSeg{false}()), Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}([:AA, :PV, :AA, :AP, :LM, :PV, :AA, :AP, :LM, :PV  …  :AZ, :JC, :LM, :SM, :AA, :AP, :AZ, :JC, :LM, :SM], [0.9166666567325592, 0.9166666567325592, 1.2166666388511658, 1.2166666388511658, 1.2166666388511658, 1.2166666388511658, 1.516666665673256, 1.516666665673256, 1.516666665673256, 1.516666665673256  …  7.7166666984558105, 7.7166666984558105, 7.7166666984558105, 7.7166666984558105, 7.983333349227905, 7.983333349227905, 7.983333349227905, 7.983333349227905, 7.983333349227905, 7.983333349227905], [(0.9166666567325592, :AA), (0.9166666567325592, :PV), (1.2166666388511658, :AA), (1.2166666388511658, :AP), (1.2166666388511658, :LM), (1.2166666388511658, :PV), (1.516666665673256, :AA), (1.516666665673256, :AP), (1.516666665673256, :LM), (1.516666665673256, :PV)  …  (7.7166666984558105, :AZ), (7.7166666984558105, :JC), (7.7166666984558105, :LM), (7.7166666984558105, :SM), (7.983333349227905, :AA), (7.983333349227905, :AP), (7.983333349227905, :AZ), (7.983333349227905, :JC), (7.983333349227905, :LM), (7.983333349227905, :SM)])), gcachep = JonesCache{Comrade.AffineDesignMatrix{SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{ComplexF64}}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), Tuple{FixedSeg{ComplexF64}, Vararg{ScanSeg{false}, 6}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}(Comrade.AffineDesignMatrix{SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{ComplexF64}}(sparse([5, 6, 7, 11, 12, 13, 17, 18, 19, 23  …  265, 266, 267, 268, 269, 270, 271, 272, 273, 274], [3, 4, 4, 6, 7, 7, 9, 10, 10, 12, 13, 13, 15, 16, 16, 18, 19, 19, 21, 22, 22, 24, 25, 25, 27, 28, 28, 29, 29, 29, 31, 32, 32, 33, 33, 33, 35, 36, 36, 37, 37, 37, 38, 39, 39, 41, 41, 41, 42, 42, 42, 42, 43, 44, 44, 44, 46, 46, 46, 46, 47, 47, 47, 47, 47, 48, 48, 49, 50, 50, 50, 52, 52, 52, 52, 53, 53, 53, 53, 53, 54, 54, 55, 56, 56, 56, 58, 58, 58, 58, 59, 59, 59, 59, 59, 60, 60, 61, 61, 63, 63, 63, 64, 65, 66, 66, 68, 68, 68, 69, 70, 70, 70, 72, 72, 72, 72, 73, 73, 74, 74, 76, 76, 76, 77, 78, 79, 79, 79, 81, 81, 81, 81, 82, 82, 83, 84, 84, 84, 86, 86, 86, 86, 87, 87, 88, 89, 89, 89, 91, 91, 91, 91, 92, 92, 93, 94, 94, 94, 96, 96, 96, 96, 97, 97, 98, 99, 99, 99, 101, 101, 101, 101, 102, 102], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 274, 102), ComplexF64[1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im  …  0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im]), sparse([1, 2, 5, 6, 4, 7, 3, 8, 11, 12  …  272, 261, 265, 267, 271, 274, 264, 263, 268, 269], [1, 2, 2, 2, 3, 3, 4, 5, 5, 5, 6, 6, 7, 8, 8, 8, 9, 9, 10, 11, 11, 11, 12, 12, 13, 14, 14, 15, 17, 17, 17, 18, 18, 19, 20, 20, 20, 21, 21, 22, 23, 23, 23, 24, 24, 25, 26, 26, 26, 26, 27, 27, 27, 28, 28, 29, 30, 30, 30, 30, 31, 31, 31, 32, 32, 33, 34, 34, 34, 34, 35, 35, 35, 36, 36, 37, 38, 38, 38, 38, 39, 39, 39, 40, 40, 40, 40, 40, 41, 41, 42, 43, 43, 43, 43, 43, 44, 44, 44, 45, 45, 45, 45, 45, 45, 46, 46, 47, 48, 48, 48, 48, 49, 49, 49, 49, 49, 50, 50, 50, 51, 51, 51, 51, 51, 51, 52, 52, 53, 54, 54, 54, 54, 55, 55, 55, 55, 55, 56, 56, 56, 57, 57, 57, 57, 57, 57, 58, 58, 59, 60, 60, 60, 60, 61, 61, 62, 62, 62, 62, 63, 64, 64, 64, 65, 65, 65, 66, 66, 67, 67, 67, 67, 68, 69, 69, 69, 69, 70, 70, 71, 71, 71, 71, 71, 72, 73, 73, 73, 74, 74, 75, 75, 75, 75, 76, 77, 77, 77, 78, 78, 78, 78, 79, 79, 80, 80, 80, 80, 80, 81, 82, 82, 82, 83, 83, 83, 83, 84, 84, 85, 85, 85, 85, 85, 86, 87, 87, 87, 88, 88, 88, 88, 89, 89, 90, 90, 90, 90, 90, 91, 92, 92, 92, 93, 93, 93, 93, 94, 94, 95, 95, 95, 95, 95, 96, 97, 97, 97, 98, 98, 98, 98, 99, 99, 100, 100, 100, 100, 100, 101, 102, 102, 102], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 274, 102), (AA = FixedSeg{ComplexF64}(1.0 + 0.0im), AP = ScanSeg{false}(), AZ = ScanSeg{false}(), JC = ScanSeg{false}(), LM = ScanSeg{false}(), PV = ScanSeg{false}(), SM = ScanSeg{false}()), Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}([:PV, :AP, :LM, :PV, :AP, :LM, :PV, :AP, :LM, :PV  …  :AP, :AZ, :JC, :LM, :SM, :AP, :AZ, :JC, :LM, :SM], [0.9166666567325592, 1.2166666388511658, 1.2166666388511658, 1.2166666388511658, 1.516666665673256, 1.516666665673256, 1.516666665673256, 1.816666603088379, 1.816666603088379, 1.816666603088379  …  7.7166666984558105, 7.7166666984558105, 7.7166666984558105, 7.7166666984558105, 7.7166666984558105, 7.983333349227905, 7.983333349227905, 7.983333349227905, 7.983333349227905, 7.983333349227905], [(0.9166666567325592, :PV), (1.2166666388511658, :AP), (1.2166666388511658, :LM), (1.2166666388511658, :PV), (1.516666665673256, :AP), (1.516666665673256, :LM), (1.516666665673256, :PV), (1.816666603088379, :AP), (1.816666603088379, :LM), (1.816666603088379, :PV)  …  (7.7166666984558105, :AP), (7.7166666984558105, :AZ), (7.7166666984558105, :JC), (7.7166666984558105, :LM), (7.7166666984558105, :SM), (7.983333349227905, :AP), (7.983333349227905, :AZ), (7.983333349227905, :JC), (7.983333349227905, :LM), (7.983333349227905, :SM)])))</code></pre><p>This is everything we need to form our likelihood. Note the first two arguments must be the model and then the metadata for the likelihood. The rest of the arguments are required to be <a href="../../api/#Comrade.EHTObservation"><code>Comrade.EHTObservation</code></a></p><pre><code class="language- hljs">lklhd = RadioLikelihood(sky, instrument, dvis;
                        skymeta=metadata, instrumentmeta=intmetadata)</code></pre><p>This forms our model. The next step is defining our image priors. For our raster <code>c</code>, we will use a Gaussian markov random field prior, with the softmax or centered log-ratio transform so that it lives on the simplex. That is, the sum of all the numbers from a <code>Dirichlet</code> distribution always equals unity. First we load <code>VLBIImagePriors</code> which containts a large number of priors and transformations that are useful for imaging.</p><pre><code class="language-julia hljs">using VLBIImagePriors</code></pre><p>Since we are using a Gaussian Markov random field prior we need to first specify our <code>mean</code> image. For this work we will use a symmetric Gaussian with a FWHM of 40 μas</p><pre><code class="language-julia hljs">fwhmfac = 2*sqrt(2*log(2))
mpr = modify(Gaussian(), Stretch(μas2rad(70.0)./fwhmfac))
imgpr = intensitymap(mpr, grid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   X ∈ 32-element LinRange{Float64,...}
→   Y ∈ 32-element LinRange{Float64,...}
And data, 32×32 NamedDimsArray(::Matrix{Float64}, (:X, :Y)):
                 (-3.52247e-10)  …  (3.29522e-10)  (3.52247e-10)
 (-3.52247e-10)     1.00681e-5        1.46195e-5     1.00681e-5
 (-3.29522e-10)     1.46195e-5        2.12284e-5     1.46195e-5
 (-3.06796e-10)     2.07071e-5        3.0068e-5      2.07071e-5
 (-2.84071e-10)     2.86093e-5        4.15425e-5     2.86093e-5
 (-2.61345e-10)     3.85563e-5   …    5.59863e-5     3.85563e-5
 (-2.38619e-10)     5.06857e-5        7.35989e-5     5.06857e-5
    ⋮                            ⋱    ⋮            
  (2.15894e-10)     6.49944e-5        9.43761e-5     6.49944e-5
  (2.38619e-10)     5.06857e-5        7.35989e-5     5.06857e-5
  (2.61345e-10)     3.85563e-5   …    5.59863e-5     3.85563e-5
  (2.84071e-10)     2.86093e-5        4.15425e-5     2.86093e-5
  (3.06796e-10)     2.07071e-5        3.0068e-5      2.07071e-5
  (3.29522e-10)     1.46195e-5        2.12284e-5     1.46195e-5
  (3.52247e-10)     1.00681e-5        1.46195e-5     1.00681e-5</code></pre><p>Now since we are actually modeling our image on the simplex we need to ensure that our mean image has unit flux</p><pre><code class="language-julia hljs">imgpr ./= flux(imgpr)
meanpr = to_real(CenteredLR(), baseimage(imgpr))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">32×32 Matrix{Float64}:
 -3.85419  -3.48121  -3.13309   -2.80983   …  -3.13309   -3.48121  -3.85419
 -3.48121  -3.10822  -2.7601    -2.43685      -2.7601    -3.10822  -3.48121
 -3.13309  -2.7601   -2.41198   -2.08872      -2.41198   -2.7601   -3.13309
 -2.80983  -2.43685  -2.08872   -1.76547      -2.08872   -2.43685  -2.80983
 -2.51144  -2.13846  -1.79034   -1.46708      -1.79034   -2.13846  -2.51144
 -2.23792  -1.86493  -1.51681   -1.19356   …  -1.51681   -1.86493  -2.23792
 -1.98926  -1.61628  -1.26815   -0.944899     -1.26815   -1.61628  -1.98926
 -1.76547  -1.39248  -1.04436   -0.721107     -1.04436   -1.39248  -1.76547
 -1.56654  -1.19356  -0.845436  -0.522181     -0.845436  -1.19356  -1.56654
 -1.39248  -1.0195   -0.671376  -0.348121     -0.671376  -1.0195   -1.39248
  ⋮                                        ⋱              ⋮        
 -1.56654  -1.19356  -0.845436  -0.522181     -0.845436  -1.19356  -1.56654
 -1.76547  -1.39248  -1.04436   -0.721107     -1.04436   -1.39248  -1.76547
 -1.98926  -1.61628  -1.26815   -0.944899  …  -1.26815   -1.61628  -1.98926
 -2.23792  -1.86493  -1.51681   -1.19356      -1.51681   -1.86493  -2.23792
 -2.51144  -2.13846  -1.79034   -1.46708      -1.79034   -2.13846  -2.51144
 -2.80983  -2.43685  -2.08872   -1.76547      -2.08872   -2.43685  -2.80983
 -3.13309  -2.7601   -2.41198   -2.08872      -2.41198   -2.7601   -3.13309
 -3.48121  -3.10822  -2.7601    -2.43685   …  -2.7601    -3.10822  -3.48121
 -3.85419  -3.48121  -3.13309   -2.80983      -3.13309   -3.48121  -3.85419</code></pre><p>Part of hybrid imaging is to force a scale separation between the different model components to make them identifiable. To enforce this we will set the length scale of the raster component equal to the beam size of the telescope in units of pixel length, which is given by</p><pre><code class="language-julia hljs">hh(x) = hypot(x...)
beam = inv(maximum(hh.(uvpositions.(extract_table(obs, ComplexVisibilities()).data))))
rat = (beam/(4*step(grid.X)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.3315841594343798</code></pre><p>Then we can define our hyperprior map fixing the inverse correlation length of the random field to be equal to the beam size of the telescope. Note that the variance of the field is left as a free parameter.</p><pre><code class="language-julia hljs">crcache = MarkovRandomFieldCache(meanpr) # The cache precomputes a number of items
fmap = let meanpr=meanpr, crcache=crcache, rat=rat
    x-&gt;GaussMarkovRandomField(meanpr, inv(rat), x.σ^2, crcache)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">#1 (generic function with 1 method)</code></pre><p>Now we can construct the instrument model prior Each station requires its own prior on both the amplitudes and phases. For the amplitudes we assume that the gains are apriori well calibrated around unit gains (or 0 log gain amplitudes) which corresponds to no instrument corruption. The gain dispersion is then set to 10% for all stations except LMT, representing that we expect 10% deviations from scan-to-scan. For LMT we let the prior expand to 100% due to the known pointing issues LMT had in 2017.</p><pre><code class="language-julia hljs">using Distributions
using DistributionsAD
distamp = station_tuple(dvis, Normal(0.0, 0.1); LM = Normal(1.0))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(AA = Distributions.Normal{Float64}(μ=0.0, σ=0.1), AP = Distributions.Normal{Float64}(μ=0.0, σ=0.1), AZ = Distributions.Normal{Float64}(μ=0.0, σ=0.1), JC = Distributions.Normal{Float64}(μ=0.0, σ=0.1), LM = Distributions.Normal{Float64}(μ=1.0, σ=1.0), PV = Distributions.Normal{Float64}(μ=0.0, σ=0.1), SM = Distributions.Normal{Float64}(μ=0.0, σ=0.1))</code></pre><p>For the phases, as mentioned above, we will use a segmented gain prior. This means that rather than the parameters being directly the gains, we fit the first gain for each site, and then the other parameters are the segmented gains compared to the previous time. To model this</p><pre><code class="language-julia hljs">#, we break the gain phase prior into two parts. The first is the prior</code></pre><p>for the first observing timestamp of each site, <code>distphase0</code>, and the second is the prior for segmented gain ϵₜ from time i to i+1, given by <code>distphase</code>. For the EHT, we are dealing with pre-2*rand(rng, ndim) .- 1.5calibrated data, so often, the gain phase jumps from scan to scan are minor. As such, we can put a more informative prior on <code>distphase</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>We use AA (ALMA) as a reference station so we do not have to specify a gain prior for it.</p></div></div><pre><code class="language-julia hljs">distphase = station_tuple(dvis, DiagonalVonMises(0.0, inv(π^2)); reference=:AA)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(AP = VLBIImagePriors.DiagonalVonMises{Float64, Float64, Float64}(μ=0.0, κ=0.10132118364233778, lnorm=-1.739120733481688), AZ = VLBIImagePriors.DiagonalVonMises{Float64, Float64, Float64}(μ=0.0, κ=0.10132118364233778, lnorm=-1.739120733481688), JC = VLBIImagePriors.DiagonalVonMises{Float64, Float64, Float64}(μ=0.0, κ=0.10132118364233778, lnorm=-1.739120733481688), LM = VLBIImagePriors.DiagonalVonMises{Float64, Float64, Float64}(μ=0.0, κ=0.10132118364233778, lnorm=-1.739120733481688), PV = VLBIImagePriors.DiagonalVonMises{Float64, Float64, Float64}(μ=0.0, κ=0.10132118364233778, lnorm=-1.739120733481688), SM = VLBIImagePriors.DiagonalVonMises{Float64, Float64, Float64}(μ=0.0, κ=0.10132118364233778, lnorm=-1.739120733481688))</code></pre><p>Finally we can put form the total model prior</p><pre><code class="language-julia hljs">prior = (
          c  = HierarchicalPrior(fmap, Comrade.NamedDist((;σ=truncated(Normal(0.0, 0.1); lower=0.0)))),
          f  = Uniform(0.0, 1.0),
          r  = Uniform(μas2rad(10.0), μas2rad(30.0)),
          σ  = Uniform(μas2rad(0.1), μas2rad(20.0)),
          ma = Uniform(0.0, 0.5),
          mp = Uniform(0.0, 2π),
          fg = Uniform(0.0, 1.0),
          lgamp = CalPrior(distamp, gcache),
          gphase = CalPrior(distphase, gcachep),
        )</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(c = VLBIImagePriors.HierarchicalPrior{Main.var&quot;#1#2&quot;{Matrix{Float64}, VLBIImagePriors.MarkovRandomFieldCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, LinearAlgebra.Diagonal{Float64, Vector{Float64}}, Matrix{Float64}}, Float64}, Comrade.NamedDist{(:σ,), Tuple{Distributions.Truncated{Distributions.Normal{Float64}, Distributions.Continuous, Float64, Float64, Nothing}}}}(
priormap: #1
hyperprior: Comrade.NamedDist{(:σ,), Tuple{Distributions.Truncated{Distributions.Normal{Float64}, Distributions.Continuous, Float64, Float64, Nothing}}}((Truncated(Distributions.Normal{Float64}(μ=0.0, σ=0.1); lower=0.0),))
)
, f = Distributions.Uniform{Float64}(a=0.0, b=1.0), r = Distributions.Uniform{Float64}(a=4.84813681109536e-11, b=1.454441043328608e-10), σ = Distributions.Uniform{Float64}(a=4.848136811095359e-13, b=9.69627362219072e-11), ma = Distributions.Uniform{Float64}(a=0.0, b=0.5), mp = Distributions.Uniform{Float64}(a=0.0, b=6.283185307179586), fg = Distributions.Uniform{Float64}(a=0.0, b=1.0), lgamp = CalPrior{Distributions.DiagNormal, JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, ScanSeg{false}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}(
dists: DiagNormal(
dim: 126
μ: [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0  …  0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0]
Σ: [0.010000000000000002 0.0 … 0.0 0.0; 0.0 0.010000000000000002 … 0.0 0.0; … ; 0.0 0.0 … 1.0 0.0; 0.0 0.0 … 0.0 0.010000000000000002]
)

jcache: JonesCache{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), NTuple{7, ScanSeg{false}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}(sparse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  265, 266, 267, 268, 269, 270, 271, 272, 273, 274], [1, 3, 3, 3, 5, 6, 6, 7, 7, 7, 9, 10, 10, 11, 11, 11, 13, 14, 14, 15, 15, 15, 17, 18, 18, 20, 21, 21, 22, 22, 22, 24, 25, 25, 26, 26, 26, 28, 29, 29, 30, 30, 30, 32, 33, 33, 34, 34, 34, 34, 36, 37, 37, 38, 38, 38, 39, 39, 39, 39, 41, 42, 42, 43, 43, 43, 44, 44, 44, 44, 46, 47, 47, 48, 48, 48, 49, 49, 49, 49, 49, 50, 51, 51, 53, 53, 53, 54, 54, 54, 54, 55, 55, 55, 55, 55, 55, 56, 57, 57, 57, 59, 59, 59, 59, 60, 60, 60, 60, 60, 61, 61, 62, 62, 62, 62, 62, 62, 63, 64, 64, 64, 66, 66, 66, 66, 67, 67, 67, 67, 67, 68, 68, 69, 69, 69, 69, 69, 69, 70, 71, 71, 71, 73, 73, 73, 73, 74, 74, 74, 74, 74, 75, 75, 76, 76, 76, 76, 77, 77, 79, 79, 79, 80, 81, 81, 81, 81, 82, 83, 83, 85, 85, 85, 86, 86, 86, 86, 86, 87, 88, 88, 88, 90, 90, 90, 90, 91, 91, 92, 92, 92, 92, 93, 93, 95, 95, 95, 96, 97, 97, 97, 97, 97, 98, 99, 99, 99, 101, 101, 101, 101, 102, 102, 103, 103, 103, 103, 103, 104, 105, 105, 105, 107, 107, 107, 107, 108, 108, 109, 109, 109, 109, 109, 110, 111, 111, 111, 113, 113, 113, 113, 114, 114, 115, 115, 115, 115, 115, 116, 117, 117, 117, 119, 119, 119, 119, 120, 120, 121, 121, 121, 121, 121, 122, 123, 123, 123, 125, 125, 125, 125, 126, 126], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 274, 126), sparse([1, 2, 5, 6, 4, 7, 3, 8, 11, 12  …  272, 261, 265, 267, 271, 274, 264, 263, 268, 269], [2, 4, 4, 4, 5, 5, 6, 8, 8, 8, 9, 9, 10, 12, 12, 12, 13, 13, 14, 16, 16, 16, 17, 17, 18, 19, 19, 20, 23, 23, 23, 24, 24, 25, 27, 27, 27, 28, 28, 29, 31, 31, 31, 32, 32, 33, 35, 35, 35, 35, 36, 36, 36, 37, 37, 38, 40, 40, 40, 40, 41, 41, 41, 42, 42, 43, 45, 45, 45, 45, 46, 46, 46, 47, 47, 48, 50, 50, 50, 50, 51, 51, 51, 52, 52, 52, 52, 52, 53, 53, 54, 56, 56, 56, 56, 56, 57, 57, 57, 58, 58, 58, 58, 58, 58, 59, 59, 60, 61, 61, 61, 61, 63, 63, 63, 63, 63, 64, 64, 64, 65, 65, 65, 65, 65, 65, 66, 66, 67, 68, 68, 68, 68, 70, 70, 70, 70, 70, 71, 71, 71, 72, 72, 72, 72, 72, 72, 73, 73, 74, 75, 75, 75, 75, 77, 77, 78, 78, 78, 78, 79, 80, 80, 80, 82, 82, 82, 83, 83, 84, 84, 84, 84, 85, 87, 87, 87, 87, 88, 88, 89, 89, 89, 89, 89, 90, 91, 91, 91, 93, 93, 94, 94, 94, 94, 95, 96, 96, 96, 98, 98, 98, 98, 99, 99, 100, 100, 100, 100, 100, 101, 102, 102, 102, 104, 104, 104, 104, 105, 105, 106, 106, 106, 106, 106, 107, 108, 108, 108, 110, 110, 110, 110, 111, 111, 112, 112, 112, 112, 112, 113, 114, 114, 114, 116, 116, 116, 116, 117, 117, 118, 118, 118, 118, 118, 119, 120, 120, 120, 122, 122, 122, 122, 123, 123, 124, 124, 124, 124, 124, 125, 126, 126, 126], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 274, 126), (AA = ScanSeg{false}(), AP = ScanSeg{false}(), AZ = ScanSeg{false}(), JC = ScanSeg{false}(), LM = ScanSeg{false}(), PV = ScanSeg{false}(), SM = ScanSeg{false}()), Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}([:AA, :PV, :AA, :AP, :LM, :PV, :AA, :AP, :LM, :PV  …  :AZ, :JC, :LM, :SM, :AA, :AP, :AZ, :JC, :LM, :SM], [0.9166666567325592, 0.9166666567325592, 1.2166666388511658, 1.2166666388511658, 1.2166666388511658, 1.2166666388511658, 1.516666665673256, 1.516666665673256, 1.516666665673256, 1.516666665673256  …  7.7166666984558105, 7.7166666984558105, 7.7166666984558105, 7.7166666984558105, 7.983333349227905, 7.983333349227905, 7.983333349227905, 7.983333349227905, 7.983333349227905, 7.983333349227905], [(0.9166666567325592, :AA), (0.9166666567325592, :PV), (1.2166666388511658, :AA), (1.2166666388511658, :AP), (1.2166666388511658, :LM), (1.2166666388511658, :PV), (1.516666665673256, :AA), (1.516666665673256, :AP), (1.516666665673256, :LM), (1.516666665673256, :PV)  …  (7.7166666984558105, :AZ), (7.7166666984558105, :JC), (7.7166666984558105, :LM), (7.7166666984558105, :SM), (7.983333349227905, :AA), (7.983333349227905, :AP), (7.983333349227905, :AZ), (7.983333349227905, :JC), (7.983333349227905, :LM), (7.983333349227905, :SM)]))
)
, gphase = CalPrior{VLBIImagePriors.DiagonalVonMises{Vector{Float64}, Vector{Float64}, Float64}, JonesCache{Comrade.AffineDesignMatrix{SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{ComplexF64}}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), Tuple{FixedSeg{ComplexF64}, Vararg{ScanSeg{false}, 6}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}}(
dists: VLBIImagePriors.DiagonalVonMises{Vector{Float64}, Vector{Float64}, Float64}(
μ: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
κ: [0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778  …  0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778, 0.10132118364233778]
lnorm: -177.39031481513217
)

jcache: JonesCache{Comrade.AffineDesignMatrix{SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{ComplexF64}}, SparseArrays.SparseMatrixCSC{Float64, Int64}, NamedTuple{(:AA, :AP, :AZ, :JC, :LM, :PV, :SM), Tuple{FixedSeg{ComplexF64}, Vararg{ScanSeg{false}, 6}}}, Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}}(Comrade.AffineDesignMatrix{SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{ComplexF64}}(sparse([5, 6, 7, 11, 12, 13, 17, 18, 19, 23  …  265, 266, 267, 268, 269, 270, 271, 272, 273, 274], [3, 4, 4, 6, 7, 7, 9, 10, 10, 12, 13, 13, 15, 16, 16, 18, 19, 19, 21, 22, 22, 24, 25, 25, 27, 28, 28, 29, 29, 29, 31, 32, 32, 33, 33, 33, 35, 36, 36, 37, 37, 37, 38, 39, 39, 41, 41, 41, 42, 42, 42, 42, 43, 44, 44, 44, 46, 46, 46, 46, 47, 47, 47, 47, 47, 48, 48, 49, 50, 50, 50, 52, 52, 52, 52, 53, 53, 53, 53, 53, 54, 54, 55, 56, 56, 56, 58, 58, 58, 58, 59, 59, 59, 59, 59, 60, 60, 61, 61, 63, 63, 63, 64, 65, 66, 66, 68, 68, 68, 69, 70, 70, 70, 72, 72, 72, 72, 73, 73, 74, 74, 76, 76, 76, 77, 78, 79, 79, 79, 81, 81, 81, 81, 82, 82, 83, 84, 84, 84, 86, 86, 86, 86, 87, 87, 88, 89, 89, 89, 91, 91, 91, 91, 92, 92, 93, 94, 94, 94, 96, 96, 96, 96, 97, 97, 98, 99, 99, 99, 101, 101, 101, 101, 102, 102], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 274, 102), ComplexF64[1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im  …  0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im]), sparse([1, 2, 5, 6, 4, 7, 3, 8, 11, 12  …  272, 261, 265, 267, 271, 274, 264, 263, 268, 269], [1, 2, 2, 2, 3, 3, 4, 5, 5, 5, 6, 6, 7, 8, 8, 8, 9, 9, 10, 11, 11, 11, 12, 12, 13, 14, 14, 15, 17, 17, 17, 18, 18, 19, 20, 20, 20, 21, 21, 22, 23, 23, 23, 24, 24, 25, 26, 26, 26, 26, 27, 27, 27, 28, 28, 29, 30, 30, 30, 30, 31, 31, 31, 32, 32, 33, 34, 34, 34, 34, 35, 35, 35, 36, 36, 37, 38, 38, 38, 38, 39, 39, 39, 40, 40, 40, 40, 40, 41, 41, 42, 43, 43, 43, 43, 43, 44, 44, 44, 45, 45, 45, 45, 45, 45, 46, 46, 47, 48, 48, 48, 48, 49, 49, 49, 49, 49, 50, 50, 50, 51, 51, 51, 51, 51, 51, 52, 52, 53, 54, 54, 54, 54, 55, 55, 55, 55, 55, 56, 56, 56, 57, 57, 57, 57, 57, 57, 58, 58, 59, 60, 60, 60, 60, 61, 61, 62, 62, 62, 62, 63, 64, 64, 64, 65, 65, 65, 66, 66, 67, 67, 67, 67, 68, 69, 69, 69, 69, 70, 70, 71, 71, 71, 71, 71, 72, 73, 73, 73, 74, 74, 75, 75, 75, 75, 76, 77, 77, 77, 78, 78, 78, 78, 79, 79, 80, 80, 80, 80, 80, 81, 82, 82, 82, 83, 83, 83, 83, 84, 84, 85, 85, 85, 85, 85, 86, 87, 87, 87, 88, 88, 88, 88, 89, 89, 90, 90, 90, 90, 90, 91, 92, 92, 92, 93, 93, 93, 93, 94, 94, 95, 95, 95, 95, 95, 96, 97, 97, 97, 98, 98, 98, 98, 99, 99, 100, 100, 100, 100, 100, 101, 102, 102, 102], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 274, 102), (AA = FixedSeg{ComplexF64}(1.0 + 0.0im), AP = ScanSeg{false}(), AZ = ScanSeg{false}(), JC = ScanSeg{false}(), LM = ScanSeg{false}(), PV = ScanSeg{false}(), SM = ScanSeg{false}()), Comrade.GainSchema{Vector{Symbol}, Vector{Float64}, Vector{Tuple{Float64, Symbol}}}([:PV, :AP, :LM, :PV, :AP, :LM, :PV, :AP, :LM, :PV  …  :AP, :AZ, :JC, :LM, :SM, :AP, :AZ, :JC, :LM, :SM], [0.9166666567325592, 1.2166666388511658, 1.2166666388511658, 1.2166666388511658, 1.516666665673256, 1.516666665673256, 1.516666665673256, 1.816666603088379, 1.816666603088379, 1.816666603088379  …  7.7166666984558105, 7.7166666984558105, 7.7166666984558105, 7.7166666984558105, 7.7166666984558105, 7.983333349227905, 7.983333349227905, 7.983333349227905, 7.983333349227905, 7.983333349227905], [(0.9166666567325592, :PV), (1.2166666388511658, :AP), (1.2166666388511658, :LM), (1.2166666388511658, :PV), (1.516666665673256, :AP), (1.516666665673256, :LM), (1.516666665673256, :PV), (1.816666603088379, :AP), (1.816666603088379, :LM), (1.816666603088379, :PV)  …  (7.7166666984558105, :AP), (7.7166666984558105, :AZ), (7.7166666984558105, :JC), (7.7166666984558105, :LM), (7.7166666984558105, :SM), (7.983333349227905, :AP), (7.983333349227905, :AZ), (7.983333349227905, :JC), (7.983333349227905, :LM), (7.983333349227905, :SM)]))
)
)</code></pre><p>This is everything we need to specify our posterior distribution, which our is the main object of interest in image reconstructions when using Bayesian inference.</p><pre><code class="language- hljs">post = Posterior(lklhd, prior)</code></pre><p>To sample from our prior we can do</p><pre><code class="language- hljs">xrand = prior_sample(rng, post)</code></pre><p>and then plot the results</p><pre><code class="language- hljs">using Plots
img = intensitymap(skymodel(post, xrand), μas2rad(150.0), μas2rad(150.0), 128, 128)
plot(img, title=&quot;Random sample&quot;)</code></pre><h2 id="Reconstructing-the-Image"><a class="docs-heading-anchor" href="#Reconstructing-the-Image">Reconstructing the Image</a><a id="Reconstructing-the-Image-1"></a><a class="docs-heading-anchor-permalink" href="#Reconstructing-the-Image" title="Permalink"></a></h2><p>To sample from this posterior, it is convenient to first move from our constrained parameter space to an unconstrained one (i.e., the support of the transformed posterior is (-∞, ∞)). This is done using the <code>asflat</code> function.</p><pre><code class="language- hljs">tpost = asflat(post)</code></pre><p>We can now also find the dimension of our posterior or the number of parameters we will sample.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This can often be different from what you would expect. This is especially true when using angular variables, where we often artificially increase the dimension of the parameter space to make sampling easier.</p></div></div><pre><code class="language- hljs">ndim = dimension(tpost)</code></pre><p>We will now move directly to sampling at this point.</p><pre><code class="language- hljs">using ComradeAHMC
using Zygote
metric = DiagEuclideanMetric(ndim)
chain, stats = sample(rng, post, AHMC(;metric, autodiff=Val(:Zygote)), 3000; nadapts=2000)</code></pre><p>We then remove the adaptation/warmup phase from our chain</p><pre><code class="language- hljs">chain = chain[2001:end]
stats = stats[2001:end]</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This should be run for 2-3x more steps to properly estimate expectations of the posterior</p></div></div><p>Now lets plot the mean image and standard deviation images. To do this we first clip the first 250 MCMC steps since that is during tuning and so the posterior is not sampling from the correct stationary distribution.</p><pre><code class="language- hljs">using StatsBase
msamples = skymodel.(Ref(post), chain[begin:10:end]);
nothing #hide</code></pre><p>The mean image is then given by</p><pre><code class="language- hljs">imgs = intensitymap.(msamples, fovxy, fovxy, 128, 128)
plot(mean(imgs), title=&quot;Mean Image&quot;)
plot(std(imgs), title=&quot;Std Dev.&quot;)</code></pre><p>We can also split up the model into its components and analyze each separately</p><pre><code class="language- hljs">comp = Comrade.components.(msamples)
ring_samples = getindex.(comp, 2)
rast_samples = first.(comp)
ring_imgs = intensitymap.(ring_samples, fovxy, fovxy, 128, 128)
rast_imgs = intensitymap.(rast_samples, fovxy, fovxy, 128, 128)

ring_mean, ring_std = mean_and_std(ring_imgs)
rast_mean, rast_std = mean_and_std(rast_imgs)

p1 = plot(ring_mean, title=&quot;Ring Mean&quot;, clims=(0.0, maximum(ring_mean)), colorbar=:none)
p2 = plot(ring_std, title=&quot;Ring Std. Dev.&quot;, clims=(0.0, maximum(ring_mean)), colorbar=:none)
p3 = plot(rast_mean, title=&quot;Raster Mean&quot;, clims=(0.0, maximum(ring_mean)), colorbar=:none)
p4 = plot(rast_std,  title=&quot;Raster Std. Dev.&quot;, clims=(0.0, maximum(ring_mean)), colorbar=:none)

plot(p1,p2,p3,p4, layout=(2,2), size=(650, 650))</code></pre><p>Finally, let&#39;s take a look at some of the ring parameters</p><pre><code class="language- hljs">using StatsPlots
p1 = density(rad2μas(chain.r)*2, xlabel=&quot;Ring Diameter (μas)&quot;)
p2 = density(rad2μas(chain.σ)*2*sqrt(2*log(2)), xlabel=&quot;Ring FWHM (μas)&quot;)
p3 = density(-rad2deg.(chain.mp) .+ 360.0, xlabel = &quot;Ring PA (deg) E of N&quot;)
p4 = density(2*chain.ma, xlabel=&quot;Brightness asymmetry&quot;)
p5 = density(1 .- chain.f, xlabel=&quot;Ring flux fraction&quot;)
plot(p1, p2, p3, p4, p5, size=(900, 600), legend=nothing)</code></pre><p>Now let&#39;s check the residuals using draws from the posterior</p><pre><code class="language- hljs">p = plot();
for s in sample(chain, 10)
    residual!(p, vlbimodel(post, s), dvis)
end
p</code></pre><p>And everything looks pretty good! Now comes the hard part: interpreting the results...</p><h2 id="Computing-information"><a class="docs-heading-anchor" href="#Computing-information">Computing information</a><a id="Computing-information-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-information" title="Permalink"></a></h2><pre><code class="nohighlight hljs">Julia Version 1.8.5
Commit 17cfb8e65ea (2023-01-08 06:45 UTC)
Platform Info:
  OS: Linux (x86_64-linux-gnu)
  CPU: 32 × AMD Ryzen 9 7950X 16-Core Processor
  WORD_SIZE: 64
  LIBM: libopenlibm
  LLVM: libLLVM-13.0.1 (ORCJIT, znver3)
  Threads: 1 on 32 virtual cores
Environment:
  JULIA_EDITOR = code
  JULIA_NUM_THREADS = 1</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../imaging_pol/">« Polarized Image and Instrumental Modeling</a><a class="docs-footer-nextpage" href="../../libs/optimization/">ComradeOptimization »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 16 June 2023 02:29">Friday 16 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
