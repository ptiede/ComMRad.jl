var documenterSearchIndex = {"docs":
[{"location":"base_api/#Base-API","page":"Base API","title":"Base API","text":"","category":"section"},{"location":"base_api/#Contents","page":"Base API","title":"Contents","text":"","category":"section"},{"location":"base_api/","page":"Base API","title":"Base API","text":"Pages = [\"base_api.md\"]","category":"page"},{"location":"base_api/#Index","page":"Base API","title":"Index","text":"","category":"section"},{"location":"base_api/","page":"Base API","title":"Base API","text":"Pages = [\"base_api.md\"]","category":"page"},{"location":"base_api/","page":"Base API","title":"Base API","text":"CurrentModule = ComradeBase","category":"page"},{"location":"base_api/#Model-API","page":"Base API","title":"Model API","text":"","category":"section"},{"location":"base_api/","page":"Base API","title":"Base API","text":"ComradeBase.flux\nComradeBase.visibility\nComradeBase.visibilitymap\nComradeBase.visibilitymap!\nComradeBase.intensitymap\nComradeBase.intensitymap!\nComradeBase.allocate_vismap\nComradeBase.allocate_imgmap\nComradeBase.create_imgmap\nComradeBase.create_vismap\nComradeBase.amplitude(::Any, ::Any)\nComradeBase.amplitudemap\nComradeBase.bispectrum\nComradeBase.bispectrummap\nComradeBase.closure_phase\nComradeBase.closure_phasemap\nComradeBase.logclosure_amplitude\nComradeBase.logclosure_amplitudemap","category":"page"},{"location":"base_api/#ComradeBase.flux","page":"Base API","title":"ComradeBase.flux","text":"flux(im::IntensityMap)\n\nComputes the flux of a intensity map\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.visibility","page":"Base API","title":"ComradeBase.visibility","text":"visibility(mimg, p)\n\nComputes the complex visibility of model m at coordinates p. p corresponds to the coordinates of the model. These need to have the properties U, V and sometimes Ti for time and Fr for frequency.\n\nNotes\n\nIf you want to compute the visibilities at a large number of positions consider using the visibilitymap.\n\nWarn\n\nThis is only defined for analytic models. If you want to compute the visibility for a single point for a non-analytic model, please use the visibilitymap function and create an UnstructuredDomain with a single point.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.visibilitymap","page":"Base API","title":"ComradeBase.visibilitymap","text":"visibilitymap(model::AbstractModel, p)\n\nComputes the complex visibilities at the locations p.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.visibilitymap!","page":"Base API","title":"ComradeBase.visibilitymap!","text":"visibilitymap!(vis::AbstractArray, model::AbstractModel, p)\n\nComputes the complex visibilities vis in place at the locations p\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.intensitymap","page":"Base API","title":"ComradeBase.intensitymap","text":"intensitymap(model::AbstractModel, p::AbstractSingleDomain)\n\nComputes the intensity map of model. For the inplace version see intensitymap!\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.intensitymap!","page":"Base API","title":"ComradeBase.intensitymap!","text":"intensitymap!(buffer::AbstractDimArray, model::AbstractModel)\n\nComputes the intensity map of model by modifying the buffer\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.allocate_vismap","page":"Base API","title":"ComradeBase.allocate_vismap","text":"allocate_vismap(m::AbstractModel, g::AbstractSingleDomain)\n\nAllocate the default map specialized by the grid g\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.allocate_imgmap","page":"Base API","title":"ComradeBase.allocate_imgmap","text":"allocate_imgmap(m::AbstractModel, g::AbstractSingleDomain)\n\nAllocate the default map specialized by the grid g\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.create_imgmap","page":"Base API","title":"ComradeBase.create_imgmap","text":"create_imgmap(array, g::AbstractSingleDomain)\n\nCreate a map of values specialized by the grid g in the image domain. The default is to call create_map with the same arguments.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.create_vismap","page":"Base API","title":"ComradeBase.create_vismap","text":"create_vismap(array, g::AbstractSingleDomain)\n\nCreate a map of values specialized by the grid g in the visibility domain. The default is to call create_map with the same arguments.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.amplitude-Tuple{Any, Any}","page":"Base API","title":"ComradeBase.amplitude","text":"amplitude(model, p)\n\nComputes the visibility amplitude of model m at the coordinate p. The coordinate p is expected to have the properties U, V, and sometimes Ti and Fr.\n\nIf you want to compute the amplitudemap at a large number of positions consider using the amplitudemap function.\n\n\n\n\n\n","category":"method"},{"location":"base_api/#ComradeBase.amplitudemap","page":"Base API","title":"ComradeBase.amplitudemap","text":"amplitudemap(m::AbstractModel, p)\n\nComputes the visibility amplitudemap of the model m at the coordinates p. The coordinates p are expected to have the properties U, V, and sometimes Ti and Fr.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.bispectrum","page":"Base API","title":"ComradeBase.bispectrum","text":"bispectrum(model, p1, p2, p3)\n\nComputes the complex bispectrum of model m at the uv-triangle p1 -> p2 -> p3\n\nIf you want to compute the bispectrum over a number of triangles consider using the bispectrummap function.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.bispectrummap","page":"Base API","title":"ComradeBase.bispectrummap","text":"bispectrummap(m, p1, p2, p3)\n\nComputes the closure phases of the model m at the triangles p1, p2, p3, where pi are coordinates.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.closure_phase","page":"Base API","title":"ComradeBase.closure_phase","text":"closure_phase(model, p1, p2, p3, p4)\n\nComputes the closure phase of model m at the uv-triangle u1,v1 -> u2,v2 -> u3,v3\n\nIf you want to compute closure phases over a number of triangles consider using the closure_phasemap function.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.closure_phasemap","page":"Base API","title":"ComradeBase.closure_phasemap","text":"closure_phasemap(m,\n               p1::AbstractArray\n               p2::AbstractArray\n               p3::AbstractArray\n               )\n\nComputes the closure phases of the model m at the triangles p1, p2, p3, where pi are coordinates.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.logclosure_amplitude","page":"Base API","title":"ComradeBase.logclosure_amplitude","text":"logclosure_amplitude(model, p1, p2, p3, p4)\n\nComputes the log-closure amplitude of model m at the uv-quadrangle u1,v1 -> u2,v2 -> u3,v3 -> u4,v4 using the formula\n\nC = logleftfracV(u1v1)V(u2v2)V(u3v3)V(u4v4)right\n\nIf you want to compute log closure amplitudemap over a number of triangles consider using the logclosure_amplitudemap function.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.logclosure_amplitudemap","page":"Base API","title":"ComradeBase.logclosure_amplitudemap","text":"logclosure_amplitudemap(m::AbstractModel,\n                      p1,\n                      p2,\n                      p3,\n                      p4\n                     )\n\nComputes the log closure amplitudemap of the model m at the quadrangles p1, p2, p3, p4.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#Model-Interface","page":"Base API","title":"Model Interface","text":"","category":"section"},{"location":"base_api/","page":"Base API","title":"Base API","text":"ComradeBase.AbstractModel\nComradeBase.AbstractPolarizedModel\nComradeBase.visanalytic\nComradeBase.imanalytic\nComradeBase.ispolarized\nComradeBase.radialextent\nComradeBase.DensityAnalytic\nComradeBase.IsAnalytic\nComradeBase.NotAnalytic\nComradeBase.visibility_point\nComradeBase.visibilitymap_analytic\nComradeBase.visibilitymap_analytic!\nComradeBase.visibilitymap_numeric\nComradeBase.visibilitymap_numeric!\nComradeBase.intensity_point\nComradeBase.intensitymap_analytic\nComradeBase.intensitymap_analytic!\nComradeBase.intensitymap_numeric\nComradeBase.intensitymap_numeric!","category":"page"},{"location":"base_api/#ComradeBase.AbstractModel","page":"Base API","title":"ComradeBase.AbstractModel","text":"AbstractModel\n\nThe Comrade abstract model type. To instantiate your own model type you should subtybe from this model. Additionally you need to implement the following methods to satify the interface:\n\nMandatory Methods\n\nvisanalytic: defines whether the model visibilities can be computed analytically. If yes  then this should return IsAnalytic() and the user must to define visibility_point.  If not analytic then visanalytic should return NotAnalytic().\nimanalytic: defines whether the model intensities can be computed pointwise. If yes   then this should return IsAnalytic() and the user must to define intensity_point.   If not analytic then imanalytic should return NotAnalytic().\nradialextent: Provides a estimate of the radial extent of the model in the image domain.  This is used for estimating the size of the image, and for plotting.\nflux: Returns the total flux of the model.\nintensity_point: Defines how to compute model intensities pointwise. Note this is must be defined if imanalytic(::Type{YourModel})==IsAnalytic().\nvisibility_point: Defines how to compute model visibilties pointwise. Note this is   must be defined if visanalytic(::Type{YourModel})==IsAnalytic().\n\nOptional Methods:\n\nispolarized: Specified whether a model is intrinsically polarized (returns IsPolarized()) or is not (returns NotPolarized()), by default a model is NotPolarized()\nvisibilitymap_analytic: Vectorized version of visibility_point for models where visanalytic returns IsAnalytic()\nvisibilitymap_numeric: Vectorized version of visibility_point for models where visanalytic returns NotAnalytic() typically these are numerical FT's\nintensitymap_analytic: Computes the entire image for models where imanalytic returns IsAnalytic()\nintensitymap_numeric: Computes the entire image for models where imanalytic returns NotAnalytic()\nintensitymap_analytic!: Inplace version of intensitymap\nintensitymap_numeric!: Inplace version of intensitymap\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.AbstractPolarizedModel","page":"Base API","title":"ComradeBase.AbstractPolarizedModel","text":"abstract type AbstractPolarizedModel <: ComradeBase.AbstractModel\n\nA generic polarized model. To implement the use needs to follow the AbstractModel implementation instructions. In addtion there is an optional method stokes(model, p::Symbol) which extracts the specific stokes parameter of the model. The default that the different stokes parameters are stored as fields of the model. To overwrite this behavior overload the function.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.visanalytic","page":"Base API","title":"ComradeBase.visanalytic","text":"visanalytic(::Type{<:AbstractModel})\n\nDetermines whether the model is pointwise analytic in Fourier domain, i.e. we can evaluate its fourier transform at an arbritrary point.\n\nIf IsAnalytic() then it will try to call visibility_point to calculate the complex visibilities. Otherwise it fallback to using the FFT that works for all models that can compute an image.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.imanalytic","page":"Base API","title":"ComradeBase.imanalytic","text":"imanalytic(::Type{<:AbstractModel})\n\nDetermines whether the model is pointwise analytic in the image domain, i.e. we can evaluate its intensity at an arbritrary point.\n\nIf IsAnalytic() then it will try to call intensity_point to calculate the intensity.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.ispolarized","page":"Base API","title":"ComradeBase.ispolarized","text":"ispolarized(::Type)\n\nTrait function that defines whether a model is polarized or not.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.radialextent","page":"Base API","title":"ComradeBase.radialextent","text":"radialextent(model::AbstractModel)\n\nProvides an estimate of the radial size/extent of the model. This is used internally to estimate image size when plotting and using modelimage\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.DensityAnalytic","page":"Base API","title":"ComradeBase.DensityAnalytic","text":"DensityAnalytic\n\nInternal type for specifying the nature of the model functions. Whether they can be easily evaluated pointwise analytic. This is an internal type that may change.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.IsAnalytic","page":"Base API","title":"ComradeBase.IsAnalytic","text":"struct IsAnalytic <: ComradeBase.DensityAnalytic\n\nDefines a trait that a states that a model is analytic. This is usually used with an abstract model where we use it to specify whether a model has a analytic fourier transform and/or image.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.NotAnalytic","page":"Base API","title":"ComradeBase.NotAnalytic","text":"struct NotAnalytic <: ComradeBase.DensityAnalytic\n\nDefines a trait that a states that a model is analytic. This is usually used with an abstract model where we use it to specify whether a model has does not have a easy analytic fourier transform and/or intensity function.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.visibility_point","page":"Base API","title":"ComradeBase.visibility_point","text":"visibility_point(model::AbstractModel, p)\n\nFunction that computes the pointwise visibility. This must be implemented in the model interface if visanalytic(::Type{MyModel}) == IsAnalytic()\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.visibilitymap_analytic","page":"Base API","title":"ComradeBase.visibilitymap_analytic","text":"visibilties_analytic(model, p)\n\nComputes the visibilties of a model using using the analytic visibility expression given by visibility_point.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.visibilitymap_analytic!","page":"Base API","title":"ComradeBase.visibilitymap_analytic!","text":"visibilties_analytic!(vis, model)\n\nComputes the visibilties of a model in-place, using using the analytic visibility expression given by visibility_point.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.visibilitymap_numeric","page":"Base API","title":"ComradeBase.visibilitymap_numeric","text":"visibilties_numeric(model, p)\n\nComputes the visibilties of a model using a numerical fourier transform. Note that none of these are implemented in ComradeBase. For implementations please see Comrade.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.visibilitymap_numeric!","page":"Base API","title":"ComradeBase.visibilitymap_numeric!","text":"visibilties_numeric!(vis, model)\n\nComputes the visibilties of a model in-place using a numerical fourier transform. Note that none of these are implemented in ComradeBase. For implementations please see Comrade.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.intensity_point","page":"Base API","title":"ComradeBase.intensity_point","text":"intensity_point(model::AbstractModel, p)\n\nFunction that computes the pointwise intensity if the model has the trait in the image domain IsAnalytic(). Otherwise it will use construct the image in visibility space and invert it.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.intensitymap_analytic","page":"Base API","title":"ComradeBase.intensitymap_analytic","text":"intensitymap_analytic(m::AbstractModel, p::AbstractSingleDomain)\n\nComputes the IntensityMap of a model m using the image dimensions p by broadcasting over the analytic intensity_point method.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.intensitymap_analytic!","page":"Base API","title":"ComradeBase.intensitymap_analytic!","text":"intensitymap_analytic!(img::IntensityMap, m::AbstractModel)\n\nUpdates the img using the model m  by broadcasting over the analytic intensity_point method.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.intensitymap_numeric","page":"Base API","title":"ComradeBase.intensitymap_numeric","text":"intensitymap_numeric(m::AbstractModel, p::AbstractSingleDomain)\n\nComputes the IntensityMap of a model m at the image positions p using a numerical method. This has to be specified uniquely for every model m if imanalytic(typeof(m)) === NotAnalytic(). See Comrade.jl for example implementations.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.intensitymap_numeric!","page":"Base API","title":"ComradeBase.intensitymap_numeric!","text":"intensitymap_numeric!(img::IntensityMap, m::AbstractModel)\n\nUpdates the img using the model m  using a numerical method. This has to be specified uniquely for every model m if imanalytic(typeof(m)) === NotAnalytic(). See Comrade.jl for example implementations.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#Image-Domain","page":"Base API","title":"Image Domain","text":"","category":"section"},{"location":"base_api/","page":"Base API","title":"Base API","text":"ComradeBase.imagepixels\nComradeBase.RectiGrid\nComradeBase.UnstructuredDomain\nComradeBase.dims\nComradeBase.named_dims\nComradeBase.axisdims\nComradeBase.domainpoints\nComradeBase.fieldofview\nComradeBase.pixelsizes\nComradeBase.phasecenter\nComradeBase.executor\nComradeBase.Serial\nComradeBase.ThreadsEx\nComradeBase.header\nComradeBase.NoHeader\nComradeBase.MinimalHeader","category":"page"},{"location":"base_api/#ComradeBase.imagepixels","page":"Base API","title":"ComradeBase.imagepixels","text":"imagepixels(fovx, fovy, nx, ny; x0=0, y0=0, executor=Serial(), header=NoHeader())\n\nConstruct a grid of pixels with a field of view fovx and fovy and nx and ny pixels. This points are the pixel centers and the field of view goes from the edge of the first pixel to the edge of the last pixel. The x0, y0 offsets shift the image origin over by (x0, y0) in the image plane.\n\nArguments:\n\nfovx::Real: The field of view in the x-direction\nfovy::Real: The field of view in the y-direction\nnx::Integer: The number of pixels in the x-direction\nny::Integer: The number of pixels in the y-direction\n\nKeyword Arguments:\n\nx0::Real=0: The x-offset of the image\ny0::Real=0: The y-offset of the image\nexecutor=Serial(): The executor to use for the grid, default is serial execution\nheader=NoHeader(): The header to use for the grid\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.RectiGrid","page":"Base API","title":"ComradeBase.RectiGrid","text":"RectiGrid(dims::NamedTuple{Na}; executor=Serial(), header=ComradeBase.NoHeader())\nRectiGrid(dims::NTuple{N, <:DimensionalData.Dimension}; executor=Serial(), header=ComradeBase.NoHeader())\n\nCreates a rectilinear grid of pixels with the dimensions dims. The dims can either be a named tuple of dimensions or a tuple of dimensions. The dimensions can be in any order however the standard orders are:\n\n(:X, :Y, :Ti, :Fr)\n(:X, :Y, :Fr, :Ti)\n(:X, :Y) # spatial only\n\nwhere X,Y are the RA and DEC spatial dimensions respectively, Ti is the time dimension and Fr is the frequency dimension.\n\nNote that the majority of the time users should just call imagepixels to create a spatial grid.\n\nOptional Arguments\n\nexecutor: specifies how different models  are executed. The default is Serial which mean serial CPU computations. For threaded  computations use ThreadsEx() or load OhMyThreads.jl to uses their schedulers.\nheader: specified underlying header information for the grid. This is used to store  information about the image such as the source, RA and DEC, MJD.\n\nExamples\n\ndims = RectiGrid((X(-5.0:0.1:5.0), Y(-4.0:0.1:4.0), Ti([1.0, 1.5, 1.75]), Fr([230, 345])); executor=ThreadsEx())\ndims = RectiGrid((X = -5.0:0.1:5.0, Y = -4.0:0.1:4.0, Ti = [1.0, 1.5, 1.75], Fr = [230, 345]); executor=ThreadsEx()))\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.UnstructuredDomain","page":"Base API","title":"ComradeBase.UnstructuredDomain","text":"UnstructuredDomain(dims::AbstractArray; executor=Serial(), header=ComradeBase.NoHeader)\n\nBuilds an unstructured grid (really a vector of points) from the dimensions dims. The executor is used controls how the grid is computed when calling visibilitymap or intensitymap. The default is Serial which mean regular CPU computations. For threaded execution use ThreadsEx() or load OhMyThreads.jl to uses their schedulers.\n\nNote that unlike RectiGrid which assigns dimensions to the grid points, UnstructuredDomain does not. This is becuase the grid is unstructured the points are a cloud in a space\n\n\n\n\n\n","category":"type"},{"location":"base_api/#DimensionalData.Dimensions.dims","page":"Base API","title":"DimensionalData.Dimensions.dims","text":"dims(g::AbstractSingleDomain)\n\nReturns a tuple containing the dimensions of g. For a named version see ComradeBase.named_dims\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.named_dims","page":"Base API","title":"ComradeBase.named_dims","text":"named_dims(g::AbstractSingleDomain)\n\nReturns a named tuple containing the dimensions of g. For a unnamed version see dims\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.axisdims","page":"Base API","title":"ComradeBase.axisdims","text":"axisdims(img::IntensityMap)\naxisdims(img::IntensityMap, p::Symbol)\n\nReturns the keys of the IntensityMap as the actual internal AbstractRectiGrid object. Optionall the user can ask for a specific dimension with p\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.domainpoints","page":"Base API","title":"ComradeBase.domainpoints","text":"domainpoints(g::AbstractSingleDomain)\n\nCreate a grid iterator that can be used to iterate through different points. All grid methods must implement this method.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.fieldofview","page":"Base API","title":"ComradeBase.fieldofview","text":"fieldofview(img::IntensityMap)\nfieldofview(img::IntensityMap)\n\nReturns a named tuple with the field of view of the image.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.pixelsizes","page":"Base API","title":"ComradeBase.pixelsizes","text":"pixelsizes(img::IntensityMap)\npixelsizes(img::AbstractRectiGrid)\n\nReturns a named tuple with the spatial pixel sizes of the image.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.phasecenter","page":"Base API","title":"ComradeBase.phasecenter","text":"phasecenter(img::IntensityMap)\n\nComputes the phase center of an intensity map. Note this is the pixels that is in the middle of the image.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.executor","page":"Base API","title":"ComradeBase.executor","text":"executor(g::AbstractSingleDomain)\n\nReturns the executor used to compute the intensitymap or visibilitymap\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.Serial","page":"Base API","title":"ComradeBase.Serial","text":"Serial()\n\nUses serial execution when computing the intensitymap or visibilitymap\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.ThreadsEx","page":"Base API","title":"ComradeBase.ThreadsEx","text":"ThreadsEx(;scheduler::Symbol = :dynamic)\n\nUses Julia's Threads @threads macro when computing the intensitymap or visibilitymap. You can choose from Julia's various schedulers by passing the scheduler as a parameter. The default is :dynamic, but it isn't considered part of the stable API and may change at any moment.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.header","page":"Base API","title":"ComradeBase.header","text":"header(g::AbstractSingleDomain)\n\nReturns the headerinformation of the dimensions g\n\n\n\n\n\nheader(img::IntensityMap)\n\nRetrieves the header of an IntensityMap\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.NoHeader","page":"Base API","title":"ComradeBase.NoHeader","text":"NoHeader\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.MinimalHeader","page":"Base API","title":"ComradeBase.MinimalHeader","text":"MinimalHeader{T}\n\nA minimal header type for ancillary image information.\n\nFields\n\nsource: Common source name\n\nra: Right ascension of the image in degrees (J2000)\n\ndec: Declination of the image in degrees (J2000)\n\nmjd: Modified Julian Date in days\n\nfrequency: Frequency of the image in Hz\n\n\n\n\n\n","category":"type"},{"location":"base_api/#Image-Types","page":"Base API","title":"Image Types","text":"","category":"section"},{"location":"base_api/","page":"Base API","title":"Base API","text":"ComradeBase.IntensityMap\nComradeBase.IntensityMap(::AbstractArray, ::AbstractRectiGrid)\nComradeBase.UnstructuredMap\nComradeBase.baseimage\nComradeBase.centroid\nComradeBase.second_moment\nComradeBase.load\nComradeBase.save\nComradeBase.stokes","category":"page"},{"location":"base_api/#ComradeBase.IntensityMap","page":"Base API","title":"ComradeBase.IntensityMap","text":"struct IntensityMap{T, N, D, G<:(ComradeBase.AbstractRectiGrid{D}), A<:AbstractArray{T, N}, R<:Tuple, Na} <: AbstractDimArray{T, N, D, A<:AbstractArray{T, N}}\n\nThis type is the basic array type for all images and models that obey the ComradeBase interface. The type is a subtype of DimensionalData.AbstractDimArray however, we make a few changes to support the Comrade API.\n\nThe dimensions should be specified by an AbstractRectiGrid interface. Usually users just need the RectiGrid grid, for rectilinear grids.\nThere are two ways to access the dimensions of the array. dims(img) will return the usual DimArray dimensions, i.e. a Tuple{DimensionalData.Dim, ...}. The other way to access the array dimensions is using the getproperty, e.g., img.X will return the RA/X grid locations but stripped of the usual DimensionalData.Dimension material. This getproperty behavior is *NOT CONSIDERED** part of the stable API and may be changed in the future.\nMetadata is stored in the AbstractRectiGrid type through the header property and can be accessed through metadata or header\n\nThe most common way to create a IntensityMap is to use the function definitions\n\njulia> g = imagepixels(10.0, 10.0, 128, 128; header=NoHeader())\njulia> X = g.X; Y = g.Y\njulia> data = rand(128, 128)\njulia> img1 = IntensityMap(data, g)\njulia> img2 = IntensityMap(data, (;X, Y); header=header(g))\njulia> img1 == img2\ntrue\njulia> img3 = IntensityMap(data, 10.0, 10.0; header=NoHeader())\n\nBroadcasting, map, and reductions should all just obey the DimensionalData interface.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.IntensityMap-Tuple{AbstractArray, ComradeBase.AbstractRectiGrid}","page":"Base API","title":"ComradeBase.IntensityMap","text":"IntensityMap(data::AbstractArray, g::AbstractRectiGrid; refdims=(), name=Symbol(\"\"))\n\nCreates a IntensityMap with the pixel fluxes data on the grid g. Optionally, you can specify a set of reference dimensions refdims as a tuple and a name for array name.\n\n\n\n\n\n","category":"method"},{"location":"base_api/#ComradeBase.UnstructuredMap","page":"Base API","title":"ComradeBase.UnstructuredMap","text":"UnstructuredMap(data::AbstractVector, dims::UnstructuredDomain)\n\nA map that is defined on an unstructured domain. This is typically just a vector of values. The vector of locations of the visibilities are stored in dims. Otherwise this behaves very similarly to IntensityMap, except that is isn't a grid.\n\nFor instance the locations of the visibilities can be accessed with axisdims, as well as the usual getproperty and propertynames functions. Like with IntensityMap during execution the executor is used to determine the execution context.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.baseimage","page":"Base API","title":"ComradeBase.baseimage","text":"Returns the base image of a intensity map type object\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.centroid","page":"Base API","title":"ComradeBase.centroid","text":"centroid(im::AbstractIntensityMap)\n\nComputes the image centroid aka the center of light of the image.\n\nFor polarized maps we return the centroid for Stokes I only.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.second_moment","page":"Base API","title":"ComradeBase.second_moment","text":"second_moment(im::AbstractIntensityMap; center=true)\n\nComputes the image second moment tensor of the image. By default we really return the second cumulant or centered second moment, which is specified by the center argument.\n\nFor polarized maps we return the second moment for Stokes I only.\n\n\n\n\n\nsecond_moment(im::AbstractIntensityMap; center=true)\n\nComputes the image second moment tensor of the image. By default we really return the second cumulant or centered second moment, which is specified by the center argument.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.load","page":"Base API","title":"ComradeBase.load","text":"ComradeBase.load(fitsfile::String, IntensityMap)\n\nThis loads in a fits file that is more robust to the various imaging algorithms in the EHT, i.e. is works with clean, smili, eht-imaging. The function returns an tuple with an intensitymap and a second named tuple with ancillary information about the image, like the source name, location, mjd, and radio frequency.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.save","page":"Base API","title":"ComradeBase.save","text":"ComradeBase.save(file::String, img::IntensityMap, obs)\n\nSaves an image to a fits file. You can optionally pass an EHTObservation so that ancillary information will be added.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.stokes","page":"Base API","title":"ComradeBase.stokes","text":"stokes(m::AbstractPolarizedModel, p::Symbol)\n\nExtract the specific stokes component p from the polarized model m\n\n\n\n\n\nstokes(m::AbstractArray{<:StokesParams}, p::Symbol)\n\nExtract the specific stokes component p from the polarized image m.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#Internal-Methods-not-part-of-public-API","page":"Base API","title":"Internal Methods not part of public API","text":"","category":"section"},{"location":"base_api/","page":"Base API","title":"Base API","text":"ComradeBase._visibilitymap\nComradeBase._visibilitymap!\nComradeBase.create_map","category":"page"},{"location":"base_api/#ComradeBase._visibilitymap","page":"Base API","title":"ComradeBase._visibilitymap","text":"_visibilitymap(model::AbstractModel, p)\n\nInternal method used for trait dispatch and unpacking of args arguments in visibilities\n\nwarn: Warn\nNot part of the public API so it may change at any moment.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase._visibilitymap!","page":"Base API","title":"ComradeBase._visibilitymap!","text":"_visibilitymap!(model::AbstractModel, p)\n\nInternal method used for trait dispatch and unpacking of args arguments in visibilities!\n\nwarn: Warn\nNot part of the public API so it may change at any moment.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.create_map","page":"Base API","title":"ComradeBase.create_map","text":"create_map(array, g::AbstractSingleDomain)\n\nCreate a map of values specialized by the grid g.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"EditURL = \"../../../examples/StokesIImaging/main.jl\"","category":"page"},{"location":"tutorials/StokesIImaging/#Stokes-I-Simultaneous-Image-and-Instrument-Modeling","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"","category":"section"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"In this tutorial, we will create a preliminary reconstruction of the 2017 M87 data on April 6 by simultaneously creating an image and model for the instrument. By instrument model, we mean something akin to self-calibration in traditional VLBI imaging terminology. However, unlike traditional self-cal, we will solve for the gains each time we update the image self-consistently. This allows us to model the correlations between gains and the image.","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"To get started we load Comrade.","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"import Pkg #hide\n__DIR = \"/home/runner/work/Comrade.jl/Comrade.jl/docs/../examples/StokesIImaging\" #hide\npkg_io = open(joinpath(__DIR, \"pkg.log\"), \"w\") #hide\nPkg.activate(__DIR; io=pkg_io) #hide\nPkg.develop(; path=joinpath(__DIR, \"..\", \"..\"), io=pkg_io) #hide\nPkg.instantiate(; io=pkg_io) #hide\nPkg.precompile(; io=pkg_io) #hide\nclose(pkg_io) #hide\n\n\nENV[\"GKSwstype\"] = \"nul\" #hide\nusing Comrade\n\n\n\nusing Pyehtim\nusing LinearAlgebra","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"For reproducibility we use a stable random number genreator","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"using StableRNGs\nrng = StableRNG(12)","category":"page"},{"location":"tutorials/StokesIImaging/#Load-the-Data","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Load the Data","text":"","category":"section"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"To download the data visit https://doi.org/10.25739/g85n-f134 First we will load our data:","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"obs = ehtim.obsdata.load_uvfits(joinpath(__DIR, \"../Data/SR1_M87_2017_096_lo_hops_netcal_StokesI.uvfits\"))","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Now we do some minor preprocessing:","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Scan average the data since the data have been preprocessed so that the gain phases  coherent.\nAdd 1% systematic noise to deal with calibration issues that cause 1% non-closing errors.","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"obs = scan_average(obs).add_fractional_noise(0.01)","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Now we extract our complex visibilities.","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"dvis = extract_table(obs, Visibilities())","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"##Building the Model/Posterior","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Now, we must build our intensity/visibility model. That is, the model that takes in a named tuple of parameters and perhaps some metadata required to construct the model. For our model, we will use a raster or ContinuousImage for our image model. The model is given below:","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"The model construction is very similar to Imaging a Black Hole using only Closure Quantities, except we include a large scale gaussian since we want to model the zero baselines. For more information about the image model please read the closure-only example.","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"function sky(θ, metadata)\n    (;fg, c, σimg) = θ\n    (;ftot, mimg) = metadata\n    # Apply the GMRF fluctuations to the image\n    rast = apply_fluctuations(CenteredLR(), mimg, σimg.*c.params)\n    m = ContinuousImage((ftot*(1-fg)).*rast, BSplinePulse{3}())\n    x0, y0 = centroid(m)\n    # Add a large-scale gaussian to deal with the over-resolved mas flux\n    g = modify(Gaussian(), Stretch(μas2rad(250.0), μas2rad(250.0)), Renormalize(ftot*fg))\n    return shifted(m, -x0, -y0) + g\nend","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Now, let's set up our image model. The EHT's nominal resolution is 20-25 μas. Additionally, the EHT is not very sensitive to a larger field of view. Typically 60-80 μas is enough to describe the compact flux of M87. Given this, we only need to use a small number of pixels to describe our image.","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"npix = 32\nfovx = μas2rad(150.0)\nfovy = μas2rad(150.0)","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Now let's form our cache's. First, we have our usual image cache which is needed to numerically compute the visibilities.","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"grid = imagepixels(fovx, fovy, npix, npix)","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Now we need to specify our image prior. For this work we will use a Gaussian Markov Random field prior Since we are using a Gaussian Markov random field prior we need to first specify our mean image. This behaves somewhat similary to a entropy regularizer in that it will start with an initial guess for the image structure. For this tutorial we will use a a symmetric Gaussian with a FWHM of 50 μas","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"using VLBIImagePriors\nusing Distributions, DistributionsAD\nfwhmfac = 2*sqrt(2*log(2))\nmpr  = modify(Gaussian(), Stretch(μas2rad(50.0)./fwhmfac))\nmimg = intensitymap(mpr, grid)","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Now we can form our metadata we need to fully define our model. We will also fix the total flux to be the observed value 1.1. This is because total flux is degenerate with a global shift in the gain amplitudes making the problem degenerate. To fix this we use the observed total flux as our value.","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"skymeta = (;ftot = 1.1, mimg = mimg./flux(mimg))","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"In addition we want a reasonable guess for what the resolution of our image should be. For radio astronomy this is given by roughly the longest baseline in the image. To put this into pixel space we then divide by the pixel size.","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"beam = beamsize(dvis)\nrat = (beam/(step(grid.X)))","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"To make the Gaussian Markov random field efficient we first precompute a bunch of quantities that allow us to scale things linearly with the number of image pixels. The returns a functional that accepts a single argument related to the correlation length of the field. The second argument defines the underlying random field of the Markov process. Here we are using a zero mean and unit variance Gaussian Markov random field. The keyword argument specifies the order of the Gaussian field. Currently, we recommend using order","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"1 which is identical to TSV variation and L₂ regularization\n2 which is identical to a Matern 1 process in 2D and is really the convolution of two order 1 processes","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"For this tutorial we will use the first order random field","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"crcache = ConditionalMarkov(GMRF, grid; order=1)","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"To demonstrate the prior let create a few random realizations","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Now we can finally form our image prior. For this we use a heirarchical prior where the inverse correlation length is given by a Half-Normal distribution whose peak is at zero and standard deviation is 0.1/rat where recall rat is the beam size per pixel. For the variance of the random field we use another half normal prior with standard deviation 0.1. The reason we use the half-normal priors is to prefer \"simple\" structures. Gaussian Markov random fields are extremly flexible models, and to prevent overfitting it is common to use priors that penalize complexity. Therefore, we want to use priors that enforce similarity to our mean image. If the data wants more complexity then it will drive us away from the prior.","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"cprior = HierarchicalPrior(crcache, truncated(InverseGamma(1.0, -log(0.1)*rat); upper=2*npix))","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"We can now form our model parameter priors. Like our other imaging examples, we use a Dirichlet prior for our image pixels. For the log gain amplitudes, we use the CalPrior which automatically constructs the prior for the given jones cache gcache.","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"prior = (\n         c = cprior,\n         fg = Uniform(0.0, 1.0),\n         σimg = truncated(Normal(0.0, 0.1), lower=0.0)\n        )\n\nskym = SkyModel(sky, prior, grid; metadata=skymeta)","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Unlike other imaging examples (e.g., Imaging a Black Hole using only Closure Quantities) we also need to include a model for the instrument, i.e., gains. The gains will be broken into two components","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Gain amplitudes which are typically known to 10-20%, except for LMT, which has amplitudes closer to 50-100%.\nGain phases which are more difficult to constrain and can shift rapidly.","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"G = SingleStokesGain() do x\n    lg = x.lg\n    gp = x.gp\n    return exp(lg + 1im*gp)\nend\n\nintpr = (\n    lg= ArrayPrior(IIDSitePrior(ScanSeg(), Normal(0.0, 0.2)); LM = IIDSitePrior(ScanSeg(), Normal(0.0, 1.0))),\n    gp= ArrayPrior(IIDSitePrior(ScanSeg(), DiagonalVonMises(0.0, inv(π^2))); refant=SEFDReference(0.0), phase=true)\n        )\nintmodel = InstrumentModel(G, intpr)\n\n\npost = VLBIPosterior(skym, intmodel, dvis)","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"done using the asflat function.","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"tpost = asflat(post)\nndim = dimension(tpost)","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"We can now also find the dimension of our posterior or the number of parameters we are going to sample.","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"warning: Warning\nThis can often be different from what you would expect. This is especially true when using angular variables where we often artificially increase the dimension of the parameter space to make sampling easier.","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"To initialize our sampler we will use optimize using Adam","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"using Optimization\nusing OptimizationOptimisers\nusing Zygote\nxopt, sol = comrade_opt(post, Optimisers.Adam(), Optimization.AutoZygote(); initial_params=prior_sample(rng, post), maxiters=15_000, g_tol=1e-1)","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"warning: Warning\nFitting gains tends to be very difficult, meaning that optimization can take a lot longer. The upside is that we usually get nicer images.","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"First we will evaluate our fit by plotting the residuals","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"using Plots\nresidual(post, xopt)","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"These look reasonable, although there may be some minor overfitting. This could be improved in a few ways, but that is beyond the goal of this quick tutorial. Plotting the image, we see that we have a much cleaner version of the closure-only image from Imaging a Black Hole using only Closure Quantities.","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"import CairoMakie as CM\nCM.activate!(type = \"png\", px_per_unit=3) #hide\ng = imagepixels(fovx, fovy, 128, 128)\nimg = intensitymap(skymodel(post, xopt), g)\nimageviz(img, size=(500, 400))","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Because we also fit the instrument model, we can inspect their parameters. To do this, Comrade provides a caltable function that converts the flattened gain parameters to a tabular format based on the time and its segmentation.","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"gt = Comrade.caltable(xopt.instrument.gp)\nplot(gt, layout=(3,3), size=(600,500))","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"The gain phases are pretty random, although much of this is due to us picking a random reference sites for each scan.","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Moving onto the gain amplitudes, we see that most of the gain variation is within 10% as expected except LMT, which has massive variations.","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"gt = Comrade.caltable(exp.(xopt.instrument.lg))\nplot(gt, layout=(3,3), size=(600,500))","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"To sample from the posterior, we will use HMC, specifically the NUTS algorithm. For information about NUTS, see Michael Betancourt's notes. However, due to the need to sample a large number of gain parameters, constructing the posterior is rather time-consuming. Therefore, for this tutorial, we will only do a quick preliminary run","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"using AdvancedHMC\nchain = sample(rng, post, NUTS(0.8), 700; n_adapts=500, progress=true, initial_params=xopt)","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"note: Note\nThe above sampler will store the samples in memory, i.e. RAM. For large models this can lead to out-of-memory issues. To fix that you can include the keyword argument saveto = DiskStore() which periodically saves the samples to disk limiting memory useage. You can load the chain using load_samples(diskout) where diskout is the object returned from sample.","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Now we prune the adaptation phase","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"chain = chain[501:end]","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"warning: Warning\nThis should be run for likely an order of magnitude more steps to properly estimate expectations of the posterior","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Now that we have our posterior, we can put error bars on all of our plots above. Let's start by finding the mean and standard deviation of the gain phases","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"mchain = Comrade.rmap(mean, chain)\nschain = Comrade.rmap(std, chain)","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Now we can use the measurements package to automatically plot everything with error bars. First we create a caltable the same way but making sure all of our variables have errors attached to them.","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"using Measurements\ngmeas_am = Measurements.measurement.(mchain.instrument.lg, schain.instrument.lg)\nctable_am = caltable(exp.(gmeas_am)) # caltable expects gmeas_am to be a Vector\ngmeas_ph = Measurements.measurement.(mchain.instrument.gp, schain.instrument.gp)\nctable_ph = caltable(gmeas_ph)","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Now let's plot the phase curves","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"plot(ctable_ph, layout=(3,3), size=(600,500))","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"and now the amplitude curves","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"plot(ctable_am, layout=(3,3), size=(600,500))","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Finally let's construct some representative image reconstructions.","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"samples = skymodel.(Ref(post), chain[begin:2:end])\nimgs = intensitymap.(samples, Ref(g))\n\nmimg = mean(imgs)\nsimg = std(imgs)\nfig = CM.Figure(;resolution=(400, 400))\nCM.image(fig[1,1], mimg,\n                   axis=(xreversed=true, aspect=1, title=\"Mean Image\"),\n                   colormap=:afmhot)\nCM.image(fig[1,2], simg./mimg,\n                   axis=(xreversed=true, aspect=1, title=\"1/SNR\",),\n                   colormap=:afmhot)\nCM.image(fig[2,1], imgs[1],\n                   axis=(xreversed=true, aspect=1,title=\"Draw 1\"),\n                   colormap=:afmhot)\nCM.image(fig[2,2], imgs[end],\n                   axis=(xreversed=true, aspect=1,title=\"Draw 2\"),\n                   colormap=:afmhot)\nCM.hidedecorations!.(fig.content)\nfig","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"And viola, you have just finished making a preliminary image and instrument model reconstruction. In reality, you should run the sample step for many more MCMC steps to get a reliable estimate for the reconstructed image and instrument model parameters.","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"","category":"page"},{"location":"tutorials/StokesIImaging/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"This page was generated using Literate.jl.","category":"page"},{"location":"ext/optimization/#Optimization-Extension","page":"Optimization Extension","title":"Optimization Extension","text":"","category":"section"},{"location":"ext/optimization/","page":"Optimization Extension","title":"Optimization Extension","text":"To optimize our posterior, we use the Optimization.jl package. Optimization provides a global interface to several Julia optimizers. The base call most people should  look at is comrade_opt which serves as the general purpose optimization algorithm.","category":"page"},{"location":"ext/optimization/","page":"Optimization Extension","title":"Optimization Extension","text":"To see what optimizers are available and what options are available, please see the Optimizations.jl docs.","category":"page"},{"location":"ext/optimization/#Example","page":"Optimization Extension","title":"Example","text":"","category":"section"},{"location":"ext/optimization/","page":"Optimization Extension","title":"Optimization Extension","text":"using Comrade\nusing Optimization\nusing OptimizationOptimJL\n\n# Some stuff to create a posterior object\npost # of type Comrade.Posterior\n\nxopt, sol = comrade_opt(post, LBFGS(); adtype=Val(:Zygote))","category":"page"},{"location":"benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Comrade was partially designed with performance in mind. Solving imaging inverse problems is traditionally very computationally expensive, especially since Comrade uses Bayesian inference. To benchmark Comrade we will compare it to two of the most common modeling or imaging packages within the EHT:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"eht-imaging\nThemis","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"eht-imaging[1] or ehtim is a Python package that is widely used within the EHT for its imaging and modeling interfaces. It is easy to use and is commonly used in the EHT. However, to specify the model, the user must specify how to calculate the model's complex visibilities and its gradients, allowing eht-imaging's modeling package to achieve acceptable speeds.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Themis is a C++ package focused on providing Bayesian estimates of the image structure. In fact, Comrade took some design cues from Themis. Themis has been used in various EHT publications and is the standard Bayesian modeling tool used in the EHT. However, Themis is quite challenging to use and requires a high level of knowledge from its users, requiring them to understand makefile, C++, and the MPI standard. Additionally, Themis provides no infrastructure to compute gradients, instead relying on finite differencing, which scales poorly for large numbers of model parameters. ","category":"page"},{"location":"benchmarks/#Benchmarking-Problem","page":"Benchmarks","title":"Benchmarking Problem","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"For our benchmarking problem, we analyze a situation very similar to the one explained in  Namely, we will consider fitting 2017 M87 April 6 data using an m-ring and a single Gaussian component. Please see the end of this page to see the code we used for Comrade and eht-imaging.","category":"page"},{"location":"benchmarks/#Results","page":"Benchmarks","title":"Results","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"All tests were run using the following system","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Julia Version 1.10.3\nPython Version 3.10.12\nComrade Version 0.10.0\neht-imaging Version 1.2.7\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: 11th Gen Intel(R) Core(TM) i7-1185G7 @ 3.00GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-12.0.1 (ORCJIT, tigerlake)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Our benchmark results are the following:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":" Comrade (micro sec) eht-imaging (micro sec) Themis (micro sec)\nposterior eval (min) 31 445 55\nposterior eval (mean) 36 476 60\ngrad posterior eval (min) 105 (ForwardDiff) 1898 1809\ngrad posterior eval (mean) 119 (ForwardDiff) 1971 1866","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Therefore, for this test we found that Comrade was the fastest method in all tests. For the posterior evaluation we found that Comrade is > 10x faster than eht-imaging, and 2x faster then Themis. For gradient evaluations we have Comrade is > 15x faster than both eht-imaging and Themis.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"[1]: Chael A, et al. Inteferometric Imaging Directly with Closure Phases 2018 ApJ 857 1 arXiv:1803/07088","category":"page"},{"location":"benchmarks/#Code","page":"Benchmarks","title":"Code","text":"","category":"section"},{"location":"benchmarks/#Julia-Code","page":"Benchmarks","title":"Julia Code","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"# To download the data visit https://doi.org/10.25739/g85n-f134\nobs = ehtim.obsdata.load_uvfits(joinpath(@__DIR__, \"..\", \"examples\", \"Data\", \"SR1_M87_2017_096_hi_hops_netcal_StokesI.uvfits\"))\nobsavg = scan_average(obs)\namp = extract_table(obsavg, VisibilityAmplitudes())\n\nfunction model(θ, p)\n    (;rad, wid, a, b, f, sig, asy, pa, x, y) = θ\n    ring = f*smoothed(stretched(MRing((a,), (b,)), μas2rad(rad), μas2rad(rad)), μas2rad(wid))\n    g = (1-f)*shifted(rotated(stretched(Gaussian(), μas2rad(sig)*asy, μas2rad(sig)), pa), μas2rad(x), μas2rad(y))\n    return ring + g\nend\nprior = (\n          rad = Uniform(10.0, 30.0),\n          wid = Uniform(1.0, 10.0),\n          a = Uniform(-0.5, 0.5), b = Uniform(-0.5, 0.5),\n          f = Uniform(0.0, 1.0),\n          sig = Uniform((1.0), (60.0)),\n          asy = Uniform(0.0, 0.9),\n          pa = Uniform(0.0, 1π),\n          x = Uniform(-(80.0), (80.0)),\n          y = Uniform(-(80.0), (80.0))\n        )\n# Now form the posterior\nskym = SkyModel(model, prior, imagepixels(μas2rad(150.0), μas2rad(150.0), 128, 128))\n\nθ = (rad= 22.0, wid= 3.0, a = 0.0, b = 0.15, f=0.8, sig = 20.0, asy=0.2, pa=π/2, x=20.0, y=20.0)\nm = model(θ, nothing)\n\npost = VLBIPosterior(skym, amp)\ntpost = asflat(post)\n\nx0 = prior_sample(tpost)\n\nusing Zygote\n@benchmark $(tpost)($x0)\n# 32 μs\n@benchmark Zygote.gradient($tpost, $x0)\n# 175 μs","category":"page"},{"location":"benchmarks/#eht-imaging-Code","page":"Benchmarks","title":"eht-imaging Code","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"import ehtim as eh\nimport numpy as np\nimport os\nobs = eh.obsdata.load_uvfits(os.path.join(\"examples\", \"Data\", \"SR1_M87_2017_096_hi_hops_netcal_StokesI.uvfits\"))\nobs.add_scans()\nobsavg = obs.avg_coherent(0.0, scan_avg=True)\n\nmeh = eh.model.Model()\nmeh = meh.add_thick_mring(F0=0.8,\n                    d=2*22.0*eh.RADPERUAS,\n                    alpha=2*np.sqrt(2*np.log(2))*eh.RADPERUAS*3.0,\n                    x0 = 0.0,\n                    y0 = 0.0,\n                    beta_list=[0.0+0.15j]\n                    )\nmeh = meh.add_gauss(F0=1-0.8,\n                    FWHM_maj=2*np.sqrt(2*np.log(2))*eh.RADPERUAS*(3.0),\n                    FWHM_min=2*np.sqrt(2*np.log(2))*eh.RADPERUAS*(3.0)*0.2,\n                    PA = np.pi/2,\n                    x0 = eh.RADPERUAS*(20.0),\n                    y0 = eh.RADPERUAS*(20.0)\n                    )\n\npreh = meh.default_prior()\npreh[0][\"F0\"] = {\"prior_type\": \"flat\", \"min\" : 0.0, \"max\" : 1.0}\npreh[0][\"d\"] = {\"prior_type\": \"flat\", \"min\" : eh.RADPERUAS*(20.0), \"max\" : eh.RADPERUAS*(60.0)}\npreh[0][\"alpha\"] = {\"prior_type\": \"flat\", \"min\" : eh.RADPERUAS*(2.0), \"max\" : eh.RADPERUAS*(25.0)}\npreh[0][\"x0\"] = {\"prior_type\": \"fixed\"}\npreh[0][\"y0\"] = {\"prior_type\": \"fixed\"}\n\npreh[1][\"F0\"] = {\"prior_type\": \"flat\", \"min\" : 0.0, \"max\" : 1.0}\npreh[1][\"FWHM_maj\"] = {\"prior_type\": \"flat\", \"min\" : eh.RADPERUAS*(2.0), \"max\" : eh.RADPERUAS*(120.0)}\npreh[1][\"FWHM_min\"] = {\"prior_type\": \"flat\", \"min\" : eh.RADPERUAS*(2.0), \"max\" : eh.RADPERUAS*(120.0)}\npreh[1][\"x0\"] = {\"prior_type\": \"flat\", \"min\" : -eh.RADPERUAS*(40.0), \"max\" : eh.RADPERUAS*(40.0)}\npreh[1][\"y0\"] = {\"prior_type\": \"flat\", \"min\" : -eh.RADPERUAS*(40.0), \"max\" : eh.RADPERUAS*(40.0)}\npreh[1][\"PA\"] = {\"prior_type\": \"flat\", \"min\" : -np.pi, \"max\" : np.pi}\n\n# This is a hack to get the objective function and its gradient\n# we need to do this since the functions depend on some global variables\ntransform_param = eh.modeling.modeling_utils.transform_param\ndef make_paraminit(param_map, meh, trial_model, model_prior):\n    model_init = meh.copy()\n    param_init = []\n    for j in range(len(param_map)):\n        pm = param_map[j]\n        if param_map[j][1] in trial_model.params[param_map[j][0]].keys():\n            param_init.append(transform_param(model_init.params[pm[0]][pm[1]]/pm[2], model_prior[pm[0]][pm[1]],inverse=False))\n        else: # In this case, the parameter is a list of complex numbers, so the real/imaginary or abs/arg components need to be assigned\n            if param_map[j][1].find('cpol') != -1:\n                param_type = 'beta_list_cpol'\n                idx = int(param_map[j][1].split('_')[0][8:])\n            elif param_map[j][1].find('pol') != -1:\n                param_type = 'beta_list_pol'\n                idx = int(param_map[j][1].split('_')[0][7:]) + (len(trial_model.params[param_map[j][0]][param_type])-1)//2\n            elif param_map[j][1].find('beta') != -1:\n                param_type = 'beta_list'\n                idx = int(param_map[j][1].split('_')[0][4:]) - 1\n            else:\n                raise Exception('Unsure how to interpret ' + param_map[j][1])\n\n            curval = model_init.params[param_map[j][0]][param_type][idx]\n            if '_' not in param_map[j][1]:\n                param_init.append(transform_param(np.real( model_init.params[pm[0]][param_type][idx]/pm[2]), model_prior[pm[0]][pm[1]],inverse=False))\n            elif   param_map[j][1][-2:] == 're':\n                param_init.append(transform_param(np.real( model_init.params[pm[0]][param_type][idx]/pm[2]), model_prior[pm[0]][pm[1]],inverse=False))\n            elif param_map[j][1][-2:] == 'im':\n                param_init.append(transform_param(np.imag( model_init.params[pm[0]][param_type][idx]/pm[2]), model_prior[pm[0]][pm[1]],inverse=False))\n            elif param_map[j][1][-3:] == 'abs':\n                param_init.append(transform_param(np.abs(  model_init.params[pm[0]][param_type][idx]/pm[2]), model_prior[pm[0]][pm[1]],inverse=False))\n            elif param_map[j][1][-3:] == 'arg':\n                param_init.append(transform_param(np.angle(model_init.params[pm[0]][param_type][idx])/pm[2], model_prior[pm[0]][pm[1]],inverse=False))\n            else:\n                if not quiet: print('Parameter ' + param_map[j][1] + ' not understood!')\n    n_params = len(param_init)\n    return n_params, param_init\n\n# make the python param map and use optimize so we flatten the parameter space.\npmap, pmask = eh.modeling.modeling_utils.make_param_map(meh, preh, \"scipy.optimize.dual_annealing\", fit_model=True)\ntrial_model = meh.copy()\n\n# get initial parameters\nn_params, pinit = make_paraminit(pmap, meh, trial_model, preh)\n\n# make data products for the globdict\ndata1, sigma1, uv1, _ = eh.modeling.modeling_utils.chisqdata(obsavg, \"amp\", pol=\"I\")\ndata2, sigma2, uv2, _ = eh.modeling.modeling_utils.chisqdata(obsavg, True, pol=\"I\")\ndata3, sigma3, uv3, _ = eh.modeling.modeling_utils.chisqdata(obsavg, True, pol=\"I\")\ndata4, sigma4, uv4, _ = eh.modeling.modeling_utils.chisqdata(obsavg, True, pol=\"I\")\n\n# now set the ehtim modeling globdict\n\neh.modeling.modeling_utils.globdict = {\"trial_model\" : trial_model,\n                \"d1\" : \"amp\", \"d2\" : False, \"d3\" : False, \"d4\" : False,\n                \"pol1\" : \"I\", \"pol2\" : \"I\", \"pol3\" : \"I\", \"pol4\" : \"I\",\n                \"data1\" : data1, \"sigma1\" : sigma1, \"uv1\" : uv1, \"jonesdict1\" : None,\n                \"data2\" : data2, \"sigma2\" : sigma2, \"uv2\" : uv2, \"jonesdict2\" : None,\n                \"data3\" : data3, \"sigma3\" : sigma3, \"uv3\" : uv3, \"jonesdict3\" : None,\n                \"data4\" : data3, \"sigma4\" : sigma3, \"uv4\" : uv3, \"jonesdict4\" : None,\n                \"alpha_d1\" : 0, \"alpha_d2\" : 0, \"alpha_d3\" : 0, \"alpha_d4\" : 0,\n                \"n_params\" :  n_params, \"n_gains\" : 0, \"n_leakage\" : 0,\n                \"model_prior\" : preh, \"param_map\" : pmap, \"param_mask\" : pmask,\n                \"gain_prior\" : None, \"gain_list\" : [], \"gain_init\" : None,\n                \"fit_leakage\" : False, \"leakage_init\" : [], \"leakage_fit\" : [],\n                \"station_leakages\" : None, \"leakage_prior\" : None,\n                \"show_updates\" : False, \"update_interval\" : 1,\n                \"gains_t1\" : None, \"gains_t2\" : None,\n                \"minimizer_func\" : \"scipy.optimize.dual_annealing\",\n                \"Obsdata\" : obsavg,\n                \"fit_pol\" : False, \"fit_cpol\" : False,\n                \"flux\" : 1.0, \"alpha_flux\" : 0, \"fit_gains\" : False,\n                \"marginalize_gains\" : False, \"ln_norm\" : 1314.33,\n                \"param_init\" : pinit, \"test_gradient\" : False\n}\n\n# This is the negative log-posterior\nfobj = eh.modeling.modeling_utils.objfunc\n%timeit fobj(pinit)\n# 298 us +/- 7.7\n\n# This is the gradient of the negative log-posterior\ngfobj = eh.modeling.modeling_utils.objgrad\n%timeit gfobj(pinit)\n# 1.3 ms","category":"page"},{"location":"interface/#Model-Interface","page":"Model Interface","title":"Model Interface","text":"","category":"section"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"For the interface for sky models please see VLBISkyModels.","category":"page"},{"location":"tutorials/LoadingData/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"EditURL = \"../../../examples/LoadingData/main.jl\"","category":"page"},{"location":"tutorials/LoadingData/#Loading-Data-into-Comrade","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"","category":"section"},{"location":"tutorials/LoadingData/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"The VLBI field does not have a standardized data format, and the EHT uses a particular uvfits format similar to the optical interferometry oifits format. As a result, we reuse the excellent eht-imaging package to load data into Comrade.","category":"page"},{"location":"tutorials/LoadingData/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"Once the data is loaded, we then convert the data into the tabular format Comrade expects. Note that this may change to a Julia package as the Julia radio astronomy group grows.","category":"page"},{"location":"tutorials/LoadingData/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"To get started, we will load Comrade and Plots to enable visualizations of the data","category":"page"},{"location":"tutorials/LoadingData/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"import Pkg #hide\n__DIR = \"/home/runner/work/Comrade.jl/Comrade.jl/docs/../examples/LoadingData\" #hide\npkg_io = open(joinpath(__DIR, \"pkg.log\"), \"w\") #hide\nPkg.activate(__DIR; io=pkg_io) #hide\nPkg.develop(; path=joinpath(__DIR, \"..\", \"..\"), io=pkg_io) #hide\nPkg.instantiate(; io=pkg_io) #hide\nPkg.precompile(; io=pkg_io) #hide\nclose(pkg_io) #hide\n\nENV[\"GKSwstype\"] = \"nul\" #hide\n\n\nusing Comrade\n\nusing Plots","category":"page"},{"location":"tutorials/LoadingData/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"We also load Pyehtim since it loads eht-imaging into Julia using PythonCall and exports the variable ehtim","category":"page"},{"location":"tutorials/LoadingData/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"using Pyehtim","category":"page"},{"location":"tutorials/LoadingData/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"To load the data we will use eht-imaging. We will use the 2017 public M87 data which can be downloaded from cyverse","category":"page"},{"location":"tutorials/LoadingData/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"obseht = ehtim.obsdata.load_uvfits(joinpath(__DIR, \"../Data/SR1_M87_2017_096_lo_hops_netcal_StokesI.uvfits\"))","category":"page"},{"location":"tutorials/LoadingData/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"Now we will average the data over telescope scans. Note that the EHT data has been pre-calibrated so this averaging doesn't induce large coherence losses.","category":"page"},{"location":"tutorials/LoadingData/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"obs = Pyehtim.scan_average(obseht)","category":"page"},{"location":"tutorials/LoadingData/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"warning: Warning\nWe use a custom scan-averaging function to ensure that the scan-times are homogenized.","category":"page"},{"location":"tutorials/LoadingData/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"We can now extract data products that Comrade can use","category":"page"},{"location":"tutorials/LoadingData/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"vis    = extract_table(obs, Visibilities()) ## complex visibilites\namp    = extract_table(obs, VisibilityAmplitudes()) ## visibility amplitudes\ncphase = extract_table(obs, ClosurePhases(; snrcut=3.0)) ## extract minimal set of closure phases\nlcamp  = extract_table(obs, LogClosureAmplitudes(; snrcut=3.0)) ## extract minimal set of log-closure amplitudes","category":"page"},{"location":"tutorials/LoadingData/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"For polarization we first load the data in the cirular polarization basis Additionally, we load the array table at the same time to load the telescope mounts.","category":"page"},{"location":"tutorials/LoadingData/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"obseht = Pyehtim.load_uvfits_and_array(\n                joinpath(__DIR, \"../Data\", \"polarized_gaussian_all_corruptions.uvfits\"),\n                joinpath(__DIR, \"..\", \"Data\", \"array.txt\"),\n                polrep=\"circ\"\n                        )\nobs = Pyehtim.scan_average(obseht)\ncoh = extract_table(obs, Coherencies())","category":"page"},{"location":"tutorials/LoadingData/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"warning: Warning\nAlways use our extract_cphase and extract_lcamp functions to find the closures eht-imaging will sometimes incorrectly calculate a non-redundant set of closures.","category":"page"},{"location":"tutorials/LoadingData/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"We can also recover the array used in the observation using","category":"page"},{"location":"tutorials/LoadingData/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"ac = arrayconfig(vis)\nplot(ac) # Plot the baseline coverage","category":"page"},{"location":"tutorials/LoadingData/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"To plot the data we just call","category":"page"},{"location":"tutorials/LoadingData/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"l = @layout [a b; c d]\npv = plot(vis)\npa = plot(amp)\npcp = plot(cphase)\nplc = plot(lcamp)\n\nplot(pv, pa, pcp, plc; layout=l)","category":"page"},{"location":"tutorials/LoadingData/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"And also the coherency matrices","category":"page"},{"location":"tutorials/LoadingData/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"plot(coh)","category":"page"},{"location":"tutorials/LoadingData/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"","category":"page"},{"location":"tutorials/LoadingData/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"This page was generated using Literate.jl.","category":"page"},{"location":"ext/dynesty/#Dynesty-Extension","page":"Dynesty Extension","title":"Dynesty Extension","text":"","category":"section"},{"location":"ext/dynesty/","page":"Dynesty Extension","title":"Dynesty Extension","text":"Dynesty interfaces Comrade to the excellent dynesty package, more specifically the Dynesty.jl Julia wrapper.","category":"page"},{"location":"ext/dynesty/","page":"Dynesty Extension","title":"Dynesty Extension","text":"We follow Dynesty.jl interface closely. However,  instead of having to pass a log-likelihood function and prior transform, we instead just pass a Comrade.VLBIPosterior object and Comrade takes care of defining the prior transformation and  log-likelihood for us. For more information about Dynesty.jl, please see its docs and docstrings.","category":"page"},{"location":"ext/dynesty/#Example","page":"Dynesty Extension","title":"Example","text":"","category":"section"},{"location":"ext/dynesty/","page":"Dynesty Extension","title":"Dynesty Extension","text":"using Comrade\nusing Dynesty\n\n# Some stuff to create a posterior object\npost # of type Comrade.Posterior\n\n# Create sampler using 1000 live points\nsmplr = NestedSampler(;nlive=1000)\n\nchain = dysample(post, smplr; dlogz=1.0)\n\n# Optionally resample the chain to create an equal weighted output\nusing StatsBase\nequal_weight_chain = Comrade.resample_equal(samples, 10_000)","category":"page"},{"location":"ext/nested/#NestedSamples-Extension","page":"NestedSamples Extension","title":"NestedSamples Extension","text":"","category":"section"},{"location":"ext/nested/","page":"NestedSamples Extension","title":"NestedSamples Extension","text":"Comrade intefaces to the NestedSamplers.jl package.","category":"page"},{"location":"ext/nested/","page":"NestedSamples Extension","title":"NestedSamples Extension","text":"We follow NestedSamplers interface closely. The  difference is that instead of creating a NestedModel, we   pass a Comrade.VLBIPosterior object as our model. Internally, Comrade defines the prior transform and extracts the log-likelihood function.","category":"page"},{"location":"ext/nested/","page":"NestedSamples Extension","title":"NestedSamples Extension","text":"For more information about NestedSamplers.jl please see its docs.","category":"page"},{"location":"ext/nested/#Example","page":"NestedSamples Extension","title":"Example","text":"","category":"section"},{"location":"ext/nested/","page":"NestedSamples Extension","title":"NestedSamples Extension","text":"using Comrade\nusing NestedSamplers\n\n# Some stuff to create a posterior object\npost # of type Comrade.Posterior\n\n# Create sampler using 1000 live points\nsmplr = Nested(dimension(ascube(post)), 1000)\n\nsamples = sample(Random.default_rng(), post, smplr; d_logz=1.0)\n\n# Optionally resample the chain to create an equal weighted output\nusing StatsBase\nequal_weight_chain = Comrade.resample_equal(samples, 10_000)","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"EditURL = \"../../../examples/PolarizedImaging/main.jl\"","category":"page"},{"location":"tutorials/PolarizedImaging/#Polarized-Image-and-Instrumental-Modeling","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"","category":"section"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"In this tutorial, we will analyze a simulated simple polarized dataset to demonstrate Comrade's polarized imaging capabilities.","category":"page"},{"location":"tutorials/PolarizedImaging/#Introduction-to-Polarized-Imaging","page":"Polarized Image and Instrumental Modeling","title":"Introduction to Polarized Imaging","text":"","category":"section"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"The EHT is a polarized interferometer. However, like all VLBI interferometers, it does not directly measure the Stokes parameters (I, Q, U, V). Instead, it measures components related to the electric field at the telescope along two directions using feeds. There are two types of feeds at telescopes: circular, which measure RL components of the electric field, and linear feeds, which measure XY components of the electric field. Most sites in the EHT use circular feeds, meaning they measure the right (R) and left electric field (L) at each telescope. Although note that ALMA actually uses linear feeds. Currently Comrade has the ability to fit natively mixed polarization data however, the publically released EHT data has been converted to circular polarization. For a VLBI array whose feeds are purely circluar the coherency matrices are given by,","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":" C_ij = beginpmatrix\n       RR^*   RL^*\n       LR^*   LL^*\n     endpmatrix","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"These coherency matrices are the fundamental object in interferometry and what the telescope observes. For a perfect interferometer, these circular coherency matrices are related to the usual Fourier transform of the stokes parameters by","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"  beginpmatrix\n      tildeI tildeQ  tildeU  tildeV\n  endpmatrix\n  =frac12\n  beginpmatrix\n     RR^* + LL^* \n     RL^* + LR^* \n     i(LR^* - RL^*)\n     RR^* - LL^*\n  endpmatrix","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"note: Note\nIn this tutorial, we stick to circular feeds but Comrade has the capabilities to model linear (XX,XY, ...) and mixed basis coherencies (e.g., RX, RY, ...).","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"In reality, the measure coherencies are corrupted by both the atmosphere and the telescope itself. In Comrade we use the RIME formalism [1] to represent these corruptions, namely our measured coherency matrices V_ij are given by","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"   V_ij = J_iC_ijJ_j^dagger","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"where J is known as a Jones matrix and ij denotes the baseline ij with sites i and j.","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Comrade is highly flexible with how the Jones matrices are formed and provides several convenience functions that parameterize standard Jones matrices. These matrices include:","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"JonesG which builds the set of complex gain Jones matrices","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"  G = beginpmatrix\n          g_a   0\n          0     g_b\n      endpmatrix","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"JonesD which builds the set of complex d-terms Jones matrices","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"  D = beginpmatrix\n          1    d_a\n          d_b     1\n      endpmatrix","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"JonesR is the basis transform matrix T. This transformation is special and  combines two things using the decomposition T=FB. The first, B, is the transformation from  some reference basis to the observed coherency basis (this allows for mixed basis measurements).  The second is the feed rotation, F, that transforms from some reference axis to the axis of the  telescope as the source moves in the sky. The feed rotation matrix F for circular feeds  in terms of the per station feed rotation angle varphi is","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"  F = beginpmatrix\n          e^-ivarphi    0\n          0      e^ivarphi\n      endpmatrix","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"In the rest of the tutorial, we are going to solve for all of these instrument model terms on  in addition to our image structure to reconstruct a polarized image of a synthetic dataset.","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"import Pkg #hide\n__DIR = \"/home/runner/work/Comrade.jl/Comrade.jl/docs/../examples/PolarizedImaging\" #hide\npkg_io = open(joinpath(__DIR, \"pkg.log\"), \"w\") #hide\nPkg.activate(__DIR; io=pkg_io) #hide\nPkg.develop(; path=joinpath(__DIR, \"..\", \"..\"), io=pkg_io) #hide\nPkg.instantiate(; io=pkg_io) #hide\nPkg.precompile(; io=pkg_io) #hide\nclose(pkg_io) #hide","category":"page"},{"location":"tutorials/PolarizedImaging/#Load-the-Data","page":"Polarized Image and Instrumental Modeling","title":"Load the Data","text":"","category":"section"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"To get started we will load Comrade","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"ENV[\"GKSwstype\"] = \"nul\" #hide\nusing Comrade","category":"page"},{"location":"tutorials/PolarizedImaging/#Load-the-Data-2","page":"Polarized Image and Instrumental Modeling","title":"Load the Data","text":"","category":"section"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"using Pyehtim","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"For reproducibility we use a stable random number genreator","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"using StableRNGs\nrng = StableRNG(42)","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Now we will load some synthetic polarized data.","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"obs = Pyehtim.load_uvfits_and_array(\n        joinpath(__DIR, \"../Data\", \"polarized_gaussian_all_corruptions.uvfits\"),\n        joinpath(__DIR, \"../Data\", \"array.txt\"), polrep=\"circ\")","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Notice that, unlike other non-polarized tutorials, we need to include a second argument. This is the array file of the observation and is required to determine the feed rotation of the array.","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Now we scan average the data since the data to boost the SNR and reduce the total data volume.","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"obs = scan_average(obs)","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Now we extract our observed/corrupted coherency matrices.","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"dvis = extract_table(obs, Coherencies())","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"##Building the Model/Posterior","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"To build the model, we first break it down into two parts:","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"The image or sky model. In Comrade, all polarized image models are written in terms of the Stokes parameters. In this tutorial, we will use a polarized image model based on Pesce (2021)[2], and parameterizes each pixel in terms of the Poincare sphere. This parameterization ensures that we have all the physical properties of stokes parameters. Note that we also have a parameterization in terms of hyperbolic trig functions VLBISkyModels.PolExp2Map\nThe instrument model. The instrument model specifies the model that describes the impact of instrumental and atmospheric effects. We will be using the J = GDR decomposition we described above. However, to parameterize the R/L complex gains, we will be using a gain product and ratio decomposition. The reason for this decomposition is that in realistic measurements, the gain ratios and products have different temporal characteristics. Namely, many of the EHT observations tend to demonstrate constant R/L gain ratios across an nights observations, compared to the gain products, which vary every scan. Additionally, the gain ratios tend to be smaller (i.e., closer to unity) than the gain products. Using this apriori knowledge, we can build this into our model and reduce the total number of parameters we need to model.","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"First we specify our sky model. As always Comrade requires this to be a two argument function where the first argument is typically a NamedTuple of parameters we will fit and the second are additional metadata required to build the model.","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"using StatsFuns: logistic\nfunction sky(θ, metadata)\n    (;c, σ, p, p0, pσ, angparams) = θ\n    (;ftot, grid) = metadata\n    # Build the stokes I model\n    rast = ftot*to_simplex(CenteredLR(), σ.*c.params)\n    # The total polarization fraction is modeled in logit space so we transform it back\n    pim = logistic.(p0 .+ pσ.*p.params)\n    # Build our IntensityMap\n    pmap = PoincareSphere2Map(rast, pim, angparams, grid)\n    # Construct the actual image model which uses a third order B-spline pulse\n    m = ContinuousImage(pmap, BSplinePulse{3}())\n    # Finally find the image centroid and shift it to be at the center\n    x0, y0 = centroid(pmap)\n    ms = shifted(m, -x0, -y0)\n    return ms\nend","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Now, we define the model metadata required to build the model. We specify our image grid and cache model needed to define the polarimetric image model. Our image will be a 10x10 raster with a 60μas FOV.","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"using Distributions, DistributionsAD\nusing VLBIImagePriors\nfovx = μas2rad(60.0)\nfovy = μas2rad(60.0)\nnx = 10\nny = floor(Int, fovy/fovx*nx)\ngrid = imagepixels(fovx, fovy, nx, ny)","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"For the image metadata we specify the grid and the total flux of the image, which is 1.0. Note that we specify the total flux out front since it is degenerate with an overall shift in the gain amplitudes.","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"skymeta = (;ftot=1.0, grid)","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"For our image prior we will use a simpler prior than","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"We use a Dirichlet prior, ImageDirichlet, with unit concentration for our stokes I image pixels, c.\nFor the total polarization fraction, p, we assume an uncorrelated uniform prior ImageUniform for each pixel.\nTo specify the orientation of the polarization, angparams, on the Poincare sphere, we use a uniform spherical distribution, ImageSphericalUniform.","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"rat = beamsize(dvis)/step(grid.X)\ncmarkov = ConditionalMarkov(GMRF, grid; order=1)\ndρ = truncated(InverseGamma(1.0, -log(0.1)*rat); lower=2.0, upper=max(nx, ny))\ncprior = HierarchicalPrior(cmarkov, dρ)","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"For all the calibration parameters, we use a helper function CalPrior which builds the prior given the named tuple of station priors and a JonesCache that specifies the segmentation scheme. For the gain products, we use the scancache, while for every other quantity, we use the trackcache.","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"fwhmfac = 2.0*sqrt(2.0*log(2.0))\nskyprior = (\n    c = cprior,\n    σ  = truncated(Normal(0.0, 1.0); lower=0.0),\n    p  = cprior,\n    p0 = Normal(-2.0, 2.0),\n    pσ =  truncated(Normal(0.0, 1.0); lower=0.01),\n    angparams = ImageSphericalUniform(nx, ny),\n    )\n\nskym = SkyModel(sky, skyprior, grid; metadata=skymeta)","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Now we build the instrument model. Due to the complexity of VLBI the instrument model is critical to the success of imaging and getting reliable results. For this example we will use the standard instrument model used in polarized EHT analyses expressed in the RIME formalism. Our Jones decomposition will be given by GDR, where G are the complex gains, D are the d-terms, and R is what we call the ideal instrument response, which is how an ideal interferometer using the feed basis we observe relative to some reference basis.","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Given the possible flexibility in different parameterizations of the individual Jones matrices each Jones matrix requires the user to specify a function that converts from parameters to specific parameterization f the jones matrices.","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"For the complex gain matrix, we used the JonesG jones matrix. The first argument is now a function that converts from the parameters to the complex gain matrix. In this case, we will use a amplitude and phase decomposition of the complex gain matrix. Note that since the gain matrix is a diagonal 2x2 matrix the function must return a 2-element tuple. The first element of the tuple is the gain for the first polarization feed (R) and the second is the gain for the second polarization feed (L).","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"G = JonesG() do x\n    gR = exp(x.lgR + 1im*x.gpR)\n    gL = gR*exp(x.lgrat + 1im*x.gprat)\n    return gR, gL\nend","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Note that we are using the Julia do syntax here to define an anonymous function. This could've also been written as","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"fgain(x) = (exp(x.lgR + 1im*x.gpR), exp(x.lgR + x.lgrat + 1im*(x.gpR + x.gprat)))\nG = JonesG(fgain)","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Similarly we provide a JonesD function for the leakage terms. Since we assume that we are in the small leakage limit, we will use the decomposition 1 d1 d2 1 Therefore, there are 2 free parameters for the JonesD our parameterization function must return a 2-element tuple. For d-terms we will use a re-im parameterization.","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"D = JonesD() do x\n    dR = complex(x.dRx, x.dRy)\n    dL = complex(x.dLx, x.dLy)\n    return dR, dL\nend","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Finally we define our response Jones matrix. This matrix is a basis transform matrix plus the feed rotation angle for each station. These are typically set by the telescope so there are no free parameters, so no parameterization is necessary.","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"R = JonesR(;add_fr=true)","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Finally, we build our total Jones matrix by using the JonesSandwich function. The first argument is a function that specifies how to combine each Jones matrix. In this case, we are completely standard so we just need to multiply the different jones matrices. Note that if no function is provided, the default is to multiply the Jones matrices, so we could've removed the splat(*) argument in this case.","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"J = JonesSandwich(splat(*), G, D, R)\n\n\nintprior = (\n    lgR  = ArrayPrior(IIDSitePrior(ScanSeg(), Normal(0.0, 0.1))),\n    gpR  = ArrayPrior(IIDSitePrior(ScanSeg(), DiagonalVonMises(0.0, inv(π  ^2))); refant=SEFDReference(0.0), phase=false),\n    lgrat= ArrayPrior(IIDSitePrior(ScanSeg(), Normal(0.0, 0.1)), phase=true),\n    gprat= ArrayPrior(IIDSitePrior(ScanSeg(), Normal(0.0, 0.1)); refant = SingleReference(:AA, 0.0)),\n    dRx  = ArrayPrior(IIDSitePrior(TrackSeg(), Normal(0.0, 0.2))),\n    dRy  = ArrayPrior(IIDSitePrior(TrackSeg(), Normal(0.0, 0.2))),\n    dLx  = ArrayPrior(IIDSitePrior(TrackSeg(), Normal(0.0, 0.2))),\n    dLy  = ArrayPrior(IIDSitePrior(TrackSeg(), Normal(0.0, 0.2))),\n)\n\nintmodel = InstrumentModel(J, intprior)","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Putting it all together, we form our likelihood and posterior objects for optimization and sampling.","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"post = VLBIPosterior(skym, intmodel, dvis)","category":"page"},{"location":"tutorials/PolarizedImaging/#Reconstructing-the-Image-and-Instrument-Effects","page":"Polarized Image and Instrumental Modeling","title":"Reconstructing the Image and Instrument Effects","text":"","category":"section"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"To sample from this posterior, it is convenient to move from our constrained parameter space to an unconstrained one (i.e., the support of the transformed posterior is (-∞, ∞)). This transformation is done using the asflat function.","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"tpost = asflat(post)","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"We can also query the dimension of our posterior or the number of parameters we will sample.","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"warning: Warning\nThis can often be different from what you would expect. This difference is especially true when using angular variables, where we often artificially increase the dimension of the parameter space to make sampling easier.","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"ndim = dimension(tpost)","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Now we optimize. Unlike other imaging examples, we move straight to gradient optimizers due to the higher dimension of the space. In addition the only AD package that can currently work with the polarized Comrade posterior is Zygote. Note that in the future we expect to shift entirely to Enzyme, and in fact large portions of Comrade's AD already uses Enzyme through custom rules.","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"using Optimization\nusing OptimizationOptimisers\nusing Zygote\nxopt, sol = comrade_opt(post, Optimisers.Adam(), Optimization.AutoZygote(); initial_params=prior_sample(rng, post), maxiters=20_000)","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"warning: Warning\nFitting polarized images is generally much harder than Stokes I imaging. This difficulty means that optimization can take a long time, and starting from a good starting location is often required.","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Now let's evaluate our fits by plotting the residuals","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"using Plots\nresidual(post, xopt)","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"These look reasonable, although there may be some minor overfitting. Let's compare our results to the ground truth values we know in this example. First, we will load the polarized truth","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"imgtrue = Comrade.load(joinpath(__DIR, \"..\", \"Data\", \"polarized_gaussian.fits\"), IntensityMap{StokesParams})","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Select a reasonable zoom in of the image.","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"imgtruesub = regrid(imgtrue, imagepixels(fovx, fovy, nx*4, ny*4))\nimg = intensitymap(Comrade.skymodel(post, xopt), axisdims(imgtruesub))\n\n#Plotting the results gives\nimport CairoMakie as CM\nCM.activate!(type = \"png\", px_per_unit=3) #hide\nfig = CM.Figure(;size=(450, 350));\npolimage(fig[1,1], imgtruesub,\n                   axis=(xreversed=true, aspect=1, title=\"Truth\"),\n                   nvec = 8,\n                   length_norm=1/2, plot_total=true, pcolormap=:RdBu,\n                   pcolorrange=(-0.25, 0.25),)\npolimage(fig[1,2], img,\n                   axis=(xreversed=true, aspect=1, title=\"Recon.\",),\n                   nvec = 8,\n                   length_norm=1/2, plot_total=true, pcolormap=:RdBu,\n                   pcolorrange=(-0.25, 0.25),)\nCM.Colorbar(fig[2,:], colormap=:RdBu, vertical=false, colorrange=(-0.25, 0.25), label=\"Signed Polarization Fraction sign(V)*|p|\", flipaxis=false)\nCM.colgap!(fig.layout, 3)\nCM.rowgap!(fig.layout, 3)\nCM.hidedecorations!.(fig.content[1:2])\nfig","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Let's compare some image statics, like the total linear polarization fraction","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"ftrue = flux(imgtruesub);\n@info \"Linear polarization true image: $(abs(linearpol(ftrue))/ftrue.I)\"\nfrecon = flux(img);\n@info \"Linear polarization recon image: $(abs(linearpol(frecon))/frecon.I)\"","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"And the Circular polarization fraction","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"@info \"Circular polarization true image: $(ftrue.V/ftrue.I)\"\n@info \"Circular polarization recon image: $(frecon.V/frecon.I)\"","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Because we also fit the instrument model, we can inspect their parameters. To do this, Comrade provides a caltable function that converts the flattened gain parameters to a tabular format based on the time and its segmentation.","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"dR = caltable(complex.(xopt.instrument.dRx, xopt.instrument.dRy))","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"We can compare this to the ground truth d-terms","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"time AA AP AZ JC LM PV SM\n0.0 0.01-0.02im -0.08+0.07im 0.09-0.10im -0.04+0.05im 0.03-0.02im -0.01+0.02im 0.08-0.07im","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"And same for the left-handed dterms","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"dL = caltable(complex.(xopt.instrument.dLx, xopt.instrument.dLy))","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"time AA AP AZ JC LM PV SM\n0.0 0.03-0.04im -0.06+0.05im 0.09-0.08im -0.06+0.07im 0.01-0.00im -0.03+0.04im 0.06-0.05im","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Looking at the gain phase ratio","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"gphase_ratio = caltable(xopt.instrument.gprat)","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"we see that they are all very small. Which should be the case since this data doesn't have gain corruptions! Similarly our gain ratio amplitudes are also very close to unity as expected.","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"gamp_ratio   = caltable(exp.(xopt.instrument.lgrat))","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Plotting the gain phases, we see some offsets from zero. This is because the prior on the gain product phases is very broad, so we can't phase center the image. For realistic data this is always the case since the atmosphere effectively scrambles the phases.","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"gphaseR = caltable(xopt.instrument.gpR)\nplot(gphaseR, layout=(3,3), size=(650,500))\nplot!(gphase_ratio, layout=(3,3), size=(650,500))","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Finally, the product gain amplitudes are all very close to unity as well, as expected since gain corruptions have not been added to the data.","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"gampr = caltable(exp.(xopt.instrument.lgR))\nplot(gampr, layout=(3,3), size=(650,500))\nplot!(gamp_ratio, layout=(3,3), size=(650,500))","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"[1]: Hamaker J.P, Bregman J.D., Sault R.J. (1996) [https://articles.adsabs.harvard.edu/pdf/1996A%26AS..117..137H]","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"[2]: Pesce D. (2021) [https://ui.adsabs.harvard.edu/abs/2021AJ....161..178P/abstract]","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"","category":"page"},{"location":"tutorials/PolarizedImaging/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/#Comrade-API","page":"Comrade API","title":"Comrade API","text":"","category":"section"},{"location":"api/#Contents","page":"Comrade API","title":"Contents","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api/#Index","page":"Comrade API","title":"Index","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Comrade.Comrade","category":"page"},{"location":"api/#Comrade.Comrade","page":"Comrade API","title":"Comrade.Comrade","text":"Comrade\n\nComposable Modeling of Radio Emission\n\n\n\n\n\n","category":"module"},{"location":"api/#Model-Definitions","page":"Comrade API","title":"Model Definitions","text":"","category":"section"},{"location":"api/#Models","page":"Comrade API","title":"Models","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"For the description of the model API see VLBISkyModels.","category":"page"},{"location":"api/#Data-Interface","page":"Comrade API","title":"Data Interface","text":"","category":"section"},{"location":"api/#Data-Tables","page":"Comrade API","title":"Data Tables","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Comrade.AbstractVLBITable\nComrade.datatable\nComrade.AbstractArrayConfiguration\nComrade.EHTArrayBaselineDatum\nComrade.EHTArrayConfiguration\nComrade.ClosureConfig\nComrade.sites(::Comrade.AbstractArrayConfiguration)\nComrade.domain(::Comrade.AbstractArrayConfiguration)\nComrade.beamsize(::Comrade.AbstractArrayConfiguration)\nComrade.logclosure_amplitudes\nComrade.closure_phases\nComrade.AbstractObservationTable\nComrade.EHTObservationTable\nComrade.domain(::Comrade.AbstractObservationTable)\nComrade.arrayconfig(::Comrade.AbstractObservationTable)\nComrade.beamsize(::Comrade.AbstractObservationTable)\nComrade.sites(::Comrade.AbstractObservationTable)\nComrade.TimeTable\nComrade.Scan\nComrade.timetable","category":"page"},{"location":"api/#Comrade.AbstractVLBITable","page":"Comrade API","title":"Comrade.AbstractVLBITable","text":"abstract type AbstractVLBITable{F}\n\nAn abstract VLBI table that is used to store data for a VLBI observation. To implement your own table you just need to specify the  VLBISkyModels.rebuild function.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.datatable","page":"Comrade API","title":"Comrade.datatable","text":"datatable(obs::AbstractVLBITable)\n\nConstruct a table from the observation obs. The table is usually a StructArray of fields\n\n\n\n\n\ndatatable(obs::AbstractObservationTable)\n\nReturns a tabular representation of the data. Note that for closures this ignores the covariance between quantities, which is otherwise included in the full EHTObservationTable.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.AbstractArrayConfiguration","page":"Comrade API","title":"Comrade.AbstractArrayConfiguration","text":"abstract type AbstractArrayConfiguration{F<:Comrade.AbstractBaselineDatum} <: Comrade.AbstractVLBITable{F<:Comrade.AbstractBaselineDatum}\n\nThis defined the abstract type for an array configuration. Namely, baseline times, SEFD's, bandwidth, observation frequencies, etc.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.EHTArrayBaselineDatum","page":"Comrade API","title":"Comrade.EHTArrayBaselineDatum","text":"struct EHTArrayBaselineDatum{T, P, V} <: Comrade.AbstractBaselineDatum\n\nA single datum of an ArrayConfiguration\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.EHTArrayConfiguration","page":"Comrade API","title":"Comrade.EHTArrayConfiguration","text":"struct EHTArrayConfiguration{A<:Comrade.EHTArrayBaselineDatum, F, T, S, D<:(AbstractArray{A<:Comrade.EHTArrayBaselineDatum})} <: Comrade.AbstractArrayConfiguration{A<:Comrade.EHTArrayBaselineDatum}\n\nTable that specified pertinent details about the EHT array during an observation. These are typically items that are known before the observation is made.\n\nFields\n\nbandwidth: Observing bandwith (Hz)\n\ntarr: Telescope array file\n\nscans: Scan times\n\nmjd: modified julia date of the observation\n\nra: RA of the observation in J2000 (deg)\n\ndec: DEC of the observation in J2000 (deg)\n\nsource: Common source name\n\ntimetype: Time zone used.\n\ndatatable: A struct array of EHTArrayBaselineDatum\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ClosureConfig","page":"Comrade API","title":"Comrade.ClosureConfig","text":"struct ClosureConfig{F, A<:Comrade.AbstractArrayConfiguration{F}, D, V, E} <: Comrade.AbstractArrayConfiguration{F}\n\nArray config file for closure quantities. This stores the design matrix designmat that transforms from visibilties to closure products.\n\nFields\n\nac: Array configuration for visibilities\ndesignmat: Closure design matrix\nvis: visibilities to closure design matrix\nnoise: visibility noises to closure design matrix\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.sites-Tuple{Comrade.AbstractArrayConfiguration}","page":"Comrade API","title":"Comrade.sites","text":"sites(d::AbstractArrayConfiguration)\n\nGet all the sites in a observation. The result is a vector of symbols.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.domain-Tuple{Comrade.AbstractArrayConfiguration}","page":"Comrade API","title":"Comrade.domain","text":"domain(ac; executor, header)\n\n\nGet the u, v, time, freq domain of the array.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.beamsize-Tuple{Comrade.AbstractArrayConfiguration}","page":"Comrade API","title":"Comrade.beamsize","text":"beamsize(ac::AbstractArrayConfiguration)\n\nCalculate the approximate beam size of the array ac as the inverse of the longest baseline distance.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.logclosure_amplitudes","page":"Comrade API","title":"Comrade.logclosure_amplitudes","text":"logclosure_amplitudes(vis::AbstractArray, d::DesignMatrix)\n\nCompute the log-closure amplitudes for a set of visibilities with a design matrix d.\n\nNotes\n\nThis uses a closure design matrix for the computation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.closure_phases","page":"Comrade API","title":"Comrade.closure_phases","text":"closure_phases(vis::AbstractArray, d::DesignMatrix)\n\nCompute the closure phases for a set of visibilities and design matrix d\n\nNotes\n\nThis uses a closure design matrix for the computation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.AbstractObservationTable","page":"Comrade API","title":"Comrade.AbstractObservationTable","text":"abstract type AbstractObservationTable{F<:Comrade.AbstractVisibilityDatum} <: Comrade.AbstractVLBITable{F<:Comrade.AbstractVisibilityDatum}\n\nThe abstract obervation table. This contains actual data plus the array configuration.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.EHTObservationTable","page":"Comrade API","title":"Comrade.EHTObservationTable","text":"struct EHTObservationTable{T<:Comrade.AbstractVisibilityDatum, S<:AbstractArray, E<:AbstractArray, A<:Comrade.AbstractArrayConfiguration} <: Comrade.AbstractObservationTable{T<:Comrade.AbstractVisibilityDatum}\n\nThe main data product type in Comrade this stores the data which can be a StructArray of any AbstractInterferometryDatum type. Note that the underlying structure is not part of the public API. Users should typically construct tables from the extract_table function.\n\nFields\n\nmeasurement: Obervation measurement\n\nnoise: Observation thermal noise\n\nconfig: Array config holds ancillary information about array\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.domain-Tuple{Comrade.AbstractObservationTable}","page":"Comrade API","title":"Comrade.domain","text":"domain(obs::AbstractObservationTable; executor=Serial(), header=ComradeBase.NoHeader()\n\nReturns the u, v, time, frequency domain of the observation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.arrayconfig-Tuple{Comrade.AbstractObservationTable}","page":"Comrade API","title":"Comrade.arrayconfig","text":"arrayconfig(obs::AbstractObservationTable)\narrayconfig(obs::AbstractObservationTable, p::Symbol)\n\nReturns the array configuration for a given observation. If p is provided then only the property p is returned.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.beamsize-Tuple{Comrade.AbstractObservationTable}","page":"Comrade API","title":"Comrade.beamsize","text":"beamsize(obs::AbstractObservationTable)\n\nCalculate the approximate beam size of the observation obs as the inverse of the longest baseline distance.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.sites-Tuple{Comrade.AbstractObservationTable}","page":"Comrade API","title":"Comrade.sites","text":"sites(d::AbstractObservationTable)\n\nGet all the sites in a observation. The result is a vector of symbols.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.TimeTable","page":"Comrade API","title":"Comrade.TimeTable","text":"struct TimeTable{O<:Comrade.AbstractVLBITable, T, S}\n\nWraps EHTObservationTable in a table that separates the observation into scans. This implements the table interface. You can access scans by directly indexing into the table. This will create a view into the table not copying the data.\n\nExample\n\njulia> st = timetable(obs)\njulia> st[begin] # grab first scan\njulia> st[end]   # grab last scan\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.Scan","page":"Comrade API","title":"Comrade.Scan","text":"struct Scan{T, I, S}\n\nComposite type that holds information for a single scan of the telescope.\n\nFields\n\ntime: Scan time\n\nindex: Scan indices which are (scan index, data start index, data end index)\n\nscan: Scan data usually a StructArray of a <:AbstractVisibilityDatum\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.timetable","page":"Comrade API","title":"Comrade.timetable","text":"timetable(obs::AbstractArrayConfiguration)\n\nReorganizes the observation into a table of scans, where scan are defined by unique timestamps. To access the data you can use scalar indexing\n\nExample\n\nst = timetable(obs)\n# Grab the first scan\nscan1 = st[1]\n\n# Acess the detections in the scan\nscan1[1]\n\n# grab e.g. the baselines\nscan1[:baseline]\n\n\n\n\n\n","category":"function"},{"location":"api/#Datums","page":"Comrade API","title":"Datums","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Comrade.AbstractVisibilityDatum\nComrade.EHTCoherencyDatum\nComrade.EHTVisibilityDatum\nComrade.EHTVisibilityAmplitudeDatum\nComrade.EHTLogClosureAmplitudeDatum\nComrade.EHTClosurePhaseDatum\nComrade.triangle\nComrade.baseline\nComrade.quadrangle","category":"page"},{"location":"api/#Comrade.AbstractVisibilityDatum","page":"Comrade API","title":"Comrade.AbstractVisibilityDatum","text":"AbstractVisibilityDatum\n\nAn abstract type for all VLBI data types. See Comrade.EHTVisibilityDatum for an example.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.EHTCoherencyDatum","page":"Comrade API","title":"Comrade.EHTCoherencyDatum","text":"struct EHTCoherencyDatum{S, B<:Comrade.AbstractBaselineDatum, M<:(StaticArraysCore.SArray{Tuple{2, 2}, Complex{S}, 2}), E<:(StaticArraysCore.SArray{Tuple{2, 2}, S, 2})} <: Comrade.AbstractVisibilityDatum{S}\n\nA Datum for a single coherency matrix\n\nFields\n\nmeasurement: coherency matrix, with entries in Jy\n\nnoise: visibility uncertainty matrix, with entries in Jy\n\nbaseline: baseline information\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.EHTVisibilityDatum","page":"Comrade API","title":"Comrade.EHTVisibilityDatum","text":"struct EHTVisibilityDatum{Pol, S<:Number, B<:Comrade.AbstractBaselineDatum} <: Comrade.AbstractSinglePolDatum{Pol, S<:Number}\n\nA struct holding the information for a single measured complex visibility.\n\nFIELDS\n\nmeasurement: Complex Vis. measurement (Jy)\n\nnoise: noise of the complex vis (Jy)\n\nbaseline: baseline information\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.EHTVisibilityAmplitudeDatum","page":"Comrade API","title":"Comrade.EHTVisibilityAmplitudeDatum","text":"struct EHTVisibilityAmplitudeDatum{P, S<:Number, B<:Comrade.AbstractBaselineDatum} <: Comrade.AbstractSinglePolDatum{P, S<:Number}\n\nA struct holding the information for a single measured visibility amplitude.\n\nFIELDS\n\nmeasurement: amplitude (Jy)\n\nnoise: noise of the visibility amplitude (Jy)\n\nbaseline: baseline information\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.EHTLogClosureAmplitudeDatum","page":"Comrade API","title":"Comrade.EHTLogClosureAmplitudeDatum","text":"struct EHTLogClosureAmplitudeDatum{P, S<:Number, B<:Comrade.AbstractBaselineDatum} <: Comrade.ClosureProducts{P, S<:Number}\n\nA Datum for a single log closure amplitude.\n\n\n\nmeasurement: log-closure amplitude\n\nnoise: log-closure amplitude noise in the high-snr limit\n\nbaseline: baselines for the closure phase\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.EHTClosurePhaseDatum","page":"Comrade API","title":"Comrade.EHTClosurePhaseDatum","text":"struct EHTClosurePhaseDatum{P, S<:Number, B<:Comrade.AbstractBaselineDatum} <: Comrade.ClosureProducts{P, S<:Number}\n\nA Datum for a single closure phase.\n\nFields\n\nmeasurement: closure phase (rad)\n\nnoise: noise of the closure phase assuming the high-snr limit\n\nbaseline: baselines for the closure phase\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.triangle","page":"Comrade API","title":"Comrade.triangle","text":"triangle(b::EHTClosurePhaseDatum)\n\nReturns the sites used in the closure phase triangle.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.baseline","page":"Comrade API","title":"Comrade.baseline","text":"baseline(scan::Scan)\n\nReturn the baselines for each datum in a scan\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.quadrangle","page":"Comrade API","title":"Comrade.quadrangle","text":"quadrangle(b::EHTClosurePhaseDatum)\n\nReturns the sites used in the closure amplitude quadrangle.\n\n\n\n\n\n","category":"function"},{"location":"api/#Data-Products","page":"Comrade API","title":"Data Products","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Comrade.extract_table\nComrade.Visibilities\nComrade.VisibilityAmplitudes\nComrade.ClosurePhases\nComrade.LogClosureAmplitudes\nComrade.Coherencies","category":"page"},{"location":"api/#Comrade.extract_table","page":"Comrade API","title":"Comrade.extract_table","text":"extract_table(obs, dataproducts::VLBIDataProducts)\n\nExtract an Comrade.EHTObservationTable table of data products dataproducts. To pass additional keyword for the data products you can pass them as keyword arguments to the data product type. For a list of potential data products see subtypes(Comrade.VLBIDataProducts).\n\nExample\n\njulia> dlcamp, dcphase = extract_table(obs, LogClosureAmplitudes(;snrcut=3.0), ClosurePhases(;snrcut=3.0, cut_trivial=true))\njulia> dcoh = extract_table(obs, Coherencies())\njulia> dvis = extract_table(obs, VisibilityAmplitudes())\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.Visibilities","page":"Comrade API","title":"Comrade.Visibilities","text":"Visibilities(;kwargs...)\n\nType to specify to extract the complex visibilities table in the extract_table function. Optional keywords are passed through extract_table to specify additional option.\n\nSpecial keywords for eht-imaging with Pyehtim.jl\n\nAny keyword arguments are ignored for now. Use eht-imaging directly to modify the data.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.VisibilityAmplitudes","page":"Comrade API","title":"Comrade.VisibilityAmplitudes","text":"Visibilities(;kwargs...)\n\nType to specify to extract the log closure amplitudes table in the extract_table function. Optional keywords are passed through extract_table to specify additional option.\n\nSpecial keywords for eht-imaging with Pyehtim.jl\n\nFor a list of potential keyword arguments see eht-imaging and add_amp command for obsdata.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ClosurePhases","page":"Comrade API","title":"Comrade.ClosurePhases","text":"ClosuresPhases(;kwargs...)\n\nType to specify to extract the closure phase table in the extract_table function. Optional keywords are passed through extract_table to specify additional option.\n\nSpecial keywords for eht-imaging with Pyehtim.jl\n\nFor a list of potential keyword arguments see eht-imaging and add_cphase command for obsdata. In addition note we have changed the following:\n\ncount: How the closures are formed, the available options are \"min-correct\", \"min\", \"max\"\n\nWarning\n\nThe count keyword argument is treated specially in Comrade. The default option is \"min-correct\" and should almost always be used. This option construct a minimal set of closure phases that is valid even when the array isn't fully connected. For testing and legacy reasons we ehtim other count options are also included. However, the current ehtim count=\"min\" option is broken and does construct proper minimal sets of closure quantities if the array isn't fully connected.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.LogClosureAmplitudes","page":"Comrade API","title":"Comrade.LogClosureAmplitudes","text":"LogClosureAmplitudes(;kwargs...)\n\nType to specify to extract the log closure amplitudes table in the extract_table function. Optional keywords are passed through extract_table to specify additional option.\n\nSpecial keywords for eht-imaging with Pyehtim.jl\n\nFor a list of potential keyword arguments see eht-imaging and add_cphase command for obsdata. In addition note we have changed the following:\n\ncount: How the closures are formed, the available options are \"min-correct\", \"min\", \"max\"\n\nReturns an EHTObservation with log-closure amp. datums\n\nWarning\n\nThe count keyword argument is treated specially in Comrade. The default option is \"min-correct\" and should almost always be used. This option construct a minimal set of closure phases that is valid even when the array isn't fully connected. For testing and legacy reasons we ehtim other count options are also included. However, the current ehtim count=\"min\" option is broken and does construct proper minimal sets of closure quantities if the array isn't fully connected.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.Coherencies","page":"Comrade API","title":"Comrade.Coherencies","text":"Coherencies(;kwargs...)\n\nType to specify to extract the coherency matrices table in the extract_table function. Optional keywords are passed through extract_table to specify additional option.\n\nSpecial keywords for eht-imaging with Pyehtim.jl\n\nAny keyword arguments are ignored for now. Use eht-imaging directly to modify the data.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBI-Modeling","page":"Comrade API","title":"VLBI Modeling","text":"","category":"section"},{"location":"api/#Sky-Models","page":"Comrade API","title":"Sky Models","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Comrade.AbstractSkyModel\nComrade.SkyModel\nComrade.FixedSkyModel\nComrade.idealvisibilities\nComrade.skymodel(::Comrade.AbstractVLBIPosterior, ::Any)","category":"page"},{"location":"api/#Comrade.AbstractSkyModel","page":"Comrade API","title":"Comrade.AbstractSkyModel","text":"AbstractSkyModel\n\nThe abstract type for Comrade Sky Models. For a concrete implementation see SkyModel.\n\nAny subtype must implement the following methods\n\nset_array(m::AbstractSkyModel, array::AbstractArrayConfiguration): Sets the array configuration  for the sky model m and returns the observed sky model and prior.\n\nThe following methods have default implementations:\n\nidealvisibilities(m::AbstractSkyModel, x): Computes the ideal visibilities of the sky model m  given the model parameters x.\nskymodel(m::AbstractSkyModel, x): Returns the sky model image given the model parameters x.\ndomain(m::AbstractSkyModel): Returns the domain of the sky model m.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.SkyModel","page":"Comrade API","title":"Comrade.SkyModel","text":"SkyModel(f, prior, grid::AbstractRectiGrid; algorithm = NFFTAlg(), metadata=nothing)\n\nConstruct a sky model using the function map f with parameter priors prior, where the image model is defined on the domain grid. If the underlying model produced by f is non-analytic, then algorithm is used to numerically Fourier transform the model image. The metadata option contains additional information needed by the model f.\n\nArguments\n\nf(x, p) : A function must be two arguments, where x are the model parameters and p is the metadata.  typically x and p are named tuples.\nprior : A named tuple of priors for the model parameters defined in x. Each model parameter used in x must have a defined element in the prior.\ngrid : The domain on which the model is defined. This defines the field of view and resolution of the model. Note that if f produces a analytic model then this field of view isn't used directly in the computation of the visibilities.\n\nOptional Arguments\n\nalgorithm : The Fourier transform algorithm used to compute the visibilities. The default is  NFFTAlg() which uses a non-uniform fast Fourier transform. Other options can be found by using  subtypes(VLBISkyModels.FourierTransform)\nmetadata : Additional information needed by the model f. These are the addtional arguments  passed to the model function f.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.FixedSkyModel","page":"Comrade API","title":"Comrade.FixedSkyModel","text":"FixedSkyModel(m::AbstractModel, grid::AbstractRectiGrid; algorithm = NFFTAlg())\n\nConstruct a sky model that has no free parameters. This is useful for models where the image structure is known apriori but the instrument model is unknown.\n\nArguments\n\nm : The fixed sky model.\ngrid : The domain on which the model is defined. This defines the field of view and resolution of the model. Note that if f produces a analytic model then this field of view isn't used directly in the computation of the visibilities.\n\nOptional Arguments\n\nalgorithm : The Fourier transform algorithm used to compute the visibilities. The default is  NFFTAlg() which uses a non-uniform fast Fourier transform. Other options can be found by using  subtypes(VLBISkyModels.FourierTransform)\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.idealvisibilities","page":"Comrade API","title":"Comrade.idealvisibilities","text":"idealvisibilities(m::AbstractSkyModel, x)\n\nComputes the ideal non-corrupted visibilities of the sky model m given the model parameters x.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.skymodel-Tuple{Comrade.AbstractVLBIPosterior, Any}","page":"Comrade API","title":"Comrade.skymodel","text":"skymodel(post::AbstractVLBIPosterior, θ)\n\nReturns the sky model or image of a posterior using the parameter valuesθ\n\n\n\n\n\n","category":"method"},{"location":"api/#Instrument-Models","page":"Comrade API","title":"Instrument Models","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Comrade.CalTable\nComrade.caltable(::Comrade.SiteArray)\nComrade.sites(::Comrade.CalTable)\nComrade.IIDSitePrior\nComrade.ArrayPrior\nComrade.Segmentation\nComrade.IntegSeg\nComrade.ScanSeg\nComrade.TrackSeg\nComrade.timestamps\nComrade.SingleReference\nComrade.SEFDReference\nComrade.SingleStokesGain\nComrade.JonesG\nComrade.JonesD\nComrade.JonesR\nComrade.JonesF\nComrade.GenericJones\nComrade.JonesSandwich\nComrade.AbstractInstrumentModel\nComrade.IdealInstrumentModel\nComrade.InstrumentModel\nComrade.SiteArray\nComrade.SiteLookup","category":"page"},{"location":"api/#Comrade.CalTable","page":"Comrade API","title":"Comrade.CalTable","text":"struct CalTable{T, G<:(AbstractVecOrMat)}\n\nA Tabes of calibration quantities. The columns of the table are the telescope sites codes. The rows are the calibration quantities at a specific time stamp. This user should not use this struct directly. Instead that should call caltable.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.caltable-Tuple{SiteArray}","page":"Comrade API","title":"Comrade.caltable","text":"caltable(s::SiteArray)\n\nCreates a calibration table from a site array\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.sites-Tuple{Comrade.CalTable}","page":"Comrade API","title":"Comrade.sites","text":"sites(g::CalTable)\n\nReturn the sites in the calibration table\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.IIDSitePrior","page":"Comrade API","title":"Comrade.IIDSitePrior","text":"IIDSitePrior(seg::Segmentation, dist)\n\nCreate a site prior that is independent and identically distributed (IID) across all times and frequencies. The seg argument is a segmentation object that defines how fine the time segmentation is. The dist argument is the distribution of the site prior.\n\nExample\n\nA = IIDSitePrior(ScanSeg(), Normal(0, 1))\n\ncreates a site prior that is constant across scans and each scan has a unit Normal prior.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ArrayPrior","page":"Comrade API","title":"Comrade.ArrayPrior","text":"ArrayPrior(default_dist; refant=NoReference(), phase=false, kwargs...)\n\nConstruct a prior for an entire array of sites.\n\nThe default_dist is the default distribution for all sites. Currently only IIDSitePrior is supported.\nDifferent priors for specified sites can be set using kwargs.\nThe refant  set the reference antennae to be used and is typically only done for priors that\n\ncorrespond to gain phases.\n\nThe phase argument is a boolean that specifies if\n\nthe prior is for a phase or not. The phase argument is experimental and we recommend setting it to false currently.\n\nExample\n\np = ArrayPrior(IIDSitePrior(ScanSeg(), Normal(0, 0.1)); LM = IIDSitePrior(ScanSeg(), Normal(0.0, 1.0)) refant=SEFDReference())\n\nmeans that every site has a normal prior with mean 0 and 0.1 std. dev. except LM which is mean zero and unit std. dev. Finally the refant is using the SEFDReference scheme.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.Segmentation","page":"Comrade API","title":"Comrade.Segmentation","text":"abstract type Segmentation\n\nThe data segmentation scheme to use. This is used specify how often we want various instrument hyperparameters to change. A user subtyping this expression must implement the following functions:\n\ntimestamps: Specifies the time region for each segmentation scheme given an array\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.IntegSeg","page":"Comrade API","title":"Comrade.IntegSeg","text":"struct IntegSeg <: Comrade.Segmentation\n\nData segmentation such that the quantity is constant over the time stamps in the data. If the data is scan-averaged before then IntegSeg will be identical to ScanSeg.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ScanSeg","page":"Comrade API","title":"Comrade.ScanSeg","text":"struct ScanSeg <: Comrade.Segmentation\n\nData segmentation such that the quantity is constant over a scan.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.TrackSeg","page":"Comrade API","title":"Comrade.TrackSeg","text":"struct TrackSeg <: Comrade.Segmentation\n\nData segmentation such that the quantity is constant over a track, i.e., the observation \"night\".\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.timestamps","page":"Comrade API","title":"Comrade.timestamps","text":"timestamps(seg::Segmentation, array::AbstractArrayConfiguration)\n\nReturn the time stamps or really a vector of integration time regions for a given segmentation scheme seg and array configuration array.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.SingleReference","page":"Comrade API","title":"Comrade.SingleReference","text":"SingleReference(site::Symbol, val)\n\nSelects a single reference site for all scans. The value of the site is set to val.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.SEFDReference","page":"Comrade API","title":"Comrade.SEFDReference","text":"SEFDReference(val::Number, sefd_index = 1)\n\nSelects the reference site based on the SEFD of each telescope, where the smallest SEFD is preferentially selected. The reference gain is set to val and the user can select to use the n lowest SEFD site by passing sefd_index = n.\n\nNotes\n\nThis is done on a per-scan basis so if a site is missing from a scan the next highest SEFD site will be used.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.SingleStokesGain","page":"Comrade API","title":"Comrade.SingleStokesGain","text":"SingleStokesGain(param_map)\n\nConstruct a gain term that is applicable to a single measured visibility. This is useful for pure stokes I modeling. The param_map is a function that maps the set of parameters to the gain term.\n\nThe arguments of param_map is typically a named tuple, where some of the elements are the parameter values needed to compute the gain. The return value of the param_map should be a single number or complex gain.\n\nExample\n\nG = SingleStokesGain(x->exp(x.lg + xp.gp))\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.JonesG","page":"Comrade API","title":"Comrade.JonesG","text":"JonesG(param_map)\n\nDescribes a gain Jones matrix with layout\n\ng1 0   0  g2\n\nwhere g1 and g2 are the gains for first and second feed of the telescope.\n\nThe param_map is a function that maps the set of parameters to the gain term. The arguments of param_map is typically a named tuple, where some of the elements are the parameter values needed to compute the gain. The return value of the param_map should be a two element tuple where the first element is the complex gain g1 and the second element is the complex gain g2.\n\nExample\n\nG = JonesG() do\n    g1 = exp(x.lg1 + 1im.*x.gp1)\n    g2 = g1*exp(x.lgratio + 1im.*x.gpratio)\n    return g1, g2\nend\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.JonesD","page":"Comrade API","title":"Comrade.JonesD","text":"JonesD(param_map)\n\nDescribes a leakage Jones matrix with layout\n\n1 d1   d2 1\n\nwhere d1 and d2 are the d-terms for first and second feed of the telescope.\n\nThe param_map is a function that maps the set of parameters to the gain term. The arguments of param_map is typically a named tuple, where some of the elements are the parameter values needed to compute the gain. The return value of the param_map should be a two element tuple where the first element is the complex d-term d1 and the second element is the complex d-term d2.\n\nExample\n\nD = JonesD() do\n    d1 = complex(x.d1real, x.d1imag)\n    d2 = complex(x.d2real, x.d2imag)\n    return d1, d2\nend\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.JonesR","page":"Comrade API","title":"Comrade.JonesR","text":"JonesR(;add_fr=true)\n\nThe response Jones matrix. This is the reponse the telescope has to the incoming electric field, if the telescope was ideal. If add_fr=true then feed rotation are included.\n\nThis Jones matrix has no parameters so it doesn't accept a param_map. The add_fr argument is a boolean that specifies if feed rotation should be included.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.JonesF","page":"Comrade API","title":"Comrade.JonesF","text":"JonesF(;add_fr=true)\n\nThe feed rotation Jones matrix. This matrix describes the orientation of the feeds of the telescope.\n\nThis Jones matrix has no parameters so it doesn't accept a param_map. The add_fr argument is a boolean that specifies if feed rotation should be included.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.GenericJones","page":"Comrade API","title":"Comrade.GenericJones","text":"GenericJones(param_map)\n\nConstruct a generic dense jones matrix with four parameterized elements.\n\nThe param_map is a function that maps the set of parameters to the gain term. The arguments of param_map is typically a named tuple, where some of the elements are the parameter values needed to compute the gain. The return value of the param_map should be a four element tuple where the elements are the entries of the jones matrix in column major order.\n\nExample\n\nJ = GenericJones() do\n    return x.j11, x.j21, x.j12, x.j22\nend\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.JonesSandwich","page":"Comrade API","title":"Comrade.JonesSandwich","text":"JonesSandwich([decomp_function=splat(*),] matrices::AbstractJonesMatrix...)\n\nConstructs a Jones matrix that is the results combining multiple Jones matrices together. The specific composition is determined by the decomp_function. For example if the decomp function is * then the matrices are multiplied together, if it is + then they are added.\n\nExamples\n\nG = JonesG(x->(x.gR, x.gL)) # Gain matrix\nD = JonesD(x->(x.dR, x.dL)) # leakage matrix\nF = JonesF()                # Feed rotation matrix\n\nJ = JonesSandwich(splat(*), G, D, F) # Construct the full Jones matrix as G*D*F\n\n# Or if you want to include FR calibration\nJ = JonesSandwich(G, D, F) do g, d, f\n    return adjoint(f)g*d*f\nend\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.AbstractInstrumentModel","page":"Comrade API","title":"Comrade.AbstractInstrumentModel","text":"abstract type AbstractInstrumentModel\n\nThe abstract instrument model. For a concrete implementation see IdealInstrumentModel and InstrumentModel.\n\nAny subtype must implement the following methods\n\nset_array(m::AbstractInstrumentModel, array::AbstractArrayConfiguration): Sets the array configuration  for the instrument model m and returns the observed instrument model and prior.\napply_instrument(vis, m::AbstractInstrumentModel, x): Applies the instrument model m to the visibilities  vis given the model parameters x.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.IdealInstrumentModel","page":"Comrade API","title":"Comrade.IdealInstrumentModel","text":"IdealInstrument(array::AbstractArrayConfiguration)\n\nConstructs an ideal instrument that has no corruptions or feed rotation.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.InstrumentModel","page":"Comrade API","title":"Comrade.InstrumentModel","text":"InstrumentModel(jones, prior; refbasis = CirBasis())\n\nBuilds an instrument model using the jones matrix jones, with priors prior. The reference basis is refbasis and is used to define what the ideal basis is. Namely, the basis that you have the ideal visibilties to be represented in. For classical VLBI refbasis = CirBasis is a good default option, sinc the majority of the array uses circular feeds. For linear feed arrays like VGOS a user should switch to LinBasis, although failure to do so will not cause any errors, and is just a less efficient representation of the visibilities.\n\nArguments\n\njones : The jones matrix that represents the instrument. This is a function that takes in the  parameters of the instrument and returns a jones matrix. See SingleStokesGain  for a Stokes I example and JonesG or JonesD for polarized examples.\nprior: A named tuple of ArrayPrior that specify what the priors are for each  component used to construct the jones matrix using the function jones\n\nOptional Arguments\n\nrefbasis: The reference basis used for the computation. The default is CirBasis() which are circular feeds.\n\nExample\n\nA Stokes I example is\n\njulia> G = SingleStokesGain(x->exp(x.lg + 1im*x.pg))\njulia> intprior = (lg = ArrayPrior(IIDSitePrior(ScanSeg(), Normal(0.0, 0.1))),\n            pg = ArrayPrior(IIDSitePrior(ScanSeg(), DiagVonMises(0.0, inv(π^2))))\n            )\n\njulia> intm = InstrumentModel(G, intprior)\n\nA standard polarized example is\n\njulia> G = JonesG() do\n        gR = exp.(x.lgr + 1im*x.gpr)\n        gL = gr*exp.(x.lgrat + 1im*x.gprat)\n        return gR, gL\n    end\njulia> D = JonesD() do\n        dR = complex.(x.dRre, x.dRim)\n        dL = complex.(x.dLre, x.dLim)\n        return gR, gL\n    end\njulia> R = JonesR()\njulia> J = JonesSandwich(G, D, R)\njulia> intprior = (lgr = ArrayPrior(IIDSitePrior(ScanSeg(), Normal(0.0, 0.1)),\n                    gpr = ArrayPrior(IIDSitePrior(ScanSeg(), DiagonalVonMises(0.0, inv(π^2))),\n                    lgrat = ArrayPrior(IIDSitePrior(ScanSeg(), Normal(0.0, 0.1)),\n                    gprat = ArrayPrior(IIDSitePrior(ScanSeg(), DiagonalVonMises(0.0, inv(π^2))),\n                    dRre = ArrayPrior(IIDSitePrior(TrackSeg(), Normal(0.0, 0.1)),\n                    dRim = ArrayPrior(IIDSitePrior(TrackSeg(), Normal(0.0, 0.1)),\n                    dLre = ArrayPrior(IIDSitePrior(TrackSeg(), Normal(0.0, 0.1)),\n                    dLim = ArrayPrior(IIDSitePrior(TrackSeg(), Normal(0.0, 0.1))\n                    )\njulia> intm = InstrumentModel(J, intprior)\n\nwhich construct the gain matrix from R and ratios, and D is the small leakage matrix. JonesR is the response matrix that controls how the site responds to the ideal visibility in the reference basis.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.SiteArray","page":"Comrade API","title":"Comrade.SiteArray","text":"SiteArray(data, times, frequencies, sites)\n\nA SiteArray is an array of data that has a specified ordering of times, frequencies, and sites. Each data point is assigned a unique time, frequency, and site code. This allows for easy selection of data points based on these criteria and forms the base array for instrument modeling.\n\nTo select a subset of the data based on a specifid site, time and frequency you can use\n\nsarr[S=:ALMA, Ti=1:10, Fr=1:10]\n\nwhich will grab the first 10 time and frequency points for the ALMA site.\n\nOtherwise indexing into the array will return an element whose time, frequency, and site are the element of the times, frequencies, and sites arrays respectively.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.SiteLookup","page":"Comrade API","title":"Comrade.SiteLookup","text":"SiteLookup(s::SiteArray)\n\nConstruct a site lookup dictionary for a site array.\n\n\n\n\n\n","category":"type"},{"location":"api/#Posterior-Constructions","page":"Comrade API","title":"Posterior Constructions","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Comrade.AbstractVLBIPosterior\nComrade.logprior\nComrade.loglikelihood\nComrade.dataproducts\nComrade.skymodel\nComrade.instrumentmodel(::Comrade.AbstractVLBIPosterior)\nComrade.forward_model\nComrade.prior_sample\nComrade.likelihood\nComrade.VLBIPosterior\nComrade.simulate_observation\nComrade.residuals\nComrade.TransformedVLBIPosterior\nHypercubeTransform.transform(::Comrade.TransformedVLBIPosterior, ::Any)\nHypercubeTransform.inverse(::Comrade.TransformedVLBIPosterior, ::Any)\nHypercubeTransform.ascube(::Comrade.VLBIPosterior)\nHypercubeTransform.asflat(::Comrade.VLBIPosterior)","category":"page"},{"location":"api/#Comrade.AbstractVLBIPosterior","page":"Comrade API","title":"Comrade.AbstractVLBIPosterior","text":"abstract type AbstractVLBIPosterior\n\nAn abstract VLBI posterior. See VLBIPosterior for a concrete implementation. This implements the  DensityInterface and LogDensityProblem interfaces.\n\nDefault methods include:\n\nlogprior(d::AbstractVLBIPosterior, θ): Computes the log-prior of the posterior.\nloglikelihood(d::AbstractVLBIPosterior, θ): Computes the log-likelihood of the posterior.\ndimension(d::AbstractVLBIPosterior): Returns the dimension of the posterior.\nskymodel(d::AbstractVLBIPosterior, θ): Returns the sky model of the posterior.\nprior_sample(rng::AbstractRandom, d::AbstractVLBIPosterior, dims...): Samples from the prior of the posterior.\nforward_model(d::AbstractVLBIPosterior, θ): Computes the forward model visibilities of the posterior.\ndataproducts(d::AbstractVLBIPosterior): Returns the data products you are fitting as a tuple.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.logprior","page":"Comrade API","title":"Comrade.logprior","text":"logprior(d::AbstractVLBIPosterior, θ)\n\nComputes the log-prior of the posterior d with parameters θ.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.loglikelihood","page":"Comrade API","title":"Comrade.loglikelihood","text":"loglikelihood(d::AbstractVLBIPosterior, θ)\n\nComputes the log-likelihood of the posterior d with parameters θ.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.dataproducts","page":"Comrade API","title":"Comrade.dataproducts","text":"dataproducts(d::AbstractVLBIPosterior)\n\nReturns the data products you are fitting as a tuple. The order of the tuple corresponds to the order of the dataproducts argument in VLBIPosterior.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.skymodel","page":"Comrade API","title":"Comrade.skymodel","text":"skymodel(d::AbstractVLBIPosterior)\n\nReturns the sky model of the posterior d.\n\n\n\n\n\nskymodel(post::AbstractVLBIPosterior, θ)\n\nReturns the sky model or image of a posterior using the parameter valuesθ\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.instrumentmodel-Tuple{Comrade.AbstractVLBIPosterior}","page":"Comrade API","title":"Comrade.instrumentmodel","text":"instrumentmodel(d::AbstractVLBIPosterior)\n\nReturns the instrument model of the posterior d.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.forward_model","page":"Comrade API","title":"Comrade.forward_model","text":"forward_model(d::AbstractVLBIPosterior, θ)\n\nComputes the forward model visibilities of the posterior d with parameters θ. Note these are the complex visiblities or the coherency matrices, not the actual data products observed.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.prior_sample","page":"Comrade API","title":"Comrade.prior_sample","text":"prior_sample([rng::AbstractRandom], post::AbstractVLBIPosterior, [dims=1])\n\nReturns sample from the prior distribution of the posterior. If dims is specified then multiple independent draws are returned with shape dims.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.likelihood","page":"Comrade API","title":"Comrade.likelihood","text":"likelihood(d::ConditionedLikelihood, μ)\n\nReturns the likelihood of the model, with parameters μ. That is, we return the distribution of the data given the model parameters μ. Samples from this distribution are simulated data.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.VLBIPosterior","page":"Comrade API","title":"Comrade.VLBIPosterior","text":"VLBIPosterior(skymodel::SkyModel, instumentmodel::InstrumentModel, dataproducts::EHTObservationTable...)\n\nCreates a VLBILikelihood using the skymodel its related metadata skymeta and the instrumentmodel and its metadata instumentmeta. . The model is a function that converts from parameters θ to a Comrade AbstractModel which can be used to compute visibilitymap and a set of metadata that is used by model to compute the model.\n\nWarning\n\nThe model itself must be a two argument function where the first argument is the set of model parameters and the second is a container that holds all the additional information needed to construct the model. An example of this is when the model needs some precomputed cache to define the model.\n\nExample\n\ndlcamp, dcphase = extract_table(obs, LogClosureAmplitude(), ClosurePhases())\narray = arrayconfiguration(dlcamp)\n\nfunction sky(θ, metadata)\n    (; r, a) = θ\n    m = stretched(ExtendedRing(a), r, r)\n    return m\nend\n\nskyprior = (r = Uniform(μas2rad(10.0), μas2rad(30.0)), a = Uniform(1.0, 10.0))\ng  = imagepixels(μas2rad(100.0), μas2rad(100.0), 256, 256)\nskym = SkyModel(sky, skyprior, g)\n\nG = SingleStokesGain(x->exp(x.lg + 1im*x.pg))\nintprior = (lg = ArrayPrior(IIDSitePrior(ScanSeg(), Normal(0.0, 0.1))),\n            pg = ArrayPrior(IIDSitePrior(ScanSeg(), DiagVonMises(0.0, inv(π^2))))\n            )\nintmodel = InstrumentModel(G, intprior, array)\n\npost = VLBIPosterior(skym, intmodel, dlcamp, dcphase)\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.simulate_observation","page":"Comrade API","title":"Comrade.simulate_observation","text":"simulate_observation([rng::Random.AbstractRNG], post::VLBIPosterior, θ; add_thermal_noise=true)\n\nCreate a simulated observation using the posterior and its data post using the parameter values θ. In Bayesian terminology this is a draw from the posterior predictive distribution.\n\nIf add_thermal_noise is true then baseline based thermal noise is added. Otherwise, we just return the model visibilities.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.residuals","page":"Comrade API","title":"Comrade.residuals","text":"residuals(post::VLBIPosterior, θ)\n\nCompute the residuals for each data product in post using the parameter values θ. The resturn objects are EHTObservationTables, where the measurements are the residuals.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.TransformedVLBIPosterior","page":"Comrade API","title":"Comrade.TransformedVLBIPosterior","text":"struct TransformedVLBIPosterior{P<:VLBIPosterior, T} <: Comrade.AbstractVLBIPosterior\n\nA transformed version of a VLBIPosterior object. This is an internal type that an end user shouldn't have to directly construct. To construct a transformed posterior see the asflat, ascube.\n\n\n\n\n\n","category":"type"},{"location":"api/#TransformVariables.transform-Tuple{Comrade.TransformedVLBIPosterior, Any}","page":"Comrade API","title":"TransformVariables.transform","text":"transform(posterior::TransformedVLBIPosterior, x)\n\nTransforms the value x from the transformed space (e.g. unit hypercube if using ascube) to parameter space which is usually encoded as a NamedTuple.\n\nFor the inverse transform see inverse\n\n\n\n\n\n","category":"method"},{"location":"api/#TransformVariables.inverse-Tuple{Comrade.TransformedVLBIPosterior, Any}","page":"Comrade API","title":"TransformVariables.inverse","text":"inverse(posterior::TransformedVLBIPosterior, x)\n\nTransforms the value y from parameter space to the transformed space (e.g. unit hypercube if using ascube).\n\nFor the inverse transform see transform\n\n\n\n\n\n","category":"method"},{"location":"api/#HypercubeTransform.ascube-Tuple{VLBIPosterior}","page":"Comrade API","title":"HypercubeTransform.ascube","text":"ascube(post::VLBIPosterior)\n\nConstruct a flattened version of the posterior where the parameters are transformed to live in (0, 1), i.e. the unit hypercube.\n\nThis returns a TransformedVLBIPosterior that obeys the DensityInterface and can be evaluated in the usual manner, i.e. logdensityof. Note that the transformed posterior automatically includes the terms log-jacobian terms of the transformation.\n\nExample\n\njulia> tpost = ascube(post)\njulia> x0 = prior_sample(tpost)\njulia> logdensityof(tpost, x0)\n\nNotes\n\nThis is the transform that should be used if using typical NestedSampling methods, i.e. ComradeNested. For the transformation to unconstrained space see asflat\n\n\n\n\n\n","category":"method"},{"location":"api/#HypercubeTransform.asflat-Tuple{VLBIPosterior}","page":"Comrade API","title":"HypercubeTransform.asflat","text":"asflat(post::VLBIPosterior)\n\nConstruct a flattened version of the posterior where the parameters are transformed to live in (-∞, ∞).\n\nThis returns a TransformedVLBIPosterior that obeys the DensityInterface and can be evaluated in the usual manner, i.e. logdensityof. Note that the transformed posterior automatically includes the terms log-jacobian terms of the transformation.\n\nExample\n\njulia> tpost = ascube(post)\njulia> x0 = prior_sample(tpost)\njulia> logdensityof(tpost, x0)\n\nNotes\n\nThis is the transform that should be used if using typical MCMC methods, i.e. NUTS. For the transformation to the unit hypercube see ascube\n\n\n\n\n\n","category":"method"},{"location":"api/#Inference","page":"Comrade API","title":"Inference","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Comrade.comrade_opt\nComrade.MemoryStore\nComrade.DiskStore\nComrade.load_samples\nComrade.PosteriorSamples\nComrade.postsamples\nComrade.samplerstats\nComrade.samplerinfo\nComrade.resample_equal\nComrade.residual\nComrade.residual_data\nComrade.chi2","category":"page"},{"location":"api/#Comrade.comrade_opt","page":"Comrade API","title":"Comrade.comrade_opt","text":"comrade_opt(post::VLBIPosterior, opt, adtype=Optimization.NoAD(), args...; initial_params=nothing, kwargs...)\n\nOptimize the posterior post using the opt optimizer. The adtype specifies the automatic differentiation. The args/kwargs are forwarded to `the specific optimization package.\n\nwarning: Warning\nThis function won't have any methods until the optimization package is loaded. We recommend loading the Optimization.jl package.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.MemoryStore","page":"Comrade API","title":"Comrade.MemoryStore","text":"MemoryStore\n\nStored the HMC samplers in memory or ram.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.DiskStore","page":"Comrade API","title":"Comrade.DiskStore","text":"DiskStore(;name::String = \"Results\", stride::Int = 100)\n\nType that specifies to save the samples results to disk.\n\nFields\n\nname: Path of the directory where the results will be saved. If the path does not exist it will be automatically created.\n\nstride: The output stride, i.e. every stride steps the MCMC output will be dumped to disk.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.load_samples","page":"Comrade API","title":"Comrade.load_samples","text":"load_samples(out::DiskOutput, indices::Union{Base.Colon, UnitRange, StepRange}=Base.Colon(); table=:samples)\nload_samples(out::String, indices::Union{Base.Colon, UnitRange, StepRange}=Base.Colon(); table=:samples)\n\nThe the results from a HMC run saved to disk. To read in the output the user can either pass the resulting out object, or the path to the directory that the results were saved, i.e. the path specified in DiskStore.\n\nArguments\n\nout::Union{String, DiskOutput}: If out is a string is must point to the direct that the DiskStore  pointed to. Otherwise it is what is directly returned from sample.\nindices: The indices of the that you want to load into memory. The default is to load the entire table.\n\nKeyword Arguments\n\ntable: A string specifying the table you wish to read in. There are two options: :samples which  corresponds to the actual MCMC chain, and stats which corresponds to additional information  about the sampler, e.g., the log density of each sample and tree statistics.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.PosteriorSamples","page":"Comrade API","title":"Comrade.PosteriorSamples","text":"PosteriorSamples(chain, stats; metadata=Dict(:sampler=>:unknown))\n\nThis is the default sampler output from Comrade MCMC extensions. The object contains the posterior samples, the sampler statistics, and metadata about the sampler used.\n\nIndexing this array behaves like indexing the samples organized as a StructArray. By default all NamedTuples and Tuples are unwrapped.\n\nTo access the samples use postsamples and to access the sampler statistics use samplerstats, or the acesss sampler specific information use samplerinfo.\n\nTo recursively map a function over the samples the unexported Comrade.rmap.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.postsamples","page":"Comrade API","title":"Comrade.postsamples","text":"postsamples(s::PosteriorSamples)\n\nReturn the samples from the PosteriorSamples object s\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.samplerstats","page":"Comrade API","title":"Comrade.samplerstats","text":"samplerstats(s::PosteriorSamples)\n\nReturn the sampler statistics from the PosteriorSamples object s\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.samplerinfo","page":"Comrade API","title":"Comrade.samplerinfo","text":"samplerinfo(s::PosteriorSamples)\n\nReturn the metadata from the PosteriorSamples object s.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.resample_equal","page":"Comrade API","title":"Comrade.resample_equal","text":"resample_equal(post::PosteriorSamples, nsamples::Int)\n\nResample the posterior samples so you have nsamples of equal weight. In order for this method to be applicable a :weights field must be present in the sampler statistics and the weight must correspond to the probability weights of the samples.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.residual","page":"Comrade API","title":"Comrade.residual","text":"residual(post::AbstractVLBIPosterior, p)\n\nPlots the normalized residuals for the posterior post given the parameters p.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.residual_data","page":"Comrade API","title":"Comrade.residual_data","text":"residual_data(vis, data::EHTObservationTable)\n\nCompute the residuals for the model visibilities vis and the data data. The residuals are not normalized and the returned object is an EHTObservationTable.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.chi2","page":"Comrade API","title":"Comrade.chi2","text":"chi2(post::AbstractVLBIPosterior, p)\n\nReturns a tuple of the chi-squared values for each data product in the posterior post given the parameters p. Note that the chi-square is not reduced.\n\n\n\n\n\n","category":"function"},{"location":"api/#Misc","page":"Comrade API","title":"Misc","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Comrade.site_tuple\nComrade.dirty_image\nComrade.dirty_beam\nComrade.beamsize\nComrade.apply_fluctuations\nComrade.rmap","category":"page"},{"location":"api/#Comrade.site_tuple","page":"Comrade API","title":"Comrade.site_tuple","text":"site_tuple(sites, default; reference=nothing kwargs...)\nsite_tuple(obs::AbstractObservationTable, default; reference=nothing, kwargs...)\nsite_tuple(obs::AbstractArrayConfiguration, default; reference=nothing, kwargs...)\n\nConvienence function that will construct a NamedTuple of objects whose names are the sites in the observation obs or explicitly in the argument sites. The NamedTuple will be filled with default if no kwargs are defined otherwise each kwarg (key, value) pair denotes a sites and value pair.\n\nOptionally the user can specify a reference sites that will be dropped from the tuple. This is useful for selecting a reference sites for gain phases\n\nExamples\n\njulia> sites = (:AA, :AP, :LM, :PV)\njulia> site_tuple(sites, ScanSeg())\n(AA = ScanSeg(), AP = ScanSeg(), LM = ScanSeg(), PV = ScanSeg())\njulia> site_tuple(sites, ScanSeg(); AA = FixedSeg(1.0))\n(AA = FixedSeg(1.0), AP = ScanSeg(), LM = ScanSeg(), PV = ScanSeg())\njulia> site_tuple(sites, ScanSeg(); AA = FixedSeg(1.0), PV = TrackSeg())\n(AA = FixedSeg(1.0), AP = ScanSeg(), LM = ScanSeg(), PV = TrackSeg())\njulia> site_tuple(sites, Normal(0.0, 0.1); reference=:AA, LM = Normal(0.0, 1.0))\n(AP = Normal(0.0, 0.1), LM = Normal(0.0, 1.0), PV = Normal(0.0, 0.1))\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.dirty_image","page":"Comrade API","title":"Comrade.dirty_image","text":"dirty_image(fov::Real, npix::Int, obs::EHTObservation{<:EHTVisibilityDatum}) where T\n\nComputes the dirty image of the complex visibilities assuming a field of view of fov and number of pixels npix using the complex visibilities found in the observation obs.\n\nThe dirty image is the inverse Fourier transform of the measured visibilties assuming every other visibility is zero.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.dirty_beam","page":"Comrade API","title":"Comrade.dirty_beam","text":"dirty_beam(fov::Real, npix::Int, obs::EHTObservation{<:EHTVisibilityDatum})\n\nComputes the dirty beam of the complex visibilities assuming a field of view of fov and number of pixels npix using baseline coverage found in obs.\n\nThe dirty beam is the inverse Fourier transform of the (u,v) coverage assuming every visibility is unity and everywhere else is zero.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.beamsize","page":"Comrade API","title":"Comrade.beamsize","text":"beamsize(ac::AbstractArrayConfiguration)\n\nCalculate the approximate beam size of the array ac as the inverse of the longest baseline distance.\n\n\n\n\n\nbeamsize(obs::AbstractObservationTable)\n\nCalculate the approximate beam size of the observation obs as the inverse of the longest baseline distance.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.apply_fluctuations","page":"Comrade API","title":"Comrade.apply_fluctuations","text":"apply_fluctuations(f, mimg::IntensityMap, δ::AbstractArray)\n\nApply multiplicative fluctuations to an image mimg with fluctuations δ. The function f is applied to the fluctuations and then the the transfored δ are multiplicatively applied to the image.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.rmap","page":"Comrade API","title":"Comrade.rmap","text":"rmap(f, x::PosteriorSamples)\n\nRecursively map a function f over the elements of x. For instance to compute the mean of all fields you can do Comrade.rmap(mean, chain)\n\n\n\n\n\n","category":"function"},{"location":"api/#Internal-(Not-Public-API)","page":"Comrade API","title":"Internal (Not Public API)","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Comrade.build_datum\nComrade.ObservedSkyModel","category":"page"},{"location":"api/#Comrade.build_datum","page":"Comrade API","title":"Comrade.build_datum","text":"build_datum(data::AbstractObservationTable, i::Int)\n\nBuild the datum F for a given observation table data. This is an internal method that users shouldn't have to deal with directly unless they are implementing a new AbstractObservationTable.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.ObservedSkyModel","page":"Comrade API","title":"Comrade.ObservedSkyModel","text":"ObservedSkyModel(sky::AbstractSkyModel, array::AbstractArrayConfiguration)\n\nConstructs a sky model that has been theoretically observed by an array with configuration array. Note that this is not a public facing method and is used internally to construct the observed sky model for use in VLBIPosterior. Users should construct a SkyModel and pass that to a VLBIPosterior object instead.\n\n\n\n\n\n","category":"type"},{"location":"api/#eht-imaging-interface-(Internal)","page":"Comrade API","title":"eht-imaging interface (Internal)","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Comrade.extract_amp\nComrade.extract_cphase\nComrade.extract_lcamp\nComrade.extract_vis\nComrade.extract_coherency","category":"page"},{"location":"api/#Comrade.extract_amp","page":"Comrade API","title":"Comrade.extract_amp","text":"extract_amp(obs; kwargs...)\n\nExtracts the visibility amplitudes from an obs. This is an internal method for dispatch. Only use this if interfacing Comrade with a new data type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.extract_cphase","page":"Comrade API","title":"Comrade.extract_cphase","text":"extract_cphase(obs; kwargs...)\n\nExtracts the closure phases from an obs. This is an internal method for dispatch. Only use this if interfacing Comrade with a new data type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.extract_lcamp","page":"Comrade API","title":"Comrade.extract_lcamp","text":"extract_lcamp(obs; kwargs...)\n\nExtracts the log-closure amplitudes from an obs. This is an internal method for dispatch. Only use this if interfacing Comrade with a new data type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.extract_vis","page":"Comrade API","title":"Comrade.extract_vis","text":"extract_vis(obs; kwargs...)\n\nExtracts the stokes I complex visibilities from an obs. This is an internal method for dispatch. Only use this if interfacing Comrade with a new data type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.extract_coherency","page":"Comrade API","title":"Comrade.extract_coherency","text":"extract_coherency(obs; kwargs...)\n\nExtracts the full coherency matrix from an observation. This is an internal method for dispatch. Only use this if interfacing Comrade with a new data type.\n\n\n\n\n\n","category":"function"},{"location":"conventions/#Conventions","page":"Conventions","title":"Conventions","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"VLBI and radio astronomy has many non-standard conventions when coming from physics. Additionally, these conventions change from telescope to telescope, often making it difficult  to know what assumptions different data sets and codes are making. We will detail the  specific conventions that Comrade adheres to.","category":"page"},{"location":"conventions/#Rotation-Convention","page":"Conventions","title":"Rotation Convention","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"We follow the standard EHT and rotate starting from the upper y-axis and moving in a counter-clockwise direction. ","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"note: Note\nWe still use the standard astronomy definition where the positive x-axis is to the left.","category":"page"},{"location":"conventions/#Fourier-Transform-Convention","page":"Conventions","title":"Fourier Transform Convention","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"We use the positive exponent definition of the Fourier transform to define our visibilities. That is, we assume that the visibilities measured by a perfect interferometer are given by","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":" V(u v) = int I(x y)e^2pi i(ux + vy)dx dy","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"This convention is consistent with the AIPS convention and what is used in other EHT codes, such as eht-imaging. ","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"warning: Warning\nThis is the opposite convention of what is written in the EHT papers, but it is the correct version for the released data.","category":"page"},{"location":"conventions/#Coherency-matrix-Convention","page":"Conventions","title":"Coherency matrix Convention","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"We use the factor of 2 definition when defining the coherency matrices. That is, the relation coherency matrix C is given by","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"  C_pq = \n  2beginpmatrix\n    leftv_pa v_qa^*right  left v_pav_qb^*right \n    leftv_pb v_qa^*right  left v_pbv_qb^*right \n  endpmatrix","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"where v_pa is the voltage measured from sites p and feed a.","category":"page"},{"location":"conventions/#Circular-Polarization-Conversions","page":"Conventions","title":"Circular Polarization Conversions","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"To convert from measured RL circular cross-correlation products to the Fourier transform of the Stokes parameters, we use:","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"  beginpmatrix\n      tildeI tildeQ  tildeU  tildeV\n  endpmatrix\n  =frac12\n  beginpmatrix\n     leftRR^*right + leftLL^*right \n     leftRL^*right + leftLR^*right \n     i(leftLR^*right - leftRL^*right)\n     leftRR^*right - leftLL^*right\n  endpmatrix","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"where e.g., leftRL^*right = 2leftv_pRv^*_pLright.","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"The inverse transformation is then:","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"  C = \n  beginpmatrix\n     tildeI + tildeV   tildeQ + itildeU\n     tildeQ - itildeU  tildeI - tildeV\n  endpmatrix","category":"page"},{"location":"conventions/#Linear-Polarization-Conversions","page":"Conventions","title":"Linear Polarization Conversions","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"To convert from measured XY linear cross-correlation products to the Fourier transform of the Stokes parameters, we use:","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"  beginpmatrix\n      tildeI tildeQ  tildeU  tildeV\n  endpmatrix\n  =frac12\n  beginpmatrix\n     leftXX^*right + leftYY^*right \n     leftXY^*right + leftYX^*right \n     i(leftYX^*right - leftXY^*right)\n     leftXX^*right - leftYY^*right\n  endpmatrix","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"The inverse transformation is then:","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"  C = \n  beginpmatrix\n     tildeI + tildeQ   tildeU + itildeV\n     tildeU - itildeV  tildeI - tildeQ\n  endpmatrix","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"where e.g., leftXY^*right = 2leftv_pXv^*_pYright.","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"EditURL = \"../../../examples/HybridImaging/main.jl\"","category":"page"},{"location":"tutorials/HybridImaging/#Hybrid-Imaging-of-a-Black-Hole","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"","category":"section"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"In this tutorial, we will use hybrid imaging to analyze the 2017 EHT data. By hybrid imaging, we mean decomposing the model into simple geometric models, e.g., rings and such, plus a rasterized image model to soak up the additional structure. This approach was first developed in BB20 and applied to EHT 2017 data. We will use a similar model in this tutorial.","category":"page"},{"location":"tutorials/HybridImaging/#Introduction-to-Hybrid-modeling-and-imaging","page":"Hybrid Imaging of a Black Hole","title":"Introduction to Hybrid modeling and imaging","text":"","category":"section"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"The benefit of using a hybrid-based modeling approach is the effective compression of information/parameters when fitting the data. Hybrid modeling requires the user to incorporate specific knowledge of how you expect the source to look like. For instance for M87, we expect the image to be dominated by a ring-like structure. Therefore, instead of using a high-dimensional raster to recover the ring, we can use a ring model plus a raster to soak up the additional degrees of freedom. This is the approach we will take in this tutorial to analyze the April 6 2017 EHT data of M87.","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"import Pkg #hide\n__DIR = \"/home/runner/work/Comrade.jl/Comrade.jl/docs/../examples/HybridImaging\" #hide\npkg_io = open(joinpath(__DIR, \"pkg.log\"), \"w\") #hide\nPkg.activate(__DIR; io=pkg_io) #hide\nPkg.develop(; path=joinpath(__DIR, \"..\", \"..\"), io=pkg_io) #hide\nPkg.instantiate(; io=pkg_io) #hide\nPkg.precompile(; io=pkg_io) #hide\nclose(pkg_io) #hide\n\nENV[\"GKSwstype\"] = \"nul\" #hide","category":"page"},{"location":"tutorials/HybridImaging/#Loading-the-Data","page":"Hybrid Imaging of a Black Hole","title":"Loading the Data","text":"","category":"section"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"To get started we will load Comrade","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"using Comrade","category":"page"},{"location":"tutorials/HybridImaging/#Load-the-Data","page":"Hybrid Imaging of a Black Hole","title":"Load the Data","text":"","category":"section"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"using Pyehtim","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"For reproducibility we use a stable random number genreator","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"using StableRNGs\nrng = StableRNG(42)","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"To download the data visit https://doi.org/10.25739/g85n-f134 To load the eht-imaging obsdata object we do:","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"obs = ehtim.obsdata.load_uvfits(joinpath(__DIR, \"../Data/SR1_M87_2017_096_lo_hops_netcal_StokesI.uvfits\"))","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"Now we do some minor preprocessing:","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"Scan average the data since the data have been preprocessed so that the gain phases  coherent.","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"obs = scan_average(obs).add_fractional_noise(0.02)","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"For this tutorial we will once again fit complex visibilities since they provide the most information once the telescope/instrument model are taken into account.","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"dvis  = extract_table(obs, Visibilities())","category":"page"},{"location":"tutorials/HybridImaging/#Building-the-Model/Posterior","page":"Hybrid Imaging of a Black Hole","title":"Building the Model/Posterior","text":"","category":"section"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"Now we build our intensity/visibility model. That is, the model that takes in a named tuple of parameters and perhaps some metadata required to construct the model. For our model, we will use a raster or ContinuousImage model, an m-ring model, and a large asymmetric Gaussian component to model the unresolved short-baseline flux.","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"function sky(θ, metadata)\n    (;c, σimg, f, r, σ, τ, ξτ, ma, mp, fg) = θ\n    (;ftot, grid) = metadata\n    # Form the image model\n    # First transform to simplex space first applying the non-centered transform\n    rast = (ftot*f*(1-fg)).*to_simplex(CenteredLR(), σimg.*c)\n    mimg = ContinuousImage(rast, grid, BSplinePulse{3}())\n    # Form the ring model\n    α = ma.*cos.(mp .- ξτ)\n    β = ma.*sin.(mp .- ξτ)\n    ring = smoothed(modify(MRing(α, β), Stretch(r, r*(1+τ)), Rotate(ξτ), Renormalize((ftot*(1-f)*(1-fg)))), σ)\n    gauss = modify(Gaussian(), Stretch(μas2rad(250.0)), Renormalize(ftot*f*fg))\n    # We group the geometric models together for improved efficiency. This will be\n    # automated in future versions.\n    return mimg + (ring + gauss)\nend","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"Unlike other imaging examples (e.g., Imaging a Black Hole using only Closure Quantities) we also need to include a model for the instrument, i.e., gains as well. The gains will be broken into two components","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"Gain amplitudes which are typically known to 10-20%, except for LMT, which has amplitudes closer to 50-100%.\nGain phases which are more difficult to constrain and can shift rapidly.","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"using VLBIImagePriors\nusing Distributions, DistributionsAD\nG = SingleStokesGain() do x\n    lg = x.lg\n    gp = x.gp\n    return exp(lg + 1im*gp)\nend\n\nintpr = (\n    lg= ArrayPrior(IIDSitePrior(ScanSeg(), Normal(0.0, 0.2)); LM = IIDSitePrior(ScanSeg(), Normal(0.0, 1.0))),\n    gp= ArrayPrior(IIDSitePrior(ScanSeg(), DiagonalVonMises(0.0, inv(π^2))); refant=SEFDReference(0.0))\n        )\nintmodel = InstrumentModel(G, intpr)","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"Before we move on, let's go into the model function a bit. This function takes two arguments θ and metadata. The θ argument is a named tuple of parameters that are fit to the data. The metadata argument is all the ancillary information we need to construct the model. For our hybrid model, we will need two variables for the metadata, a grid that specifies the locations of the image pixels and a cache that defines the algorithm used to calculate the visibilities given the image model. This is required since ContinuousImage is most easily computed using number Fourier transforms like the NFFT or FFT. To combine the models, we use Comrade's overloaded + operators, which will combine the images such that their intensities and visibilities are added pointwise.","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"Now let's define our metadata. First we will define the cache for the image. This is required to compute the numerical Fourier transform.","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"fovxy  = μas2rad(200.0)\nnpix   = 32\ng      = imagepixels(fovxy, fovxy, npix, npix)","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"Part of hybrid imaging is to force a scale separation between the different model components to make them identifiable. To enforce this we will set the length scale of the raster component equal to the beam size of the telescope in units of pixel length, which is given by","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"beam = beamsize(dvis)\nrat = (beam/(step(g.X)))\ncprior = GaussMarkovRandomField(rat, size(g); order=2)","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"additionlly we will fix the standard deviation of the field to unity and instead use a pseudo non-centered parameterization for the field. GaussMarkovRandomField(meanpr, 0.1*rat, 1.0, crcache)","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"Finally we can put form the total model prior","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"skyprior = (\n    # We use a strong smoothing prior since we want to limit the amount of high-frequency structure in the raster.\n          c  = cprior,\n          σimg = truncated(Normal(0.0, 1.0); lower=0.01),\n          f  = Uniform(0.0, 1.0),\n          r  = Uniform(μas2rad(10.0), μas2rad(30.0)),\n          σ  = Uniform(μas2rad(0.1), μas2rad(10.0)),\n          τ  = truncated(Normal(0.0, 0.1); lower=0.0, upper=1.0),\n          ξτ = Uniform(-π/2, π/2),\n          ma = ntuple(_->Uniform(0.0, 0.5), 2),\n          mp = ntuple(_->Uniform(0.0, 2π), 2),\n          fg = Uniform(0.0, 1.0),\n        )","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"Now we form the metadata","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"skymetadata = (;ftot=1.1, grid = g)\nskym = SkyModel(sky, skyprior, g; metadata=skymetadata)","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"This is everything we need to specify our posterior distribution, which our is the main object of interest in image reconstructions when using Bayesian inference.","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"post = VLBIPosterior(skym, intmodel, dvis)","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"To sample from our prior we can do","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"xrand = prior_sample(rng, post)","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"and then plot the results","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"using DisplayAs #hide\nimport CairoMakie as CM\nCM.activate!(type = \"png\", px_per_unit=1) #hide\ngpl = imagepixels(μas2rad(200.0), μas2rad(200.0), 128, 128)\nfig = imageviz(intensitymap(skymodel(post, xrand), gpl), size=(400, 400));\nDisplayAs.Text(DisplayAs.PNG(fig)) #hide","category":"page"},{"location":"tutorials/HybridImaging/#Reconstructing-the-Image","page":"Hybrid Imaging of a Black Hole","title":"Reconstructing the Image","text":"","category":"section"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"To find the image we will demonstrate two methods:","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"Optimization to find the MAP (fast but often a poor estimator)\nSampling to find the posterior (slow but provides a substantially better estimator)","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"For optimization we will use the Optimization.jl package and the LBFGS optimizer. To use this we use the comrade_opt function","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"using Optimization\nusing OptimizationOptimJL\nusing Zygote\nxopt, sol = comrade_opt(post, LBFGS(), Optimization.AutoZygote(); initial_params=prior_sample(rng, post), maxiters=1000, g_tol=1e0)","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"First we will evaluate our fit by plotting the residuals","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"using Plots\nfig = residual(post, xopt);\nDisplayAs.Text(DisplayAs.PNG(fig)) #hide","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"These residuals suggest that we are substantially overfitting the data. This is a common side effect of MAP imaging. As a result if we plot the image we see that there is substantial high-frequency structure in the image that isn't supported by the data.","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"imageviz(intensitymap(skymodel(post, xopt), gpl), figure=(;resolution=(500, 400),))","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"To improve our results we will now move to Posterior sampling. This is the main method we recommend for all inference problems in Comrade. While it is slower the results are often substantially better. To sample we will use the AdvancedHMC package.","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"using AdvancedHMC\nchain = sample(rng, post, NUTS(0.8), 700; n_adapts=500, progress=false, initial_params=xopt);\nnothing #hide","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"We then remove the adaptation/warmup phase from our chain","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"chain = chain[501:end]","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"warning: Warning\nThis should be run for 4-5x more steps to properly estimate expectations of the posterior","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"Now lets plot the mean image and standard deviation images. To do this we first clip the first 250 MCMC steps since that is during tuning and so the posterior is not sampling from the correct sitesary distribution.","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"using StatsBase\nmsamples = skymodel.(Ref(post), chain[begin:2:end]);\nnothing #hide","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"The mean image is then given by","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"imgs = intensitymap.(msamples, Ref(gpl))\nfig = imageviz(mean(imgs), colormap=:afmhot, size=(400, 300));\nDisplayAs.Text(DisplayAs.PNG(fig)) #hide","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"fig = imageviz(std(imgs), colormap=:batlow, size=(400, 300));\nDisplayAs.Text(DisplayAs.PNG(fig)) #hide","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"We can also split up the model into its components and analyze each separately","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"comp = Comrade.components.(msamples)\nring_samples = getindex.(comp, 2)\nrast_samples = first.(comp)\nring_imgs = intensitymap.(ring_samples, Ref(gpl));\nrast_imgs = intensitymap.(rast_samples, Ref(gpl));\n\nring_mean, ring_std = mean_and_std(ring_imgs);\nrast_mean, rast_std = mean_and_std(rast_imgs);\n\nfig = CM.Figure(; resolution=(400, 400));\naxes = [CM.Axis(fig[i, j], xreversed=true, aspect=CM.DataAspect()) for i in 1:2, j in 1:2]\nCM.image!(axes[1,1], ring_mean, colormap=:afmhot); axes[1,1].title = \"Ring Mean\"\nCM.image!(axes[1,2], ring_std, colormap=:afmhot); axes[1,2].title = \"Ring Std. Dev.\"\nCM.image!(axes[2,1], rast_mean, colormap=:afmhot); axes[2,1].title = \"Rast Mean\"\nCM.image!(axes[2,2], rast_mean./rast_std, colormap=:afmhot, colorrange=(1.5, 3)); axes[2,2].title = \"Rast SNR\"\nCM.hidedecorations!.(axes)\nDisplayAs.Text(DisplayAs.PNG(fig)) #hide","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"Finally, let's take a look at some of the ring parameters","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"figd = CM.Figure(;resolution=(650, 400));\np1 = CM.density(figd[1,1], rad2μas(chain.sky.r)*2, axis=(xlabel=\"Ring Diameter (μas)\",))\np2 = CM.density(figd[1,2], rad2μas(chain.sky.σ)*2*sqrt(2*log(2)), axis=(xlabel=\"Ring FWHM (μas)\",))\np3 = CM.density(figd[1,3], -rad2deg.(chain.sky.mp.:1) .+ 360.0, axis=(xlabel = \"Ring PA (deg) E of N\",))\np4 = CM.density(figd[2,1], 2*chain.sky.ma.:2, axis=(xlabel=\"Brightness asymmetry\",))\np5 = CM.density(figd[2,2], 1 .- chain.sky.f, axis=(xlabel=\"Ring flux fraction\",))\nDisplayAs.Text(DisplayAs.PNG(figd)) #hide","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"Now let's check the residuals using draws from the posterior","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"p = Plots.plot();\nfor s in sample(chain, 10)\n    residual!(p, post, s, legend=false)\nend\nDisplayAs.Text(DisplayAs.PNG(p)) #hide","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"And everything looks pretty good! Now comes the hard part: interpreting the results...","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"","category":"page"},{"location":"tutorials/HybridImaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"This page was generated using Literate.jl.","category":"page"},{"location":"ext/ahmc/#AdvancedHMC-Extension","page":"AdvancedHMC Extension","title":"AdvancedHMC Extension","text":"","category":"section"},{"location":"ext/ahmc/","page":"AdvancedHMC Extension","title":"AdvancedHMC Extension","text":"The first choice when sampling from the model/image posterior,  is AdvancedHMC, which uses Hamiltonian Monte Carlo to sample from the posterior. Specifically, we usually use the NUTS algorithm.","category":"page"},{"location":"ext/ahmc/","page":"AdvancedHMC Extension","title":"AdvancedHMC Extension","text":"The interface to AdvancedHMC is very powerful and general. To simplify  the procedure for Comrade users, we have provided a thin interface.  A user needs to specify a sampler and then call  the sample function.","category":"page"},{"location":"ext/ahmc/","page":"AdvancedHMC Extension","title":"AdvancedHMC Extension","text":"To sample a user can use follow the standard AdvancedHMC interface, e.g.,","category":"page"},{"location":"ext/ahmc/","page":"AdvancedHMC Extension","title":"AdvancedHMC Extension","text":"chain = sample(post, NUTS(0.8), 10_000; n_adapts=5_000)","category":"page"},{"location":"ext/ahmc/","page":"AdvancedHMC Extension","title":"AdvancedHMC Extension","text":"In addition our sample call has a few additional keyword arguments:","category":"page"},{"location":"ext/ahmc/","page":"AdvancedHMC Extension","title":"AdvancedHMC Extension","text":"adtype = Val(:Zygote): The autodiff package to use. Currently the default is Zygote and we recommend using this. Note that you must load Zygote before calling sample.\nsaveto = MemoryStore(): Specifies how to store the samples. The default is MemoryStore which stores the samples directly in RAM. For large models this is not a good idea. To save samples periodically to disk use DiskStore, and then load the results with load_samples.","category":"page"},{"location":"ext/ahmc/","page":"AdvancedHMC Extension","title":"AdvancedHMC Extension","text":"Note that like most AbstractMCMC samplers the initial location can be specified with the initial_params argument.","category":"page"},{"location":"ext/ahmc/#Example","page":"AdvancedHMC Extension","title":"Example","text":"","category":"section"},{"location":"ext/ahmc/","page":"AdvancedHMC Extension","title":"AdvancedHMC Extension","text":"using Comrade\nusing AdvancedHMC\nusing Zygote\n\n# Some stuff to create a posterior object\npost # of type Comrade.Posterior\n\nout = sample(post, NUTS(0.9), 2_000; n_adapts=1_000, saveto=DiskStore())\nchain = load_samples(out)","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"EditURL = \"../../../examples/ClosureImaging/main.jl\"","category":"page"},{"location":"tutorials/ClosureImaging/#Imaging-a-Black-Hole-using-only-Closure-Quantities","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"","category":"section"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"In this tutorial, we will create a preliminary reconstruction of the 2017 M87 data on April 6 using closure-only imaging. This tutorial is a general introduction to closure-only imaging in Comrade. For an introduction to simultaneous image and instrument modeling, see Stokes I Simultaneous Image and Instrument Modeling","category":"page"},{"location":"tutorials/ClosureImaging/#Introduction-to-Closure-Imaging","page":"Imaging a Black Hole using only Closure Quantities","title":"Introduction to Closure Imaging","text":"","category":"section"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"The EHT is one of the highest-resolution telescope ever created. Its resolution is equivalent to roughly tracking a hockey puck on the moon when viewing it from the earth. However, the EHT is also a unique interferometer. First, EHT data is incredibly sparse, the array is formed from only eight geographic locations around the planet. Second, the obseving frequency is much higher than traditional VLBI. Lastly, each site in the array is unique. They have different dishes, recievers, feeds, and electronics. Putting this all together implies that many of the common imaging techniques struggle to fit the EHT data and explore the uncertainty in both the image and instrument. One way to deal with some of these uncertainties is to not directly fit the data but instead fit closure quantities, which are independent of many of the instrumental effects that plague the data. The types of closure quantities are briefly described in Introduction to the VLBI Imaging Problem.","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"In this tutorial, we will do closure-only modeling of M87 to produce a posterior of images of M87.","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"import Pkg #hide\n__DIR = \"/home/runner/work/Comrade.jl/Comrade.jl/docs/../examples/ClosureImaging\" #hide\npkg_io = open(joinpath(__DIR, \"pkg.log\"), \"w\") #hide\nPkg.activate(__DIR; io=pkg_io) #hide\nPkg.develop(; path=joinpath(__DIR, \"..\", \"..\"), io=pkg_io) #hide\nPkg.instantiate(; io=pkg_io) #hide\nPkg.precompile(; io=pkg_io) #hide\nclose(pkg_io) #hide\nENV[\"GKSwstype\"] = \"nul\"; #hide\nnothing #hide","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"To get started, we will load Comrade","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"using Comrade","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"Pyehtim loads eht-imaging using PythonCall this is necessary to load uvfits files currently.","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"using Pyehtim","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"For reproducibility we use a stable random number genreator","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"using StableRNGs\nrng = StableRNG(123)","category":"page"},{"location":"tutorials/ClosureImaging/#Load-the-Data","page":"Imaging a Black Hole using only Closure Quantities","title":"Load the Data","text":"","category":"section"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"To download the data visit https://doi.org/10.25739/g85n-f134 To load the eht-imaging obsdata object we do:","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"obs = ehtim.obsdata.load_uvfits(joinpath(__DIR, \"../Data/SR1_M87_2017_096_lo_hops_netcal_StokesI.uvfits\"))","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"Now we do some minor preprocessing:","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"Scan average the data since the data have been preprocessed so that the gain phases  are coherent.\nAdd 2% systematic noise to deal with calibration issues such as leakage.","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"obs = scan_average(obs).add_fractional_noise(0.02)","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"Now, we extract our closure quantities from the EHT data set. We flag now SNR points since the closure likelihood we use is only applicable to high SNR data.","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"dlcamp, dcphase  = extract_table(obs, LogClosureAmplitudes(;snrcut=3), ClosurePhases(;snrcut=3))","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"note: Note\nFitting low SNR closure data is complicated and requires a more sophisticated likelihood. If low-SNR data is very important we recommend fitting visibilties with a instrumental model.","category":"page"},{"location":"tutorials/ClosureImaging/#Build-the-Model/Posterior","page":"Imaging a Black Hole using only Closure Quantities","title":"Build the Model/Posterior","text":"","category":"section"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"For our model, we will be using an image model that consists of a raster of point sources, convolved with some pulse or kernel to make a ContinuousImage. To define this model we define the standard two argument function sky that defines the sky model we want to fit. The first argument are the model parameters, and are typically a NamedTuple. The second argument defines the metadata for the model that is typically constant. For our model the constant metdata will just by the mean or prior image.","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"function sky(θ, metadata)\n    (;fg, c, σimg) = θ\n    (;mimg) = metadata\n    # Apply the GMRF fluctuations to the image\n    rast = apply_fluctuations(CenteredLR(), mimg, σimg.*c.params)\n    m = ContinuousImage(((1-fg)).*rast, BSplinePulse{3}())\n    # Force the image centroid to be at the origin\n    x0, y0 = centroid(m)\n    # Add a large-scale gaussian to deal with the over-resolved mas flux\n    g = modify(Gaussian(), Stretch(μas2rad(250.0), μas2rad(250.0)), Renormalize(fg))\n    return shifted(m, -x0, -y0) + g\nend","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"Now, let's set up our image model. The EHT's nominal resolution is 20-25 μas. Additionally, the EHT is not very sensitive to a larger field of views; typically, 60-80 μas is enough to describe the compact flux of M87. Given this, we only need to use a small number of pixels to describe our image.","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"npix = 32\nfovxy = μas2rad(150.0)","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"To define the image model we need to specify both the grid we will be using and the FT algorithm we will use, in this case the NFFT which is the most efficient.","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"grid = imagepixels(fovxy, fovxy, npix, npix)","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"Now we need to specify our image prior. For this work we will use a Gaussian Markov Random field prior","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"using VLBIImagePriors, Distributions, DistributionsAD","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"Since we are using a Gaussian Markov random field prior we need to first specify our mean image. For this work we will use a symmetric Gaussian with a FWHM of 50 μas","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"fwhmfac = 2*sqrt(2*log(2))\nmpr = modify(Gaussian(), Stretch(μas2rad(50.0)./fwhmfac))\nimgpr = intensitymap(mpr, grid)\nskymeta = (;mimg = imgpr./flux(imgpr));\nnothing #hide","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"In addition we want a reasonable guess for what the resolution of our image should be. For radio astronomy this is given by roughly the longest baseline in the image. To put this into pixel space we then divide by the pixel size.","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"beam = beamsize(dlcamp)\nrat = (beam/(step(grid.X)))","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"To make the Gaussian Markov random field efficient we first precompute a bunch of quantities that allow us to scale things linearly with the number of image pixels. This drastically improves the usual N^3 scaling you get from usual Gaussian Processes.","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"crcache = ConditionalMarkov(GMRF, grid; order=1)","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"Now we can finally form our image prior. For this we use a heirarchical prior where the correlation length is given by a inverse gamma prior to prevent overfitting. Gaussian Markov random fields are extremly flexible models. To prevent overfitting it is common to use priors that penalize complexity. Therefore, we want to use priors that enforce similarity to our mean image, and prefer smoothness.","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"cprior = HierarchicalPrior(crcache, truncated(InverseGamma(1.0, -log(0.1)*rat); upper=2*npix))\nprior = (c = cprior, σimg = Exponential(0.5), fg=Uniform(0.0, 1.0))","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"Putting this all together we can define our sky model.","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"skym = SkyModel(sky, prior, grid; metadata=skymeta)","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"Since we are fitting closures we do not need to include an instrument model, since the closure likelihood is approximately independent of gains in the high SNR limit.","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"post = VLBIPosterior(skym, dlcamp, dcphase)","category":"page"},{"location":"tutorials/ClosureImaging/#Reconstructing-the-Image","page":"Imaging a Black Hole using only Closure Quantities","title":"Reconstructing the Image","text":"","category":"section"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"To reconstruct the image we will first use the MAP estimate. This is approach is basically a re-implentation of regularized maximum likelihood (RML) imaging. However, unlike traditional RML imaging we also fit the regularizer hyperparameters, thanks to our interpretation of as our imaging prior as a hierarchical model.","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"To optimize our posterior Comrade provides the comrade_opt function. To use this functionality a user first needs to import Optimization.jl and the optimizer of choice. In this tutorial we will use Optim.jl's L-BFGS optimizer, which is defined in the sub-package OptimizationOptimJL. We also need to import Zygote to allow for automatic differentiation.","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"using Optimization\nusing OptimizationOptimJL\nusing Zygote\nxopt, sol = comrade_opt(post, LBFGS(), Optimization.AutoZygote(); initial_params=prior_sample(rng, post), maxiters=1000)","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"First we will evaluate our fit by plotting the residuals","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"using DisplayAs #hide\nusing Plots\np = residual(post, xopt)\nDisplayAs.Text(DisplayAs.PNG(p)) #hide","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"Now let's plot the MAP estimate.","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"import CairoMakie as CM\nCM.activate!(type = \"png\", px_per_unit=1) #hide\ng = imagepixels(μas2rad(150.0), μas2rad(150.0), 100, 100)\nimg = intensitymap(skymodel(post, xopt), g)\nfig = imageviz(img, size=(600, 500));\nDisplayAs.Text(DisplayAs.PNG(fig)) #hide","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"That doesn't look great. This is pretty common for the sparse EHT data. In this case the MAP often drastically overfits the data, producing a image filled with artifacts. In addition, we note that the MAP itself is not invariant to the model parameterization. Namely, if we changed our prior to use a fully centered parameterization we would get a very different image. Fortunately, these issues go away when we sample from the posterior, and construct expectations of the posterior, like the mean image.","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"To sample from the posterior we will use HMC and more specifically the NUTS algorithm. For information about NUTS see Michael Betancourt's notes.","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"note: Note\nFor our metric we use a diagonal matrix due to easier tuning.","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"using AdvancedHMC\nusing Zygote\nchain = sample(post, NUTS(0.8), 700; n_adapts=500, progress=false, initial_params=xopt);\nnothing #hide","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"warning: Warning\nThis should be run for longer!","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"Now that we have our posterior, we can assess which parts of the image are strongly inferred by the data. This is rather unique to Comrade where more traditional imaging algorithms like CLEAN and RML are inherently unable to assess uncertainty in their reconstructions.","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"To explore our posterior let's first create images from a bunch of draws from the posterior","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"msamples = skymodel.(Ref(post), chain[501:2:end]);\nnothing #hide","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"The mean image is then given by","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"using StatsBase\nimgs = intensitymap.(msamples, Ref(g))\nmimg = mean(imgs)\nsimg = std(imgs)\nfig = CM.Figure(;resolution=(700, 700));\nCM.image(fig[1,1], mimg,\n                   axis=(xreversed=true, aspect=1, title=\"Mean Image\"),\n                   colormap=:afmhot);\nCM.image(fig[1,2], simg./(max.(mimg, 1e-8)),\n                   axis=(xreversed=true, aspect=1, title=\"1/SNR\",), colorrange=(0.0, 2.0),\n                   colormap=:afmhot);\nCM.image(fig[2,1], imgs[1],\n                   axis=(xreversed=true, aspect=1,title=\"Draw 1\"),\n                   colormap=:afmhot);\nCM.image(fig[2,2], imgs[end],\n                   axis=(xreversed=true, aspect=1,title=\"Draw 2\"),\n                   colormap=:afmhot);\nCM.hidedecorations!.(fig.content)\nDisplayAs.Text(DisplayAs.PNG(fig)) #hide","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"Now let's see whether our residuals look better.","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"p = Plots.plot(layout=(2,1));\nfor s in sample(chain[501:end], 10)\n    residual!(post, s)\nend\np","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"And viola, you have a quick and preliminary image of M87 fitting only closure products. For a publication-level version we would recommend","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"Running the chain longer and multiple times to properly assess things like ESS and R̂ (see Geometric Modeling of EHT Data)\nFitting gains. Typically gain amplitudes are good to 10-20% for the EHT not the infinite uncertainty closures implicitly assume","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"","category":"page"},{"location":"tutorials/ClosureImaging/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"EditURL = \"../../../examples/GeometricModeling/main.jl\"","category":"page"},{"location":"tutorials/GeometricModeling/#Geometric-Modeling-of-EHT-Data","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"","category":"section"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"Comrade has been designed to work with the EHT and ngEHT. In this tutorial, we will show how to reproduce some of the results from EHTC VI 2019.","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"In EHTC VI, they considered fitting simple geometric models to the data to estimate the black hole's image size, shape, brightness profile, etc. In this tutorial, we will construct a similar model and fit it to the data in under 50 lines of code (sans comments). To start, we load Comrade and some other packages we need.","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"import Pkg #hide\n__DIR = \"/home/runner/work/Comrade.jl/Comrade.jl/docs/../examples/GeometricModeling\" #hide\npkg_io = open(joinpath(__DIR, \"pkg.log\"), \"w\") #hide\nPkg.activate(__DIR; io=pkg_io) #hide\nPkg.develop(; path=joinpath(__DIR, \"..\", \"..\"), io=pkg_io) #hide\nPkg.instantiate(; io=pkg_io) #hide\nPkg.precompile(; io=pkg_io) #hide\nclose(pkg_io) #hide\nENV[\"GKSwstype\"] = \"nul\" #hide\n\n\nusing Comrade\n\n\nusing Pyehtim","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"For reproducibility we use a stable random number genreator","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"using StableRNGs\nrng = StableRNG(42)","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"The next step is to load the data. We will use the publically available M 87 data which can be downloaded from cyverse. For an introduction to data loading, see Loading Data into Comrade.","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"obs = ehtim.obsdata.load_uvfits(joinpath(__DIR, \"../Data/SR1_M87_2017_096_lo_hops_netcal_StokesI.uvfits\"))","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"Now we will kill 0-baselines since we don't care about large-scale flux and since we know that the gains in this dataset are coherent across a scan, we make scan-average data","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"obs = Pyehtim.scan_average(obs.flag_uvdist(uv_min=0.1e9)).add_fractional_noise(0.02)","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"Now we extract the data products we want to fit","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"dlcamp, dcphase = extract_table(obs, LogClosureAmplitudes(;snrcut=3.0), ClosurePhases(;snrcut=3.0))","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"!!!warn    We remove the low-snr closures since they are very non-gaussian. This can create rather    large biases in the model fitting since the likelihood has much heavier tails that the    usual Gaussian approximation.","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"For the image model, we will use a modified MRing, a infinitely thin delta ring with an azimuthal structure given by a Fourier expansion. To give the MRing some width, we will convolve the ring with a Gaussian and add an additional gaussian to the image to model any non-ring flux. Comrade expects that any model function must accept a named tuple and returns  must always return an object that implements the VLBISkyModels Interface","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"function model(θ, p)\n    (;radius, width, ma, mp, τ, ξτ, f, σG, τG, ξG, xG, yG) = θ\n    α = ma.*cos.(mp .- ξτ)\n    β = ma.*sin.(mp .- ξτ)\n    ring = f*smoothed(modify(MRing(α, β), Stretch(radius, radius*(1+τ)), Rotate(ξτ)), width)\n    g = (1-f)*shifted(rotated(stretched(Gaussian(), σG, σG*(1+τG)), ξG), xG, yG)\n    return ring + g\nend","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"To construct our likelihood p(V|M) where V is our data and M is our model, we use the RadioLikelihood function. The first argument of RadioLikelihood is always a function that constructs our Comrade model from the set of parameters θ.","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"We now need to specify the priors for our model. The easiest way to do this is to specify a NamedTuple of distributions:","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"using Distributions, VLBIImagePriors\nprior = (\n          radius = Uniform(μas2rad(10.0), μas2rad(30.0)),\n          width = Uniform(μas2rad(1.0), μas2rad(10.0)),\n          ma = (Uniform(0.0, 0.5), Uniform(0.0, 0.5)),\n          mp = (Uniform(0, 2π), Uniform(0, 2π)),\n          τ = Uniform(0.0, 1.0),\n          ξτ= Uniform(0.0, π),\n          f = Uniform(0.0, 1.0),\n          σG = Uniform(μas2rad(1.0), μas2rad(100.0)),\n          τG = Uniform(0.0, 1.0),\n          ξG = Uniform(0.0, 1π),\n          xG = Uniform(-μas2rad(80.0), μas2rad(80.0)),\n          yG = Uniform(-μas2rad(80.0), μas2rad(80.0))\n        )\n\nskym = SkyModel(model, prior, imagepixels(μas2rad(200.0), μas2rad(200.0), 128, 128))","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"Note that for α and β we use a product distribution to signify that we want to use a multivariate uniform for the mring components α and β. In general the structure of the variables is specified by the prior. Note that this structure must be compatible with the model definition model(θ).","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"To form the posterior we now call","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"post = VLBIPosterior(skym, dlcamp, dcphase)","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"!!!warn    As of Comrade 0.9 we have switched to the proper covariant closure likelihood.    This is slower than the naieve diagonal liklelihood, but takes into account the    correlations between closures that share the same baselines.","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"This constructs a posterior density that can be evaluated by calling logdensityof. For example,","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"logdensityof(post, (sky = (radius = μas2rad(20.0),\n                  width = μas2rad(10.0),\n                  ma = (0.3, 0.3),\n                  mp = (π/2, π),\n                  τ = 0.1,\n                  ξτ= π/2,\n                  f = 0.6,\n                  σG = μas2rad(50.0),\n                  τG = 0.1,\n                  ξG = 0.5,\n                  xG = 0.0,\n                  yG = 0.0),))","category":"page"},{"location":"tutorials/GeometricModeling/#Reconstruction","page":"Geometric Modeling of EHT Data","title":"Reconstruction","text":"","category":"section"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"Now that we have fully specified our model, we now will try to find the optimal reconstruction of our model given our observed data.","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"Currently, post is in parameter space. Often optimization and sampling algorithms want it in some modified space. For example, nested sampling algorithms want the parameters in the unit hypercube. To transform the posterior to the unit hypercube, we can use the ascube function","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"cpost = ascube(post)","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"If we want to flatten the parameter space and move from constrained parameters to (-∞, ∞) support we can use the asflat function","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"fpost = asflat(post)","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"These transformed posterior expect a vector of parameters. That is we can evaluate the transformed log density by calling","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"logdensityof(cpost, rand(rng, dimension(cpost)))\nlogdensityof(fpost, randn(rng, dimension(fpost)))","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"note that cpost logdensity vector expects that each element lives in [0,1].","category":"page"},{"location":"tutorials/GeometricModeling/#Finding-the-Optimal-Image","page":"Geometric Modeling of EHT Data","title":"Finding the Optimal Image","text":"","category":"section"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"Typically, most VLBI modeling codes only care about finding the optimal or best guess image of our posterior post To do this, we will use Optimization.jl and specifically the BlackBoxOptim.jl package. For Comrade, this workflow is we use the comrade_opt function.","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"using Optimization\nusing OptimizationBBO\nxopt, sol = comrade_opt(post, BBO_adaptive_de_rand_1_bin_radiuslimited(); maxiters=50_000);\nnothing #hide","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"Given this we can now plot the optimal image or the maximum a posteriori (MAP) image.","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"using DisplayAs\nimport CairoMakie as CM\nCM.activate!(type = \"png\", px_per_unit=1) #hide\ng = imagepixels(μas2rad(200.0), μas2rad(200.0), 256, 256)\nfig = imageviz(intensitymap(skymodel(post, xopt), g), colormap=:afmhot, size=(500, 400));\nDisplayAs.Text(DisplayAs.PNG(fig))","category":"page"},{"location":"tutorials/GeometricModeling/#Quantifying-the-Uncertainty-of-the-Reconstruction","page":"Geometric Modeling of EHT Data","title":"Quantifying the Uncertainty of the Reconstruction","text":"","category":"section"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"While finding the optimal image is often helpful, in science, the most important thing is to quantify the certainty of our inferences. This is the goal of Comrade. In the language of Bayesian statistics, we want to find a representation of the posterior of possible image reconstructions given our choice of model and the data.","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"Comrade provides several sampling and other posterior approximation tools. To see the list, please see the Libraries section of the docs. For this example, we will be using Pigeons.jl which is a state-of-the-art parallel tempering sampler that enables global exploration of the posterior. For smaller dimension problems (< 100) we recommend using this sampler, especially if you have access to > 1 core.","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"using Pigeons\npt = pigeons(target=cpost, explorer=SliceSampler(), record=[traces, round_trip, log_sum_ratio], n_chains=16, n_rounds=8)","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"That's it! To finish it up we can then plot some simple visual fit diagnostics. First we extract the MCMC chain for our posterior.","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"chain = sample_array(cpost, pt)","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"First to plot the image we call","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"using DisplayAs #hide\nimgs = intensitymap.(skymodel.(Ref(post), sample(chain, 100)), Ref(g))\nfig = imageviz(imgs[end], colormap=:afmhot)\nDisplayAs.Text(DisplayAs.PNG(fig))","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"What about the mean image? Well let's grab 100 images from the chain, where we first remove the adaptation steps since they don't sample from the correct posterior distribution","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"meanimg = mean(imgs)\nfig = imageviz(meanimg, colormap=:afmhot);\nDisplayAs.Text(DisplayAs.PNG(fig))","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"That looks similar to the EHTC VI, and it took us no time at all!. To see how well the model is fitting the data we can plot the model and data products","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"using Plots\np1 = Plots.plot(simulate_observation(post, xopt; add_thermal_noise=false)[1], label=\"MAP\")\nPlots.plot!(p1, dlcamp)\np2 = Plots.plot(simulate_observation(post, xopt; add_thermal_noise=false)[2], label=\"MAP\")\nPlots.plot!(p2, dcphase)\nDisplayAs.Text(DisplayAs.PNG(Plots.plot(p1, p2, layout=(2,1))))","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"We can also plot random draws from the posterior predictive distribution. The posterior predictive distribution create a number of synthetic observations that are marginalized over the posterior.","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"p1 = Plots.plot(dlcamp);\np2 = Plots.plot(dcphase);\nuva = uvdist.(datatable(dlcamp))\nuvp = uvdist.(datatable(dcphase))\nfor i in 1:10\n    mobs = simulate_observation(post, sample(chain, 1)[1])\n    mlca = mobs[1]\n    mcp  = mobs[2]\n    Plots.scatter!(p1, uva, mlca[:measurement], color=:grey, label=:none, alpha=0.2)\n    Plots.scatter!(p2, uvp, atan.(sin.(mcp[:measurement]), cos.(mcp[:measurement])), color=:grey, label=:none, alpha=0.2)\nend\np = Plots.plot(p1, p2, layout=(2,1));\nDisplayAs.Text(DisplayAs.PNG(p))","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"Finally, we can also put everything onto a common scale and plot the normalized residuals. The normalied residuals are the difference between the data and the model, divided by the data's error:","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"p = residual(post, chain[end]);\nDisplayAs.Text(DisplayAs.PNG(p))","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"","category":"page"},{"location":"tutorials/GeometricModeling/","page":"Geometric Modeling of EHT Data","title":"Geometric Modeling of EHT Data","text":"This page was generated using Literate.jl.","category":"page"},{"location":"vlbi_imaging_problem/#Introduction-to-the-VLBI-Imaging-Problem","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"","category":"section"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"Very-long baseline interferometry (VLBI) is capable of taking the highest resolution images in the world, achieving angular resolutions of ~20 μas. In 2019, the first-ever image of a black hole was produced by the Event Horizon Telescope (EHT). However, while the EHT has unprecedented resolution, it is also a sparse interferometer. As a result, the sampling in the uv or Fourier space of the image is incomplete. This incompleteness makes the imaging problem uncertain. Namely, infinitely many images are possible, given the data. Comrade is a imaging/modeling package that aims to quantify this uncertainty using Bayesian inference.","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"If we denote visibilities by V and the image structure/model by I, Comrade will then compute the posterior or the probability of an image given the visibility data or in an equation","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"p(IV) = fracp(VI)p(I)p(V)","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"Here p(VI) is known as the likelihood and describes the probability distribution of the data given some image I. The prior p(I) encodes prior knowledge of the image structure. This prior includes distributions of model parameters and even the model itself. Finally, the denominator p(V) is a normalization term and is known as the marginal likelihood or evidence and can be used to assess how well particular models fit the data.","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"Therefore, we must specify the likelihood and prior to construct our posterior. Below we provide a brief description of the likelihoods and models/priors that Comrade uses. However, if the user wants to see how everything works first, they should check out the ","category":"page"},{"location":"vlbi_imaging_problem/#Likelihood","page":"Introduction to the VLBI Imaging Problem","title":"Likelihood","text":"","category":"section"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"Following TMS[TMS], we note that the likelihood for a single complex visibility at baseline u_ij v_ij is","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"p(V_ij  I) = (2pi sigma^2_ij)^-12expleft(-frac V_ij - g_ig_j^*tildeI_ij(I)^22sigma^2_ijright)","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"In this equation, tildeI is the Fourier transform of the image I, and g_ij are complex numbers known as gains. The gains arise due to atmospheric and telescope effects and corrupt the incoming signal. Therefore, if a user attempts to model the complex visibilities, they must also model the complex gains. An example showing how to model gains in Comrade can be found in ","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"Modeling the gains can be computationally expensive, especially if our image model is simple. For instance, in Comrade, we have a wide variety of geometric models. These models tend to have a small number of parameters and are simple to evaluate. Solving for gains then drastically increases the amount of time it takes to sample the posterior. As a result, part of the typical EHT analysis[M87P6][SgrAP4] instead uses closure products as its data. The two forms of closure products are:","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"Closure Phases,\nLog-Closure Amplitudes.","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"Closure Phases psi are constructed by selecting three baselines (ijk) and finding the argument of the bispectrum:","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"    psi_ijk = arg V_ijV_jkV_ki","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"Similar log-closure amplitudes are found by selecting four baselines (ijkl) and forming the closure amplitudes:","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"    A_ijkl = frac V_ijV_klV_jkV_li","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"Instead of directly fitting closure amplitudes, it turns out that the statistically better-behaved data product is the log-closure amplitude. ","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"The benefit of fitting closure products is that they are independent of complex gains, so we can leave them out when modeling the data. However, the downside is that they effectively put uniform improper priors on the gains[Blackburn], meaning that we often throw away information about the telescope's performance. On the other hand, we can then view closure fitting as a very conservative estimate about what image structures are consistent with the data. Another downside of using closure products is that their likelihoods are complex. In the high-signal-to-noise limit, however, they do reduce to Gaussian likelihoods, and this is the limit we are usually in for the EHT. For the explicit likelihood Comrade uses, we refer the reader to appendix F in paper IV of the first Sgr A* EHT publications[SgrAP4]. The computational implementation of these likelihoods can be found in VLBILikelihoods.jl.","category":"page"},{"location":"vlbi_imaging_problem/#Prior-Model","page":"Introduction to the VLBI Imaging Problem","title":"Prior Model","text":"","category":"section"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"Comrade has included a large number of possible models (see Comrade API for a list). These can be broken down into two categories:","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"Parametric or geometric models\nNon-parametric or image models","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"Comrade's geometric model interface is built using VLBISkyModels and is different from other EHT modeling packages because we don't directly provide fully formed models. Instead, we offer simple geometric models, which we call primitives. These primitive models can then be modified and combined to form complicated  image structures. For more information, we refer the reader to the  VLBISkyModels docs.","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"Additionally, we include an interface to Bayesian imaging methods, where we directly fit a rasterized image to the data. These models are highly flexible and assume very little about the image structure. In that sense, these methods are an excellent way to explore the data first and see what kinds of image structures are consistent with observations. For an example of how to fit an image model to closure products, we refer the reader to the other tutorial included in the docs.","category":"page"},{"location":"vlbi_imaging_problem/#References","page":"Introduction to the VLBI Imaging Problem","title":"References","text":"","category":"section"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"[TMS]: Thompson, A., Moran, J., Swenson, G. (2017). Interferometry and Synthesis in Radio Astronomy (Third). Springer Cham","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"[M87P6]: Event Horizon Telescope Collaboration, (2022). First M87 Event Horizon Telescope Results. VI. The Shadow and Mass of the Central Black Hole. ApJL 875 L6 doi","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"[SgrAP4]: Event Horizon Telescope Collaboration, (2022). First Sagittarius A* Event Horizon Telscope Results. IV. Variability, Morphology, and Black Hole Mass. ApJL 930 L15 arXiv","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"[Blackburn]: Blackburn, L., et. al. (2020). Closure statistics in interferometric data. ApJ, 894(1), 31.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Comrade","category":"page"},{"location":"#Comrade","page":"Home","title":"Comrade","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Comrade is a Bayesian differentiable modular modeling framework for use with very long baseline interferometry. The goal is to allow the user to easily combine and modify a set of primitive models to construct complicated source structures. The benefit of this approach is that it is straightforward to construct different source models out of these primitives. Namely, an end-user does not have to create a separate source \"model\" every time they change the model specification. Additionally, most models currently implemented are differentiable with at Zygote and sometimes ForwardDiff[2]. This allows for gradient accelerated optimization and sampling (e.g., HMC) to be used with little effort by the end user. To sample from the posterior, we provide a somewhat barebones interface since, most of the time, and we don't require the additional features offered by most PPLs. Additionally, the overhead introduced by PPLs tends to be rather large. In the future, we may revisit this as Julia's PPL ecosystem matures.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nThe primitives the Comrade defines, however, would allow for it to be easily included in PPLs like Turing.","category":"page"},{"location":"#Tutorials","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Our tutorial section currently has a large number of examples. The simplest example is fitting simple geometric models to the 2017 M87 data and is detailed in the Geometric Modeling of EHT Data tutorial. We also include \"non-parametric\" modeling or imaging examples in Imaging a Black Hole using only Closure Quantities, and Stokes I Simultaneous Image and Instrument Modeling. There is also an introduction to hybrid geometric and image modeling in Hybrid Imaging of a Black Hole, which combines physically motivated geometric modeling with the flexibility of image-based models. Finally, we provide a tutorial on how to use Comrade to model polarized data including simultaneously solving for  the image and instrumental effects like gain ratios and leakage terms in Polarized Image and Instrumental Modeling.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This repository has recently moved to ColPrac. If you would like to contribute please feel free to open a issue or pull-request.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2]: As of 0.9 Comrade switched to using full covariance closures. As a result this requires a sparse cholesky solve in the likelihood evaluation which requires which isn't defined in ForwardDiff. As a result we recommend using Zygote which does work and often is similarly performant (reverse pass is 3-6x slower compared to the forward pass).","category":"page"},{"location":"#Requirements","page":"Home","title":"Requirements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The minimum Julia version we require is 1.9. In the future we may increase this as Julia advances.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"index.md\",\n    \"vlbi_imaging_problem.md\",\n    \"conventions.md\",\n    \"Tutorials\",\n    \"Libraries\",\n    \"interface.md\",\n    \"base_api.md\",\n    \"api.md\"\n]","category":"page"}]
}
