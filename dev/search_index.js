var documenterSearchIndex = {"docs":
[{"location":"base_api/#ComradeBase-API","page":"ComradeBase API","title":"ComradeBase API","text":"","category":"section"},{"location":"base_api/#Contents","page":"ComradeBase API","title":"Contents","text":"","category":"section"},{"location":"base_api/","page":"ComradeBase API","title":"ComradeBase API","text":"Pages = [\"base_api.md\"]","category":"page"},{"location":"base_api/#Index","page":"ComradeBase API","title":"Index","text":"","category":"section"},{"location":"base_api/","page":"ComradeBase API","title":"ComradeBase API","text":"Pages = [\"base_api.md\"]","category":"page"},{"location":"base_api/","page":"ComradeBase API","title":"ComradeBase API","text":"CurrentModule = ComradeBase","category":"page"},{"location":"base_api/#Model-API","page":"ComradeBase API","title":"Model API","text":"","category":"section"},{"location":"base_api/","page":"ComradeBase API","title":"ComradeBase API","text":"ComradeBase.AbstractModel\nComradeBase.flux\nComradeBase.isprimitive\nComradeBase.visanalytic\nComradeBase.imanalytic\nComradeBase.ispolarized\nComradeBase.radialextent\nComradeBase.visibility_point\nComradeBase.visibilities\nComradeBase.visibilities!\nComradeBase.visibilities_analytic\nComradeBase.visibilities_analytic!\nComradeBase.visibilities_numeric\nComradeBase.visibilities_numeric!\nComradeBase.intensity_point\nComradeBase.intensitymap\nComradeBase.intensitymap!\nComradeBase.intensitymap_analytic\nComradeBase.intensitymap_analytic!\nComradeBase.intensitymap_numeric\nComradeBase.intensitymap_numeric!\nComradeBase.PrimitiveTrait\nComradeBase.IsPrimitive\nComradeBase.NotPrimitive\nComradeBase.DensityAnalytic\nComradeBase.IsAnalytic\nComradeBase.NotAnalytic\nComradeBase.IntensityMap","category":"page"},{"location":"base_api/#ComradeBase.AbstractModel","page":"ComradeBase API","title":"ComradeBase.AbstractModel","text":"AbstractModel\n\nThe Comrade abstract model type. To instantiate your own model type you should subtybe from this model. Additionally you need to implement the following methods to satify the interface:\n\nMandatory Methods\n\nisprimitive: defines whether a model is standalone or is defined in terms of other models.  is the model is primitive then this should return IsPrimitive() otherwise it returns  NotPrimitive()\nvisanalytic: defines whether the model visibilities can be computed analytically. If yes  then this should return IsAnalytic() and the user must to define visibility_point.  If not analytic then visanalytic should return NotAnalytic().\nimanalytic: defines whether the model intensities can be computed pointwise. If yes   then this should return IsAnalytic() and the user must to define intensity_point.   If not analytic then imanalytic should return NotAnalytic().\nradialextent: Provides a estimate of the radial extent of the model in the image domain.  This is used for estimating the size of the image, and for plotting.\nflux: Returns the total flux of the model.\nintensity_point: Defines how to compute model intensities pointwise. Note this is must be defined if imanalytic(::Type{YourModel})==IsAnalytic().\nvisibility_point: Defines how to compute model visibilties pointwise. Note this is   must be defined if visanalytic(::Type{YourModel})==IsAnalytic().\n\nOptional Methods:\n\nispolarized: Specified whether a model is intrinsically polarized (returns IsPolarized()) or is not (returns NotPolarized()), by default a model is NotPolarized()\nvisibilities_analytic: Vectorized version of visibility_point for models where visanalytic returns IsAnalytic()\nvisibilities_numeric: Vectorized version of visibility_point for models where visanalytic returns NotAnalytic() typically these are numerical FT's\nintensitymap_analytic: Computes the entire image for models where imanalytic returns IsAnalytic()\nintensitymap_numeric: Computes the entire image for models where imanalytic returns NotAnalytic()\nintensitymap_analytic!: Inplace version of intensitymap\nintensitymap_numeric!: Inplace version of intensitymap\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.flux","page":"ComradeBase API","title":"ComradeBase.flux","text":"flux(im::IntensityMap)\nflux(img::StokesIntensityMap)\n\nComputes the flux of a intensity map\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.isprimitive","page":"ComradeBase API","title":"ComradeBase.isprimitive","text":"isprimitive(::Type)\n\nDispatch function that specifies whether a type is a primitive Comrade model. This function is used for dispatch purposes when composing models.\n\nNotes\n\nIf a user is specifying their own model primitive model outside of Comrade they need to specify if it is primitive\n\nstruct MyPrimitiveModel end\nComradeBase.isprimitive(::Type{MyModel}) = ComradeBase.IsPrimitive()\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.visanalytic","page":"ComradeBase API","title":"ComradeBase.visanalytic","text":"visanalytic(::Type{<:AbstractModel})\n\nDetermines whether the model is pointwise analytic in Fourier domain, i.e. we can evaluate its fourier transform at an arbritrary point.\n\nIf IsAnalytic() then it will try to call visibility_point to calculate the complex visibilities. Otherwise it fallback to using the FFT that works for all models that can compute an image.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.imanalytic","page":"ComradeBase API","title":"ComradeBase.imanalytic","text":"imanalytic(::Type{<:AbstractModel})\n\nDetermines whether the model is pointwise analytic in the image domain, i.e. we can evaluate its intensity at an arbritrary point.\n\nIf IsAnalytic() then it will try to call intensity_point to calculate the intensity.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.ispolarized","page":"ComradeBase API","title":"ComradeBase.ispolarized","text":"ispolarized(::Type)\n\nTrait function that defines whether a model is polarized or not.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.radialextent","page":"ComradeBase API","title":"ComradeBase.radialextent","text":"radialextent(model::AbstractModel)\n\nProvides an estimate of the radial size/extent of the model. This is used internally to estimate image size when plotting and using modelimage\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.visibility_point","page":"ComradeBase API","title":"ComradeBase.visibility_point","text":"visibility_point(model::AbstractModel, p)\n\nFunction that computes the pointwise visibility. This must be implemented in the model interface if visanalytic(::Type{MyModel}) == IsAnalytic()\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.visibilities","page":"ComradeBase API","title":"ComradeBase.visibilities","text":"visibilities(model::AbstractModel, args...)\n\nComputes the complex visibilities at the locations given by args...\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.visibilities!","page":"ComradeBase API","title":"ComradeBase.visibilities!","text":"visibilities!(vis::AbstractArray, model::AbstractModel, args...)\n\nComputes the complex visibilities vis in place at the locations given by args...\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.visibilities_analytic","page":"ComradeBase API","title":"ComradeBase.visibilities_analytic","text":"visibilties_analytic(model, u, v, time, freq)\n\nComputes the visibilties of a model using using the analytic visibility expression given by visibility_point.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.visibilities_analytic!","page":"ComradeBase API","title":"ComradeBase.visibilities_analytic!","text":"visibilties_analytic!(vis, model, u, v, time, freq)\n\nComputes the visibilties of a model in-place, using using the analytic visibility expression given by visibility_point.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.visibilities_numeric","page":"ComradeBase API","title":"ComradeBase.visibilities_numeric","text":"visibilties_numeric(model, u, v, time, freq)\n\nComputes the visibilties of a model using a numerical fourier transform. Note that none of these are implemented in ComradeBase. For implementations please see Comrade.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.visibilities_numeric!","page":"ComradeBase API","title":"ComradeBase.visibilities_numeric!","text":"visibilties_numeric!(vis, model, u, v, time, freq)\n\nComputes the visibilties of a model in-place using a numerical fourier transform. Note that none of these are implemented in ComradeBase. For implementations please see Comrade.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.intensity_point","page":"ComradeBase API","title":"ComradeBase.intensity_point","text":"intensity_point(model::AbstractModel, p)\n\nFunction that computes the pointwise intensity if the model has the trait in the image domain IsAnalytic(). Otherwise it will use construct the image in visibility space and invert it.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.intensitymap","page":"ComradeBase API","title":"ComradeBase.intensitymap","text":"intensitymap(model::AbstractModel, p::AbstractDims)\n\nComputes the intensity map of model. For the inplace version see intensitymap!\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.intensitymap!","page":"ComradeBase API","title":"ComradeBase.intensitymap!","text":"intensitymap!(buffer::AbstractDimArray, model::AbstractModel)\n\nComputes the intensity map of model by modifying the buffer\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.intensitymap_analytic","page":"ComradeBase API","title":"ComradeBase.intensitymap_analytic","text":"intensitymap_analytic(m::AbstractModel, p::AbstractDims)\n\nComputes the IntensityMap of a model m using the image dimensions p by broadcasting over the analytic intensity_point method.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.intensitymap_analytic!","page":"ComradeBase API","title":"ComradeBase.intensitymap_analytic!","text":"intensitymap_analytic!(img::IntensityMap, m::AbstractModel)\nintensitymap_analytic!(img::StokesIntensityMap, m::AbstractModel)\n\nUpdates the img using the model m  by broadcasting over the analytic intensity_point method.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.intensitymap_numeric","page":"ComradeBase API","title":"ComradeBase.intensitymap_numeric","text":"intensitymap_numeric(m::AbstractModel, p::AbstractDims)\n\nComputes the IntensityMap of a model m at the image positions p using a numerical method. This has to be specified uniquely for every model m if imanalytic(typeof(m)) === NotAnalytic(). See Comrade.jl for example implementations.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.intensitymap_numeric!","page":"ComradeBase API","title":"ComradeBase.intensitymap_numeric!","text":"intensitymap_numeric!(img::IntensityMap, m::AbstractModel)\nintensitymap_numeric!(img::StokesIntensityMap, m::AbstractModel)\n\nUpdates the img using the model m  using a numerical method. This has to be specified uniquely for every model m if imanalytic(typeof(m)) === NotAnalytic(). See Comrade.jl for example implementations.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.PrimitiveTrait","page":"ComradeBase API","title":"ComradeBase.PrimitiveTrait","text":"abstract type PrimitiveTrait\n\nThis trait specifies whether the model is a primitive\n\nNotes\n\nThis will likely turn into a trait in the future so people can inject their models into Comrade more easily.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.IsPrimitive","page":"ComradeBase API","title":"ComradeBase.IsPrimitive","text":"struct IsPrimitive\n\nTrait for primitive model\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.NotPrimitive","page":"ComradeBase API","title":"ComradeBase.NotPrimitive","text":"struct NotPrimitive\n\nTrait for not-primitive model\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.DensityAnalytic","page":"ComradeBase API","title":"ComradeBase.DensityAnalytic","text":"DensityAnalytic\n\nInternal type for specifying the nature of the model functions. Whether they can be easily evaluated pointwise analytic. This is an internal type that may change.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.IsAnalytic","page":"ComradeBase API","title":"ComradeBase.IsAnalytic","text":"struct IsAnalytic <: ComradeBase.DensityAnalytic\n\nDefines a trait that a states that a model is analytic. This is usually used with an abstract model where we use it to specify whether a model has a analytic fourier transform and/or image.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.NotAnalytic","page":"ComradeBase API","title":"ComradeBase.NotAnalytic","text":"struct NotAnalytic <: ComradeBase.DensityAnalytic\n\nDefines a trait that a states that a model is analytic. This is usually used with an abstract model where we use it to specify whether a model has does not have a easy analytic fourier transform and/or intensity function.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.IntensityMap","page":"ComradeBase API","title":"ComradeBase.IntensityMap","text":"IntensityMap(data::AbstractArray, dims::NamedTuple)\nIntensityMap(data::AbstractArray, grid::AbstractDims)\n\nConstructs an intensitymap using the image dimensions given by dims. This returns a KeyedArray with keys given by an ImageDimensions object.\n\ndims = (X=range(-10.0, 10.0, length=100), Y = range(-10.0, 10.0, length=100),\n        T = [0.1, 0.2, 0.5, 0.9, 1.0], F = [230e9, 345e9]\n        )\nimgk = IntensityMap(rand(100,100,5,1), dims)\n\n\n\n\n\n","category":"type"},{"location":"base_api/#Image-Types","page":"ComradeBase API","title":"Image Types","text":"","category":"section"},{"location":"base_api/","page":"ComradeBase API","title":"ComradeBase API","text":"ComradeBase.IntensityMap(::AbstractArray, ::AbstractDims)\nComradeBase.StokesIntensityMap\nComradeBase.imagepixels\nComradeBase.GriddedKeys\nComradeBase.dims\nComradeBase.named_dims\nComradeBase.axisdims\nComradeBase.stokes\nComradeBase.imagegrid\nComradeBase.fieldofview\nComradeBase.pixelsizes\nComradeBase.phasecenter\nComradeBase.centroid\nComradeBase.second_moment","category":"page"},{"location":"base_api/#ComradeBase.IntensityMap-Tuple{AbstractArray, ComradeBase.AbstractDims}","page":"ComradeBase API","title":"ComradeBase.IntensityMap","text":"IntensityMap(data::AbstractArray, dims::NamedTuple)\nIntensityMap(data::AbstractArray, grid::AbstractDims)\n\nConstructs an intensitymap using the image dimensions given by dims. This returns a KeyedArray with keys given by an ImageDimensions object.\n\ndims = (X=range(-10.0, 10.0, length=100), Y = range(-10.0, 10.0, length=100),\n        T = [0.1, 0.2, 0.5, 0.9, 1.0], F = [230e9, 345e9]\n        )\nimgk = IntensityMap(rand(100,100,5,1), dims)\n\n\n\n\n\n","category":"method"},{"location":"base_api/#ComradeBase.StokesIntensityMap","page":"ComradeBase API","title":"ComradeBase.StokesIntensityMap","text":"struct StokesIntensityMap{T, N, SI, SQ, SU, SV}\n\nGeneral struct that holds intensity maps for each stokes parameter. Each image I, Q, U, V must share the same axis dimensions. This type also obeys much of the usual array interface in Julia. The following methods have been implemented:\n\nsize\neltype (returns StokesParams)\nndims\ngetindex\nsetindex!\npixelsizes\nfieldofview\nimagepixels\nimagegrid\nstokes\n\nwarning: Warning\nThis may eventually be phased out for IntensityMaps whose base types are StokesParams, but currently we use this for speed reasons with Zygote.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.imagepixels","page":"ComradeBase API","title":"ComradeBase.imagepixels","text":"imagepixels(img::IntensityMap)\nimagepixels(img::IntensityMapTypes)\n\nReturns a abstract spatial dimension with the image pixels locations X and Y.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.GriddedKeys","page":"ComradeBase API","title":"ComradeBase.GriddedKeys","text":"struct GriddedKeys{N, G, Hd, T} <: ComradeBase.AbstractDims{N, T}\n\nThis struct holds the dimensions that the EHT expect. The first type parameter N defines the names of each dimension. These names are usually one of     - (:X, :Y, :T, :F)     - (:X, :Y, :F, :T)     - (:X, :Y) # spatial only where :X,:Y are the RA and DEC spatial dimensions respectively, :T is the the time direction and :F is the frequency direction.\n\nFieldnames\n\ndims\nheader\n\nNotes\n\nWarning it is rare you need to access this constructor directly. Instead use the direct IntensityMap function.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.dims","page":"ComradeBase API","title":"ComradeBase.dims","text":"dims(g::AbstractDims)\n\nReturns a tuple containing the dimensions of g. For a named version see ComradeBase.named_dims\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.named_dims","page":"ComradeBase API","title":"ComradeBase.named_dims","text":"named_dims(g::AbstractDims)\n\nReturns a named tuple containing the dimensions of g. For a unnamed version see dims\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.axisdims","page":"ComradeBase API","title":"ComradeBase.axisdims","text":"axisdims(img::IntensityMap)\n\nReturns the keys of the IntensityMap as the actual internal AbstractDims object.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.stokes","page":"ComradeBase API","title":"ComradeBase.stokes","text":"stokes(m::AbstractPolarizedModel, p::Symbol)\n\nExtract the specific stokes component p from the polarized model m\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.imagegrid","page":"ComradeBase API","title":"ComradeBase.imagegrid","text":"imagegrid(k::IntensityMap)\n\nReturns the grid the IntensityMap is defined as. Note that this is unallocating since it lazily computes the grid. The grid is an example of a KeyedArray and works similarly. This is useful for broadcasting a model across an abritrary grid.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.fieldofview","page":"ComradeBase API","title":"ComradeBase.fieldofview","text":"fieldofview(img::IntensityMap)\nfieldofview(img::IntensityMapTypes)\n\nReturns a named tuple with the field of view of the image.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.pixelsizes","page":"ComradeBase API","title":"ComradeBase.pixelsizes","text":"pixelsizes(img::IntensityMap)\npixelsizes(img::IntensityMapTypes)\n\nReturns a named tuple with the spatial pixel sizes of the image.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.phasecenter","page":"ComradeBase API","title":"ComradeBase.phasecenter","text":"phasecenter(img::IntensityMap)\nphasecenter(img::StokesIntensitymap)\n\nComputes the phase center of an intensity map. Note this is the pixels that is in the middle of the image.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.centroid","page":"ComradeBase API","title":"ComradeBase.centroid","text":"centroid(im::AbstractIntensityMap)\n\nComputes the image centroid aka the center of light of the image.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.second_moment","page":"ComradeBase API","title":"ComradeBase.second_moment","text":"centroid(im::AbstractIntensityMap)\n\nComputes the image centroid aka the center of light of the image.\n\n\n\n\n\nsecond_moment(im::AbstractIntensityMap; center=true)\n\nComputes the image second moment tensor of the image. By default we really return the second cumulant or centered second moment, which is specified by the center argument.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#Polarization","page":"ComradeBase API","title":"Polarization","text":"","category":"section"},{"location":"base_api/","page":"ComradeBase API","title":"ComradeBase API","text":"ComradeBase.AbstractPolarizedModel\nComradeBase.StokesParams\nComradeBase.ElectricFieldBasis\nComradeBase.RPol\nComradeBase.LPol\nComradeBase.XPol\nComradeBase.YPol\nComradeBase.PolBasis\nComradeBase.CirBasis\nComradeBase.LinBasis\nComradeBase.CoherencyMatrix\nComradeBase.evpa\nComradeBase.m̆\nComradeBase.linearpol\nComradeBase.SingleStokes\nComradeBase.innerprod\nComradeBase.basis_components\nComradeBase.basis_transform","category":"page"},{"location":"base_api/#ComradeBase.AbstractPolarizedModel","page":"ComradeBase API","title":"ComradeBase.AbstractPolarizedModel","text":"abstract type AbstractPolarizedModel <: ComradeBase.AbstractModel\n\nType the classifies a model as being intrinsically polarized. This means that any call to visibility must return a StokesParams to denote the full stokes polarization of the model.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.StokesParams","page":"ComradeBase API","title":"ComradeBase.StokesParams","text":"struct StokesParams{T} <: StaticArraysCore.FieldVector{4, T}\n\nStatic vector that holds the stokes parameters of a polarized complex visibility\n\nTo convert between a StokesParams and CoherencyMatrix use the convert function\n\nconvert(::CoherencyMatrix, StokesVector(1.0, 0.1, 0.1, 0.4))\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.ElectricFieldBasis","page":"ComradeBase API","title":"ComradeBase.ElectricFieldBasis","text":"abstract type ElectricFieldBasis\n\nAn abstract type whose subtypes denote a specific electric field basis.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.RPol","page":"ComradeBase API","title":"ComradeBase.RPol","text":"struct RPol <: ComradeBase.ElectricFieldBasis\n\nThe right circular electric field basis, i.e. a right-handed circular feed.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.LPol","page":"ComradeBase API","title":"ComradeBase.LPol","text":"struct LPol <: ComradeBase.ElectricFieldBasis\n\nThe left circular electric field basis, i.e. a left-handed circular feed.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.XPol","page":"ComradeBase API","title":"ComradeBase.XPol","text":"struct XPol <: ComradeBase.ElectricFieldBasis\n\nThe horizontal or X electric feed basis, i.e. the horizontal linear feed.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.YPol","page":"ComradeBase API","title":"ComradeBase.YPol","text":"struct YPol <: ComradeBase.ElectricFieldBasis\n\nThe vertical or Y electric feed basis, i.e. the vertical linear feed.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.PolBasis","page":"ComradeBase API","title":"ComradeBase.PolBasis","text":"struct PolBasis{B1<:Union{Missing, ComradeBase.ElectricFieldBasis}, B2<:Union{Missing, ComradeBase.ElectricFieldBasis}}\n\nDenotes a general polarization basis, with basis vectors (B1,B2) which are typically <: Union{ElectricFieldBasis, Missing}\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.CirBasis","page":"ComradeBase API","title":"ComradeBase.CirBasis","text":"CirBasis <: PolBasis\n\nMeasurement uses the circular polarization basis, which is typically used for circular feed interferometers.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.LinBasis","page":"ComradeBase API","title":"ComradeBase.LinBasis","text":"LinBasis <: PolBasis\n\nMeasurement uses the linear polarization basis, which is typically used for linear feed interferometers.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.CoherencyMatrix","page":"ComradeBase API","title":"ComradeBase.CoherencyMatrix","text":"struct CoherencyMatrix{B1, B2, T} <: StaticArraysCore.FieldMatrix{2, 2, T}\n\nCoherency matrix for a single baseline with bases B1 and B2. The two bases correspond to the type of feeds used for each telescope and should be subtypes of PolBasis. To see which bases are implemented type subtypes(Rimes.PolBasis) in the REPL.\n\nFor a circular basis the layout of the coherency matrix is\n\nRR* RL*\nLR* RR*\n\nwhich can be constructed using\n\nc = CoherencyMatrix(RR, LR, RL, LL, CirBasis())\n\nFor a linear basis the layout of the coherency matrix is\n\nXX* XY*\nYX* YY*\n\nwhich can be constructed using\n\nc = CoherencyMatrix(XX, YX, XY, YY, CirBasis())\n\nFor a mixed (e.g., circular and linear basis) the layout of the coherency matrix is\n\nRX* RY*\nLX* LY*\n\nor e.g., linear and circular the layout of the coherency matrix is\n\nXR* XL*\nYR* YL*\n\nThese coherency matrices can be constructed using:\n\n# Circular and linear feeds i.e., |R><X|\nc = CoherencyMatrix(RX, LX, RY, LY, LinBasis(), CirBasis())\n# Linear and circular feeds i.e., |X><R|\nc = CoherencyMatrix(XR, YR, XL, YL, LinBasis(), CirBasis())\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.evpa","page":"ComradeBase API","title":"ComradeBase.evpa","text":"evpa(pimg::AbstractPolarizedModel, p)\n\nelectric vector position angle or EVPA of the polarized model pimg at u and v\n\n\n\n\n\nevpa(m)\n\n\nCompute the evpa of a stokes vector or cohereny matrix.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.m̆","page":"ComradeBase API","title":"ComradeBase.m̆","text":"m̆(pimg::AbstractPolarizedModel, p)\nmbreve(pimg::AbstractPolarizedModel, p)\n\nComputes the fractional linear polarization in the visibility domain\n\nm̆ = (Q + iU)/I\n\nTo create the symbol type m\\breve in the REPL or use the mbreve function.\n\n\n\n\n\nm̆(m)\n\n\nCompute the fractional linear polarization of a stokes vector or coherency matrix\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.linearpol","page":"ComradeBase API","title":"ComradeBase.linearpol","text":"linearpol(s)\n\n\nComputes linearpol from a set of stokes parameters s.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.SingleStokes","page":"ComradeBase API","title":"ComradeBase.SingleStokes","text":"struct SingleStokes{M, S} <: ComradeBase.AbstractModel\n\nHelper function that converts a model from something that compute polarized images to just a single stokes parameter. This is useful if you just want to fit a single stokes parameter.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.innerprod","page":"ComradeBase API","title":"ComradeBase.innerprod","text":"innerprod(::Type{T}, XPol(), YPol())\n\nComputes the complex inner product of two elements of a complex Hilbert space X and Y where base element of the output is T.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.basis_components","page":"ComradeBase API","title":"ComradeBase.basis_components","text":"basis_components([T=Float64,], e::ElectricFieldBasis, b::PolBasis)\n\nReturns a static vector that contains the components of the electric field basis vector e in terms of the polarization basis b. The first argument is optionally the eltype of the static vector.\n\nExamples\n\njulia> basis_components(Float64, R(), PolBasis{XPol,Y}())\n2-element StaticArraysCore.SVector{2, ComplexF64} with indices SOneTo(2):\n 0.7071067811865475 + 0.0im\n                0.0 - 0.7071067811865475im\n\njulia> basis_components(R(), PolBasis{XPol,Y}())\n2-element StaticArraysCore.SVector{2, ComplexF64} with indices SOneTo(2):\n 0.7071067811865475 + 0.0im\n                0.0 - 0.7071067811865475im\n\n\njulia> basis_components(Float64, X(), PolBasis{XPol,Y}())\n2-element StaticArraysCore.SVector{2, ComplexF64} with indices SOneTo(2):\n 1.0 + 0.0im\n 0.0 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.basis_transform","page":"ComradeBase API","title":"ComradeBase.basis_transform","text":"basis_transform([T=Float64,], b1::PolBasis, b2::PolBasis)\nbasis_transform([T=Float64,], b1::PolBasis=>b2::PolBasis)\n\nProduces the transformation matrix that transforms the vector components from basis b1 to basis b2. This means that if for example E is the circular basis then basis_transform(CirBasis=>LinBasis)E is in the linear basis. In other words the columns of the transformation matrix are the coordinate vectors of the new basis vectors in the old basis.\n\nExample\n\njulia> basis_transform(CirBasis()=>LinBasis())\n2×2 StaticArraysCore.SMatrix{2, 2, ComplexF64, 4} with indices SOneTo(2)×SOneTo(2):\n 0.707107-0.0im       0.707107-0.0im\n      0.0-0.707107im       0.0+0.707107im\n\n\n\n\n\n","category":"function"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"EditURL = \"https://github.com/ptiede/Comrade.jl/blob/main/examples/imaging_closures.jl\"","category":"page"},{"location":"examples/imaging_closures/#Imaging-a-Black-Hole-using-only-Closure-Quantities","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"","category":"section"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"In this tutorial, we will create a preliminary reconstruction of the 2017 M87 data on April 6 using closure-only imaging. This tutorial is a general introduction to closure-only imaging in Comrade. For an introduction to simultaneous image and instrument modeling, see Stokes I Simultaneous Image and Instrument Modeling","category":"page"},{"location":"examples/imaging_closures/#Introduction-to-Closure-Imaging","page":"Imaging a Black Hole using only Closure Quantities","title":"Introduction to Closure Imaging","text":"","category":"section"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"The EHT is the highest-resolution telescope ever created. Its resolution is equivalent to roughly tracking a hockey puck on the moon when viewing it from the earth. However, the EHT is also a unique interferometer. For one, the data it produces is incredibly sparse. The array is formed from only eight geographic locations around the planet, each with its unique telescope. Additionally, the EHT observes at a much higher frequency than typical interferometers. As a result, it is often difficult to directly provide calibrated data since the source model can be complicated. This implies there can be large instrumental effects often called gains that can corrupt our signal. One way to deal with this is to fit quantities that are independent of gains. These are often called closure quantities. The types of closure quantities are briefly described in Introduction to the VLBI Imaging Problem.","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"In this tutorial, we will do closure-only modeling of M87 to produce preliminary images of M87.","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"To get started, we will load Comrade","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"using Comrade\n\n\nusing Pkg #hide\nPkg.activate(joinpath(dirname(pathof(Comrade)), \"..\", \"examples\")) #hide","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"For reproducibility we use a stable random number genreator","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"using StableRNGs\nrng = StableRNG(123)","category":"page"},{"location":"examples/imaging_closures/#Load-the-Data","page":"Imaging a Black Hole using only Closure Quantities","title":"Load the Data","text":"","category":"section"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"To download the data visit https://doi.org/10.25739/g85n-f134 To load the eht-imaging obsdata object we do:","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"obs = load_ehtim_uvfits(joinpath(dirname(pathof(Comrade)), \"..\", \"examples\", \"SR1_M87_2017_096_lo_hops_netcal_StokesI.uvfits\"))","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"Now we do some minor preprocessing:","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"Scan average the data since the data have been preprocessed so that the gain phases  are coherent.\nAdd 2% systematic noise to deal with calibration issues that cause 1% non-closing errors.","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"obs = scan_average(obs).add_fractional_noise(0.02)","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"Now, we extract our closure quantities from the EHT data set.","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"dlcamp = extract_lcamp(obs; snrcut=3.0)\ndcphase = extract_cphase(obs; snrcut=3.0)","category":"page"},{"location":"examples/imaging_closures/#Build-the-Model/Posterior","page":"Imaging a Black Hole using only Closure Quantities","title":"Build the Model/Posterior","text":"","category":"section"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"For our model, we will be using an image model that consists of a raster of point sources, convolved with some pulse or kernel to make a ContinuousImage object with it Comrade's. generic image model. Note that ContinuousImage(img, cache) actually creates a Comrade.ModelImage object that allows Comrade to numerically compute the Fourier transform of the image.","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"function model(θ, metadata)\n    (;c) = θ\n    (; grid, cache) = metadata\n    # Construct the image model\n    img = IntensityMap(c, grid)\n    return  ContinuousImage(img, cache)\nend","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"Now, let's set up our image model. The EHT's nominal resolution is 20-25 μas. Additionally, the EHT is not very sensitive to a larger field of views; typically, 60-80 μas is enough to describe the compact flux of M87. Given this, we only need to use a small number of pixels to describe our image.","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"npix = 7\nfovxy = μas2rad(77.5)","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"Now, we can feed in the array information to form the cache. We will be using a DFT since it is efficient for so few pixels We will use a Dirichlet prior, enforcing that the flux sums to unity since closures are degenerate to total flux.","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"grid = imagepixels(fovxy, fovxy, npix, npix)\nbuffer = IntensityMap(zeros(npix,npix), grid)\ncache = create_cache(DFTAlg(dlcamp), buffer, BSplinePulse{3}())\nmetadata = (;grid, cache)","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"Now we need to specify our image prior. For this work we use a very simple Dirichlet prior","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"using VLBIImagePriors\n(;X, Y) = grid\nprior = (c = ImageDirichlet(1.0, npix, npix), )\n\nlklhd = RadioLikelihood(model, metadata, dlcamp, dcphase)\npost = Posterior(lklhd, prior)","category":"page"},{"location":"examples/imaging_closures/#Reconstructing-the-Image","page":"Imaging a Black Hole using only Closure Quantities","title":"Reconstructing the Image","text":"","category":"section"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"To sample from this posterior, it is convenient to first move from our constrained parameter space to an unconstrained one (i.e., the support of the transformed posterior is (-∞, ∞)). This is done using the asflat function.","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"tpost = asflat(post)","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"We can now also find the dimension of our posterior or the number of parameters we will sample. !!! Warning    This can often be different from what you would expect. This is especially true when using    angular variables, where we often artificially increase the dimension    of the parameter space to make sampling easier.","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"ndim = dimension(tpost)","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"Now we optimize. First we will use BlackBoxOptim which is a genetic algorithm to get us in the region of the best fit model.","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"using ComradeOptimization\nusing OptimizationBBO\nf = OptimizationFunction(tpost, Optimization.AutoForwardDiff())\nprob = Optimization.OptimizationProblem(f, prior_sample(tpost), nothing, lb=fill(-5.0, ndim), ub=fill(5.0,ndim))\nsol = solve(prob, BBO_adaptive_de_rand_1_bin_radiuslimited(); maxiters=100_000)","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"Alright now let's zoom to the peak","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"using OptimizationOptimJL\nprob = Optimization.OptimizationProblem(f, sol.u, nothing)\nℓ = logdensityof(tpost)\nsol = solve(prob, LBFGS(), maxiters=1_000, callback=((x,p)->(@info ℓ(x);false)), g_tol=1e-1)","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"Before we analyze our solution we first need to transform back to parameter space.","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"xopt = transform(tpost, sol)","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"First we will evaluate our fit by plotting the residuals","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"using Plots\nresidual(model(xopt, metadata), dlcamp)\nresidual(model(xopt, metadata), dcphase)","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"These look pretty reasonable, although maybe they are a bit high. This could probably be improved in a few ways, but that is beyond the goal of this quick tutorial. Plotting the image, we have recovered a ring-like image reproducing the first EHT results.","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"img = intensitymap(model(xopt, metadata), μas2rad(120.0), μas2rad(120.0), 128, 128)\nplot(img, title=\"MAP Image\")","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"To sample from the posterior we will use HMC and more specifically the NUTS algorithm. For information about NUTS see Michael Betancourt's notes.","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"note: Note\nFor our metric we use a diagonal matrix due to easier tuning.","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"using ComradeAHMC\nusing Zygote\nmetric = DiagEuclideanMetric(ndim)\nchain, stats = sample(post, AHMC(;metric, autodiff=Val(:Zygote)), 500; nadapts=250, init_params=xopt)","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"warning: Warning\nThis should be run for likely an order of magnitude more steps to estimate expectations of the posterior properly","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"Now that we have our posterior, we can assess which parts of the image are strongly inferred by the data. This is rather unique to Comrade where more traditional imaging algorithms like CLEAN and RML are inherently unable to assess uncertainty in their reconstructions.","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"To explore our posterior let's first create images from a bunch of draws from the posterior","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"msamples = model.(chain[251:2:end], Ref(metadata))","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"The mean image is then given by","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"using StatsBase\nimgs = intensitymap.(msamples, μas2rad(120.0), μas2rad(120.0), 128, 128)\nmimg = mean(imgs)\nsimg = std(imgs)\np1 = plot(mimg, title=\"Mean Image\")\np2 = plot(simg./mimg, title=\"1/SNR\")\np3 = plot(imgs[1], title=\"Draw 1\")\np4 = plot(imgs[end], title=\"Draw 2\")\nplot(p1, p2, p3, p4, size=(800,800), colorbar=:none)","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"And viola, you have a quick and preliminary image of M87 fitting only closure products. For a publication-level version we would recommend","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"Running the chain longer and multiple times to properly assess things like ESS and R̂ (see Making an Image of a Black Hole)\nFitting gains. Typically gain amplitudes are good to 10-20% for the EHT not the infinite uncertainty closures implicitly assume\nMaking sure the posterior is unimodal (hint for this example it isn't!). The EHT image posteriors can be pretty complicated, so typically you want to use a sampler that can deal with multi-modal posteriors. Check out the package Pigeons.jl for an in-development package that should easily enable this type of sampling.","category":"page"},{"location":"examples/imaging_closures/#Computing-information","page":"Imaging a Black Hole using only Closure Quantities","title":"Computing information","text":"","category":"section"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"Julia Version 1.8.5\nCommit 17cfb8e65ea (2023-01-08 06:45 UTC)\nPlatform Info:\n  OS: Linux (x86_64-linux-gnu)\n  CPU: 32 × AMD Ryzen 9 7950X 16-Core Processor\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-13.0.1 (ORCJIT, znver3)\n  Threads: 1 on 32 virtual cores\nEnvironment:\n  JULIA_EDITOR = code\n  JULIA_NUM_THREADS = 1","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"","category":"page"},{"location":"examples/imaging_closures/","page":"Imaging a Black Hole using only Closure Quantities","title":"Imaging a Black Hole using only Closure Quantities","text":"This page was generated using Literate.jl.","category":"page"},{"location":"libs/adaptmcmc/#ComradeAdaptMCMC","page":"ComradeAdaptMCMC","title":"ComradeAdaptMCMC","text":"","category":"section"},{"location":"libs/adaptmcmc/","page":"ComradeAdaptMCMC","title":"ComradeAdaptMCMC","text":"Interface to the `AdaptiveMCMC.jl MCMC package. This uses parallel tempering to sample from the posterior. We typically recommend using one of the nested sampling packages. This interface follows Comrade's usual sampling interface for uniformity.","category":"page"},{"location":"libs/adaptmcmc/#Example","page":"ComradeAdaptMCMC","title":"Example","text":"","category":"section"},{"location":"libs/adaptmcmc/","page":"ComradeAdaptMCMC","title":"ComradeAdaptMCMC","text":"using Comrade\nusing ComradeAdaptMCMC\n\n# Some stuff to create a posterior object\npost # of type Comrade.Posterior\n\n\nsmplr = AdaptMCMC(ntemp=5) # use 5 tempering levels\n\nsamples, endstate = sample(post, smplr, 500_000, 300_000)","category":"page"},{"location":"libs/adaptmcmc/#API","page":"ComradeAdaptMCMC","title":"API","text":"","category":"section"},{"location":"libs/adaptmcmc/","page":"ComradeAdaptMCMC","title":"ComradeAdaptMCMC","text":"CurrentModule = ComradeAdaptMCMC","category":"page"},{"location":"libs/adaptmcmc/","page":"ComradeAdaptMCMC","title":"ComradeAdaptMCMC","text":"Modules = [ComradeAdaptMCMC]","category":"page"},{"location":"libs/adaptmcmc/#ComradeAdaptMCMC.AdaptMCMC","page":"ComradeAdaptMCMC","title":"ComradeAdaptMCMC.AdaptMCMC","text":"AdaptMCMC(;ntemp,\n          swap=:nonrev,\n          algorithm = :ram,\n          fulladapt = true,\n          acc_sw = 0.234,\n          all_levels = false\n          )\n\nCreate an AdaptMCMC.jl sampler. This sampler uses the AdaptiveMCMC.jl package to sample from the posterior. Namely, this is a parallel tempering algorithm with an adaptive exploration and tempering sampler. For more information please see [https://github.com/mvihola/AdaptiveMCMC.jl].\n\nThe arguments of the function are:\n\nntemp: Number of temperature to run in parallel tempering\nswap: Which temperature swapping strategy to use, options are:\n:norev (default) uses a non-reversible tempering scheme (still ergodic)\n:single single randomly picked swap\n:randperm swap in random order\n:sweep upward or downward sweeps picked at random\nalgorithm: exploration MCMC algorithm (default is :ram which uses robust adaptive metropolis-hastings) options are:\n:ram (default) Robust adaptive metropolis\n:am Adaptive metropolis\n:asm Adaptive scaling metropolis\n:aswam Adaptive scaling within adaptive metropolis\nfulladapt: whether we adapt both the tempering ladder and the exploration kernel (default is true, i.e. adapt everything)\nacc_sw: The target acceptance rate for temperature swaps\nall_levels: Store all tempering levels to memory (warning this can use a lot of memory)\n\n\n\n\n\n","category":"type"},{"location":"libs/adaptmcmc/#StatsBase.sample","page":"ComradeAdaptMCMC","title":"StatsBase.sample","text":"sample(post::Posterior, sampler::AdaptMCMC, nsamples, burnin=nsamples÷2, args...; init_params=nothing, kwargs...)\n\nSample the posterior post using the AdaptMCMC sampler. This will produce nsamples with the first burnin steps removed. The init_params indicate where to start the sampler from and it is expected to be a NamedTuple of parameters.\n\nPossible additional kwargs are:\n\nthin::Int = 1: which says to save only every thin sample to memory\nrng: Specify a random number generator (default uses GLOBAL_RNG)\n\nThis return a tuple where:\n\nFirst element are the chains from the sampler. If all_levels=false the only the unit temperature (posterior) chain is returned\nSecond element is the additional ancilliary information about the samples including the loglikelihood logl, sampler state state, average exploration kernel acceptance rate accexp for each tempering level, and average temperate swap acceptance rates accswp  for each tempering level.\n\n\n\n\n\n","category":"function"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"EditURL = \"https://github.com/ptiede/Comrade.jl/blob/main/examples/black_hole_image.jl\"","category":"page"},{"location":"examples/black_hole_image/#Making-an-Image-of-a-Black-Hole","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"","category":"section"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"Comrade has been designed to work with the EHT and ngEHT. In this tutorial, we will show how to reproduce some of the results from EHTC VI 2019.","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"In EHTC VI, they considered fitting simple geometric models to the data to estimate the black hole's image size, shape, brightness profile, etc. In this tutorial, we will construct a similar model and fit it to the data in under 50 lines of code (sans comments). To start, we load Comrade and some other packages we need.","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"using Comrade\n\nusing Pkg #hide\nPkg.activate(joinpath(dirname(pathof(Comrade)), \"..\", \"examples\")) #hide","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"For reproducibility we use a stable random number genreator","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"using StableRNGs\nrng = StableRNG(42)","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"The next step is to load the data. We will use the publically available M 87 data which can be downloaded from cyverse. For an introduction to data loading, see Loading Data into Comrade.","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"obs = load_ehtim_uvfits(joinpath(dirname(pathof(Comrade)), \"..\", \"examples\", \"SR1_M87_2017_096_lo_hops_netcal_StokesI.uvfits\"))","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"Now we will kill 0-baselines since we don't care about large-scale flux and since we know that the gains in this dataset are coherent across a scan, we make scan-average data","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"obs = scan_average(obs.flag_uvdist(uv_min=0.1e9))","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"Now we extract the data products we want to fit:","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"log closure amplitudes\nclosure phases","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"dlcamp = extract_lcamp(obs)\ndcphase = extract_cphase(obs)","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"For the image model, we will use a modified MRing, a infinitely thin delta ring with an azimuthal structure given by a Fourier expansion. To give the MRing some width, we will convolve the ring with a Gaussian and add an additional gaussian to the image to model any non-ring flux. Comrade expects that any model function must accept a named tuple and returns  must always return an object that implements the Comrade Model Interface","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"function model(θ)\n    (;radius, width, α, β, f, σG, τG, ξG, xG, yG) = θ\n    ring = f*smoothed(stretched(MRing((α,), (β,)), radius, radius), width)\n    g = (1-f)*shifted(rotated(stretched(Gaussian(), σG, σG*(1+τG)), ξG), xG, yG)\n    return ring + g\nend","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"To construct our likelihood p(V|M) where V is our data and M is our model, we use the RadioLikelihood function. The first argument of RadioLikelihood is always a function that constructs our Comrade model from the set of parameters θ.","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"lklhd = RadioLikelihood(model, dlcamp, dcphase)","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"We now need to specify the priors for our model. The easiest way to do this is to specify a NamedTuple of distributions:","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"using Distributions\nprior = (\n          radius = Uniform(μas2rad(10.0), μas2rad(30.0)),\n          width = Uniform(μas2rad(1.0), μas2rad(10.0)),\n          α = Uniform(-0.5, 0.5),\n          β = Uniform(-0.5, 0.5),\n          f = Uniform(0.0, 1.0),\n          σG = Uniform(μas2rad(1.0), μas2rad(40.0)),\n          τG = Uniform(0.0, 0.75),\n          ξG = Uniform(0.0, 1π),\n          xG = Uniform(-μas2rad(80.0), μas2rad(80.0)),\n          yG = Uniform(-μas2rad(80.0), μas2rad(80.0))\n        )","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"To form the posterior we now call","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"post = Posterior(lklhd, prior)","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"This constructs a posterior density that can be evaluated by calling logdensityof. For example,","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"logdensityof(post, (radius = μas2rad(20.0),\n                  width = μas2rad(10.0),\n                  α = 0.3,\n                  β = 0.3,\n                  f = 0.6,\n                  σG = μas2rad(20.0),\n                  τG = 0.1,\n                  ξG = 0.5,\n                  xG = 0.0,\n                  yG = 0.0))","category":"page"},{"location":"examples/black_hole_image/#Reconstruction","page":"Making an Image of a Black Hole","title":"Reconstruction","text":"","category":"section"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"Now that we have fully specified our model, we now will try to find the optimal reconstruction of our model given our observed data.","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"Currently, post is in parameter space. Often optimization and sampling algorithms want it in some modified space. For example, nested sampling algorithms want the parameters in the unit hypercube. To transform the posterior to the unit hypercube, we can use the ascube function","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"cpost = ascube(post)","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"If we want to flatten the parameter space and move from constrained parameters to (-∞, ∞) support we can use the asflat function","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"fpost = asflat(post)","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"These transformed posterior expect a vector of parameters. That is we can evaluate the transformed log density by calling","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"logdensityof(cpost, rand(rng, dimension(cpost)))\nlogdensityof(fpost, randn(rng, dimension(fpost)))","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"note that cpost logdensity vector expects that each element lives in [0,1].","category":"page"},{"location":"examples/black_hole_image/#Finding-the-Optimal-Image","page":"Making an Image of a Black Hole","title":"Finding the Optimal Image","text":"","category":"section"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"Typically, most VLBI modeling codes only care about finding the optimal or best guess image of our posterior post To do this, we will use Optimization.jl and specifically the BlackBoxOptim.jl package. For Comrade, this workflow is very similar to the usual Optimization.jl workflow. The only thing to keep in mind is that Optimization.jl expects that the function we are evaluating expects the parameters to be represented as a flat Vector of float. Therefore, we must use one of our transformed posteriors, cpost or fpost. For this example","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"#, we will use `cpost` since it restricts the domain to live within the compact unit hypercube\n#, which is easier to explore for non-gradient-based optimizers like `BBO`.\n\nusing ComradeOptimization\nusing OptimizationBBO\n\nndim = dimension(fpost)\nf = OptimizationFunction(fpost)\nprob = Optimization.OptimizationProblem(f, randn(rng, ndim), nothing, lb=fill(-5.0, ndim), ub=fill(5.0, ndim))","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"Now we solve for our optimial image.","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"sol = solve(prob, BBO_adaptive_de_rand_1_bin_radiuslimited(); maxiters=50_000)","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"The sol vector is in the transformed space, so first we need to transform back to parameter space to that we can interpret the solution.","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"xopt = transform(fpost, sol)","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"Given this we can now plot the optimal image or the maximum a posteriori (MAP) image.","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"using Plots\nplot(model(xopt), title=\"MAP image\", xlims=(-60.0,50.0), ylims=(-60.0,50.0))","category":"page"},{"location":"examples/black_hole_image/#Quantifying-the-Uncertainty-of-the-Reconstruction","page":"Making an Image of a Black Hole","title":"Quantifying the Uncertainty of the Reconstruction","text":"","category":"section"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"While finding the optimal image is often helpful, in science, the most important thing is to quantify the certainty of our inferences. This is the goal of Comrade. In the language of Bayesian statistics, we want to find a representation of the posterior of possible image reconstructions given our choice of model and the data.","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"Comrade provides several sampling and other posterior approximation tools. To see the list, please see the Libraries section of the docs. For this example, we will be using AdvancedHMC.jl, which uses an adaptive Hamiltonian Monte Carlo sampler called NUTS to approximate the posterior. Most of Comrade's external libraries follow a similar interface. To use AdvancedHMC do the following:","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"using ComradeAHMC, ForwardDiff\nchain, stats = sample(rng, post, AHMC(metric=DiagEuclideanMetric(ndim), autodiff=Val(:ForwardDiff)), 2000; nadapts=1000, init_params=xopt)","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"That's it! To finish it up we can then plot some simple visual fit diagnostics.","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"First to plot the image we call","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"plot(model(chain[end]), title=\"Random image\", xlims=(-60.0,60.0), ylims=(-60.0,60.0))","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"What about the mean image? Well let's grab 100 images from the chain, where we first remove the adaptation steps since they don't sample from the correct posterior distribution","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"meanimg = mean(intensitymap.(model.(sample(chain[1000:end], 100)), μas2rad(120.0), μas2rad(120.0), 128, 128))\nplot(sqrt.(max.(meanimg, 0.0)), title=\"Mean Image\") #plot on a sqrt color scale to see the Gaussian","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"That looks similar to the EHTC VI, and it took us no time at all!. To see how well the model is fitting the data we can plot the model and data products","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"plot(model(xopt), dlcamp, label=\"MAP\")","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"We can also plot what many draws from the posterior look like","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"p = plot(dlcamp);\nuva = [sqrt.(uvarea(dlcamp[i])) for i in 1:length(dlcamp)]\nfor i in 1:10\n    m = logclosure_amplitudes(model(chain[rand(rng, 1000:2000)]), arrayconfig(dlcamp))\n    scatter!(uva, m, color=:grey, label=:none, alpha=0.1)\nend\np","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"Finally, we can also put everything onto a common scale and plot the normalized residuals. The normalied residuals are the difference between the data and the model, divided by the data's error:","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"residual(model(xopt), dlcamp)","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"All diagnostic plots suggest that the model is missing some emission sources. In fact, this model is too simple to explain the data. Check out EHTC VI 2019 for some ideas about what features need to be added to the model to get a better fit!","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"For a real run we should also check that the MCMC chain has converged. For this we can use MCMCDiagnosticTools","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"using MCMCDiagnosticTools, Tables","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"First, lets look at the effective sample size (ESS) and R̂. This is important since the Monte Carlo standard error for MCMC estimates is proportional to 1/√ESS (for some problems) and R̂ is a measure of chain convergence. To find both, we can use:","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"essrhat = map(ess_rhat∘(x->reshape(x, :, 1, 1)), Tables.columns(chain))","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"Here, the first value is the ESS, and the second is the R̂. Note that we typically want R̂ < 1.01 for all parameters, but you should also be running the problem at least four times from four different starting locations.","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"In our example here, we see that we have an ESS > 100 for all parameters and the R̂ < 1.01 meaning that our MCMC chain is a reasonable approximation of the posterior. For more diagnostics, see MCMCDiagnosticTools.jl.","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"Computing information","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"Julia Version 1.7.3\nCommit 742b9abb4d (2022-05-06 12:58 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: 11th Gen Intel(R) Core(TM) i7-1185G7 @ 3.00GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-12.0.1 (ORCJIT, tigerlake)","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"","category":"page"},{"location":"examples/black_hole_image/","page":"Making an Image of a Black Hole","title":"Making an Image of a Black Hole","text":"This page was generated using Literate.jl.","category":"page"},{"location":"benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Comrade was partially designed with performance in mind. Solving imaging inverse problems is traditionally very computationally expensive, especially since Comrade uses Bayesian inference. To benchmark Comrade we will compare it to two of the most common modeling or imaging packages within the EHT:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"eht-imaging\nThemis","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"eht-imaging[1] or ehtim is a Python package that is widely used within the EHT for its imaging and modeling interfaces. It is easy to use and is commonly used in the EHT. However, to specify the model, the user must specify how to calculate the model's complex visibilities and its gradients, allowing eht-imaging's modeling package to achieve acceptable speeds.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Themis is a C++ package focused on providing Bayesian estimates of the image structure. In fact, Comrade took some design cues from Themis. Themis has been used in various EHT publications and is the standard Bayesian modeling tool used in the EHT. However, Themis is quite challenging to use and requires a high level of knowledge from its users, requiring them to understand makefile, C++, and the MPI standard. Additionally, Themis provides no infrastructure to compute gradients, instead relying on finite differencing, which scales poorly for large numbers of model parameters. ","category":"page"},{"location":"benchmarks/#Benchmarking-Problem","page":"Benchmarks","title":"Benchmarking Problem","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"For our benchmarking problem, we analyze a situation very similar to the one explained in Making an Image of a Black Hole. Namely, we will consider fitting 2017 M87 April 6 data using an m-ring and a single Gaussian component. Please see the end of this page to see the code we used for Comrade and eht-imaging.","category":"page"},{"location":"benchmarks/#Results","page":"Benchmarks","title":"Results","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"All tests were run using the following system","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Julia Version 1.7.3\nPython Version 3.10.5\nComrade Version 0.4.0\neht-imaging Version 1.2.4\nCommit 742b9abb4d (2022-05-06 12:58 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: 11th Gen Intel(R) Core(TM) i7-1185G7 @ 3.00GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-12.0.1 (ORCJIT, tigerlake)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Our benchmark results are the following:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":" Comrade (micro sec) eht-imaging (micro sec) Themis (micro sec)\nposterior eval (min) 31 445 55\nposterior eval (mean) 36 476 60\ngrad posterior eval (min) 105 (ForwardDiff) 1898 1809\ngrad posterior eval (mean) 119 (ForwardDiff) 1971 1866","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Therefore, for this test we found that Comrade was the fastest method in all tests. For the posterior evaluation we found that Comrade is > 10x faster than eht-imaging, and 2x faster then Themis. For gradient evaluations we have Comrade is > 15x faster than both eht-imaging and Themis.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"[1]: Chael A, et al. Inteferometric Imaging Directly with Closure Phases 2018 ApJ 857 1 arXiv:1803/07088","category":"page"},{"location":"benchmarks/#Code","page":"Benchmarks","title":"Code","text":"","category":"section"},{"location":"benchmarks/#Julia-Code","page":"Benchmarks","title":"Julia Code","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using Comrade\nusing Distributions\nusing BenchmarkTools\nusing ForwardDiff\n\nload_ehtim()\n# To download the data visit https://doi.org/10.25739/g85n-f134\nobs = load_ehtim_uvfits(joinpath(@__DIR__, \"assets/SR1_M87_2017_096_lo_hops_netcal_StokesI.uvfits\"))\nobs = scan_average(obs)\namp = extract_amp(obs)\n\nfunction model(θ)\n    (;rad, wid, a, b, f, sig, asy, pa, x, y) = θ\n    ring = f*smoothed(stretched(MRing((a,), (b,)), μas2rad(rad), μas2rad(rad)), μas2rad(wid))\n    g = (1-f)*shifted(rotated(stretched(Gaussian(), μas2rad(sig)*asy, μas2rad(sig)), pa), μas2rad(x), μas2rad(y))\n    return ring + g\nend\n\nlklhd = RadioLikelihood(model, amp)\nprior = (\n          rad = Uniform(10.0, 30.0),\n          wid = Uniform(1.0, 10.0),\n          a = Uniform(-0.5, 0.5), b = Uniform(-0.5, 0.5),\n          f = Uniform(0.0, 1.0),\n          sig = Uniform((1.0), (60.0)),\n          asy = Uniform(0.0, 0.9),\n          pa = Uniform(0.0, 1π),\n          x = Uniform(-(80.0), (80.0)),\n          y = Uniform(-(80.0), (80.0))\n        )\n\nθ = (rad= 22.0, wid= 3.0, a = 0.0, b = 0.15, f=0.8, sig = 20.0, asy=0.2, pa=π/2, x=20.0, y=20.0)\nm = model(θ)\n\npost = Posterior(lklhd, prior)\ntpost = asflat(post)\n\n# Transform to the unconstrained space\nx0 = inverse(tpost, θ)\n\n# Lets benchmark the posterior evaluation\nℓ = logdensityof(tpost)\n@benchmark ℓ($x0)\n\nusing LogDensityProblemsAD\n# Now we benchmark the gradient\ngℓ = ADgradient(Val(:ForwardDiff), tpost)\n@benchmark LogDensityProblemsAD.logdensity_and_gradient($gℓ, $x0)","category":"page"},{"location":"benchmarks/#eht-imaging-Code","page":"Benchmarks","title":"eht-imaging Code","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"load_ehtim()\n# To download the data visit https://doi.org/10.25739/g85n-f134\nobs = load_ehtim_uvfits(joinpath(@__DIR__, \"assets/SR1_M87_2017_096_lo_hops_netcal_StokesI.uvfits\"))\nobs = scan_average(obs)\n\n\n\nmeh = ehtim.model.Model()\nmeh = meh.add_thick_mring(F0=θ.f,\n                    d=2*μas2rad(θ.rad),\n                    alpha=2*sqrt(2*log(2))*μas2rad(θ.wid),\n                    x0 = 0.0,\n                    y0 = 0.0,\n                    beta_list=[0.0+θ.b]\n                    )\nmeh = meh.add_gauss(F0=1-θ.f,\n                    FWHM_maj=2*sqrt(2*log(2))*μas2rad(θ.sig),\n                    FWHM_min=2*sqrt(2*log(2))*μas2rad(θ.sig)*θ.asy,\n                    PA = θ.pa,\n                    x0 = μas2rad(20.0),\n                    y0 = μas2rad(20.0)\n                    )\n\npreh = meh.default_prior()\npreh[1][\"F0\"] = Dict(\"prior_type\"=>\"flat\", \"min\"=>0.0, \"max\"=>1.0)\npreh[1][\"d\"] = Dict(\"prior_type\"=>\"flat\", \"min\"=>μas2rad(20.0), \"max\"=>μas2rad(60.0))\npreh[1][\"alpha\"] = Dict(\"prior_type\"=>\"flat\", \"min\"=>μas2rad(2.0), \"max\"=>μas2rad(25.0))\npreh[1][\"x0\"] = Dict(\"prior_type\"=>\"fixed\")\npreh[1][\"y0\"] = Dict(\"prior_type\"=>\"fixed\")\n\npreh[2][\"F0\"] = Dict(\"prior_type\"=>\"flat\", \"min\"=>0.0, \"max\"=>1.0)\npreh[2][\"FWHM_maj\"] = Dict(\"prior_type\"=>\"flat\", \"min\"=>μas2rad(2.0), \"max\"=>μas2rad(120.0))\npreh[2][\"FWHM_min\"] = Dict(\"prior_type\"=>\"flat\", \"min\"=>μas2rad(2.0), \"max\"=>μas2rad(120.0))\npreh[2][\"x0\"] = Dict(\"prior_type\"=>\"flat\", \"min\"=>-μas2rad(40.0), \"max\"=>μas2rad(40.0))\npreh[2][\"y0\"] = Dict(\"prior_type\"=>\"flat\", \"min\"=>-μas2rad(40.0), \"max\"=>μas2rad(40.0))\npreh[2][\"PA\"] = Dict(\"prior_type\"=>\"flat\", \"min\"=>-1π, \"max\"=>1π)\n\nusing PyCall\npy\"\"\"\nimport ehtim\nimport numpy as np\ntransform_param = ehtim.modeling.modeling_utils.transform_param\ndef make_paraminit(param_map, meh, trial_model, model_prior):\n    model_init = meh.copy()\n    param_init = []\n    for j in range(len(param_map)):\n        pm = param_map[j]\n        if param_map[j][1] in trial_model.params[param_map[j][0]].keys():\n            param_init.append(transform_param(model_init.params[pm[0]][pm[1]]/pm[2], model_prior[pm[0]][pm[1]],inverse=False))\n        else: # In this case, the parameter is a list of complex numbers, so the real/imaginary or abs/arg components need to be assigned\n            if param_map[j][1].find('cpol') != -1:\n                param_type = 'beta_list_cpol'\n                idx = int(param_map[j][1].split('_')[0][8:])\n            elif param_map[j][1].find('pol') != -1:\n                param_type = 'beta_list_pol'\n                idx = int(param_map[j][1].split('_')[0][7:]) + (len(trial_model.params[param_map[j][0]][param_type])-1)//2\n            elif param_map[j][1].find('beta') != -1:\n                param_type = 'beta_list'\n                idx = int(param_map[j][1].split('_')[0][4:]) - 1\n            else:\n                raise Exception('Unsure how to interpret ' + param_map[j][1])\n\n            curval = model_init.params[param_map[j][0]][param_type][idx]\n            if '_' not in param_map[j][1]:\n                param_init.append(transform_param(np.real( model_init.params[pm[0]][param_type][idx]/pm[2]), model_prior[pm[0]][pm[1]],inverse=False))\n            elif   param_map[j][1][-2:] == 're':\n                param_init.append(transform_param(np.real( model_init.params[pm[0]][param_type][idx]/pm[2]), model_prior[pm[0]][pm[1]],inverse=False))\n            elif param_map[j][1][-2:] == 'im':\n                param_init.append(transform_param(np.imag( model_init.params[pm[0]][param_type][idx]/pm[2]), model_prior[pm[0]][pm[1]],inverse=False))\n            elif param_map[j][1][-3:] == 'abs':\n                param_init.append(transform_param(np.abs(  model_init.params[pm[0]][param_type][idx]/pm[2]), model_prior[pm[0]][pm[1]],inverse=False))\n            elif param_map[j][1][-3:] == 'arg':\n                param_init.append(transform_param(np.angle(model_init.params[pm[0]][param_type][idx])/pm[2], model_prior[pm[0]][pm[1]],inverse=False))\n            else:\n                if not quiet: print('Parameter ' + param_map[j][1] + ' not understood!')\n    n_params = len(param_init)\n    return n_params, param_init\n\"\"\"\n\n# make the python param map and use optimize so we flatten the parameter space.\npmap, pmask = ehtim.modeling.modeling_utils.make_param_map(meh, preh, \"scipy.optimize.dual_annealing\", fit_model=true)\ntrial_model = meh.copy()\n\n# get initial parameters\nn_params, pinit = py\"make_paraminit\"(pmap, meh, trial_model, preh)\n\n# make data products for the globdict\ndata1, sigma1, uv1, _ = ehtim.modeling.modeling_utils.chisqdata(obs, \"amp\")\ndata2, sigma2, uv2, _ = ehtim.modeling.modeling_utils.chisqdata(obs, false)\ndata3, sigma3, uv3, _ = ehtim.modeling.modeling_utils.chisqdata(obs, false)\n\n# now set the ehtim modeling globdict\n\nehtim.modeling.modeling_utils.globdict = Dict(\"trial_model\"=>trial_model,\n                \"d1\"=>\"amp\", \"d2\"=>false, \"d3\"=>false,\n                \"pol1\"=>\"I\", \"pol2\"=>\"I\", \"pol3\"=>\"I\",\n                \"data1\"=>data1, \"sigma1\"=>sigma1, \"uv1\"=>uv1, \"jonesdict1\"=>nothing,\n                \"data2\"=>data2, \"sigma2\"=>sigma2, \"uv2\"=>uv2, \"jonesdict2\"=>nothing,\n                \"data3\"=>data3, \"sigma3\"=>sigma3, \"uv3\"=>uv3, \"jonesdict3\"=>nothing,\n                \"alpha_d1\"=>0, \"alpha_d2\"=>0, \"alpha_d3\"=>0,\n                \"n_params\"=> n_params, \"n_gains\"=>0, \"n_leakage\"=>0,\n                \"model_prior\"=>preh, \"param_map\"=>pmap, \"param_mask\"=>pmask,\n                \"gain_prior\"=>nothing, \"gain_list\"=>[], \"gain_init\"=>nothing,\n                \"fit_leakage\"=>false, \"leakage_init\"=>[], \"leakage_fit\"=>[],\n                \"station_leakages\"=>nothing, \"leakage_prior\"=>nothing,\n                \"show_updates\"=>false, \"update_interval\"=>1,\n                \"gains_t1\"=>nothing, \"gains_t2\"=>nothing,\n                \"minimizer_func\"=>\"scipy.optimize.dual_annealing\",\n                \"Obsdata\"=>obs,\n                \"fit_pol\"=>false, \"fit_cpol\"=>false,\n                \"flux\"=>1.0, \"alpha_flux\"=>0, \"fit_gains\"=>false,\n                \"marginalize_gains\"=>false, \"ln_norm\"=>1314.33,\n                \"param_init\"=>pinit, \"test_gradient\"=>false\n            )\n\n# This is the negative log-posterior\nfobj = ehtim.modeling.modeling_utils.objfunc\n\n# This is the gradient of the negative log-posterior\ngfobj = ehtim.modeling.modeling_utils.objgrad\n\n# Lets benchmark the posterior evaluation\n@benchmark fobj($pinit)\n\n# Now we benchmark the gradient\n@benchmark gfobj($pinit)","category":"page"},{"location":"libs/ahmc/#ComradeAHMC","page":"ComradeAHMC","title":"ComradeAHMC","text":"","category":"section"},{"location":"libs/ahmc/","page":"ComradeAHMC","title":"ComradeAHMC","text":"The first choice when sampling from the model/image posterior,  is AdvancedHMC ), which uses Hamiltonian Monte Carlo to sample from the posterior. Specifically, we usually use the NUTS algorithm. ","category":"page"},{"location":"libs/ahmc/","page":"ComradeAHMC","title":"ComradeAHMC","text":"The interface to AdvancedHMC is very powerful and general. To simplify  the procedure for Comrade users, we have provided a thin interface.  A user needs to specify a sampler and then call  the sample function.","category":"page"},{"location":"libs/ahmc/","page":"ComradeAHMC","title":"ComradeAHMC","text":"For AdvancedHMC, the user can create the sampler by calling the AHMC function. This only has one mandatory argument, the metric the sampler uses. There are currently two options:","category":"page"},{"location":"libs/ahmc/","page":"ComradeAHMC","title":"ComradeAHMC","text":"- `DiagEuclideanMetric` which uses a diagonal metric for covariance adaptation\n- `DenseEuclideanMetric` which uses a dense or full rank metric for covariance adaptation","category":"page"},{"location":"libs/ahmc/","page":"ComradeAHMC","title":"ComradeAHMC","text":"We recommend that a user starts with DiagEuclideanMetric since the dense metric typically requires many more samples to tune correctly.  The other options for AHMC (sans autodiff) specify which version of HMC to use. Our default options match the choices made by the Stan programming language. The final option to consider is the autodiff optional argument. This specifies which auto differentiation package to use. For geometric modeling, we recommend the Val(:ForwardDiff), while for Bayesian Imaging, Val(:Zygote).","category":"page"},{"location":"libs/ahmc/#Example","page":"ComradeAHMC","title":"Example","text":"","category":"section"},{"location":"libs/ahmc/","page":"ComradeAHMC","title":"ComradeAHMC","text":"using Comrade\nusing ComradeAHMC\n\n# Some stuff to create a posterior object\npost # of type Comrade.Posterior\n\nmetric = DiagEuclideanMetric(dimension(post))\nsmplr = AHMC(metric=metric, autodiff=Val(:ForwardDiff))\n\nsamples, endstate = sample(post, smplr, 2_000; nadapts=1_000)","category":"page"},{"location":"libs/ahmc/#API","page":"ComradeAHMC","title":"API","text":"","category":"section"},{"location":"libs/ahmc/","page":"ComradeAHMC","title":"ComradeAHMC","text":"CurrentModule = ComradeAHMC","category":"page"},{"location":"libs/ahmc/","page":"ComradeAHMC","title":"ComradeAHMC","text":"Modules = [ComradeAHMC]","category":"page"},{"location":"libs/ahmc/#ComradeAHMC.AHMC","page":"ComradeAHMC","title":"ComradeAHMC.AHMC","text":"AHMC\n\nCreates a sampler that uses the AdvancedHMC framework to construct an Hamiltonian Monte Carlo NUTS sampler.\n\nThe user must specify the metric they want to use. Typically we recommend DiagEuclideanMetric as a reasonable starting place. The other options are chosen to match the Stan languages defaults and should provide a good starting point. Please see the AdvancedHMC docs for more information.\n\nNotes\n\nFor autodiff the must provide a Val(::Symbol) that specifies the AD backend. Currently, we use LogDensityProblemsAD.\n\nFields\n\nmetric: AdvancedHMC metric to use\n\nintegrator: AdvancedHMC integrator Defaults to AdvancedHMC.Leapfrog\n\ntrajectory: HMC trajectory sampler Defaults to AdvancedHMC.MultinomialTS\n\ntermination: HMC termination condition Defaults to AdvancedHMC.StrictGeneralisedNoUTurn\n\nadaptor: Adaptation strategy for mass matrix and stepsize Defaults to AdvancedHMC.StanHMCAdaptor\n\ntargetacc: Target acceptance rate for all trajectories on the tree Defaults to 0.85\n\ninit_buffer: The number of steps for the initial tuning phase. Defaults to 75 which is the Stan default\n\nterm_buffer: The number of steps for the final fast step size adaptation Default if 50 which is the Stan default\n\nwindow_size: The number of steps to tune the covariance before the first doubling Default is 23 which is the Stan default\n\nautodiff: autodiff backend see LogDensitProblemsAD.jl for possible backends. The default is Zygote which is appropriate for high dimensional problems.\n\n\n\n\n\n","category":"type"},{"location":"libs/ahmc/#StatsBase.sample-Tuple{Random.AbstractRNG, Comrade.TransformedPosterior, AHMC, Any, Vararg{Any}}","page":"ComradeAHMC","title":"StatsBase.sample","text":"AbstractMCMC.sample(post::Comrade.Posterior,\n                    sampler::AHMC,\n                    nsamples;\n                    init_params=nothing,\n                    kwargs...)\n\nSamples the posterior post using the AdvancedHMC sampler specified by AHMC. This will run the sampler for nsamples.\n\nTo initialize the chain the user can set init_params to Vector{NamedTuple} whose elements are the starting locations for each of the nchains. If no starting location is specified nchains random samples from the prior will be chosen for the starting locations.\n\nFor possible kwargs please see the AdvancedHMC.jl docs\n\nThis returns a tuple where the first element is a TypedTable of the MCMC samples in parameter space and the second argument is a set of ancilliary information about the sampler.\n\nNotes\n\nThis will automatically transform the posterior to the flattened unconstrained space.\n\n\n\n\n\n","category":"method"},{"location":"libs/ahmc/#StatsBase.sample-Union{Tuple{A}, Tuple{Random.AbstractRNG, Posterior, A, AbstractMCMC.AbstractMCMCEnsemble, Any, Any}} where A<:AHMC","page":"ComradeAHMC","title":"StatsBase.sample","text":"AbstractMCMC.sample(post::Comrade.Posterior,\n                    sampler::AHMC,\n                    parallel::AbstractMCMC.AbstractMCMCEnsemble,\n                    nsamples,\n                    nchainsl;\n                    init_params=nothing,\n                    kwargs...)\n\nSamples the posterior post using the AdvancedHMC sampler specified by AHMC. This will sample nchains copies of the posterior using the parallel scheme. Each chain will be sampled for nsamples.\n\nTo initialize the chain the user can set init_params to Vector{NamedTuple} whose elements are the starting locations for each of the nchains. If no starting location is specified nchains random samples from the prior will be chosen for the starting locations.\n\nFor possible kwargs please see the AdvancedHMC.jl docs\n\nThis returns a tuple where the first element is nchains of TypedTable's each which contains the MCMC samples of one of the parallel chain and the second argument is a set of ancilliary information about each set of samples.\n\nNotes\n\nThis will automatically transform the posterior to the flattened unconstrained space.\n\n\n\n\n\n","category":"method"},{"location":"interface/#Model-Interface","page":"Model Interface","title":"Model Interface","text":"","category":"section"},{"location":"interface/#Primitive-Geometric-Models","page":"Model Interface","title":"Primitive Geometric Models","text":"","category":"section"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Comrade aims to be more modular and extensible than previous VLBI modeling packages. Namely, simple models are composed to construct complicated source morphologies instead of making many different models. This is accomplished with a type and trait-based hierarchy.","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Additionally, ComradeBase is a low-dependency version of this package that defines this type and trait hierarchy that users can more easily incorporate into their packages.","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"To see how this works, we will go through a simplified implementation of the Gaussian model in Comrade. The Gaussian model is a simple, compact emission structure model that can constrain the typical characteristic size of an image feature from VLBI data. To construct a Gaussian model, we will first define a struct:","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"struct MyGaussian <: Comrade.AbstractModel end","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Notice that we don't provide any more information about the model, e.g., size, shape, flux, etc. This is because we will use Comrade's extensive set of modifiers to change the structure of the model. Now a Gaussian is the simplest model structure we can consider. We can consider this Gaussian to be a primitive model. That means a Gaussian is not a combination or modification of an existing model. To tell Comrade that this is the case, we define the following method:","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"# Tell Comrade Gaussian is a primitive model\nComradeBase.isprimitive(::Type{<:MyGaussian}) = IsPrimitive()","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Note that if the Gaussian wasn't a primitive model, we could've used NotPrimitive() instead. Now a Gaussian has an analytic expression in the image and Fourier domain. We can tell Comrade this by setting:","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"# Fourier and image domains are analytic\nComrade.visanalytic(::Type{<:MyGaussian}) = IsAnalytic()\nComrade.imanalytic(::Type{<:MyGaussian}) = IsAnalytic()","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Finally, we can specify if the model is intrinsically polarized by using the IsPolarized and NotPolarized() trait","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Comrade.ispolarized(::Type{<:MyGaussian}) = NotPolarized()","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"note: Note\nThe actual implementation defines the Gaussian to be a subtype of Comrade.GeometricModel, which automatically defines these methods. However, for models that aren't a subtype of GeometricModel, we assume the image domain IsAnalytic() and the Fourier domain is NotAnalytic().","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Since both the image and visibility domain representation of the Gaussian are analytic, we need to define an intensity_point and visibility_point method. For a Gaussian, these are given by","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"function ComradeBase.intensity_point(::MyGaussian, p)\n    (;X, Y) = p\n    return exp(-(X^2+Y^2)/2)/2π\nend\n\nfunction ComradeBase.visibility_point(::MyGaussian, u, v, time, freq) where {T}\n    return exp(-2π^2*(u^2 + v^2)) + 0im\nend","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Additionally, most models in Comrade has two additional functions one can implement if possible:","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"flux(m::MyGaussian): This defines the flux of a model. If this isn't defined, the model won't have a flux until an image is created. For a Gaussian, the definition is flux(::MyGaussian) = 1.0.\nradialextent(::MyGaussian): This defines the model's default radial extent. For a Gaussian, we will consider the radial extent to be 5σ, so radialextent(::MyGaussian) = 5.0.","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"This completely defines the model interface for Comrade. With this, you can call the usual user API to evaluate, fit, and plot the model. Additionally, we can start talking about adding multiple Gaussians and modifying them. For instance, suppose you want an elliptical Gaussian with a flux of 2 Jy. This can be created by Comrade as follows:","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"gauss = MyGaussian()\nellgauss = 2.0*rotated(stretched(gauss, 1.0, 0.5), π/4)\nfig = plot(gauss, layout=(1,2), size=(800,300))\nplot!(fig[2], ellgauss, size=(800,350))","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"(Image: Image)","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"u = rand(100)*0.5; v=rand(100)*0.5\nvg  = visibilities(gauss, u, v)\nveg = visibilities(ellgauss, u, v)\n\nscatter(hypot.(u, v), abs.(vg), label=\"Gaussian\")\nscatter!(hypot.(u, v), abs.(veg), label=\"Elliptical Gaussian\")","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"(Image: Image)","category":"page"},{"location":"interface/#Models-without-an-Analytic-Fourier-Transform","page":"Model Interface","title":"Models without an Analytic Fourier Transform","text":"","category":"section"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Now suppose your model does not have an analytic Fourier transform. In this case, the procedure is very similar to the above, except you define visanalytic(::Type{<:MyModel}) = NotAnalytic(). However, everything else is the same. To compute visibilities, you just then create a ModelImage type using the modelimage function. To see how this see Modeling with non-analytic Fourier transforms.","category":"page"},{"location":"libs/optimization/#ComradeOptimization","page":"ComradeOptimization","title":"ComradeOptimization","text":"","category":"section"},{"location":"libs/optimization/","page":"ComradeOptimization","title":"ComradeOptimization","text":"To optimize our posterior, we use the Optimization.jl package. Optimization provides a global interface to several Julia optimizers. The Comrade wrapper for Optimization.jl is very thin. The only difference addition is that Comrade has provided a method:","category":"page"},{"location":"libs/optimization/","page":"ComradeOptimization","title":"ComradeOptimization","text":"OptimizationFunction(::TransformedPosterior, args...; kwargs...)","category":"page"},{"location":"libs/optimization/","page":"ComradeOptimization","title":"ComradeOptimization","text":"meaning we can pass it a posterior object and it will set up the OptimizationFunction for us. ","category":"page"},{"location":"libs/optimization/","page":"ComradeOptimization","title":"ComradeOptimization","text":"note: Note\n","category":"page"},{"location":"libs/optimization/","page":"ComradeOptimization","title":"ComradeOptimization","text":"We only specify this for a transformed version of the posterior. This is because Optimization.jl requires a flattened version of the posterior.","category":"page"},{"location":"libs/optimization/","page":"ComradeOptimization","title":"ComradeOptimization","text":"Additionally, different optimizers may prefer different parameter transformations. For example, if we use OptimizationBBO, using ascube is a good choice since it needs a compact region to search over, and ascube convert our parameter space to the unit hypercube. On the other hand, gradient-based optimizers work best without bounds, so a better choice would be the asflat transformation.","category":"page"},{"location":"libs/optimization/","page":"ComradeOptimization","title":"ComradeOptimization","text":"To see what optimizers are available and what options are available, please see the Optimizations.jl docs.","category":"page"},{"location":"libs/optimization/#Example","page":"ComradeOptimization","title":"Example","text":"","category":"section"},{"location":"libs/optimization/","page":"ComradeOptimization","title":"ComradeOptimization","text":"using Comrade\nusing ComradeOptimization\nusing OptimizationOptimJL\n\n# Some stuff to create a posterior object\npost # of type Comrade.Posterior\n\n# Create a optimization problem using ForwardDiff as the backend\nfflat = OptimizationProblem(asflat(post), Optimization.AutoForwardDiff())\n\n# create the problem from a random point in the prior, nothing is b/c there are no additional arugments to our function.\nprob = OptimizationProblem(fflat, prior_sample(asflat(post)), nothing)\n\n# Now solve! Here we use LBFGS\nsol = solve(prob, LBFGS(); g_tol=1e-2)","category":"page"},{"location":"libs/optimization/#API","page":"ComradeOptimization","title":"API","text":"","category":"section"},{"location":"libs/optimization/","page":"ComradeOptimization","title":"ComradeOptimization","text":"CurrentModule = ComradeOptimization","category":"page"},{"location":"libs/optimization/","page":"ComradeOptimization","title":"ComradeOptimization","text":"Modules = [ComradeOptimization]\nOrder   = [:function, :type]","category":"page"},{"location":"libs/optimization/#ComradeOptimization.laplace-Tuple{SciMLBase.OptimizationProblem, Any, Vararg{Any}}","page":"ComradeOptimization","title":"ComradeOptimization.laplace","text":"laplace(prob, opt, args...; kwargs...)\n\nCompute the Laplace or Quadratic approximation to the prob or posterior. The args and kwargs are passed the the SciMLBase.solve function. This will return a Distributions.MvNormal object that approximates the posterior in the transformed space.\n\nNote the quadratic approximation is in the space of the transformed posterior not the usual parameter space. This is better for constrained problems where we may run up against a boundary.\n\n\n\n\n\n","category":"method"},{"location":"libs/optimization/#SciMLBase.OptimizationFunction-Tuple{Comrade.TransformedPosterior, Vararg{Any}}","page":"ComradeOptimization","title":"SciMLBase.OptimizationFunction","text":"SciMLBase.OptimizationFunction(post::Posterior, args...; kwargs...)\n\nConstructs a OptimizationFunction from a Comrade.TransformedPosterior object. Note that a user must transform the posterior first. This is so we know which space is most amenable to optimization.\n\n\n\n\n\n","category":"method"},{"location":"libs/dynesty/#ComradeDynesty","page":"ComradeDynesty","title":"ComradeDynesty","text":"","category":"section"},{"location":"libs/dynesty/","page":"ComradeDynesty","title":"ComradeDynesty","text":"ComradeDynesty interfaces Comrade to the excellent dynesty package, more specifically the Dynesty.jl Julia wrapper.","category":"page"},{"location":"libs/dynesty/","page":"ComradeDynesty","title":"ComradeDynesty","text":"We follow Dynesty.jl interface closely. However,  instead of having to pass a log-likelihood function and prior transform, we instead just pass a Comrade.Posterior object and Comrade takes care of defining the prior transformation and  log-likelihood for us. For more information about Dynesty.jl, please see its docs and docstrings.","category":"page"},{"location":"libs/dynesty/#Example","page":"ComradeDynesty","title":"Example","text":"","category":"section"},{"location":"libs/dynesty/","page":"ComradeDynesty","title":"ComradeDynesty","text":"using Comrade\nusing ComradeDynesty\n\n# Some stuff to create a posterior object\npost # of type Comrade.Posterior\n\n# Create sampler using 1000 live points\nsmplr = NestedSampler(dimension(post), 1000)\n\nsamples, dyres = sample(post, smplr; dlogz=1.0)\n\n# Optionally resample the chain to create an equal weighted output\nusing StatsBase\nequal_weight_chain = ComradeDynesty.equalresample(samples, 10_000)","category":"page"},{"location":"libs/dynesty/#API","page":"ComradeDynesty","title":"API","text":"","category":"section"},{"location":"libs/dynesty/","page":"ComradeDynesty","title":"ComradeDynesty","text":"CurrentModule = ComradeDynesty","category":"page"},{"location":"libs/dynesty/","page":"ComradeDynesty","title":"ComradeDynesty","text":"Modules = [ComradeDynesty]\nOrder   = [:function, :type]","category":"page"},{"location":"libs/dynesty/#StatsBase.sample-Tuple{Random.AbstractRNG, Comrade.TransformedPosterior, Union{DynamicNestedSampler, NestedSampler}}","page":"ComradeDynesty","title":"StatsBase.sample","text":"AbstractMCMC.sample(post::Comrade.Posterior, smplr::Dynesty.NestedSampler, args...; kwargs...)\nAbstractMCMC.sample(post::Comrade.Posterior, smplr::Dynesty.DynamicNestedSampler, args...; kwargs...)\n\nSample the posterior post using Dynesty.jl NestedSampler/DynamicNestedSampler sampler. The args/kwargs are forwarded to Dynesty for more information see its docs\n\nThis returns a tuple where the first element are the weighted samples from dynesty in a TypedTable. The second element includes additional information about the samples, like the log-likelihood, evidence, evidence error, and the sample weights. The final element of the tuple is the original dynesty output file.\n\nTo create equally weighted samples the user can use\n\nusing StatsBase\nchain, stats = sample(post, NestedSampler(dimension(post), 1000))\nequal_weighted_chain = sample(chain, Weights(stats.weights), 10_000)\n\n\n\n\n\n","category":"method"},{"location":"libs/nested/#ComradeNested","page":"ComradeNested","title":"ComradeNested","text":"","category":"section"},{"location":"libs/nested/","page":"ComradeNested","title":"ComradeNested","text":"ComradeNested interfaces Comrade to the excellent NestedSamplers.jl package.","category":"page"},{"location":"libs/nested/","page":"ComradeNested","title":"ComradeNested","text":"We follow NestedSamplers interface closely. The  difference is that instead of creating a NestedModel, we   pass a Comrade.Posterior object as our model. Internally, Comrade defines the prior transform and extracts the log-likelihood function.","category":"page"},{"location":"libs/nested/","page":"ComradeNested","title":"ComradeNested","text":"For more information about NestedSamplers.jl please see its docs.","category":"page"},{"location":"libs/nested/#Example","page":"ComradeNested","title":"Example","text":"","category":"section"},{"location":"libs/nested/","page":"ComradeNested","title":"ComradeNested","text":"using Comrade\nusing ComradeNested\n\n# Some stuff to create a posterior object\npost # of type Comrade.Posterior\n\n# Create sampler using 1000 live points\nsmplr = Nested(dimension(post), 1000)\n\nsamples = sample(post, smplr; d_logz=1.0)\n\n# Optionally resample the chain to create an equal weighted output\nusing StatsBase\nequal_weight_chain = ComradeNested.equalresample(samples, 10_000)","category":"page"},{"location":"libs/nested/#API","page":"ComradeNested","title":"API","text":"","category":"section"},{"location":"libs/nested/","page":"ComradeNested","title":"ComradeNested","text":"CurrentModule = ComradeNested","category":"page"},{"location":"libs/nested/","page":"ComradeNested","title":"ComradeNested","text":"Modules = [ComradeNested]\nOrder   = [:function, :type]","category":"page"},{"location":"libs/nested/#StatsBase.sample-Tuple{Random.AbstractRNG, Comrade.TransformedPosterior, Nested, Vararg{Any}}","page":"ComradeNested","title":"StatsBase.sample","text":"AbstractMCMC.sample(post::Comrade.Posterior, smplr::Nested, args...; kwargs...)\n\nSample the posterior post using NestedSamplers.jl Nested sampler. The args/kwargs are forwarded to NestedSampler for more information see its docs\n\nThis returns a tuple where the first element are the weighted samples from NestedSamplers in a TypedTable. The second element includes additional information about the samples, like the log-likelihood, evidence, evidence error, and the sample weights.\n\nTo create equally weighted samples the user can use ```julia using StatsBase chain, stats = sample(post, NestedSampler(dimension(post), 1000)) equalweightedchain = sample(chain, Weights(stats.weights), 10_000)\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade-API","page":"Comrade API","title":"Comrade API","text":"","category":"section"},{"location":"api/#Contents","page":"Comrade API","title":"Contents","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api/#Index","page":"Comrade API","title":"Index","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api/#Model-Definitions","page":"Comrade API","title":"Model Definitions","text":"","category":"section"},{"location":"api/#Calibration-Models","page":"Comrade API","title":"Calibration Models","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Comrade.corrupt\nComrade.CalTable\nComrade.caltable(::Comrade.JonesCache, ::AbstractVector)\nComrade.caltable(::Comrade.EHTObservation, ::AbstractVector)\nComrade.DesignMatrix\nComrade.JonesCache\nComrade.TransformCache\nComrade.JonesModel\nComrade.CalPrior\nComrade.CalPrior(::NamedTuple, ::JonesCache)\nComrade.CalPrior(::NamedTuple, ::NamedTuple, ::JonesCache)\nComrade.RIMEModel\nComrade.ObsSegmentation\nComrade.IntegSeg\nComrade.ScanSeg\nComrade.TrackSeg\nComrade.FixedSeg\nComrade.jonescache(::Comrade.EHTObservation, ::Comrade.ObsSegmentation)\nComrade.jonesStokes\nComrade.jonesG\nComrade.jonesD\nComrade.jonesT\nComrade.PoincareSphere2Map\nComrade.caltable\nComrade.JonesPairs","category":"page"},{"location":"api/#Comrade.corrupt","page":"Comrade API","title":"Comrade.corrupt","text":"corrupt(vis, j1, j2)\n\nCorrupts the model coherency matrices with the Jones matrices j1 for station 1 and j2 for station 2.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.CalTable","page":"Comrade API","title":"Comrade.CalTable","text":"struct CalTable{T, G<:(AbstractVecOrMat)}\n\nA Tabes of calibration quantities. The columns of the table are the telescope station codes. The rows are the calibration quantities at a specific time stamp. This user should not use this struct directly. Instead that should call caltable.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.caltable-Tuple{JonesCache, AbstractVector}","page":"Comrade API","title":"Comrade.caltable","text":"caltable(g::JonesCache, jterms::AbstractVector)\n\nConvert the JonesCache g and recovered Jones/corruption elements jterms into a CalTable which satisfies the Tables.jl interface.\n\nExample\n\nct = caltable(gcache, gains)\n\n# Access a particular station (here ALMA)\nct[:AA]\nct.AA\n\n# Access a the first row\nct[1, :]\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.caltable-Tuple{Comrade.EHTObservation, AbstractVector}","page":"Comrade API","title":"Comrade.caltable","text":"caltable(obs::EHTObservation, gains::AbstractVector)\n\nCreate a calibration table for the observations obs with gains. This returns a CalTable object that satisfies the Tables.jl interface. This table is very similar to the DataFrames interface.\n\nExample\n\nct = caltable(obs, gains)\n\n# Access a particular station (here ALMA)\nct[:AA]\nct.AA\n\n# Access a the first row\nct[1, :]\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.DesignMatrix","page":"Comrade API","title":"Comrade.DesignMatrix","text":"struct DesignMatrix{X, M<:AbstractArray{X, 2}, T, S} <: AbstractArray{X, 2}\n\nInternal type that holds the gain design matrices for visibility corruption.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.JonesCache","page":"Comrade API","title":"Comrade.JonesCache","text":"struct JonesCache{D1, D2, S, Sc} <: Comrade.AbstractJonesCache\n\nHolds the ancillary information for a the design matrix cache for Jones matrices. That is, it defines the cached map that moves from model visibilities to the corrupted voltages that are measured from the telescope.\n\nFields\n\nm1: Design matrix for the first station\n\nm2: Design matrix for the second station\n\nseg: Segmentation schemes for this cache\n\nschema: Gain Schema\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.TransformCache","page":"Comrade API","title":"Comrade.TransformCache","text":"struct TransformCache{M, B<:PolBasis} <: Comrade.AbstractJonesCache\n\nHolds various transformations that move from the measured telescope basis to the chosen on sky reference basis.\n\nFields\n\nT1: Transform matrices for the first stations\n\nT2: Transform matrices for the second stations\n\nrefbasis: Reference polarization basis\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.JonesModel","page":"Comrade API","title":"Comrade.JonesModel","text":"JonesModel(jones::JonesPairs, model, tcache::TransformCache)\nJonesModel(jones::JonesPairs, model, refbasis::PolBasis=CirBasis())\n\nConstructs a JonesModel from a jones pairs that describe the intrument model and the model which describes the on-sky polarized visibilities. The third argument can either be the tcache that converts from the model coherency basis to the instrumental basis, or just the refbasis that will be used when constructing the model coherency matrices.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.CalPrior","page":"Comrade API","title":"Comrade.CalPrior","text":"CalPrior(dists, cache::JonesCache, reference=:none)\n\nCreates a distribution for the gain priors for gain cache cache. The dists should be a NamedTuple of Distributions, where each name corresponds to a telescope or station in the observation. The resulting type is a subtype of the Distributions.AbstractDistribution so the usual Distributions interface should work.\n\nExample\n\nFor the 2017 observations of M87 a common CalPrior call is:\n\njulia> gdist = CalPrior((AA = LogNormal(0.0, 0.1),\n                   AP = LogNormal(0.0, 0.1),\n                   JC = LogNormal(0.0, 0.1),\n                   SM = LogNormal(0.0, 0.1),\n                   AZ = LogNormal(0.0, 0.1),\n                   LM = LogNormal(0.0, 1.0),\n                   PV = LogNormal(0.0, 0.1)\n                ), cache)\n\njulia> x = rand(gdist)\njulia> logdensityof(gdist, x)\n\n\n\n\n\nCalPrior(dist0::NamedTuple, dist_transition::NamedTuple, jcache::SegmentedJonesCache)\n\nConstructs a calibration prior in two steps. The first two arguments have to be a named tuple of distributions, where each name corresponds to a site. The first argument is gain prior for the first time stamp. The second argument is the segmented gain prior for each subsequent time stamp. For instance, if we have\n\ndist0 = (AA = Normal(0.0, 1.0), )\ndistt = (AA = Normal(0.0, 0.1), )\n\nthen the gain prior for first time stamp that AA obserserves will be Normal(0.0, 1.0). The next time stamp gain is the construted from\n\ng2 = g1 + ϵ1\n\nwhere ϵ1 ~ Normal(0.0, 0.1) = distt.AA, and g1 is the gain from the first time stamp. In other words distt is the uncorrelated transition probability when moving from timestamp i to timestamp i+1. For the typical pre-calibrated dataset the gain prior on distt can be tighter than the prior on dist0.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.CalPrior-Tuple{NamedTuple, JonesCache}","page":"Comrade API","title":"Comrade.CalPrior","text":"CalPrior(dists, cache::JonesCache, reference=:none)\n\nCreates a distribution for the gain priors for gain cache cache. The dists should be a NamedTuple of Distributions, where each name corresponds to a telescope or station in the observation. The resulting type is a subtype of the Distributions.AbstractDistribution so the usual Distributions interface should work.\n\nExample\n\nFor the 2017 observations of M87 a common CalPrior call is:\n\njulia> gdist = CalPrior((AA = LogNormal(0.0, 0.1),\n                   AP = LogNormal(0.0, 0.1),\n                   JC = LogNormal(0.0, 0.1),\n                   SM = LogNormal(0.0, 0.1),\n                   AZ = LogNormal(0.0, 0.1),\n                   LM = LogNormal(0.0, 1.0),\n                   PV = LogNormal(0.0, 0.1)\n                ), cache)\n\njulia> x = rand(gdist)\njulia> logdensityof(gdist, x)\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.CalPrior-Tuple{NamedTuple, NamedTuple, JonesCache}","page":"Comrade API","title":"Comrade.CalPrior","text":"CalPrior(dist0::NamedTuple, dist_transition::NamedTuple, jcache::SegmentedJonesCache)\n\nConstructs a calibration prior in two steps. The first two arguments have to be a named tuple of distributions, where each name corresponds to a site. The first argument is gain prior for the first time stamp. The second argument is the segmented gain prior for each subsequent time stamp. For instance, if we have\n\ndist0 = (AA = Normal(0.0, 1.0), )\ndistt = (AA = Normal(0.0, 0.1), )\n\nthen the gain prior for first time stamp that AA obserserves will be Normal(0.0, 1.0). The next time stamp gain is the construted from\n\ng2 = g1 + ϵ1\n\nwhere ϵ1 ~ Normal(0.0, 0.1) = distt.AA, and g1 is the gain from the first time stamp. In other words distt is the uncorrelated transition probability when moving from timestamp i to timestamp i+1. For the typical pre-calibrated dataset the gain prior on distt can be tighter than the prior on dist0.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.RIMEModel","page":"Comrade API","title":"Comrade.RIMEModel","text":"abstract type RIMEModel <: ComradeBase.AbstractModel\n\nAbstract type that encompasses all RIME style corruptions.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ObsSegmentation","page":"Comrade API","title":"Comrade.ObsSegmentation","text":"abstract type ObsSegmentation\n\nThe data segmentation scheme to use. This is important for constructing a JonesCache\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.IntegSeg","page":"Comrade API","title":"Comrade.IntegSeg","text":"struct IntegSeg{S} <: Comrade.ObsSegmentation\n\nData segmentation such that the quantity is constant over a correlation integration.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ScanSeg","page":"Comrade API","title":"Comrade.ScanSeg","text":"struct ScanSeg{S} <: Comrade.ObsSegmentation\n\nData segmentation such that the quantity is constant over a scan.\n\nWarning\n\nCurrently we do not explicity track the telescope scans. This will be fixed in a future version. Right now ScanSeg and TrackSeg are the same\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.TrackSeg","page":"Comrade API","title":"Comrade.TrackSeg","text":"struct TrackSeg <: Comrade.ObsSegmentation\n\nData segmentation such that the quantity is constant over a track, i.e., the observation \"night\".\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.FixedSeg","page":"Comrade API","title":"Comrade.FixedSeg","text":"struct FixedSeg{T} <: Comrade.ObsSegmentation\n\nEnforces that the station calibraton value will have a fixed value. This is most commonly used when enforcing a reference station for gain phases.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.jonescache-Tuple{Comrade.EHTObservation, Comrade.ObsSegmentation}","page":"Comrade API","title":"Comrade.jonescache","text":"jonescache(obs::EHTObservation, segmentation::ObsSegmentation)\njonescache(obs::EHTObservatoin, segmentation::NamedTuple)\n\nConstructs a JonesCache from a given observation obs using the segmentation scheme segmentation. If segmentation is a named tuple it is assumed that each symbol in the named tuple corresponds to a segmentation for thes sites in obs.\n\nExample\n\n# coh is a EHTObservation\njulia> jonescache(coh, ScanSeg())\njulia> segs = (AA = ScanSeg(), AP = TrachSeg(), AZ=FixedSegSeg())\njulia> jonescache(coh, segs)\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.jonesStokes","page":"Comrade API","title":"Comrade.jonesStokes","text":"jonesStokes(g1::AbstractArray, gcache::AbstractJonesCache)\njonesStokes(f, g1::AbstractArray, gcache::AbstractJonesCache)\n\nConstruct the Jones Pairs for the stokes I image only. That is, we only need to pass a single vector corresponding to the gain for the stokes I visibility. This is for when you only want to image Stokes I. The first argument is optional and denotes a function that is applied to every element of jones cache. For instance if g1 and g2 are the log-gains then f=exp will convert them into the gains.\n\nWarning\n\nIn the future this functionality may be removed when stokes I fitting is replaced with the more correct trace(coherency), i.e. RR+LL for a circular basis.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.jonesG","page":"Comrade API","title":"Comrade.jonesG","text":"jonesG(g1::AbstractVector, g2::AbstractVector, jcache::AbstractJonesCache)\njonesG(f, g1::AbstractVector, g2::AbstractVector, jcache::AbstractJonesCache)\n\nConstructs the pairs Jones G matrices for each pair of stations. The g1 are the gains for the first polarization basis and g2 are the gains for the other polarization. The first argument is optional and denotes a function that is applied to every element of jones cache. For instance if g1 and g2 are the log-gains then f=exp will convert them into the gains.\n\nThe layout for each matrix is as follows:\n\n    g1 0\n    0  g2\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.jonesD","page":"Comrade API","title":"Comrade.jonesD","text":"jonesD(d1::AbstractVector, d2::AbstractVector, jcache::AbstractJonesCache)\njonesD(f, d1::AbstractVector, d2::AbstractVector, jcache::AbstractJonesCache)\n\nConstructs the pairs Jones D matrices for each pair of stations. The d1 are the d-termsfor the first polarization basis and d2 are the d-terms for the other polarization. The first argument is optional and denotes a function that is applied to every element of jones cache. For instance if d1 and d2 are the log-dterms then f=exp will convert them into the dterms.\n\nThe layout for each matrix is as follows:\n\n    1  d1\n    d2 1\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.jonesT","page":"Comrade API","title":"Comrade.jonesT","text":"jonesT(tcache::TransformCache)\n\nReturns a JonesPair of matrices that transform from the model coherency matrices basis to the on-sky coherency basis, this includes the feed rotation and choice of polarization feeds.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.PoincareSphere2Map","page":"Comrade API","title":"Comrade.PoincareSphere2Map","text":"PoincareSphere2Map(I, p, X, grid)\nPoincareSphere2Map(I::IntensityMap, p, X)\n\nConstructs an polarized intensity map model using the Poincare parameterization. The arguments are:\n\nI is a grid of fluxes for each pixel.\np is a grid of numbers between 0, 1 and the represent the total fractional polarization\nX is a grid, where each element is 3 numbers that represents the point on the Poincare sphere that is, X[1,1] is a NTuple{3} such that ||X[1,1]|| == 1.\ngrid is the dimensional grid that gives the pixels locations of the intensity map.\n\nnote: Note\nIf I is an IntensityMap then grid is not required since the same grid that was use for I will be used to construct the polarized intensity map\n\nwarning: Warning\nThe return type for this function is a polarized image object, however what we return is not considered to be part of the stable API so it may change suddenly.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.caltable","page":"Comrade API","title":"Comrade.caltable","text":"caltable(args...)\n\nCreates a calibration table from a set of arguments. The specific arguments depend on what calibration you are applying.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.JonesPairs","page":"Comrade API","title":"Comrade.JonesPairs","text":"struct JonesPairs{T, M1<:AbstractArray{T, 1}, M2<:AbstractArray{T, 1}}\n\nHolds the pairs of Jones matrices for the first and second station of a baseline.\n\nFields\n\nm1: Vector of jones matrices for station 1\n\nm2: Vector of jones matrices for station 2\n\n\n\n\n\n","category":"type"},{"location":"api/#Combinators","page":"Comrade API","title":"Combinators","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Base.:+(::Comrade.AbstractModel, ::Comrade.AbstractModel)\nComrade.added\nComrade.convolved\nComrade.components\nComrade.smoothed\nComrade.CompositeModel\nComrade.AddModel\nComrade.ConvolvedModel","category":"page"},{"location":"api/#Base.:+-Tuple{ComradeBase.AbstractModel, ComradeBase.AbstractModel}","page":"Comrade API","title":"Base.:+","text":"Base.:+(m1::AbstractModel, m2::AbstractModel)\n\nCombine two models to create a composite AddModel. This adds two models pointwise, i.e.\n\njulia> m1 = Gaussian()\njulia> m2 = Disk()\njulia> visibility(m1+m2, 1.0, 1.0) == visibility(m1, 1.0, 1.0) + visibility(m2, 1.0, 1.0)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.added","page":"Comrade API","title":"Comrade.added","text":"added(m1::AbstractModel, m2::AbstractModel)\n\nCombine two models to create a composite AddModel. This adds two models pointwise, i.e.\n\njulia> m1 = Gaussian()\njulia> m2 = Disk()\njulia> visibility(added(m1,m2), 1.0, 1.0) == visibility(m1, 1.0, 1.0) + visibility(m2, 1.0, 1.0)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.convolved","page":"Comrade API","title":"Comrade.convolved","text":"convolved(m1::AbstractModel, m2::AbstractModel)\n\nConvolve two models to create a composite ConvolvedModel.\n\njulia> m1 = Ring()\njulia> m2 = Disk()\njulia> convolved(m1, m2)\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.components","page":"Comrade API","title":"Comrade.components","text":"components(m::AbstractModel)\n\nReturns the model components for a composite model. This will return a Tuple with all the models you have constructed.\n\nExample\n\njulia> m = Gaussian() + Disk()\njulia> components(m)\n(Gaussian{Float64}(), Disk{Float64}())\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.smoothed","page":"Comrade API","title":"Comrade.smoothed","text":"smoothed(m::AbstractModel, σ::Number)\n\nSmooths a model m with a Gaussian kernel with standard deviation σ.\n\nNotes\n\nThis uses convolved to created the model, i.e.\n\njulia> m1 = Disk()\njulia> m2 = Gaussian()\njulia> convolved(m1, m2) == smoothed(m1, 1.0)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.CompositeModel","page":"Comrade API","title":"Comrade.CompositeModel","text":"abstract type CompositeModel{M1, M2} <: ComradeBase.AbstractModel\n\nAbstract type that denotes a composite model. Where we have combined two models together.\n\nImplementation\n\nAny implementation of a composite type must define the following methods:\n\nvisibility_point\nuv_combinator\nimanalytic\nvisanalytic\nComradeBase.intensity_point if model intensity is IsAnalytic\nintensitymap_numeric! if model intensity is NotAnalytic\nintensitymap_numeric if model intensity is NotAnalytic\nflux\nradialextent\n\nIn addition there are additional optional methods a person can define if needed:\n\nintensitymap_analytic! if model intensity is IsAnalytic  (optional)\nintensitymap_analytic if model intensity is IsAnalytic (optional)\nvisibilities_analytic if visanalytic is IsAnalytic (optional)\nvisibilities_numeric  if visanalytic is Not Analytic (optional)\nvisibilities_analytic! if visanalytic is IsAnalytic (optional)\nvisibilities_numeric!  if visanalytic is Not Analytic (optional)\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.AddModel","page":"Comrade API","title":"Comrade.AddModel","text":"struct AddModel{T1, T2} <: Comrade.CompositeModel{T1, T2}\n\nPointwise addition of two models in the image and visibility domain. An end user should instead call added or Base.+ when constructing a model\n\nExample\n\njulia> m1 = Disk() + Gaussian()\njulia> m2 = added(Disk(), Gaussian()) + Ring()\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ConvolvedModel","page":"Comrade API","title":"Comrade.ConvolvedModel","text":"struct ConvolvedModel{M1, M2} <: Comrade.CompositeModel{M1, M2}\n\nPointwise addition of two models in the image and visibility domain. An end user should instead call convolved. Also see smoothed(m, σ) for a simplified function that convolves a model m with a Gaussian with standard deviation σ.\n\n\n\n\n\n","category":"type"},{"location":"api/#Geometric-and-Image-Models","page":"Comrade API","title":"Geometric and Image Models","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Comrade.GeometricModel\nComrade.ConcordanceCrescent\nComrade.Crescent\nComrade.Disk\nComrade.SlashedDisk\nComrade.ExtendedRing\nComrade.Gaussian\nComrade.MRing\nComrade.Ring\nComrade.ParabolicSegment\nComrade.ContinuousImage\nComrade.ZeroModel","category":"page"},{"location":"api/#Comrade.GeometricModel","page":"Comrade API","title":"Comrade.GeometricModel","text":"abstract type GeometricModel <: ComradeBase.AbstractModel\n\nA type that defines it is a geometric model. These are usually primitive models, and are usually analytic in Fourier and the image domain. As a result a user only needs to implement the following methods\n\nvisibility_point\nintensity_point\nradialextent\n\nNote that if the geometric model isn't analytic then the usual methods listed in Comrade.AbstractModel for non-analytic models need to be implemented.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ConcordanceCrescent","page":"Comrade API","title":"Comrade.ConcordanceCrescent","text":"struct ConcordanceCrescent{T} <: Comrade.GeometricModel\n\nCreates the ConcordanceCrescent model, i.e. a flat-top crescent with a displacment and a slash and shadow depth. Note this creates a crescent with unit flux. If you want a different flux please use the renomed modifier.\n\nFields\n\nrouter: Outer radius of the crescent\n\nrinner: Inner radius of the crescent (i.e. inside this radius there is a hole)\n\nshift: Displacment of the inner disk radius\n\nslash: Strength of the linear slash. Note that s∈[0.0,1.0] to ensure positivity in the image.\n\nNotes\n\nUnlike the Gaussian and Disk models this does not create the unit version. In fact, this model could have been created using the Disk and primitives by using Comrade.jl's model composition functionality.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.Crescent","page":"Comrade API","title":"Comrade.Crescent","text":"Creates a Kamruddin and Dexter crescent model. This works by composing two disk models together.\n\nArguments\n\nrouter: The radius of the outer disk\nrinner: The radius of the inner disk\nshift: How much the inner disk radius is shifted (positive is to the right)\nfloor: The floor of the inner disk 0 means the inner intensity is zero and 1 means it is a large disk.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.Disk","page":"Comrade API","title":"Comrade.Disk","text":"Disk{T}() where {T}\n\nTophat disk geometrical model, i.e. the intensity profile\n\n    I(xy) = begincases pi^-1  x^2+y^2  1  0  x^2+y^2 geq 0 endcases\n\ni.e. a unit radius and unit flux disk.\n\nBy default if T isn't given, Disk defaults to Float64\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.SlashedDisk","page":"Comrade API","title":"Comrade.SlashedDisk","text":"SlashedDisk{T}(slash::T) where {T}\n\nTophat disk geometrical model, i.e. the intensity profile\n\n    I(xy) = begincases pi^-1  x^2+y^2  1  0  x^2+y^2 geq 0 endcases\n\ni.e. a unit radius and unit flux disk.\n\nBy default if T isn't given, Disk defaults to Float64\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ExtendedRing","page":"Comrade API","title":"Comrade.ExtendedRing","text":"struct ExtendedRing{F<:Number} <: Comrade.GeometricModel\n\nA symmetric extended ring whose radial profile follows an inverse gamma distributions.\n\nThe formula in the image domain is given by\n\nI(r,θ) = βᵅrᵅ⁻²exp(-β/r)/2πΓ(α)\n\nwhere α = shape and β = shape+1\n\nNote\n\nWe mainly use this as an example of a non-analytic Fourier transform (although it has a complicated expression)\n\nFields\n\nshape: shape of the radial distribution\n\nNote that if T isn't specified at construction then it defaults to Float64.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.Gaussian","page":"Comrade API","title":"Comrade.Gaussian","text":"struct Gaussian{T} <: Comrade.GeometricModel\n\nGaussian with unit standard deviation and flux.\n\nBy default if T isn't given, Gaussian defaults to Float64\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.MRing","page":"Comrade API","title":"Comrade.MRing","text":"struct MRing{T, V<:Union{AbstractArray{T, 1}, Tuple{Vararg{T, N}} where {N, T}}} <: Comrade.GeometricModel\n\nm-ring geometric model. This is a infinitely thin unit flux delta ring whose angular structure is given by a Fourier expansion. That is,\n\nI(r,θ) = (2π)⁻¹δ(r-1)∑ₙ(αₙcos(nθ) - βₙsin(nθ))\n\nThe N in the type defines the order of the Fourier expansion.\n\nFields\n\nα: Real Fourier mode coefficients\n\nβ: Imaginary Fourier mode coefficients\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.Ring","page":"Comrade API","title":"Comrade.Ring","text":"struct Ring{T} <: Comrade.GeometricModel\n\nA infinitely thin ring model, whose expression in the image domain is     I(r,θ) = δ(r - 1)/2π i.e. a unit radius and flux delta ring.\n\nBy default if T isn't given, Gaussian defaults to Float64\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ParabolicSegment","page":"Comrade API","title":"Comrade.ParabolicSegment","text":"struct ParabolicSegment{T} <: Comrade.GeometricModel\n\nA infinitely thin parabolic segment in the image domain. The segment is centered at zero, with roots ±1 and a yintercept of 1.\n\nNote that if T isn't specified at construction then it defaults to Float64.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ContinuousImage","page":"Comrade API","title":"Comrade.ContinuousImage","text":"ContinuousImage{A<:IntensityMap, P} <: AbstractModel\nContinuousImage(img::Intensitymap, kernel)\n\nThe basic continuous image model for Comrade. This expects a IntensityMap style object as its imag as well as a image kernel or pulse that allows you to evaluate the image at any image and visibility location. The image model is\n\nI(x,y) = ∑ᵢ Iᵢⱼ κ(x-xᵢ, y-yᵢ)\n\nwhere Iᵢⱼ are the flux densities of the image img and κ is the intensity function for the kernel.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ZeroModel","page":"Comrade API","title":"Comrade.ZeroModel","text":"struct ZeroModel{T} <: ComradeBase.AbstractModel\n\nDefines a model that is empty that is it return zero for everything.\n\nNotes\n\nThis returns 0 by using FillArrays so everything should be non-allocating\n\n\n\n\n\n","category":"type"},{"location":"api/#Image-Pulses","page":"Comrade API","title":"Image Pulses","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Comrade.Pulse\nComrade.DeltaPulse\nComrade.BSplinePulse\nComrade.RaisedCosinePulse\nComrade.BicubicPulse\nComrade.Butterworth","category":"page"},{"location":"api/#Comrade.Pulse","page":"Comrade API","title":"Comrade.Pulse","text":"Pulse\n\nPixel response function for a radio image model. This makes a discrete sampling continuous by picking a certain smoothing kernel for the image.\n\nNotes\n\nTo see the implemented Pulses please use the subtypes function i.e. subtypes(Pulse)\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.DeltaPulse","page":"Comrade API","title":"Comrade.DeltaPulse","text":"struct DeltaPulse{T} <: Comrade.Pulse\n\nA dirac comb pulse function. This means the image is just the dicrete Fourier transform\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.BSplinePulse","page":"Comrade API","title":"Comrade.BSplinePulse","text":"$(TYPEDEF)\n\nUses the basis spline (BSpline) kernel of order N. These are the kernel that come from recursively convolving the tophat kernel\n\n    B_0(x) = begincases 1  x  1  0  otherwise endcases\n\nN times.\n\nNotes\n\nBSpline kernels have a number of nice properties:\n\nSimple frequency response sinc(u2)^N\npreserve total intensity\n\nFor N>1 these kernels aren't actually interpolation kernels however, this doesn't matter for us.\n\nCurrently only the 0,1,3 order kernels are implemented.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.RaisedCosinePulse","page":"Comrade API","title":"Comrade.RaisedCosinePulse","text":"struct RaisedCosinePulse{T} <: Comrade.Pulse\n\nRaisedCosinePulse()\nRaisedCosinePulse(rolloff)\n\nRaised cosine pulse function. This tends to be a very flat response, where the roll off controls the speed of decay. By default we set rolloff = 0.5.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.BicubicPulse","page":"Comrade API","title":"Comrade.BicubicPulse","text":"struct BicubicPulse{T} <: Comrade.Pulse\n\nBicubicPulse(b = 0.5)\n\nThe bicubic pulse for imaging. This pulse tends to have a flat spectrum but for most values of b can produce negative intensities in an image. This is the pulse used in Broderick et al. 2020.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.Butterworth","page":"Comrade API","title":"Comrade.Butterworth","text":"Butterworth{N}()\nButterworth{N, T}()\n\nConstruct a model that corresponds to the Butterworth filter of order N. The type of the output is given by T and if not given defaults to Float64\n\n\n\n\n\n","category":"type"},{"location":"api/#Model-Image-(non-analytic-FFT)","page":"Comrade API","title":"Model Image (non analytic FFT)","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Comrade.create_cache\nComrade.update_cache\nComrade.modelimage\nComrade.uviterator\nComrade.fouriermap\nComrade.ModelImage\nComrade.DFTAlg\nComrade.DFTAlg(::Comrade.EHTObservation)\nComrade.DFTAlg(::AbstractArray, ::AbstractArray)\nComrade.DFTAlg(::Comrade.ArrayConfiguration)\nComrade.FFTAlg\nComrade.FFTCache\nComrade.NFFTAlg\nComrade.NUFTCache\nComrade.ObservedNUFT","category":"page"},{"location":"api/#Comrade.create_cache","page":"Comrade API","title":"Comrade.create_cache","text":"create_cache(alg::AbstractFourierTransform, img::AbstractIntensityMap)\n\nCreates a Fourier transform cache for a img using algorithm alg. For non-analytic visibility models this can significantly speed up computations.\n\nExamples\n\njulia> u,v = rand(100), rand(100)\njulia> cache = create_cache(DFTAlg(u, v), IntensityMap(randn(50,50), 10.0, 10.0))\njulia> cache = create_cache(NFFTAlg(u, v), IntensityMap(randn(50,50), 10.0, 10.0))\njulia> cache = create_cache(FFTAlg(), IntensityMap(randn(50,50), 10.0, 10.0))\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.update_cache","page":"Comrade API","title":"Comrade.update_cache","text":"update_cache(cache, img)\n\nUpdate the Fourier transform cache. This will reuse an FFT/NFFT plan saving some computational time.\n\nNote\n\nThis is an intenal method than an end user shouldn't have to usually call.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.modelimage","page":"Comrade API","title":"Comrade.modelimage","text":"modelimage(model::AbstractModel, image::AbstractIntensityMap, alg=FFTAlg())\n\nConstruct a ModelImage from a model, image and the optionally specified visibility algorithm alg\n\nNotes\n\nFor analytic models this is a no-op and returns the model. For non-analytic models this creates a ModelImage object which uses alg to compute the non-analytic Fourier transform.\n\n\n\n\n\nmodelimage(model, cache::AbstractCach))\n\nConstruct a ModelImage from the model and using a precompute Fourier transform cache. You can optionally specify th which will compute the internal image buffer using the`.\n\nExample\n\njulia> m = ExtendedRing(10.0)\njulia> cache = create_cache(DFTAlg(), IntensityMap(zeros(128, 128), 50.0, 50.0)) # used threads to make the image\njulia> mimg = modelimage(m, cache, true)\n\nNotes\n\nFor analytic models this is a no-op and returns the model.\n\n\n\n\n\nmodelimage(m;\n           fovx=2*radialextent(m),\n           fovy=2*radialextent(m),\n           nx=512,\n           ny=512,\n           alg=FFTAlg(),\n           pulse=ComradeBase.DeltaPulse(),\n            )\n\nConstruct a ModelImage where just the model m is specified.\n\nIf fovx or fovy aren't given modelimage will guess a reasonable field of view based on the radialextent function. nx and ny are the number of pixels in the x and y direction. The pulse is the pulse used for the image and alg\n\nNotes\n\nFor analytic models this is a no-op and returns the model.\n\n\n\n\n\nmodelimage(img::ContinuousImage, alg=NFFTAlg())\n\nCreate a model image directly using an image, i.e. treating it as the model. You can optionally specify the Fourier transform algorithm using alg\n\n\n\n\n\nmodelimage(img::ContinuousImage, cache::AbstractCache)\n\nCreate a model image directly using an image, i.e. treating it as the model. Additionally reuse a previously compute image cache. This can be used when directly modeling an image of a fixed size and number of pixels.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.uviterator","page":"Comrade API","title":"Comrade.uviterator","text":"uviterator(nx, dx, ny dy)\n\nConstruct the u,v iterators for the Fourier transform of the image with pixel sizes dx, dy and number of pixels nx, ny\n\nIf you are extending Fourier transform stuff please use these functions to ensure that the centroid is being properly computed.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.fouriermap","page":"Comrade API","title":"Comrade.fouriermap","text":"fouriermap(m, x)\n\nCreate a Fourier or visibility map of a model m where the image is specified in the image domain by the pixel locations x and y\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.ModelImage","page":"Comrade API","title":"Comrade.ModelImage","text":"struct ModelImage{M, I, C} <: Comrade.AbstractModelImage{M}\n\nContainer for non-analytic model that contains a image cache which will hold the image, a Fourier transform cache, which usually an instance of a <: FourierCache.\n\nNote\n\nThis is an internal implementation detail that shouldn't usually be called directly. Instead the user should use the exported function modelimage, for example\n\nusing Comrade\nm = ExtendedRing(20.0, 5.0)\n\n# This creates an version where the image is dynamically specified according to the\n# radial extent of the image\nmimg = modelimage(m) # you can also optionally pass the number of pixels nx and ny\n\n# Or you can create an IntensityMap\nimg = intensitymap(m, 100.0, 100.0, 512, 512)\nmimg = modelimage(m, img)\n\n# Or precompute a cache\ncache = create_cache(FFTAlg(), img)\nmimg = modelimage(m, cache)\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.DFTAlg","page":"Comrade API","title":"Comrade.DFTAlg","text":"DFTAlg\n\nUses a discrete fourier transform. This is not very efficient for larger images. In those cases  NFFTAlg or FFTAlg are more reasonable. For small images this is a reasonable choice especially since it's easy to define derivatives.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.DFTAlg-Tuple{Comrade.EHTObservation}","page":"Comrade API","title":"Comrade.DFTAlg","text":"DFTAlg(obs::EHTObservation)\n\nCreate an algorithm object using the direct Fourier transform object from the observation obs. This will extract the uv positions from the observation to allow for a more efficient FT cache.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.DFTAlg-Tuple{AbstractArray, AbstractArray}","page":"Comrade API","title":"Comrade.DFTAlg","text":"DFTAlg(u::AbstractArray, v::AbstractArray)\n\nCreate an algorithm object using the direct Fourier transform object using the uv positions u, v allowing for a more efficient transform.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.DFTAlg-Tuple{Comrade.ArrayConfiguration}","page":"Comrade API","title":"Comrade.DFTAlg","text":"DFTAlg(ac::ArrayConfiguration)\n\nCreate an algorithm object using the direct Fourier transform object from the array configuration ac. This will extract the uv positions from the observation to allow for a more efficient FT cache.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.FFTAlg","page":"Comrade API","title":"Comrade.FFTAlg","text":"struct FFTAlg <: Comrade.FourierTransform\n\nUse an FFT to compute the approximate numerical visibilities of a model. For a DTFT see DFTAlg or for an NFFT NFFTAlg\n\nFields\n\npadfac: The amount to pad the image by. Note we actually round up to the nearest factor of 2, but this will be improved in the future to use small primes\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.FFTCache","page":"Comrade API","title":"Comrade.FFTCache","text":"struct FFTCache{A<:FFTAlg, P, I, Pu, S} <: Comrade.AbstractCache\n\nThe cache used when the FFT algorithm is used to compute visibilties. This is an internal type and is not part of the public API\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.NFFTAlg","page":"Comrade API","title":"Comrade.NFFTAlg","text":"NFFTAlg\n\nUses a non-uniform FFT to compute the visibilities. You can optionally pass uv which are the uv positions you will compute the NFFT at. This can allow for the NFFT plan to be cached improving performance\n\nFields\n\npadfac: Amount to pad the image\n\nm: Kernel size parameters. This controls the accuracy of NFFT you do not usually need to change this\n\nσ: Over sampling factor. This controls the accuracy of NFFT you do not usually need to change this.\n\nwindow: Window function for the NFFT. You do not usually need to change this\n\nprecompute: NFFT interpolation algorithm. TENSOR is the fastest but takes the longest to precompute\n\nblocking: Flag blcok partioning should be used to speed up computation\n\nsortNodes: Flag if the node should be sorted in a lexicographic way\n\nstoreDeconvolutionIdx: Flag if the deconvolve indices should be stored, Currently required for GPU\n\nfftflags: Flag passed to inner AbstractFFT. The fastest FFTW is FFTW.MEASURE but takes the longest to precompute\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.NUFTCache","page":"Comrade API","title":"Comrade.NUFTCache","text":"struct NUFTCache{A, P, M, PI, I} <: Comrade.AbstractCache\n\nInternal type used to store the cache for a non-uniform Fourier transform (NUFT).\n\nThe user should instead create this using the create_cache function.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ObservedNUFT","page":"Comrade API","title":"Comrade.ObservedNUFT","text":"struct ObservedNUFT{A<:Comrade.NUFT, T} <: Comrade.NUFT\n\nContainer type for a non-uniform Fourier transform (NUFT). This stores the uv-positions that the model will be sampled at in the Fourier domain, allowing certain transformtion factors (e.g., NUFT matrix) to be cached.\n\nThis is an internal type, an end user should instead create this using NFFTAlg or DFTAlg.\n\n\n\n\n\n","category":"type"},{"location":"api/#Modifiers","page":"Comrade API","title":"Modifiers","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Comrade.basemodel\nComrade.unmodified\nComrade.renormed\nComrade.rotated\nComrade.posangle\nComrade.shifted\nComrade.stretched\nComrade.ModifiedModel\nComrade.ModelModifiers\nComrade.Stretch\nComrade.Shift\nComrade.Rotate\nComrade.Renormalize","category":"page"},{"location":"api/#Comrade.basemodel","page":"Comrade API","title":"Comrade.basemodel","text":"basemodel(model::ModifiedModel)\n\nReturns the ModifiedModel with the last transformation stripped.\n\nExample\n\njulia> basemodel(stretched(Disk(), 1.0, 2.0)) == Disk()\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.unmodified","page":"Comrade API","title":"Comrade.unmodified","text":"unmodified(model::ModifiedModel)\n\nReturns the un-modified model\n\nExample\n\njulia> m = stretched(rotated(Gaussian(), π/4), 2.0, 1.0)\njulia> umodified(m) == Gaussian()\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.renormed","page":"Comrade API","title":"Comrade.renormed","text":"renormed(model, f)\n\n\nRenormalizes the model m to have total flux f*flux(m). This can also be done directly by calling Base.:* i.e.,\n\njulia> renormed(m, f) == f*M\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.rotated","page":"Comrade API","title":"Comrade.rotated","text":"rotated(model, ξ)\n\n\nRotates the model by an amount ξ in radians in the clockwise direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.posangle","page":"Comrade API","title":"Comrade.posangle","text":"posangle(model)\n\n\nReturns the rotation angle of the rotated model\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.shifted","page":"Comrade API","title":"Comrade.shifted","text":"shifted(model, Δx, Δy)\n\n\nShifts the model m in the image domain by an amount Δx,Δy in the x and y directions respectively.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.stretched","page":"Comrade API","title":"Comrade.stretched","text":"stretched(model, α, β)\n\n\nStretches the model m according to the formula     Iₛ(x,y) = 1/(αβ) I(x/α, y/β), where were renormalize the intensity to preserve the models flux.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.ModifiedModel","page":"Comrade API","title":"Comrade.ModifiedModel","text":"struct ModifiedModel{M<:ComradeBase.AbstractModel, T<:Tuple} <: ComradeBase.AbstractModel\n\nContainer type for models that have been transformed in some way. For a list of potential modifiers or transforms see subtypes(ModelModifiers).\n\nFields\n\nmodel: base model\ntransform: model transforms\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.Stretch","page":"Comrade API","title":"Comrade.Stretch","text":"struct Stretch{T} <: Comrade.ModelModifier\n\nStretched the model in the x and y directions, i.e. the new intensity is     Iₛ(x,y) = 1/(αβ) I(x/α, y/β), where were renormalize the intensity to preserve the models flux.\n\nAn end user should not call this directly but instead the stretched function instead.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.Shift","page":"Comrade API","title":"Comrade.Shift","text":"struct Shift{T} <: Comrade.ModelModifier\n\nShifts the model by Δx units in the x-direction and Δy units in the y-direction.\n\nAn end user should not call this directly but instead the shifted function instead.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.Rotate","page":"Comrade API","title":"Comrade.Rotate","text":"struct Rotate{T} <: Comrade.ModelModifier\n\nType for the rotated model. This is more fine grained constrol of rotated model.\n\nAn end user should not call this directly but instead the rotated function instead.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.Renormalize","page":"Comrade API","title":"Comrade.Renormalize","text":"struct Renormalize{T} <: Comrade.ModelModifier\n\nRenormalizes the flux of the model to the new value scale*flux(model). We have also overloaded the Base.:* operator as syntactic sugar although I may get rid of this.\n\nAn end user should not call this directly but instead the renormed function or Base.:* instead.\n\nExample\n\njulia> renormed(Gaussian(), 2.0) == 2.0*Gaussian()\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api/#Polarized-Models","page":"Comrade API","title":"Polarized Models","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"ComradeBase.mbreve\nComradeBase.evpa(pimg::ComradeBase.AbstractPolarizedModel, p)\nComrade.PolarizedModel","category":"page"},{"location":"api/#ComradeBase.mbreve","page":"Comrade API","title":"ComradeBase.mbreve","text":"mbreve(pimg, p)\n\n\nExplicit m̆ function used for convenience.\n\n\n\n\n\n","category":"function"},{"location":"api/#ComradeBase.evpa-Tuple{ComradeBase.AbstractPolarizedModel, Any}","page":"Comrade API","title":"ComradeBase.evpa","text":"evpa(pimg::AbstractPolarizedModel, p)\n\nelectric vector position angle or EVPA of the polarized model pimg at u and v\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.PolarizedModel","page":"Comrade API","title":"Comrade.PolarizedModel","text":"struct PolarizedModel{TI, TQ, TU, TV} <: ComradeBase.AbstractPolarizedModel\n\nWrapped model for a polarized model. This uses the stokes representation of the image.\n\nFields\n\nI: Stokes I model\n\nQ: Stokes Q Model\n\nU: Stokes U Model\n\nV: Stokes V Model\n\n\n\n\n\n","category":"type"},{"location":"api/#Model-Evaluation","page":"Comrade API","title":"Model Evaluation","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"For more docstrings on how to evaluate models see ComradeBase API.","category":"page"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Comrade.amplitude\nComrade.amplitudes\nComrade.bispectra\nComrade.bispectrum\nComrade.closure_phase\nComrade.closure_phases\nComrade.logclosure_amplitude\nComrade.logclosure_amplitudes\nComrade.visibility","category":"page"},{"location":"api/#Comrade.amplitude","page":"Comrade API","title":"Comrade.amplitude","text":"amplitude(d::EHTVisibilityDatum)\n\nGet the amplitude of a visibility datum\n\n\n\n\n\namplitude(d::EHTVisibilityAmplitudeDatum)\n\nGet the amplitude of a amplitude datum\n\n\n\n\n\namplitude(model, p)\n\nComputes the visibility amplitude of model m at the coordinate p. The coordinate p is expected to have the properties U, V, and sometimes Ti and Fr.\n\nIf you want to compute the amplitudes at a large number of positions consider using the amplitudes function.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.amplitudes","page":"Comrade API","title":"Comrade.amplitudes","text":"amplitudes(m::AbstractModel, u::AbstractArray, v::AbstractArray)\n\nComputes the visibility amplitudes of the model m at the coordinates p. The coordinates p are expected to have the properties U, V, and sometimes Ti and Fr.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.bispectra","page":"Comrade API","title":"Comrade.bispectra","text":"bispectra(m, p1, p2, p3)\n\nComputes the closure phases of the model m at the triangles p1, p2, p3, where pi are coordinates.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.bispectrum","page":"Comrade API","title":"Comrade.bispectrum","text":"bispectrum(d1::T, d2::T, d3::T) where {T<:EHTVisibilityDatum}\n\nFinds the bispectrum of three visibilities. We will assume these form closed triangles, i.e. the phase of the bispectrum is a closure phase.\n\n\n\n\n\nbispectrum(model, p1, p2, p3)\n\nComputes the complex bispectrum of model m at the uv-triangle p1 -> p2 -> p3\n\nIf you want to compute the bispectrum over a number of triangles consider using the bispectra function.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.closure_phase","page":"Comrade API","title":"Comrade.closure_phase","text":"closure_phase(D1::EHTVisibilityDatum,\n              D2::EHTVisibilityDatum,\n              D3::EHTVisibilityDatum\n              )\n\nComputes the closure phase of the three visibility datums.\n\nNotes\n\nWe currently use the high SNR Gaussian error approximation for the closure phase. In the future we may use the moment matching from Monte Carlo sampling.\n\n\n\n\n\nclosure_phase(model, p1, p2, p3, p4)\n\nComputes the closure phase of model m at the uv-triangle u1,v1 -> u2,v2 -> u3,v3\n\nIf you want to compute closure phases over a number of triangles consider using the closure_phases function.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.closure_phases","page":"Comrade API","title":"Comrade.closure_phases","text":"closure_phases(m,\n               p1::AbstractArray\n               p2::AbstractArray\n               p3::AbstractArray\n               )\n\nComputes the closure phases of the model m at the triangles p1, p2, p3, where pi are coordinates.\n\n\n\n\n\nclosure_phases(m::AbstractModel, ac::ClosureConfig)\n\nComputes the closure phases of the model m using the array configuration ac.\n\nNotes\n\nThis is faster than the closure_phases(m, u1, v1, ...) method since it only computes as many visibilities as required thanks to the closure design matrix formalism from Blackburn et al.[1]\n\n[1]: Blackburn L., et al \"Closure Statistics in Interferometric Data\" ApJ 2020\n\n\n\n\n\nclosure_phases(vis::AbstractArray, ac::ArrayConfiguration)\n\nCompute the closure phases for a set of visibilities and an array configuration\n\nNotes\n\nThis uses a closure design matrix for the computation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.logclosure_amplitude","page":"Comrade API","title":"Comrade.logclosure_amplitude","text":"logclosure_amplitude(model, p1, p2, p3, p4)\n\nComputes the log-closure amplitude of model m at the uv-quadrangle u1,v1 -> u2,v2 -> u3,v3 -> u4,v4 using the formula\n\nC = logleftfracV(u1v1)V(u2v2)V(u3v3)V(u4v4)right\n\nIf you want to compute log closure amplitudes over a number of triangles consider using the logclosure_amplitudes function.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.logclosure_amplitudes","page":"Comrade API","title":"Comrade.logclosure_amplitudes","text":"logclosure_amplitudes(m::AbstractModel,\n                      p1,\n                      p2,\n                      p3,\n                      p4\n                     )\n\nComputes the log closure amplitudes of the model m at the quadrangles p1, p2, p3, p4.\n\n\n\n\n\nlogclosure_amplitudes(m::AbstractModel, ac::ClosureConfig)\n\nComputes the log closure amplitudes of the model m using the array configuration ac.\n\nNotes\n\nThis is faster than the logclosure_amplitudes(m, u1, v1, ...) method since it only computes as many visibilities as required thanks to the closure design matrix formalism from Blackburn et al.[1]\n\n[1]: Blackburn L., et al \"Closure Statistics in Interferometric Data\" ApJ 2020\n\n\n\n\n\nlogclosure_amplitudes(vis::AbstractArray, ac::ArrayConfiguration)\n\nCompute the log-closure amplitudes for a set of visibilities and an array configuration\n\nNotes\n\nThis uses a closure design matrix for the computation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.visibility","page":"Comrade API","title":"Comrade.visibility","text":"visibility(d::EHTVisibilityDatum)\n\nReturn the complex visibility of the visibility datum\n\n\n\n\n\nvisibility(mimg, p)\n\nComputes the complex visibility of model m at coordinates p. p corresponds to the coordinates of the model. These need to have the properties U, V and sometimes Ti for time and Fr for frequency.\n\nNotes\n\nIf you want to compute the visibilities at a large number of positions consider using the visibilities.\n\n\n\n\n\n","category":"function"},{"location":"api/#Data-Types","page":"Comrade API","title":"Data Types","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Comrade.amplitude(::Comrade.EHTVisibilityDatum)\nComrade.amplitude(::Comrade.EHTVisibilityAmplitudeDatum)\nComrade.baselines\nComrade.arrayconfig\nComrade.closure_phase(::Comrade.EHTVisibilityDatum, ::Comrade.EHTVisibilityDatum, ::Comrade.EHTVisibilityDatum)\nComrade.getdata\nComrade.getuv\nComrade.getuvtimefreq\nComrade.scantable\nComrade.stations\nComrade.uvpositions\nComrade.ArrayConfiguration\nComrade.ClosureConfig\nComrade.AbstractInterferometryDatum\nComrade.ArrayBaselineDatum\nComrade.EHTObservation\nComrade.EHTArrayConfiguration\nComrade.EHTCoherencyDatum\nComrade.EHTClosurePhaseDatum\nComrade.EHTLogClosureAmplitudeDatum\nComrade.EHTVisibilityDatum\nComrade.EHTVisibilityAmplitudeDatum\nComrade.Scan\nComrade.ScanTable","category":"page"},{"location":"api/#Comrade.amplitude-Tuple{Comrade.EHTVisibilityDatum}","page":"Comrade API","title":"Comrade.amplitude","text":"amplitude(d::EHTVisibilityDatum)\n\nGet the amplitude of a visibility datum\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.amplitude-Tuple{Comrade.EHTVisibilityAmplitudeDatum}","page":"Comrade API","title":"Comrade.amplitude","text":"amplitude(d::EHTVisibilityAmplitudeDatum)\n\nGet the amplitude of a amplitude datum\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.baselines","page":"Comrade API","title":"Comrade.baselines","text":"baselines(CP::EHTClosurePhaseDatum)\n\nReturns the baselines used for a single closure phase datum\n\n\n\n\n\nbaselines(CP::EHTLogClosureAmplitudeDatum)\n\nReturns the baselines used for a single closure phase datum\n\n\n\n\n\nbaselines(scan::Scan)\n\nReturn the baselines for each datum in a scan\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.arrayconfig","page":"Comrade API","title":"Comrade.arrayconfig","text":"arrayconfig(vis)\n\n\nExtract the array configuration from a EHT observation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.closure_phase-Tuple{Comrade.EHTVisibilityDatum, Comrade.EHTVisibilityDatum, Comrade.EHTVisibilityDatum}","page":"Comrade API","title":"Comrade.closure_phase","text":"closure_phase(D1::EHTVisibilityDatum,\n              D2::EHTVisibilityDatum,\n              D3::EHTVisibilityDatum\n              )\n\nComputes the closure phase of the three visibility datums.\n\nNotes\n\nWe currently use the high SNR Gaussian error approximation for the closure phase. In the future we may use the moment matching from Monte Carlo sampling.\n\n\n\n\n\n","category":"method"},{"location":"api/#Comrade.getdata","page":"Comrade API","title":"Comrade.getdata","text":"getdata(obs::EHTObservation, s::Symbol)\n\nPass-through function that gets the array of s from the EHTObservation. For example say you want the times of all measurement then\n\ngetdata(obs, :time)\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.getuv","page":"Comrade API","title":"Comrade.getuv","text":"getuv\n\nGet the u, v positions of the array.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.getuvtimefreq","page":"Comrade API","title":"Comrade.getuvtimefreq","text":"getuvtimefreq(ac)\n\n\nGet the u, v, time, freq of the array as a tuple.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.scantable","page":"Comrade API","title":"Comrade.scantable","text":"scantable(obs::EHTObservation)\n\nReorganizes the observation into a table of scans, where scan are defined by unique timestamps. To access the data you can use scalar indexing\n\nExample\n\nst = scantable(obs)\n# Grab the first scan\nscan1 = st[1]\n\n# Acess the detections in the scan\nscan1[1]\n\n# grab e.g. the baselines\nscan1[:baseline]\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.stations","page":"Comrade API","title":"Comrade.stations","text":"stations(d::EHTObservation)\n\nGet all the stations in a observation. The result is a vector of symbols.\n\n\n\n\n\nstations(g::CalTable)\n\nReturn the stations in the calibration table\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.uvpositions","page":"Comrade API","title":"Comrade.uvpositions","text":"uvpositions(datum::AbstractVisibilityDatum)\n\nGet the uvp positions of an inferometric datum.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.ArrayConfiguration","page":"Comrade API","title":"Comrade.ArrayConfiguration","text":"abstract type ArrayConfiguration\n\nThis defined the abstract type for an array configuration. Namely, baseline times, SEFD's, bandwidth, observation frequencies, etc.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ClosureConfig","page":"Comrade API","title":"Comrade.ClosureConfig","text":"struct ClosureConfig{A, D} <: Comrade.ArrayConfiguration\n\nArray config file for closure quantities. This stores the design matrix designmat that transforms from visibilties to closure products.\n\nFields\n\nac: Array configuration for visibilities\ndesignmat: Closure design matrix\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.AbstractInterferometryDatum","page":"Comrade API","title":"Comrade.AbstractInterferometryDatum","text":"abstract type AbstractInterferometryDatum{T}\n\nAn abstract type for all VLBI interfermetry data types. See Comrade.EHTVisibilityDatum for an example.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ArrayBaselineDatum","page":"Comrade API","title":"Comrade.ArrayBaselineDatum","text":"struct ArrayBaselineDatum{T, E, V}\n\nA single datum of an ArrayConfiguration\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.EHTObservation","page":"Comrade API","title":"Comrade.EHTObservation","text":"struct EHTObservation{F, T<:Comrade.AbstractInterferometryDatum{F}, S<:(StructArrays.StructArray{T<:Comrade.AbstractInterferometryDatum{F}}), A, N} <: Comrade.Observation{F}\n\nThe main data product type in Comrade this stores the data which can be a StructArray of any AbstractInterferometryDatum type.\n\nFields\n\ndata: StructArray of data productts\n\nconfig: Array config holds ancillary information about array\n\nmjd: modified julia date of the observation\n\nra: RA of the observation in J2000 (deg)\n\ndec: DEC of the observation in J2000 (deg)\n\nbandwidth: bandwidth of the observation (Hz)\n\nsource: Common source name\n\ntimetype: Time zone used.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.EHTArrayConfiguration","page":"Comrade API","title":"Comrade.EHTArrayConfiguration","text":"struct EHTArrayConfiguration{F, T, S, D<:AbstractArray} <: Comrade.ArrayConfiguration\n\nStores all the non-visibility data products for an EHT array. This is useful when evaluating model visibilities.\n\nFields\n\nbandwidth: Observing bandwith (Hz)\n\ntarr: Telescope array file\n\nscans: Scan times\n\ndata: A struct array of ArrayBaselineDatum holding time, freq, u, v, baselines.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.EHTCoherencyDatum","page":"Comrade API","title":"Comrade.EHTCoherencyDatum","text":"struct EHTCoherencyDatum{S, B1, B2, M<:(StaticArraysCore.SArray{Tuple{2, 2}, Complex{S}, 2}), E<:(StaticArraysCore.SArray{Tuple{2, 2}, S, 2})} <: Comrade.AbstractInterferometryDatum{S}\n\nA Datum for a single coherency matrix\n\nFields\n\nmeasurement: coherency matrix, with entries in Jy\n\nerror: visibility uncertainty matrix, with entries in Jy\n\nU: x-direction baseline length, in λ\n\nV: y-direction baseline length, in λ\n\nT: Timestamp, in hours\n\nF: Frequency, in Hz\n\nbaseline: station baseline codes\n\npolbasis: polarization basis for each station\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.EHTClosurePhaseDatum","page":"Comrade API","title":"Comrade.EHTClosurePhaseDatum","text":"struct EHTClosurePhaseDatum{S<:Number} <: Comrade.ClosureProducts{S<:Number}\n\nA Datum for a single closure phase.\n\nFields\n\nmeasurement: closure phase (rad)\n\nerror: error of the closure phase assuming the high-snr limit\n\nU1: u (λ) of first station\n\nV1: v (λ) of first station\n\nU2: u (λ) of second station\n\nV2: v (λ) of second station\n\nU3: u (λ) of third station\n\nV3: v (λ) of third station\n\nT: Measured time of closure phase in hours\n\nF: Measured frequency of closure phase in Hz\n\ntriangle: station baselines used\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.EHTLogClosureAmplitudeDatum","page":"Comrade API","title":"Comrade.EHTLogClosureAmplitudeDatum","text":"struct EHTLogClosureAmplitudeDatum{S<:Number} <: Comrade.ClosureProducts{S<:Number}\n\nA Datum for a single log closure amplitude.\n\n\n\nmeasurement: log-closure amplitude\n\nerror: log-closure amplitude error in the high-snr limit\n\nU1: u (λ) of first station\n\nV1: v (λ) of first station\n\nU2: u (λ) of second station\n\nV2: v (λ) of second station\n\nU3: u (λ) of third station\n\nV3: v (λ) of third station\n\nU4: u (λ) of fourth station\n\nV4: v (λ) of fourth station\n\nT: Measured time of closure phase in hours\n\nF: Measured frequency of closure phase in Hz\n\nquadrangle: station codes for the quadrangle\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.EHTVisibilityDatum","page":"Comrade API","title":"Comrade.EHTVisibilityDatum","text":"struct EHTVisibilityDatum{S<:Number} <: Comrade.AbstractVisibilityDatum{S<:Number}\n\nA struct holding the information for a single measured visibility.\n\n\n\nmeasurement: real component of the visibility (Jy)\n\nerror: error of the visibility (Jy)\n\nU: u position of the data point in λ\n\nV: v position of the data point in λ\n\nT: time of the data point in (Hr)\n\nF: frequency of the data point (Hz)\n\nbaseline: station baseline codes\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.EHTVisibilityAmplitudeDatum","page":"Comrade API","title":"Comrade.EHTVisibilityAmplitudeDatum","text":"struct EHTVisibilityAmplitudeDatum{S<:Number} <: Comrade.AbstractVisibilityDatum{S<:Number}\n\nA struct holding the information for a single measured visibility amplitude.\n\nFIELDS\n\nmeasurement: amplitude (Jy)\n\nerror: error of the visibility amplitude (Jy)\n\nU: u position of the data point in λ\n\nV: v position of the data point in λ\n\nT: time of the data point in (Hr)\n\nF: frequency of the data point (Hz)\n\nbaseline: station baseline codes\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.Scan","page":"Comrade API","title":"Comrade.Scan","text":"struct Scan{T, I, S}\n\nComposite type that holds information for a single scan of the telescope.\n\nFields\n\ntime: Scan time\n\nindex: Scan indices which are (scan index, data start index, data end index)\n\nscan: Scan data usually a StructArray of a <:AbstractVisibilityDatum\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.ScanTable","page":"Comrade API","title":"Comrade.ScanTable","text":"struct ScanTable{O<:Union{Comrade.ArrayConfiguration, Comrade.Observation}, T, S}\n\nWraps EHTObservation in a table that separates the observation into scans. This implements the table interface. You can access scans by directly indexing into the table. This will create a view into the table not copying the data.\n\nExample\n\njulia> st = scantable(obs)\njulia> st[begin] # grab first scan\njulia> st[end]   # grab last scan\n\n\n\n\n\n","category":"type"},{"location":"api/#eht-imaging-interface","page":"Comrade API","title":"eht-imaging interface","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Comrade.extract_coherency\nComrade.extract_amp\nComrade.extract_cphase\nComrade.extract_lcamp\nComrade.extract_vis\nComrade.load_ehtim_uvfits\nComrade.load_ehtim\nComrade.scan_average","category":"page"},{"location":"api/#Comrade.extract_coherency","page":"Comrade API","title":"Comrade.extract_coherency","text":"extract_coherency(obs)\n\nExtracts the coherency matrix from an ehtim observation object\n\nThis grabs the raw data object from the obs object. Any keyword arguments are ignored.\n\nReturns an EHTObservation with coherency matrix\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.extract_amp","page":"Comrade API","title":"Comrade.extract_amp","text":"extract_amp(obs)\n\nExtracts the visibility amplitudes from an ehtim observation object.\n\nAny valid keyword arguments to add_amp in ehtim can be passed through extract_amp.\n\nReturns an EHTObservation with visibility amplitude data\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.extract_cphase","page":"Comrade API","title":"Comrade.extract_cphase","text":"extract_cphase(obs)\n\nExtracts the closure phases from an ehtim observation object\n\nAny valid keyword arguments to add_cphase in ehtim can be passed through extract_cphase.\n\nReturns an EHTObservation with closure phases datums\n\nSpecial Keyword arguments:\n\ncount: How the closures are formed, the available options are \"min-correct\", \"min\", \"max\"\ncut_trivial: Cut the trivial triangles from the closures\nuvmin: The flag to decide what are trivial triangles. Any baseline with ||(u,v)|| < uvmin        are removed.\nkwargs...: Other arguments are forwarded to eht-imaging.\n\nWarning\n\nThe count keyword argument is treated specially in Comrade. The default option is \"min-correct\" and should almost always be used. This option construct a minimal set of closure phases that is valid even when the array isn't fully connected. For testing and legacy reasons we ehtim other count options are also included. However, the current ehtim count=\"min\" option is broken and does construct proper minimal sets of closure quantities if the array isn't fully connected.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.extract_lcamp","page":"Comrade API","title":"Comrade.extract_lcamp","text":"extract_lcamp(obs)\n\nExtracts the log-closure amp. from an ehtim observation object\n\nAny valid keyword arguments to add_logcamp in ehtim can be passed through extract_lcamp.\n\nSpecial Keyword arguments:\n\ncount: How the closures are formed, the available options are \"min-correct\", \"min\", \"max\"\nkwargs...: Other arguments are forwarded to eht-imaging.\n\nReturns an EHTObservation with log-closure amp. datums\n\nWarning\n\nThe count keyword argument is treated specially in Comrade. The default option is \"min-correct\" and should almost always be used. This option construct a minimal set of closure phases that is valid even when the array isn't fully connected. For testing and legacy reasons we ehtim other count options are also included. However, the current ehtim count=\"min\" option is broken and does construct proper minimal sets of closure quantities if the array isn't fully connected.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.extract_vis","page":"Comrade API","title":"Comrade.extract_vis","text":"extract_vis(obs)\n\nExtracts the complex visibilities from an ehtim observation object\n\nThis grabs the raw data object from the obs object. Any keyword arguments are ignored.\n\nReturns an EHTObservation with complex visibility data\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.load_ehtim_uvfits","page":"Comrade API","title":"Comrade.load_ehtim_uvfits","text":"load_ehtim_uvfits(uvfile, arrayfile=nothing; kwargs...)\n\nLoad a uvfits file with eht-imaging and returns a eht-imaging Obsdata object. You can optionally pass an array file as well that will load additional information such at the telescopes field rotation information with the arrayfile. This is expected to be an eht-imaging produced array or antenna file.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.load_ehtim","page":"Comrade API","title":"Comrade.load_ehtim","text":"load_ehtim()\n\nLoads the eht-imaging library and stores it in the exported ehtim variable.\n\nNotes\n\nWe use PythonCall and CondaPkg to install load all dependencies manually. If you want to use your own Python environment please see CondaPkg.jl.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.scan_average","page":"Comrade API","title":"Comrade.scan_average","text":"scan_average(obs; homogenize=true)\n\nThis homogenizes the scan times for an eht-imaging Obsdata object. This is needed because eht-imaging has a bug that will sometimes create very small scans and this can mess up both the closure construction and the gain scan times. Note that this is only a problem if we are fitting scan averaged data.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bayesian-Tools","page":"Comrade API","title":"Bayesian Tools","text":"","category":"section"},{"location":"api/#Posterior-Constructions","page":"Comrade API","title":"Posterior Constructions","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Comrade.ascube\nComrade.asflat\nComrade.flatten\nComrade.inverse\nComrade.prior_sample\nComrade.likelihood\nComrade.sample(::Posterior)\nComrade.transform\nComrade.MultiRadioLikelihood\nComrade.Posterior\nComrade.TransformedPosterior\nComrade.RadioLikelihood\nComrade.IsFlat\nComrade.IsCube","category":"page"},{"location":"api/#HypercubeTransform.ascube","page":"Comrade API","title":"HypercubeTransform.ascube","text":"ascube(post::Posterior)\n\nConstruct a flattened version of the posterior where the parameters are transformed to live in (0, 1), i.e. the unit hypercube.\n\nThis returns a TransformedPosterior that obeys the DensityInterface and can be evaluated in the usual manner, i.e. logdensityof. Note that the transformed posterior automatically includes the terms log-jacobian terms of the transformation.\n\nExample\n\njulia> tpost = ascube(post)\njulia> x0 = prior_sample(tpost)\njulia> logdensityof(tpost, x0)\n\nNotes\n\nThis is the transform that should be used if using typical NestedSampling methods, i.e. ComradeNested. For the transformation to unconstrained space see asflat\n\n\n\n\n\n","category":"function"},{"location":"api/#HypercubeTransform.asflat","page":"Comrade API","title":"HypercubeTransform.asflat","text":"asflat(post::Posterior)\n\nConstruct a flattened version of the posterior where the parameters are transformed to live in (-∞, ∞).\n\nThis returns a TransformedPosterior that obeys the DensityInterface and can be evaluated in the usual manner, i.e. logdensityof. Note that the transformed posterior automatically includes the terms log-jacobian terms of the transformation.\n\nExample\n\njulia> tpost = ascube(post)\njulia> x0 = prior_sample(tpost)\njulia> logdensityof(tpost, x0)\n\nNotes\n\nThis is the transform that should be used if using typical MCMC methods, i.e. ComradeAHMC. For the transformation to the unit hypercube see ascube\n\n\n\n\n\n","category":"function"},{"location":"api/#ParameterHandling.flatten","page":"Comrade API","title":"ParameterHandling.flatten","text":"flatten(post::Posterior)\n\nConstruct a flattened version of the posterior but do not transform to any space, i.e. use the support specified by the prior.\n\nThis returns a TransformedPosterior that obeys the DensityInterface and can be evaluated in the usual manner, i.e. logdensityof. Note that the transformed posterior automatically includes the terms log-jacobian terms of the transformation.\n\nExample\n\njulia> tpost = flatten(post)\njulia> x0 = prior_sample(tpost)\njulia> logdensityof(tpost, x0)\n\nNotes\n\nThis is the transform that should be used if using typical MCMC methods, i.e. ComradeAHMC. For the transformation to the unit hypercube see ascube\n\n\n\n\n\n","category":"function"},{"location":"api/#TransformVariables.inverse","page":"Comrade API","title":"TransformVariables.inverse","text":"inverse(posterior::TransformedPosterior, x)\n\nTransforms the value y from parameter space to the transformed space (e.g. unit hypercube if using ascube).\n\nFor the inverse transform see transform\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.prior_sample","page":"Comrade API","title":"Comrade.prior_sample","text":"prior_sample([rng::AbstractRandom], post::Posterior, args...)\n\nSamples the prior distribution from the posterior. The args... are forwarded to the Base.rand method.\n\n\n\n\n\nprior_sample([rng::AbstractRandom], post::Posterior)\n\nReturns a single sample from the prior distribution.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.likelihood","page":"Comrade API","title":"Comrade.likelihood","text":"likelihood(d::ConditionedLikelihood, μ)\n\nReturns the likelihood of the model, with parameters μ. That is, we return the distribution of the data given the model parameters μ. This is an actual probability distribution.\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsBase.sample-Tuple{Posterior}","page":"Comrade API","title":"StatsBase.sample","text":"sample(post::Posterior, sampler::S, args...; init_params=nothing, kwargs...)\n\nSample a posterior post using the sampler. You can optionally pass the starting location of the sampler using init_params, otherwise a random draw from the prior will be used.\n\n\n\n\n\n","category":"method"},{"location":"api/#TransformVariables.transform","page":"Comrade API","title":"TransformVariables.transform","text":"transform(posterior::TransformedPosterior, x)\n\nTransforms the value x from the transformed space (e.g. unit hypercube if using ascube) to parameter space which is usually encoded as a NamedTuple.\n\nFor the inverse transform see inverse\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.MultiRadioLikelihood","page":"Comrade API","title":"Comrade.MultiRadioLikelihood","text":"MultiRadioLikelihood(lklhd1, lklhd2, ...)\n\nCombines multiple likelihoods into one object that is useful for fitting multiple days/frequencies.\n\njulia> lklhd1 = RadioLikelihood(dcphase1, dlcamp1)\njulia> lklhd2 = RadioLikelihood(dcphase2, dlcamp2)\njulia> MultiRadioLikelihood(lklhd1, lklhd2)\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.Posterior","page":"Comrade API","title":"Comrade.Posterior","text":"Posterior(lklhd, prior)\n\nCreates a Posterior density that follows obeys DensityInterface. The lklhd object is expected to be a VLB object. For instance, these can be created using RadioLikelihood. prior is expected to be a NamedTuple of distributions that reflect the priors on the parameters you are considering.\n\nNotes\n\nSince this function obeys DensityInterface you can evaluate it with\n\njulia> ℓ = logdensityof(post)\njulia> ℓ(x)\n\nor using the 2-argument version directly\n\njulia> logdensityof(post, x)\n\nwhere post::Posterior.\n\nTo generate random draws from the prior see the prior_sample function.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.TransformedPosterior","page":"Comrade API","title":"Comrade.TransformedPosterior","text":"struct TransformedPosterior{P<:Posterior, T} <: Comrade.AbstractPosterior\n\nA transformed version of a Posterior object. This is an internal type that an end user shouldn't have to directly construct. To construct a transformed posterior see the asflat, ascube, and flatten docstrings.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.RadioLikelihood","page":"Comrade API","title":"Comrade.RadioLikelihood","text":"RadioLikelihood(model, data1, data2, ...)\n\nForms a radio likelihood from a set of data products. These data products must share the same array data/configuration. If you want to form a likelihood from multiple arrays such as when fitting different wavelengths or days, you can combine them using MultiRadioLikelihood\n\nExample\n\njulia> RadioLikelihood(model, dcphase1, dlcamp1)\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.IsFlat","page":"Comrade API","title":"Comrade.IsFlat","text":"struct IsFlat\n\nSpecifies that the sampling algorithm usually expects a uncontrained transform\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.IsCube","page":"Comrade API","title":"Comrade.IsCube","text":"struct IsCube\n\nSpecifies that the sampling algorithm usually expects a hypercube transform\n\n\n\n\n\n","category":"type"},{"location":"api/#Misc","page":"Comrade API","title":"Misc","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Comrade.μas2rad\nComrade.rad2μas\nComrade.load\nComrade.save\nComrade.NonAnalyticTest\nComrade.station_tuple","category":"page"},{"location":"api/#Comrade.μas2rad","page":"Comrade API","title":"Comrade.μas2rad","text":"μas2rad(x)\n\nConverts a number from micro-arcseconds (μas) to rad\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.rad2μas","page":"Comrade API","title":"Comrade.rad2μas","text":"rad2μas(x)\n\nConverts a number from radians to micro-arcseconds (μas)\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.load","page":"Comrade API","title":"Comrade.load","text":"Comrade.load(fitsfile::String, IntensityMap)\n\nThis loads in a fits file that is more robust to the various imaging algorithms in the EHT, i.e. is works with clean, smili, eht-imaging. The function returns an tuple with an intensitymap and a second named tuple with ancillary information about the image, like the source name, location, mjd, and radio frequency.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.save","page":"Comrade API","title":"Comrade.save","text":"Comrade.save(file::String, img::IntensityMap, obs)\n\nSaves an image to a fits file. You can optionally pass an EHTObservation so that ancillary information will be added.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.NonAnalyticTest","page":"Comrade API","title":"Comrade.NonAnalyticTest","text":"`NonAnalyticTest`\n\nAn internal model used primarly for testing. Any model passed to it will be interpreted as not having an analytic Fourier transform.\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.station_tuple","page":"Comrade API","title":"Comrade.station_tuple","text":"station_tuple(stations, default; kwargs...)\nstation_tuple(obs::EHTObservation, default; kwargs...)\n\nConvienence function that will construct a NamedTuple of objects whose names are the stations in the observation obs or explicitly in the argument stations. The NamedTuple will be filled with default if no kwargs are defined otherwise each kwarg (key, value) pair denotes a station and value pair.\n\nExamples\n\njulia> stations = (:AA, :AP, :LM, :PV)\njulia> station_tuple(stations, ScanSeg())\n(AA = ScanSeg(), AP = ScanSeg(), LM = ScanSeg(), PV = ScanSeg())\njulia> station_tuple(stations, ScanSeg(); AA = FixedSeg(1.0))\n(AA = FixedSeg(1.0), AP = ScanSeg(), LM = ScanSeg(), PV = ScanSeg())\njulia> station_tuple(stations, ScanSeg(); AA = FixedSeg(1.0), PV = TrackSeg())\n(AA = FixedSeg(1.0), AP = ScanSeg(), LM = ScanSeg(), PV = TrackSeg())\n\n\n\n\n\n","category":"function"},{"location":"api/#Internal-(Not-Public-API)","page":"Comrade API","title":"Internal (Not Public API)","text":"","category":"section"},{"location":"api/","page":"Comrade API","title":"Comrade API","text":"Comrade.scale_uv\nComrade.scale_image\nComrade.transform_uv\nComrade.transform_image\nComrade.ThreadedModel\nComrade.extract_FRs","category":"page"},{"location":"api/#Comrade.scale_uv","page":"Comrade API","title":"Comrade.scale_uv","text":"scale_image(model::AbstractModifier, u, u)\n\nReturns a number on how to scale the image visibility at u v for an modified model\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.scale_image","page":"Comrade API","title":"Comrade.scale_image","text":"scale_image(model::AbstractModifier, x, y)\n\nReturns a number of how to to scale the image intensity at x y for an modified model\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.transform_uv","page":"Comrade API","title":"Comrade.transform_uv","text":"transform_uv(model::AbstractModifier, u, u)\n\nReturns a transformed u and v according to the model modifier\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.transform_image","page":"Comrade API","title":"Comrade.transform_image","text":"transform_image(model::AbstractModifier, x, y)\n\nReturns a transformed x and y according to the model modifier\n\n\n\n\n\n","category":"function"},{"location":"api/#Comrade.ThreadedModel","page":"Comrade API","title":"Comrade.ThreadedModel","text":"ThreadedModel\n\nExperimental model wrapper than enables multi-threading when evaluating intensitymap\n\n\n\n\n\n","category":"type"},{"location":"api/#Comrade.extract_FRs","page":"Comrade API","title":"Comrade.extract_FRs","text":"extract_FRs\n\nExtracts the feed rotation Jones matrices (returned as a JonesPair) from an EHT observation obs.\n\nWarning\n\neht-imaging can sometimes pre-rotate the coherency matrices. As a result the field rotation can sometimes be applied twice. To compensate for this we have added a ehtim_fr_convention which will fix this.\n\n\n\n\n\n","category":"function"},{"location":"conventions/#Conventions","page":"Conventions","title":"Conventions","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"VLBI and radio astronomy has many non-standard conventions when coming from physics. Additionally, these conventions change from telescope to telescope, often making it difficult  to know what assumptions different data sets and codes are making. We will detail the  specific conventions that Comrade adheres to.","category":"page"},{"location":"conventions/#Rotation-Convention","page":"Conventions","title":"Rotation Convention","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"We follow the standard EHT and rotate starting from the upper y-axis and moving in a counter-clockwise direction. ","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"note: Note\nWe still use the standard astronomy definition where the positive x-axis is to the left.","category":"page"},{"location":"conventions/#Fourier-Transform-Convention","page":"Conventions","title":"Fourier Transform Convention","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"We use the positive exponent definition of the Fourier transform to define our visibilities. That is, we assume that the visibilities measured by a perfect interferometer are given by","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":" V(u v) = int I(x y)e^2pi i(ux + vy)dx dy","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"This convention is consistent with the AIPS convention and what is used in other EHT codes, such as eht-imaging. ","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"warning: Warning\nThis is the opposite convention of what is written in the EHT papers, but it is the correct version for the released data.","category":"page"},{"location":"conventions/#Coherency-matrix-Convention","page":"Conventions","title":"Coherency matrix Convention","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"We use the factor of 2 definition when defining the coherency matrices. That is, the relation coherency matrix C is given by","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"  C_pq = \n  2beginpmatrix\n    leftv_pa v_qa^*right  left v_pav_qb^*right \n    leftv_pb v_qa^*right  left v_pbv_qb^*right \n  endpmatrix","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"where v_pa is the voltage measured from station p and feed a.","category":"page"},{"location":"conventions/#Circular-Polarization-Conversions","page":"Conventions","title":"Circular Polarization Conversions","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"To convert from measured RL circular cross-correlation products to the Fourier transform of the Stokes parameters, we use:","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"  beginpmatrix\n      tildeI tildeQ  tildeU  tildeV\n  endpmatrix\n  =frac12\n  beginpmatrix\n     leftRR^*right + leftLL^*right \n     leftRL^*right + leftLR^*right \n     i(leftLR^*right - leftRL^*right)\n     leftRR^*right - leftLL^*right\n  endpmatrix","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"where e.g., leftRL^*right = 2leftv_pRv^*_pLright.","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"The inverse transformation is then:","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"  C = \n  beginpmatrix\n     tildeI + tildeV   tildeQ + itildeU\n     tildeQ - itildeU  tildeI - tildeV\n  endpmatrix","category":"page"},{"location":"conventions/#Linear-Polarization-Conversions","page":"Conventions","title":"Linear Polarization Conversions","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"To convert from measured XY linear cross-correlation products to the Fourier transform of the Stokes parameters, we use:","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"  beginpmatrix\n      tildeI tildeQ  tildeU  tildeV\n  endpmatrix\n  =frac12\n  beginpmatrix\n     leftXX^*right + leftYY^*right \n     leftXY^*right + leftYX^*right \n     i(leftYX^*right - leftXY^*right)\n     leftXX^*right - leftYY^*right\n  endpmatrix","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"The inverse transformation is then:","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"  C = \n  beginpmatrix\n     tildeI + tildeQ   tildeU + itildeV\n     tildeU - itildeV  tildeI - tildeQ\n  endpmatrix","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"where e.g., leftXY^*right = 2leftv_pXv^*_pYright.","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"EditURL = \"https://github.com/ptiede/Comrade.jl/blob/main/examples/hybrid_imaging.jl\"","category":"page"},{"location":"examples/hybrid_imaging/#Hybrid-Imaging-of-a-Black-Hole","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"","category":"section"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"In this tutorial, we will use hybrid imaging to analyze the 2017 EHT data. By hybrid imaging, we mean decomposing the model into simple geometric models, e.g., rings and such, plus a rasterized image model to soak up the additional structure. This approach was first developed in BB20 and applied to EHT 2017 data. We will use a similar model in this tutorial.","category":"page"},{"location":"examples/hybrid_imaging/#Introduction-to-Hybrid-modeling-and-imaging","page":"Hybrid Imaging of a Black Hole","title":"Introduction to Hybrid modeling and imaging","text":"","category":"section"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"The benefit of using a hybrid-based modeling approach is the effective compression of information/parameters when fitting the data. Hybrid modeling requires the user to incorporate specific knowledge of how you expect the source to look like. For instance for M87, we expect the image to be dominated by a ring-like structure. Therefore, instead of using a high-dimensional raster to recover the ring, we can use a ring model plus","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"#, a very low-dimensional or large pixel size raster to soak up the rest of the emission.","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"This is the approach we will take in this tutorial to analyze the April 6 2017 EHT data of M87.","category":"page"},{"location":"examples/hybrid_imaging/#Loading-the-Data","page":"Hybrid Imaging of a Black Hole","title":"Loading the Data","text":"","category":"section"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"To get started we will load Comrade","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"using Comrade","category":"page"},{"location":"examples/hybrid_imaging/#Load-the-Data","page":"Hybrid Imaging of a Black Hole","title":"Load the Data","text":"","category":"section"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"using Pkg #hide\nPkg.activate(joinpath(dirname(pathof(Comrade)), \"..\", \"examples\")) #hide","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"For reproducibility we use a stable random number genreator","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"using StableRNGs\nrng = StableRNG(42)","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"To download the data visit https://doi.org/10.25739/g85n-f134 To load the eht-imaging obsdata object we do:","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"obs = load_ehtim_uvfits(joinpath(dirname(pathof(Comrade)), \"..\", \"examples\", \"SR1_M87_2017_096_lo_hops_netcal_StokesI.uvfits\"))","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"Now we do some minor preprocessing:","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"Scan average the data since the data have been preprocessed so that the gain phases  coherent.","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"obs = scan_average(obs).add_fractional_noise(0.02)","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"For this tutorial we will stick to fitting closure only data, although we can get better results by also modeling gains, since closure only modeling is equivalent to assuming infinite gain priors.","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"dlcamp = extract_lcamp(obs; snrcut=4)\ndcphase = extract_cphase(obs; snrcut=3)","category":"page"},{"location":"examples/hybrid_imaging/#Building-the-Model/Posterior","page":"Hybrid Imaging of a Black Hole","title":"Building the Model/Posterior","text":"","category":"section"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"Now we build our intensity/visibility model. That is, the model that takes in a named tuple of parameters and perhaps some metadata required to construct the model. For our model, we will use a raster or ContinuousImage model, an m-ring model, and a large asymmetric Gaussian component to model the unresolved short-baseline flux.","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"function model(θ, metadata)\n    (;c, f, r, σ, ma, mp, fg, σg, τg, ξg) = θ\n    (; grid, cache) = metadata\n    # Form the image model\n    img = IntensityMap(f*(1-fg)*c, grid)\n    mimg = ContinuousImage(img, cache)\n    # Form the ring model\n    s,c = sincos(mp)\n    α = ma*c\n    β = ma*s\n    ring = ((1-f)*(1-fg))*smoothed(stretched(MRing(α, β), r, r),σ)\n    gauss = fg*rotated(stretched(Gaussian(), σg, σg*(1+τg)), ξg)\n    return mimg + (ring + gauss)\nend","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"Before we move on, let's go into the model function a bit. This function takes two arguments θ and metadata. The θ argument is a named tuple of parameters that are fit to the data. The metadata argument is all the ancillary information we need to construct the model. For our hybrid model, we will need two variables for the metadata, a grid that specifies the locations of the image pixels and a cache that defines the algorithm used to calculate the visibilities given the image model. This is required since ContinuousImage is most easily computed using number Fourier transforms like the NFFT or FFT. To combine the models, we use Comrade's overloaded + operators, which will combine the images such that their intensities and visibilities are added pointwise.","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"Now let's define our metadata. First we will define the cache for the image. This is required to compute the numerical Fourier transform.","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"fovxy  = μas2rad(90.0)\nnpix   = 6\ngrid   = imagepixels(fovxy, fovxy, npix, npix)\nbuffer = IntensityMap(zeros(npix,npix), grid)","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"For our image, we will use the discrete Fourier transform (DFTAlg) since we use such a small dimensional image. For larger rasters (8x8 and above) we recommend using NFFTAlg instead of DFFTAlg due to the improved scaling. The last argument to the create_cache call is the image kernel or pulse defines the continuous function we convolve our image with to produce a continuous on-sky image.","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"cache  = create_cache(DFTAlg(dlcamp), buffer, BSplinePulse{3}())","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"Now we form the metadata","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"metadata = (;grid, cache)","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"This is everything we need to form our likelihood. Note the first two arguments must be the model and then the metadata for the likelihood. The rest of the arguments are required to be Comrade.EHTObservation","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"lklhd = RadioLikelihood(model, metadata, dlcamp, dcphase)","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"This forms our model. The next step is defining our image priors. For our raster c, we will use a Dirichlet prior, a multivariate prior that exists on the simplex. That is, the sum of all the numbers from a Dirichlet distribution always equals unity. The first parameter is the concentration parameter α. As α→0, the images tend to become very sparse, while for α >> 1, the images tend to have uniform brightness. The α=1 distribution is the uniform distribution on the simplex. For our work here, we use the uniform simplex distribution.","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"!!! Warning    As α gets small sampling, it gets very difficult and quite multimodal due to the nature    of the sparsity prior, be careful when checking convergence when using such a prior.","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"using VLBIImagePriors\nusing Distributions\nprior = (\n          c  = ImageDirichlet(1.0, npix, npix),\n          f  = Uniform(0.0, 1.0),\n          r  = Uniform(μas2rad(10.0), μas2rad(30.0)),\n          σ  = Uniform(μas2rad(0.5), μas2rad(20.0)),\n          ma = Uniform(0.0, 0.5),\n          mp = Uniform(0.0, 2π),\n          fg = Uniform(0.2, 1.0),\n          σg = Uniform(μas2rad(50.0), μas2rad(500.0)),\n          τg = Uniform(0.0, 1.0),\n          ξg = Uniform(0, π)\n        )","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"This is everything we need to specify our posterior distribution, which our is the main object of interest in image reconstructions when using Bayesian inference.","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"post = Posterior(lklhd, prior)","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"To sample from our prior we can do","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"xrand = prior_sample(rng, post)","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"and then plot the results","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"using Plots\nimg = intensitymap(model(xrand, metadata), μas2rad(120.0), μas2rad(120.0), 128, 128)\nplot(img, title=\"Random sample\")","category":"page"},{"location":"examples/hybrid_imaging/#Reconstructing-the-Image","page":"Hybrid Imaging of a Black Hole","title":"Reconstructing the Image","text":"","category":"section"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"To sample from this posterior, it is convenient to first move from our constrained parameter space to an unconstrained one (i.e., the support of the transformed posterior is (-∞, ∞)). This is done using the asflat function.","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"tpost = asflat(post)","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"We can now also find the dimension of our posterior or the number of parameters we will sample. !!! Warning    This can often be different from what you would expect. This is especially true when using    angular variables, where we often artificially increase the dimension    of the parameter space to make sampling easier.","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"ndim = dimension(tpost)","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"Now we optimize. First, we will use BlackBoxOptim, which is a genetic algorithm, to get us in the region of the best-fit model.","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"using ComradeOptimization\nusing OptimizationBBO\nusing Zygote\nf = OptimizationFunction(tpost, Optimization.AutoZygote())\nprob = Optimization.OptimizationProblem(f, prior_sample(rng, tpost), nothing, lb=fill(-5.0, ndim), ub=fill(5.0,ndim))\nsol = solve(prob, BBO_adaptive_de_rand_1_bin_radiuslimited(); maxiters=100_000)","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"Alright now we can zoom to the peak!","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"using OptimizationOptimJL\nprob = Optimization.OptimizationProblem(f, sol.u, nothing)\nℓ = logdensityof(tpost)\nsol = solve(prob, LBFGS(), maxiters=1_000, g_tol=1e-1)","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"Before we analyze our solution we first need to transform back to parameter space.","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"xopt = transform(tpost, sol)","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"First we will evaluate our fit by plotting the residuals","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"residual(model(xopt, metadata), dlcamp)\nresidual(model(xopt, metadata), dcphase)","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"These look reasonable, although they are a bit high. This could be improved in a few ways, but that is beyond the goal of this quick tutorial. Plotting the image, we see that we have a ring and an image that looks like a sharper version of the original M87 image. This is because we used a more physically motivated model by assuming that the image should have a ring component.","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"img = intensitymap(model(xopt, metadata), 1.5*fovxy, 1.5*fovxy, 128, 128)\nplot(img, title=\"MAP Image\")","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"now we sample using hmc","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"using ComradeAHMC\nmetric = DiagEuclideanMetric(ndim)\nchain, stats = sample(rng, post, AHMC(;metric, autodiff=Val(:Zygote)), 500; nadapts=250, init_params=xopt)","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"warning: Warning\nThis should be run for likely an order of magnitude more steps to properly estimate expectations of the posterior","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"Now lets plot the mean image and standard deviation images. To do this we first clip the first 250 MCMC steps since that is during tuning and so the posterior is not sampling from the correct stationary distribution.","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"using StatsBase\nmsamples = model.(chain[251:2:end], Ref(metadata))","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"The mean image is then given by","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"imgs = intensitymap.(msamples, 1.5*fovxy, 1.5*fovxy, 128, 128)\nplot(mean(imgs), title=\"Mean Image\")\nplot(std(imgs), title=\"Std Dev.\")","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"We can also split up the model into its components and analyze each separately","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"comp = Comrade.components.(msamples)\nring_samples = getindex.(comp, 2)\nrast_samples = first.(comp)\nring_imgs = intensitymap.(ring_samples, fovxy, fovxy, 128, 128)\nrast_imgs = intensitymap.(rast_samples, fovxy, fovxy, 128, 128)\n\nring_mean, ring_std = mean_and_std(ring_imgs)\nrast_mean, rast_std = mean_and_std(rast_imgs)\n\np1 = plot(ring_mean, title=\"Ring Mean\", clims=(0.0, maximum(ring_mean)), colorbar=:none)\np2 = plot(ring_std, title=\"Ring Std. Dev.\", clims=(0.0, maximum(ring_mean)), colorbar=:none)\np3 = plot(rast_mean, title=\"Raster Mean\", clims=(0.0, maximum(ring_mean)), colorbar=:none)\np4 = plot(rast_std,  title=\"Raster Std. Dev.\", clims=(0.0, maximum(ring_mean)), colorbar=:none)\n\nplot(p1,p2,p3,p4, layout=(2,2), size=(650, 650))","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"Finally, let's take a look at some of the ring parameters","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"using StatsPlots\np1 = density(rad2μas(chain.r)*2, xlabel=\"Ring Diameter (μas)\")\np2 = density(rad2μas(chain.σ)*2*sqrt(2*log(2)), xlabel=\"Ring FWHM (μas)\")\np3 = density(-rad2deg.(chain.mp) .+ 360.0, xlabel = \"Ring PA (deg) E of N\")\np4 = density(2*chain.ma, xlabel=\"Brightness asymmetry\")\np5 = density(1 .- chain.f, xlabel=\"Ring flux fraction\")\nplot(p1, p2, p3, p4, p5, size=(900, 600), legend=nothing)","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"This is very consistent with the original M87 results and it only took 20 minutes compared to the week it used to take using old imaging tools.","category":"page"},{"location":"examples/hybrid_imaging/#Computing-information","page":"Hybrid Imaging of a Black Hole","title":"Computing information","text":"","category":"section"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"Julia Version 1.8.5\nCommit 17cfb8e65ea (2023-01-08 06:45 UTC)\nPlatform Info:\n  OS: Linux (x86_64-linux-gnu)\n  CPU: 32 × AMD Ryzen 9 7950X 16-Core Processor\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-13.0.1 (ORCJIT, znver3)\n  Threads: 1 on 32 virtual cores\nEnvironment:\n  JULIA_EDITOR = code\n  JULIA_NUM_THREADS = 1","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"","category":"page"},{"location":"examples/hybrid_imaging/","page":"Hybrid Imaging of a Black Hole","title":"Hybrid Imaging of a Black Hole","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"EditURL = \"https://github.com/ptiede/Comrade.jl/blob/main/examples/data.jl\"","category":"page"},{"location":"examples/data/#Loading-Data-into-Comrade","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"","category":"section"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"The VLBI field does not have a standardized data format, and the EHT uses a particular uvfits format similar to the optical interferometry oifits format. As a result, we reuse the excellent eht-imaging package to load data into Comrade.","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"Once the data is loaded, we then convert the data into the tabular format Comrade expects. Note that this may change to a Julia package as the Julia radio astronomy group grows.","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"To get started, we will load Comrade and Plots to enable visualizations of the data","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"using Comrade\n\nusing Pkg #hide\nPkg.activate(joinpath(dirname(pathof(Comrade)), \"..\", \"examples\")) #hide\n\n\nusing Plots","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"To load the data we will use eht-imaging. We will use the 2017 public M87 data which can be downloaded from cyverse","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"obseht = load_ehtim_uvfits(joinpath(dirname(pathof(Comrade)), \"..\", \"examples\", \"SR1_M87_2017_096_lo_hops_netcal_StokesI.uvfits\"))","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"Now we will average the data over telescope scans. Note that the EHT data has been pre-calibrated so this averaging doesn't induce large coherence losses.","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"obs = scan_average(obseht)","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"!!! Warning    We use a custom scan-averaging function to ensure that the scan-times are homogenized.","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"We can now extract data products that Comrade can use","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"coh = extract_coherency(obs) # Coherency matrices\nvis = extract_vis(obs) #complex visibilites\namp = extract_amp(obs) # visibility amplitudes\ncphase = extract_cphase(obs) # extract minimal set of closure phases\nlcamp = extract_lcamp(obs) # extract minimal set of log-closure amplitudes","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"!!! Warning    Always use our extract_cphase and extract_lcamp functions to find the closures    eht-imaging will sometimes incorrectly calculate a non-redundant set of closures.","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"We can also recover the array used in the observation using","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"ac = arrayconfig(vis)\nplot(ac) # Plot the baseline coverage","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"To plot the data we just call","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"l = @layout [a b; c d]\npv = plot(vis)\npa = plot(amp)\npcp = plot(cphase)\nplc = plot(lcamp)\n\nplot(pv, pa, pcp, plc; layout=l)","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"And also the coherency matrices","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"plot(coh)","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"","category":"page"},{"location":"examples/data/","page":"Loading Data into Comrade","title":"Loading Data into Comrade","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"EditURL = \"https://github.com/ptiede/Comrade.jl/blob/main/examples/imaging_vis.jl\"","category":"page"},{"location":"examples/imaging_vis/#Stokes-I-Simultaneous-Image-and-Instrument-Modeling","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"","category":"section"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"In this tutorial, we will create a preliminary reconstruction of the 2017 M87 data on April 6 by simultaneously creating an image and model for the instrument. By instrument model, we mean something akin to self-calibration in traditional VLBI imaging terminology. However, unlike traditional self-cal, we will at each point in our parameter space effectively explore the possible self-cal solutions. This will allow us to constrain and marginalize over the instrument effects, such as time variable gains.","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"To get started we load Comrade.","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"using Comrade\n\n\nusing Pkg #hide\nPkg.activate(joinpath(dirname(pathof(Comrade)), \"..\", \"examples\")) #hide","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"For reproducibility we use a stable random number genreator","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"using StableRNGs\nrng = StableRNG(124)","category":"page"},{"location":"examples/imaging_vis/#Load-the-Data","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Load the Data","text":"","category":"section"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"To download the data visit https://doi.org/10.25739/g85n-f134 First we will load our data:","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"obs = load_ehtim_uvfits(joinpath(dirname(pathof(Comrade)), \"..\", \"examples\", \"SR1_M87_2017_096_hi_hops_netcal_StokesI.uvfits\"))","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Now we do some minor preprocessing:","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Scan average the data since the data have been preprocessed so that the gain phases  coherent.\nAdd 1% systematic noise to deal with calibration issues that cause 1% non-closing errors.","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"obs = scan_average(obs.add_fractional_noise(0.01))","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Now we extract our complex visibilities.","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"dvis = extract_vis(obs)","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"##Building the Model/Posterior","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Now, we must build our intensity/visibility model. That is, the model that takes in a named tuple of parameters and perhaps some metadata required to construct the model. For our model, we will use a raster or ContinuousImage for our image model. Unlike other imaging examples (e.g., Imaging a Black Hole using only Closure Quantities) we also need to include a model for the instrument, i.e., gains as well. The gains will be broken into two components","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Gain amplitudes which are typically known to 10-20%, except for LMT, which has amplitudes closer to 50-100%.\nGain phases which are more difficult to constrain and can shift rapidly.","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"The model is given below:","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"function model(θ, metadata)\n    (;fg, c, lgamp, gphase) = θ\n    (; grid, cache, gcache, gcachep) = metadata\n    # Construct the image model we fix the flux to 0.6 Jy in this case\n    img = IntensityMap((1.1*(1-fg)).*c, grid)\n    m = ContinuousImage(img,cache)\n    g = modify(Gaussian(), Stretch(μas2rad(250.0), μas2rad(250.0)), Renormalize(1.1*fg))\n    # Now form our instrument model\n    gvis = exp.(lgamp)\n    gphase = exp.(1im.*gphase)\n    jgamp = jonesStokes(gvis, gcache)\n    jgphase = jonesStokes(gphase, gcachep)\n    return JonesModel(jgamp*jgphase, m+g)\nend","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"The model construction is very similar to Imaging a Black Hole using only Closure Quantities, except we fix the compact flux to 0.6 Jy for simplicity in this run. For more information about the image model please read the closure-only example. Let's discuss the instrument model JonesModel. Thanks to the EHT pre-calibration, the gains are stable over scans. Therefore, we can model the gains on a scan-by-scan basis. To form the instrument model, we need our","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Our (log) gain amplitudes and phases are given below by lgamp and gphase\nOur function or cache that maps the gains from a list to the stations they impact gcache.\nThe set of Comrade.JonesPairs produced by jonesStokes","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"These three ingredients then specify our instrument model. The instrument model can then be combined with our image model cimg to form the total JonesModel.","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Now, let's set up our image model. The EHT's nominal resolution is 20-25 μas. Additionally, the EHT is not very sensitive to a larger field of view. Typically 60-80 μas is enough to describe the compact flux of M87. Given this, we only need to use a small number of pixels to describe our image.","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"npix = 32\nfovx = μas2rad(65.0)\nfovy = μas2rad(65.0)","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Now let's form our cache's. First, we have our usual image cache which is needed to numerically compute the visibilities.","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"grid = imagepixels(fovx, fovy, npix, npix)\nbuffer = IntensityMap(zeros(npix, npix), grid)\ncache = create_cache(NFFTAlg(dvis), buffer, BSplinePulse{3}())","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Second, we now construct our instrument model cache. This tells us how to map from the gains to the model visibilities. However, to construct this map, we also need to specify the observation segmentation over which we expect the gains to change. This is specified in the second argument to jonescache, and currently, there are two options","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"FixedSeg(val): Fixes the corruption to the value val for all time. This is usefule for reference stations\nScanSeg(): which forces the corruptions to only change from scan-to-scan\nTrackSeg(): which forces the corruptions to be constant over a night's observation","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"For this work, we use the scan segmentation for the gain amplitudes since that is roughly the timescale we expect them to vary. For the phases we use a station specific scheme where we set AA to be fixed to unit gain because it will function as a reference station.","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"gcache = jonescache(dvis, ScanSeg())\nsegs = (AA = FixedSeg(1.0 + 0.0im),\n        AP = ScanSeg(),\n        AZ = ScanSeg(),\n        JC = ScanSeg(),\n        LM = ScanSeg(),\n        PV = ScanSeg(),\n        SM = ScanSeg())\ngcachep = jonescache(dvis, segs)","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Now we can form our metadata we need to fully define our model.","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"metadata = (;grid, cache, gcache, gcachep)","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Moving onto our prior, we first focus on the instrument model priors. Each station requires its own prior on both the amplitudes and phases. For the amplitudes we assume that the gains are apriori well calibrated around unit gains (or 0 log gain amplitudes) which corresponds to no instrument corruption. The gain dispersion is then set to 10% for all stations except LMT, representing that we expect 10% deviations from scan-to-scan. For LMT we let the prior expand to 100% due to the known pointing issues LMT had in 2017.","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"using Distributions\nusing DistributionsAD\ndistamp = (AA = Normal(0.0, 0.1),\n           AP = Normal(0.0, 0.1),\n           LM = Normal(0.0, 1.0),\n           AZ = Normal(0.0, 0.1),\n           JC = Normal(0.0, 0.1),\n           PV = Normal(0.0, 0.1),\n           SM = Normal(0.0, 0.1),\n           )","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"For the phases, as mentioned above, we will use a segmented gain prior. This means that rather than the parameters being directly the gains, we fit the first gain for each site, and then the other parameters are the segmented gains compared to the previous time. To model this","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"#, we break the gain phase prior into two parts. The first is the prior","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"for the first observing timestamp of each site, distphase0, and the second is the prior for segmented gain ϵₜ from time i to i+1, given by distphase. For the EHT, we are dealing with pre-2*rand(rng, ndim) .- 1.5calibrated data, so often, the gain phase jumps from scan to scan are minor. As such, we can put a more informative prior on distphase.","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"warning: Warning\nWe use AA (ALMA) as a reference station so we do not have to specify a gain prior for it.","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"using VLBIImagePriors\n\ndistphase = (\n             AP = DiagonalVonMises(0.0, inv(π^2)),\n             LM = DiagonalVonMises(0.0, inv(π^2)),\n             AZ = DiagonalVonMises(0.0, inv(π^2)),\n             JC = DiagonalVonMises(0.0, inv(π^2)),\n             PV = DiagonalVonMises(0.0, inv(π^2)),\n             SM = DiagonalVonMises(0.0, inv(π^2)),\n           )","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"We can now form our model parameter priors. Like our other imaging examples, we use a Dirichlet prior for our image pixels. For the log gain amplitudes, we use the CalPrior which automatically constructs the prior for the given jones cache gcache.","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"(;X, Y) = grid\nprior = (\n         fg = Uniform(0.0, 1.0),\n         c = ImageDirichlet(1.0, npix, npix),\n         lgamp = CalPrior(distamp, gcache),\n         gphase = CalPrior(distphase, gcachep),\n        )","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Putting it all together we form our likelihood and posterior objects for optimization and sampling.","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"lklhd = RadioLikelihood(model, metadata, dvis)\npost = Posterior(lklhd, prior)","category":"page"},{"location":"examples/imaging_vis/#Reconstructing-the-Image-and-Instrument-Effects","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Reconstructing the Image and Instrument Effects","text":"","category":"section"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"To sample from this posterior, it is convenient to move from our constrained parameter space to an unconstrained one (i.e., the support of the transformed posterior is (-∞, ∞)). This is done using the asflat function.","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"tpost = asflat(post)\nndim = dimension(tpost)","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Our Posterior and TransformedPosterior objects satisfy the LogDensityProblems interface. This allows us to easily switch between different AD backends and many of Julia's statistical inference packages use this interface as well.","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"using LogDensityProblemsAD\nusing Zygote\ngtpost = ADgradient(Val(:Zygote), tpost)\nx0 = randn(ndim)\nLogDensityProblemsAD.logdensity_and_gradient(gtpost, x0)","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"We can now also find the dimension of our posterior or the number of parameters we are going to sample. !!! Warning     This can often be different from what you would expect. This is especially true when using     angular variables where we often artificially increase the dimension     of the parameter space to make sampling easier.","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"To initialize our sampler we will use optimize using LBFGS","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"using ComradeOptimization\nusing OptimizationOptimJL\nf = OptimizationFunction(tpost, Optimization.AutoZygote())\nprob = Optimization.OptimizationProblem(f, 2*rand(rng, ndim) .- 1.0, nothing)\nℓ = logdensityof(tpost)\nsol = solve(prob, LBFGS(), maxiters=5_000, g_tol=1e-1, callback=((x,p)->(@info f(x,p); false)))","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Now transform back to parameter space","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"xopt = transform(tpost, sol.u)","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"warning: Warning\n","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Fitting gains tends to be very difficult, meaning that optimization can take a lot longer.    The upside is that we usually get nicer images.","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"First we will evaluate our fit by plotting the residuals","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"using Plots\nresidual(model(xopt, metadata), dvis)","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"These look reasonable, although there may be some minor overfitting. This could be improved in a few ways, but that is beyond the goal of this quick tutorial. Plotting the image, we see that we have a much cleaner version of the closure-only image from Imaging a Black Hole using only Closure Quantities.","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"img = intensitymap(model(xopt, metadata), fovx, fovy, 128, 128)\nplot(img, title=\"MAP Image\")","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Because we also fit the instrument model, we can inspect their parameters. To do this, Comrade provides a caltable function that converts the flattened gain parameters to a tabular format based on the time and its segmentation.","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"gt = Comrade.caltable(gcachep, xopt.gphase)\nplot(gt, layout=(3,3), size=(600,500))","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"The gain phases are pretty random, although much of this is due to us picking a random reference station for each scan.","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Moving onto the gain amplitudes, we see that most of the gain variation is within 10% as expected except LMT, which has massive variations.","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"gt = Comrade.caltable(gcache, exp.(xopt.lgamp))\nplot(gt, layout=(3,3), size=(600,500))","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"To sample from the posterior, we will use HMC, specifically the NUTS algorithm. For information about NUTS, see Michael Betancourt's notes.","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"note: Note\nFor our metric, we use a diagonal matrix due to easier tuning","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"However, due to the need to sample a large number of gain parameters, constructing the posterior is rather time-consuming. Therefore, for this tutorial, we will only do a quick preliminary run, and any posterior inferences should be appropriately skeptical.","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"using ComradeAHMC\nmetric = DenseEuclideanMetric(ndim)\nchain, stats = sample(rng, post, AHMC(;metric, autodiff=Val(:Zygote)), 500; nadapts=200, init_params=chain[end])","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"warning: Warning\nThis should be run for likely an order of magnitude more steps to properly estimate expectations of the posterior","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Now that we have our posterior, we can put error bars on all of our plots above. Let's start by finding the mean and standard deviation of the gain phases","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"gphase  = hcat(chain.gphase...)\nmgphase = mean(gphase, dims=2)\nsgphase = std(gphase, dims=2)","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"and now the gain amplitudes","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"gamp  = exp.(hcat(chain.lgamp...))\nmgamp = mean(gamp, dims=2)\nsgamp = std(gamp, dims=2)","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Now we can use the measurements package to automatically plot everything with error bars. First we create a caltable the same way but making sure all of our variables have errors attached to them.","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"using Measurements\ngmeas_am = measurement.(mgamp, sgamp)\nctable_am = caltable(gcache, vec(gmeas_am)) # caltable expects gmeas_am to be a Vector\ngmeas_ph = measurement.(mgphase, sgphase)\nctable_ph = caltable(gcachep, vec(gmeas_ph))","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Now let's plot the phase curves","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"plot(ctable_ph, layout=(3,3), size=(600,500))","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"and now the amplitude curves","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"plot(ctable_am, layout=(3,3), size=(600,500))","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Finally let's construct some representative image reconstructions.","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"samples = model.(chain[201:10:end], Ref(metadata))\nimgs = intensitymap.(samples, μas2rad(75.0), μas2rad(75.0), 128,  128);\n\nmimg = mean(imgs)\nsimg = std(imgs)\np1 = plot(mimg, title=\"Mean\", clims=(0.0, maximum(mimg)));\np2 = plot(simg,  title=\"Std. Dev.\", clims=(0.0, maximum(mimg)));\np3 = plot(imgs[begin],  title=\"Draw 1\", clims = (0.0, maximum(mimg)));\np4 = plot(imgs[end],  title=\"Draw 2\", clims = (0.0, maximum(mimg)));\nplot(p1,p2,p3,p4, layout=(2,2), size=(800,800))","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"And viola, you have just finished making a preliminary image and instrument model reconstruction. In reality, you should run the sample step for many more MCMC steps to get a reliable estimate for the reconstructed image and instrument model parameters.","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Computing information","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"Julia Version 1.7.3\nCommit 742b9abb4d (2022-05-06 12:58 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: 11th Gen Intel(R) Core(TM) i7-1185G7 @ 3.00GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-12.0.1 (ORCJIT, tigerlake)","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"","category":"page"},{"location":"examples/imaging_vis/","page":"Stokes I Simultaneous Image and Instrument Modeling","title":"Stokes I Simultaneous Image and Instrument Modeling","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"EditURL = \"https://github.com/ptiede/Comrade.jl/blob/main/examples/imaging_pol.jl\"","category":"page"},{"location":"examples/imaging_pol/#Polarized-Image-and-Instrumental-Modeling","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"","category":"section"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"In this tutorial, we will analyze a simulated simple polarized dataset to demonstrate Comrade's polarized imaging capabilities.","category":"page"},{"location":"examples/imaging_pol/#Introduction-to-Polarized-Imaging","page":"Polarized Image and Instrumental Modeling","title":"Introduction to Polarized Imaging","text":"","category":"section"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"The EHT is a polarized interferometer. However, like all VLBI interferometers, it does not directly measure the Stokes parameters (I, Q, U, V). Instead, it measures components related to the electric field at the telescope along two directions using feeds. There are two types of feeds at telescopes: circular, which measure RL components of the electric field, and linear feeds, which measure XY components of the electric field. Most sites in the EHT use circular feeds, meaning they measure the right (R) and left electric field (L) at each telescope. These circular electric field measurements are then correlated, producing coherency matrices,","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":" C_ij = beginpmatrix\n       RR^*   RL^*\n       LR^*   LL^*\n     endpmatrix","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"These coherency matrices are the fundamental object in interferometry and what the telescope observes. For a perfect interferometer, these coherency matrices are related to the usual Fourier transform of the stokes parameters by","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"  beginpmatrix\n      tildeI tildeQ  tildeU  tildeV\n  endpmatrix\n  =frac12\n  beginpmatrix\n     RR^* + LL^* \n     RL^* + LR^* \n     i(LR^* - RL^*)\n     RR^* - LL^*\n  endpmatrix","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"for circularly polarized measurements.","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"note: Note\nIn this tutorial, we stick to circular feeds but Comrade has the capabilities to model linear (XX,XY, ...) and mixed basis coherencies (e.g., RX, RY, ...).","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"In reality, the measure coherencies are corrupted by both the atmosphere and the telescope itself. In Comrade we use the RIME formalism [1] to represent these corruptions, namely our measured coherency matrices V_ij are given by","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"   V_ij = J_iC_ijJ_j^dagger","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"where J is known as a Jones matrix and ij denotes the baseline ij with sites i and j.","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Comrade is highly flexible with how the Jones matrices are formed and provides several convenience functions that parameterize standard Jones matrices. These matrices include:","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"jonesG which builds the set of complex gain Jones matrices","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"  G = beginpmatrix\n          g_a   0\n          0     g_b\n      endpmatrix","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"jonesD which builds the set of complex d-terms Jones matrices","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"  D = beginpmatrix\n          1    d_a\n          d_b     1\n      endpmatrix","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"jonesT is the basis transform matrix T. This transformation is special and  combines two things using the decomposition T=FB. The first, B, is the transformation from  some reference basis to the observed coherency basis (this allows for mixed basis measurements).  The second is the feed rotation, F, that transforms from some reference axis to the axis of the  telescope as the source moves in the sky. The feed rotation matrix F in terms of  the per station feed rotation angle varphi is","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"  F = beginpmatrix\n          e^-ivarphi    0\n          0      e^ivarphi\n      endpmatrix","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"In the rest of the tutorial, we are going to solve for all of these instrument model terms on  in addition to our image structure to reconstruct a polarized image of a synthetic dataset.","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"using Comrade","category":"page"},{"location":"examples/imaging_pol/#Load-the-Data","page":"Polarized Image and Instrumental Modeling","title":"Load the Data","text":"","category":"section"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"using Pkg #hide\nPkg.activate(joinpath(dirname(pathof(Comrade)), \"..\", \"examples\")) #hide","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"For reproducibility we use a stable random number genreator","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"using StableRNGs\nrng = StableRNG(123)","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Now we will load some synthetic polarized data.","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"obs = load_ehtim_uvfits(joinpath(dirname(pathof(Comrade)), \"..\", \"examples\", \"PolarizedExamples/polarized_gaussian_nogains_withdterms_withfr.uvfits\"),\n                        joinpath(dirname(pathof(Comrade)), \"..\", \"examples\", \"PolarizedExamples/array.txt\"))","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Notice that, unlike other non-polarized tutorials, we need to include a second argument. This is the array file of the observation and is required to determine the feed rotation of the array.","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Now we scan average the data since the data to boost the SNR and reduce the total data volume.","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"obs = scan_average(obs)","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Now we extract our observed/corrupted coherency matrices.","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"dvis = extract_coherency(obs)","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"##Building the Model/Posterior","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"To build the model, we first break it down into two parts:","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"The image model. In Comrade, all polarized image models are written in terms of the Stokes parameters. The reason for using Stokes parameters is that it is usually what physical models consider and is the often easiest to reason about since they are additive. In this tutorial, we will use a polarized image model based on Pesce (2021)[2]. This model parameterizes the polarized image in terms of the Poincare sphere, and allows us to easily incorporate physical restrictions such as I^2  Q^2 + U^2 + V^2.\nThe instrument model. The instrument model specifies the model that describes the impact of instrumental and atmospheric effects. We will be using the J = GDT decomposition we described above. However, to parameterize the R/L complex gains, we will be using a gain product and ratio decomposition. The reason for this decomposition is that in realistic measurements, the gain ratios and products have different temporal characteristics. Namely, many of the EHT observations tend to demonstrate constant R/L gain ratios across an nights observations, compared to the gain products, which vary every scan. Additionally, the gain ratios tend to be smaller (i.e., closer to unity) than the gain products. Using this apriori knowledge, we can build this into our model and reduce the total number of parameters we need to model.","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"function model(θ, metadata)\n    (;c, f, p, angparams, dRx, dRy, dLx, dLy, lgp, gpp, lgr, gpr) = θ\n    (; grid, cache, tcache, scancache, trackcache) = metadata\n    # Construct the image model\n    # produce Stokes images from parameters\n    imgI = f*c\n    # Converts from poincare sphere parameterization of polzarization to Stokes Parameters\n    pimg = PoincareSphere2Map(imgI, p, angparams, grid)\n    m = ContinuousImage(pimg, cache)\n\n    # Now construct the basis transformation cache\n    jT = jonesT(tcache)\n\n    # Gain product parameters\n    gP = exp.(lgp/2 .+ 1im.*gpp/2)\n    Gp = jonesG(gP, gP, scancache)\n    # Gain ratio\n    gR = exp.(lgr/2 .+ 1im.*gpr/2)\n    Gr = jonesG(gR, inv.(gR), trackcache)\n    ##D-terms\n    D = jonesD(complex.(dRx, dRy), complex.(dLx, dLy), trackcache)\n    # sandwich all the jones matrices together\n    J = Gp*Gr*D*jT\n    # form the complete Jones or RIME model. We use tcache here\n    # to set the reference basis of the model.\n    return JonesModel(J, m, tcache)\nend","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Now, we define the model metadata required to build the model. We specify our image grid and cache model needed to define the polarimetric image model.","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"fovx = μas2rad(50.0)\nfovy = μas2rad(50.0)\nnx = 5\nny = floor(Int, fovy/fovx*nx)\ngrid = imagepixels(fovx, fovy, nx, ny) # image grid\nbuffer = IntensityMap(zeros(nx, ny), grid) # buffer to store temporary image\npulse = BSplinePulse{3}() # pulse we will be using\ncache = create_cache(NFFTAlg(dvis), buffer, pulse) # cache to define the NFFT transform","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"To define the instrument models, T, G, D, we need to build some Jones caches (see JonesCache) that map from a flat vector of gain/dterms to the specific sites for each baseline.","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"First, we will define our deterministic transform cache. Note that this dataset has need been pre-corrected for feed rotation, so we need to add those into the tcache.","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"tcache = TransformCache(dvis; add_fr=true, ehtim_fr_convention=false)","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Next we define our cache that maps quantities e.g., gain products, that change from scan-to-scan.","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"scancache = jonescache(dvis, ScanSeg())","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Finally, we define our cache that maps quantities, e.g., gain ratios and d-terms, that are constant across a observation night, and we collect everything together.","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"trackcache = jonescache(dvis, TrackSeg())\nmetadata = (;cache, grid, tcache, scancache, trackcache)","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Moving onto our prior, we first focus on the instrument model priors. Each station gain requires its own prior on both the amplitudes and phases. For the amplitudes, we assume that the gains are apriori well calibrated around unit gains (or 0 log gain amplitudes) which corresponds to no instrument corruption. The gain dispersion is then set to 10% for all stations except LMT, representing that we expect 10% deviations from scan-to-scan. For LMT, we let the prior expand to 100% due to the known pointing issues LMT had in 2017.","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"using Distributions\nusing DistributionsAD\ndistamp = (AA = Normal(0.0, 0.1),\n           AP = Normal(0.0, 0.1),\n           LM = Normal(0.0, 0.1),\n           AZ = Normal(0.0, 0.1),\n           JC = Normal(0.0, 0.1),\n           PV = Normal(0.0, 0.1),\n           SM = Normal(0.0, 0.1),\n           )","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"For the phases, we assume that the atmosphere effectively scrambles the gains. Since the gain phases are periodic, we also use broad von Mises priors for all stations.","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"using VLBIImagePriors\ndistphase = (AA = DiagonalVonMises(0.0, inv(0.01)),\n             AP = DiagonalVonMises(0.0, inv(π^2)),\n             LM = DiagonalVonMises(0.0, inv(π^2)),\n             AZ = DiagonalVonMises(0.0, inv(π^2)),\n             JC = DiagonalVonMises(0.0, inv(π^2)),\n             PV = DiagonalVonMises(0.0, inv(π^2)),\n             SM = DiagonalVonMises(0.0, inv(π^2)),\n           )","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"However, we can now also use a little additional information about the phase offsets where in most cases, they are much better behaved than the products","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"distphase_ratio = (AA = DiagonalVonMises(0.0, inv(0.01)),\n             AP = DiagonalVonMises(0.0, inv(0.1^2)),\n             LM = DiagonalVonMises(0.0, inv(0.1^2)),\n             AZ = DiagonalVonMises(0.0, inv(0.1^2)),\n             JC = DiagonalVonMises(0.0, inv(0.1^2)),\n             PV = DiagonalVonMises(0.0, inv(0.1^2)),\n             SM = DiagonalVonMises(0.0, inv(0.1^2)),\n           )","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Moving onto the d-terms, here we directly parameterize the real and complex components of the d-terms since they are expected to be complex numbers near the origin. To help enforce this smallness, a weakly informative Normal prior is used.","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"distD = ( AA = Normal(0.0, 0.1),\n          AP = Normal(0.0, 0.1),\n          LM = Normal(0.0, 0.1),\n          AZ = Normal(0.0, 0.1),\n          JC = Normal(0.0, 0.1),\n          PV = Normal(0.0, 0.1),\n          SM = Normal(0.0, 0.1),\n        )","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Our image priors are:","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"We use a Dirichlet prior, ImageDirichlet, with unit concentration for our stokes I image pixels, c.\nFor the total polarization fraction, p, we assume an uncorrelated uniform prior ImageUniform for each pixel.\nTo specify the orientation of the polarization, angparams, on the Poincare sphere, we use a uniform spherical distribution, ImageSphericalUniform.","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"For all the calibration parameters, we use a helper function CalPrior which builds the prior given the named tuple of station priors and a JonesCache that specifies the segmentation scheme. For the gain products, we use the scancache, while for every other quantity, we use the trackcache.","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"prior = (\n          c = ImageDirichlet(1.0, nx, ny),\n          f = Uniform(0.7, 1.2),\n          p = ImageUniform(nx, ny),\n          angparams = ImageSphericalUniform(nx, ny),\n          dRx = CalPrior(distD, trackcache),\n          dRy = CalPrior(distD, trackcache),\n          dLx = CalPrior(distD, trackcache),\n          dLy = CalPrior(distD, trackcache),\n          lgp = CalPrior(distamp, scancache),\n          gpp = CalPrior(distphase, scancache),\n          lgr = CalPrior(distamp, trackcache),\n          gpr = CalPrior(distphase_ratio,trackcache),\n          )","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Putting it all together, we form our likelihood and posterior objects for optimization and sampling.","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"lklhd = RadioLikelihood(model, metadata, dvis)\npost = Posterior(lklhd, prior)","category":"page"},{"location":"examples/imaging_pol/#Reconstructing-the-Image-and-Instrument-Effects","page":"Polarized Image and Instrumental Modeling","title":"Reconstructing the Image and Instrument Effects","text":"","category":"section"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"To sample from this posterior, it is convenient to move from our constrained parameter space to an unconstrained one (i.e., the support of the transformed posterior is (-∞, ∞)). This transformation is done using the asflat function.","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"tpost = asflat(post)","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"We can now also find the dimension of our posterior or the number of parameters we will sample.","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"warning: Warning\nThis can often be different from what you would expect. This difference is especially true when using angular variables, where we often artificially increase the dimension of the parameter space to make sampling easier.","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"ndim = dimension(tpost)","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Now we optimize. Unlike other imaging examples, we move straight to gradient optimizers due to the higher dimension of the space.","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"using ComradeOptimization\nusing OptimizationOptimJL\nusing Zygote\nf = OptimizationFunction(tpost, Optimization.AutoZygote())\nℓ = logdensityof(tpost)\nprob = Optimization.OptimizationProblem(f, prior_sample(rng, tpost), nothing)\nsol = solve(prob, LBFGS(), maxiters=15_000, callback=((x,p)->(@info ℓ(x);false)), g_tol=1e-1)","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"warning: Warning\nFitting polarized images is generally much harder than Stokes I imaging. This difficulty means that optimization can take a long time, and starting from a good starting location is often required.","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Before we analyze our solution, we need to transform it back to parameter space.","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"xopt = transform(tpost, sol)","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Now let's evaluate our fits by plotting the residuals","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"using Plots\nresidual(model(xopt, metadata), dvis)","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"These look reasonable, although there may be some minor overfitting. Let's compare our results to the ground truth values we know in this example. First, we will load the polarized truth","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"using AxisKeys\nimgtrue = Comrade.load(joinpath(dirname(pathof(Comrade)), \"..\", \"examples\", \"PolarizedExamples/polarized_gaussian.fits\"), StokesIntensityMap)","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Select a reasonable zoom in of the image.","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"imgtruesub = imgtrue(Interval(-fovx/2, fovx/2), Interval(-fovy/2, fovy/2))\nplot(imgtruesub, title=\"True Image\", xlims=(-25.0,25.0), ylims=(-25.0,25.0))","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"img = intensitymap!(copy(imgtruesub), model(xopt, metadata))\nplot(img, title=\"Reconstructed Image\", xlims=(-25.0,25.0), ylims=(-25.0,25.0))","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Let's compare some image statics, like the total linear polarization fraction","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"using Comrade.ComradeBase: linearpol\nftrue = flux(imgtruesub);\n@info \"Linear polarization true image: $(abs(linearpol(ftrue))/ftrue.I)\"\nfrecon = flux(img);\n@info \"Linear polarization recon image: $(abs(linearpol(frecon))/frecon.I)\"","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"And the Circular polarization fraction","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"@info \"Circular polarization true image: $(ftrue.V/ftrue.I)\"\n@info \"Circular polarization recon image: $(frecon.V/frecon.I)\"","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Because we also fit the instrument model, we can inspect their parameters. To do this, Comrade provides a caltable function that converts the flattened gain parameters to a tabular format based on the time and its segmentation.","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"dR = caltable(trackcache, complex.(xopt.dRx, xopt.dRy))","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"We can compare this to the ground truth d-terms","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"time AA AP AZ JC LM PV SM\n0.0 0.01-0.02im -0.08+0.07im 0.09-0.10im -0.04+0.05im 0.03-0.02im -0.01+0.02im 0.08-0.07im","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"And same for the left-handed dterms","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"dL = caltable(trackcache, complex.(xopt.dLx, xopt.dLy))","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"time AA AP AZ JC LM PV SM\n0.0 0.03-0.04im -0.06+0.05im 0.09-0.08im -0.06+0.07im 0.01-0.00im -0.03+0.04im 0.06-0.05im","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Looking at the gain phase ratio","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"gphase_ratio = caltable(trackcache, xopt.gpr)","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"we see that they are all very small. Which should be the case since this data doesn't have gain corruptions! Similarly our gain ratio amplitudes are also very close to unity as expected.","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"gamp_ratio   = caltable(trackcache, exp.(xopt.lgr))","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Plotting the gain phases, we see some offsets from zero. This is because the prior on the gain product phases is very broad, so we can't phase center the image. For realistic data this is always the case since the atmosphere effectively scrambles the phases.","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"gphase_prod = caltable(scancache, xopt.gpp)\nplot(gphase_prod, layout=(3,3), size=(650,500))","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Finally, the product gain amplitudes are all very close to unity as well, as expected since gain corruptions have not been added to the data.","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"gamp_prod = caltable(scancache, exp.(xopt.lgp))\nplot(gamp_prod, layout=(3,3), size=(650,500))","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"At this point, you should run the sampler to recover an uncertainty estimate, which is identical to every other imaging example (see, e.g., Stokes I Simultaneous Image and Instrument Modeling. However, due to the time it takes to sample, we will skip that for this tutorial. Note that on the computer environment listed below, 20_000 MCMC steps take 4 hours.","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"[1]: Hamaker J.P, Bregman J.D., Sault R.J. (1996) [https://articles.adsabs.harvard.edu/pdf/1996A%26AS..117..137H]","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"[2]: Pesce D. (2021) [https://ui.adsabs.harvard.edu/abs/2021AJ....161..178P/abstract]","category":"page"},{"location":"examples/imaging_pol/#Computing-information","page":"Polarized Image and Instrumental Modeling","title":"Computing information","text":"","category":"section"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"Julia Version 1.8.5\nCommit 17cfb8e65ea (2023-01-08 06:45 UTC)\nPlatform Info:\n  OS: Linux (x86_64-linux-gnu)\n  CPU: 32 × AMD Ryzen 9 7950X 16-Core Processor\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-13.0.1 (ORCJIT, znver3)\n  Threads: 1 on 32 virtual cores\nEnvironment:\n  JULIA_EDITOR = code\n  JULIA_NUM_THREADS = 1","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"","category":"page"},{"location":"examples/imaging_pol/","page":"Polarized Image and Instrumental Modeling","title":"Polarized Image and Instrumental Modeling","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"EditURL = \"https://github.com/ptiede/Comrade.jl/blob/main/examples/nonanalytic.jl\"","category":"page"},{"location":"examples/nonanalytic/#Modeling-with-non-analytic-Fourier-transforms","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"","category":"section"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"using Comrade\n\nusing Pkg #hide\nPkg.activate(joinpath(dirname(pathof(Comrade)), \"..\", \"examples\")) #hide\n\nusing Plots","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"While most of the models implemented in Comrade have an analytic Fourier transform this is not required. In this notebook we will describe how a user can do Bayesian model fitting with a non-analytic model.","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"The ExtendedRing model is an example of a non-analytic model. The image structure is given by","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"I(r) = fracbeta^alpha2pi Gamma(alpha) r^-alpha-2e^-betar","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"This can be created as follows","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"m = ExtendedRing(8.0)","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"The argument is \\alpha in the above equation. beta is given by (1+alpha).","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"This is an example of a ring model that has a substantially different flux profile.","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"plot(m, xlims=(-5.0, 5.0), ylims=(-5.0, 5.0), uvscale=identity)","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"This function does not have a simple analytic Fourier transform, e.g.","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"Comrade.visanalytic(ExtendedRing)","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"Therefore, to find the Fourier transform of the image we need to revert to numerical methods. For this notebook we will use the fast Fourier transform or FFT. Specifically we will use FFTW. To compute a numerical Fourier transform we first need to specify the image.","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"image = IntensityMap(zeros(256, 256), 10.0, 10.0)","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"This will serve as our cache to store the image going forward. The next step is to create a model wrapper that holds the model and the image. Comrade provides the modelimage function to do exactly that","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"mimage = modelimage(m, image, Comrade.FFTAlg())","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"the alg keyword argument then specifies that we want to use an FFT to compute the Fourier transform. When modelimage is called, the FFT is performed and then we use a bicubic interpolator on the resulting visibilities to construct a continuous representation of the Fourier transform. Once we have this everything else is the same. Namely we can calculatge the VLBI data products in the usual manner i.e.","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"u = randn(1000)/2\nv = randn(1000)/2","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"Now we can plot our sampled visibilities","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"vis = visibilities(mimage, (U=u, V=v))\nscatter(hypot.(u, v), real.(vis), label=\"Real\")\nscatter!(hypot.(u, v), imag.(vis), label=\"Imag\")","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"We can also directly get the amplitudes using:","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"amp = amplitudes(mimage, (U=u, V=v))\nscatter(hypot.(u, v), amp, label=\"Amplitude\")","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"This page was generated using Literate.jl.","category":"page"},{"location":"vlbi_imaging_problem/#Introduction-to-the-VLBI-Imaging-Problem","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"","category":"section"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"Very-long baseline interferometry (VLBI) is capable of taking the highest resolution images in the world, achieving angular resolutions of ~20 μas. In 2019, the first-ever image of a black hole was produced by the Event Horizon Telescope (EHT). However, while the EHT has unprecedented resolution, it is also a sparse interferometer. As a result, the sampling in the uv or Fourier space of the image is incomplete. This incompleteness makes the imaging problem uncertain. Namely, infinitely many images are possible, given the data. Comrade is a imaging/modeling package that aims to quantify this uncertainty using Bayesian inference.","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"If we denote visibilities by V and the image structure/model by I, Comrade will then compute the posterior or the probability of an image given the visibility data or in an equation","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"p(IV) = fracp(VI)p(I)p(V)","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"Here p(VI) is known as the likelihood and describes the probability distribution of the data given some image I. The prior p(I) encodes prior knowledge of the image structure. This prior includes distributions of model parameters and even the model itself. Finally, the denominator p(V) is a normalization term and is known as the marginal likelihood or evidence and can be used to assess how well particular models fit the data.","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"Therefore, we must specify the likelihood and prior to construct our posterior. Below we provide a brief description of the likelihoods and models/priors that Comrade uses. However, if the user wants to see how everything works first, they should check out the Making an Image of a Black Hole tutorial.","category":"page"},{"location":"vlbi_imaging_problem/#Likelihood","page":"Introduction to the VLBI Imaging Problem","title":"Likelihood","text":"","category":"section"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"Following TMS[TMS], we note that the likelihood for a single complex visibility at baseline u_ij v_ij is","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"p(V_ij  I) = (2pi sigma^2_ij)^-12expleft(-frac V_ij - g_ig_j^*tildeI_ij(I)^22sigma^2_ijright)","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"In this equation, tildeI is the Fourier transform of the image I, and g_ij are complex numbers known as gains. The gains arise due to atmospheric and telescope effects and corrupt the incoming signal. Therefore, if a user attempts to model the complex visibilities, they must also model the complex gains. An example showing how to model gains in Comrade can be found in Stokes I Simultaneous Image and Instrument Modeling.","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"Modeling the gains can be computationally expensive, especially if our image model is simple. For instance, in Comrade, we have a wide variety of geometric models. These models tend to have a small number of parameters and are simple to evaluate. Solving for gains then drastically increases the amount of time it takes to sample the posterior. As a result, part of the typical EHT analysis[M87P6][SgrAP4] instead uses closure products as its data. The two forms of closure products are:","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"Closure Phases,\nLog-Closure Amplitudes.","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"Closure Phases psi are constructed by selecting three baselines (ijk) and finding the argument of the bispectrum:","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"    psi_ijk = arg V_ijV_jkV_ki","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"Similar log-closure amplitudes are found by selecting four baselines (ijkl) and forming the closure amplitudes:","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"    A_ijkl = frac V_ijV_klV_jkV_li","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"Instead of directly fitting closure amplitudes, it turns out that the statistically better-behaved data product is the log-closure amplitude. ","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"The benefit of fitting closure products is that they are independent of complex gains, so we can leave them out when modeling the data. However, the downside is that they effectively put uniform improper priors on the gains[Blackburn], meaning that we often throw away information about the telescope's performance. On the other hand, we can then view closure fitting as a very conservative estimate about what image structures are consistent with the data. Another downside of using closure products is that their likelihoods are complex. In the high-signal-to-noise limit, however, they do reduce to Gaussian likelihoods, and this is the limit we are usually in for the EHT. For the explicit likelihood Comrade uses, we refer the reader to appendix F in paper IV of the first Sgr A* EHT publications[SgrAP4]. The computational implementation of these likelihoods can be found in VLBILikelihoods.jl.","category":"page"},{"location":"vlbi_imaging_problem/#Prior-Model","page":"Introduction to the VLBI Imaging Problem","title":"Prior Model","text":"","category":"section"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"Comrade has included a large number of possible models (see Comrade API for a list). These can be broken down into two categories:","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"Parametric or geometric models\nNon-parametric or image models","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"Comrade's geometric model interface is different from other EHT modeling packages because we don't directly provide fully formed models. Instead, we offer simple geometric models, which we call primitives. These primitive models can then be modified and combined to form complicated  image structures. For more information, we refer the reader to Model Interface.","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"Additionally, we include an interface to Bayesian imaging methods, where we directly fit a rasterized image to the data. These models are highly flexible and assume very little about the image structure. In that sense, these methods are an excellent way to explore the data first and see what kinds of image structures are consistent with observations. For an example of how to fit an image model to closure products, we refer the reader to the other tutorial included in the docs.","category":"page"},{"location":"vlbi_imaging_problem/#References","page":"Introduction to the VLBI Imaging Problem","title":"References","text":"","category":"section"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"[TMS]: Thompson, A., Moran, J., Swenson, G. (2017). Interferometry and Synthesis in Radio Astronomy (Third). Springer Cham","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"[M87P6]: Event Horizon Telescope Collaboration, (2022). First M87 Event Horizon Telescope Results. VI. The Shadow and Mass of the Central Black Hole. ApJL 875 L6 doi","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"[SgrAP4]: Event Horizon Telescope Collaboration, (2022). First Sagittarius A* Event Horizon Telscope Results. IV. Variability, Morphology, and Black Hole Mass. ApJL 930 L15 arXiv","category":"page"},{"location":"vlbi_imaging_problem/","page":"Introduction to the VLBI Imaging Problem","title":"Introduction to the VLBI Imaging Problem","text":"[Blackburn]: Blackburn, L., et. al. (2020). Closure statistics in interferometric data. ApJ, 894(1), 31.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Comrade","category":"page"},{"location":"#Comrade","page":"Home","title":"Comrade","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Comrade is a Bayesian differentiable modular modeling framework for use with very long baseline interferometry. The goal is to allow the user to easily combine and modify a set of primitive models to construct complicated source structures. The benefit of this approach is that it is straightforward to construct different source models out of these primitives. Namely, an end-user does not have to create a separate source \"model\" every time they change the model specification. Additionally, most models currently implemented are differentiable with at least ForwardDiff and Zygote. This allows for gradient accelerated optimization and sampling (e.g., HMC) to be used with little effort by the end user. To sample from the posterior, we provide a somewhat barebones interface since, most of the time, and we don't require the additional features offered by most PPLs. Additionally, the overhead introduced by PPLs tends to be rather large. In the future, we may revisit this as Julia's PPL ecosystem matures.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nThe primitives the Comrade defines, however, would allow for it to be easily included in PPLs like Turing.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Our tutorial section currently has a large number of examples. The simplest example is fitting simple geometric models to the 2017 M87 data and is detailed in the Making an Image of a Black Hole tutorial. We also include \"non-parametric\" modeling or imaging examples in Imaging a Black Hole using only Closure Quantities, and Stokes I Simultaneous Image and Instrument Modeling. There is also an introduction to hybrid geometric and image modeling in Hybrid Imaging of a Black Hole, which combines physically motivated geometric modeling with the flexibility of image-based models.","category":"page"},{"location":"","page":"Home","title":"Home","text":"As of 0.7, Comrade also can simultaneously reconstruct polarized image models and instrument corruptions through the RIME[1] formalism. A short example explaining these features can be found in Polarized Image and Instrumental Modeling.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This repository has recently moved to ColPrac. If you would like to contribute please feel free to open a issue or pull-request.","category":"page"},{"location":"#Requirements","page":"Home","title":"Requirements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The minimum Julia version we require is 1.7. In the future we may increase this as Julia advances.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"index.md\",\n    \"vlbi_imaging_problem.md\",\n    \"conventions.md\",\n    \"Tutorials\",\n    \"Libraries\",\n    \"interface.md\",\n    \"base_api.md\",\n    \"api.md\"\n]","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]: Hamaker J.P and Bregman J.D. and Sault R.J. Understanding radio polarimetry. I. Mathematical foundations ADS. ","category":"page"}]
}
